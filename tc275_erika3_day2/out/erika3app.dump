
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004000 vaddr 0x50100000 paddr 0x50100000 align 2**14
         filesz 0x00002000 memsz 0x00002000 flags r-x
    LOAD off    0x00008020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x00012478 memsz 0x00012478 flags r-x
    LOAD off    0x0001c000 vaddr 0x70000000 paddr 0x80012498 align 2**14
         filesz 0x00001998 memsz 0x00001998 flags rw-
    LOAD off    0x0001e600 vaddr 0x5001a600 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x0001f700 vaddr 0x5001b700 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0001e600 vaddr 0x6001a600 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x0001f700 vaddr 0x6001b700 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0001d998 vaddr 0x70001998 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00003380 flags rw-
    LOAD off    0x00020600 vaddr 0x70018600 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00021700 vaddr 0x70019700 paddr 0x80013e30 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0001fc00 vaddr 0x5001bc00 paddr 0x80013e40 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x0001fc00 vaddr 0x6001bc00 paddr 0x80013e40 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x0001dc00 vaddr 0x70019c00 paddr 0x80013e40 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00008020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000ed8  80000028  80000028  00008028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .bss          00003380  70001998  80013e30  0001d998  2**3
                  ALLOC
  3 .data         00001998  70000000  80012498  0001c000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .traptab      00000200  80000f00  80000f00  00008f00  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ctors        00000008  80001100  80001100  00009100  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .dtors        00000008  80001108  80001108  00009108  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .inttab_cpu0  00002000  80002000  80002000  0000a000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text         0000e498  80004000  80004000  0000c000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .inttab       00002000  50100000  50100000  00004000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .CPU2.ustack  00001000  5001a600  80013e30  0001e600  2**3
                  ALLOC, CPU2
 11 .CPU2.istack  00000400  5001b700  80013e30  0001f700  2**3
                  ALLOC, CPU2
 12 .CPU2.csa     00002000  5001bc00  80013e40  0001fc00  2**6
                  ALLOC, CPU2
 13 .CPU1.ustack  00001000  6001a600  80013e30  0001e600  2**3
                  ALLOC, CPU1
 14 .CPU1.istack  00000400  6001b700  80013e30  0001f700  2**3
                  ALLOC, CPU1
 15 .CPU1.csa     00002000  6001bc00  80013e40  0001fc00  2**6
                  ALLOC, CPU1
 16 .CPU0.ustack  00001000  70018600  80013e30  00020600  2**3
                  ALLOC, CPU0
 17 .CPU0.istack  00000400  70019700  80013e30  00021700  2**3
                  ALLOC, CPU0
 18 .CPU0.csa     00002000  70019c00  80013e40  0001dc00  2**6
                  ALLOC, CPU0
 19 .comment      00000053  00000000  00000000  0001d998  2**0
                  CONTENTS, READONLY
 20 .debug_aranges 00000d50  00000000  00000000  0001d9f0  2**3
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_info   000b2919  00000000  00000000  0001e740  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_abbrev 0000b733  00000000  00000000  000d1059  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   000167f3  00000000  00000000  000dc78c  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  00002030  00000000  00000000  000f2f80  2**2
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    00001d5a  00000000  00000000  000f4fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_loc    00019e7c  00000000  00000000  000f6d0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_ranges 00002f38  00000000  00000000  00110b86  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .version_info 0007b65e  00000000  00000000  00113abe  2**0
                  CONTENTS, READONLY
 29 .debug_macro  00287290  00000000  00000000  0018f11c  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
70001998 l    d  .bss	00000000 .bss
70000000 l    d  .data	00000000 .data
80000f00 l    d  .traptab	00000000 .traptab
80001100 l    d  .ctors	00000000 .ctors
80001108 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
50100000 l    d  .inttab	00000000 .inttab
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 IfxMultican_PinMap.c
00000000 l    df *ABS*	00000000 IfxMultican_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
80006f74 l     F .text	000000e4 IfxScuCcu_wait
70000f38 l     O .data	00000004 IfxScuCcu_xtalFrequency
800004d4 l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 asclin.c
00000000 l    df *ABS*	00000000 ee_applcfg.c
8000059c l     O .rodata	00000040 osEE_tdb_ptr_array
80000590 l     O .rodata	00000004 osEE_res_db_ptr_array
80000580 l     O .rodata	00000004 osEE_counter_db_ptr_array
80000560 l     O .rodata	00000004 osEE_alarm_db_ptr_array
800005dc l     O .rodata	00000200 osEE_tdb_array
80000584 l     O .rodata	0000000c osEE_counter_db_array
70000f68 l     O .data	00000078 osEE_sn_array
80000564 l     O .rodata	0000001c osEE_alarm_db_array
70001c1c l     O .bss	00000010 osEE_alarm_cb_array
70001c2c l     O .bss	00000008 osEE_counter_cb_array
80000594 l     O .rodata	00000008 osEE_res_db_array
70001c34 l     O .bss	0000000c osEE_res_cb_array
800007dc l     O .rodata	00000058 osEE_sdb_array
70001120 l     O .data	0000002c osEE_scb_array
70000fe0 l     O .data	00000140 osEE_tcb_array
70004088 l     O .bss	00000404 osEE_task_stack_1
70003c80 l     O .bss	00000404 osEE_task_stack_2
70003878 l     O .bss	00000404 osEE_task_stack_3
70003470 l     O .bss	00000404 osEE_task_stack_4
70003068 l     O .bss	00000404 osEE_task_stack_5
70002c60 l     O .bss	00000404 osEE_task_stack_6
70002858 l     O .bss	00000404 osEE_task_stack_7
70002450 l     O .bss	00000404 osEE_task_stack_8
70002048 l     O .bss	00000404 osEE_task_stack_9
70001c40 l     O .bss	00000404 osEE_task_stack_10
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 ctype_.c
80000a69 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 impure.c
7000115c l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 vfprintf.c
80000c38 l     O .rodata	00000010 blanks.4035
80000c28 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000f69c l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 locale.c
80000c64 l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80000c9c l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 IfxPort_PinMap.c
00000000 l    df *ABS*	00000000 gpt12.c
70000f44 l     O .data	00000004 lMotorDuty
70001bc4 l     O .bss	00000004 cnt_10us
70000f40 l     O .data	00000004 rMotorDuty
70001bc0 l     O .bss	00000004 cntDelay
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70001990 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ctraptab.c
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
8000cf36 l     F .text	0000000c osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 IfxMultican.c
80004000 l     F .text	0000013c IfxMultican_MsgObj_doReadLongFrame
00000000 l    df *ABS*	00000000 IfxMultican_Can.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 Driver_Can.c
70001998 l     O .bss	00000004 u32nuTemp3.10893
7000199c l     O .bss	00000004 u32nuTemp1.10892
00000000 l    df *ABS*	00000000 vadc.c
00000000 l    df *ABS*	00000000 etc.c
00000000 l    df *ABS*	00000000 Buzzer.c
00000000 l    df *ABS*	00000000 GPIO.c
00000000 l    df *ABS*	00000000 LCD.c
00000000 l    df *ABS*	00000000 Motor.c
00000000 l    df *ABS*	00000000 ToF.c
70001bf0 l     O .bss	00000004 rxBufIdx
70001bd0 l     O .bss	00000010 rxBuf.37695
70001be0 l     O .bss	00000010 gBuf_tof
00000000 l    df *ABS*	00000000 Ultrasonic.c
70001c10 l     O .bss	00000004 old_index.37638
70001bfc l     O .bss	00000014 avg_filt_buf.37637
70001bf8 l     O .bss	00000004 sensorRxCnt.37640
00000000 l    df *ABS*	00000000 interrupts.c
00000000 l    df *ABS*	00000000 system_tc27x.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
700044a0 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
00000000 l    df *ABS*	00000000 ee_oo_counter.c
00000000 l    df *ABS*	00000000 ee_oo_alarm.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
8000e1ec l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 int1.c
00000000 l    df *ABS*	00000000 trap6.c
0000fe00 l       *ABS*	00000000 $pcxi
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 cint.c
80011778 l     F .text	0000000e __class_0_trap_handler
70004d08 l     O .bss	00000004 _init_vectab_initialized
800117a0 l     F .text	0000000a __class_7_trap_handler
800117aa l     F .text	0000000a __class_6_trap_handler
800117b4 l     F .text	0000000a __class_5_trap_handler
800117be l     F .text	0000000a __class_4_trap_handler
800117c8 l     F .text	0000000a __class_3_trap_handler
800117d2 l     F .text	0000000a __class_2_trap_handler
800117dc l     F .text	0000000a __class_1_trap_handler
0000fe24 l       *ABS*	00000000 $btv
0000fe20 l       *ABS*	00000000 $biv
00000000 l    df *ABS*	00000000 wdtcon.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
800119b8 l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 cinttab.c
00000000 l    df *ABS*	00000000 CompilerGcc.c
00000000 l    df *ABS*	00000000 CompilerGhs.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 CompilerTasking.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 reent.c
50101a80 g       .inttab	00000000 __interrupt_212
800031c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_142
80002d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_105
70000f48 g     O .data	00000020 osEE_ccb_var
70004ce8 g     O .bss	00000020 Tdisptab
70004d18 g     O .inttab	00000001 __HEAP
80003980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_204
8000957e g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
501017a0 g       .inttab	00000000 __interrupt_189
80002c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_100
800099d0 g     F .text	00000036 IfxScuWdt_setCpuEndinit
80000ca8 g     O .rodata	00000028 __mprec_tinytens
80002060 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_3
8000aafa g     F .text	00000006 setGpt12_T4
50100a00 g       .inttab	00000000 __interrupt_80
8000acfa g     F .text	00000114 Init_GPIO
50101b80 g       .inttab	00000000 __interrupt_220
8000c474 g     F .text	00000074 FuncOS_EE_Task_Init
80012156 g     F .text	0000001a .hidden __ashldi3
50100080 g       .inttab	00000000 __interrupt_4
50100260 g       .inttab	00000000 __interrupt_19
70000ce0 g     O .data	00000008 IfxPort_P15_2
80009514 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
800021e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_15
8000d25a g     F .text	00000052 TerminateTask
70000b18 g     O .data	00000008 IfxPort_P33_11
50100ee0 g       .inttab	00000000 __interrupt_119
50101c20 g       .inttab	00000000 __interrupt_225
70001c18 g     O .bss	00000004 osEE_kcb_var
70000d80 g     O .data	00000008 IfxPort_P11_9
80002f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_123
70000dd0 g     O .data	00000008 IfxPort_P11_13
50101320 g       .inttab	00000000 __interrupt_153
8000bdc4 g     F .text	00000004 SYSTEM_DisableSecProtection
80011e88 g     F .text	00000040 .hidden __eqdf2
800094a8 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
70000e18 g     O .data	00000008 IfxPort_P10_5
70000b60 g     O .data	00000008 IfxPort_P32_2
70000b50 g     O .data	00000008 IfxPort_P32_4
800045a8 g     F .text	0000000e IfxMultican_MsgObj_setStatusFlag
00000000 g       *ABS*	00000000 __HEAP_SIZE
8000b742 g     F .text	000000ee ReadUltrasonic_Filt
8000e0f0 g     F .text	00000030 osEE_alarm_get
8000da34 g     F .text	0000001c osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80003e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_242
80002300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_24
70000c40 g     O .data	00000008 IfxPort_P21_1
80003580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_172
8000bd9a g     F .text	00000006 SYSTEM_DisableInterrupts
8000c50a g     F .text	0000046a osEE_tc_core0_start
501015a0 g       .inttab	00000000 __interrupt_173
70000c10 g     O .data	00000008 IfxPort_P21_7
50100380 g       .inttab	00000000 __interrupt_28
50101140 g       .inttab	00000000 __interrupt_138
800024c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_38
8000e4e0 g     F .text	00000016 vsprintf
50101ae0 g       .inttab	00000000 __interrupt_215
50101fe0 g       .inttab	00000000 __interrupt_255
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
50101e80 g       .inttab	00000000 __interrupt_244
70000d18 g     O .data	00000008 IfxPort_P14_5
70000000 g       *ABS*	00000000 __DSPR0_START
80002be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_95
8000e0a2 g     F .text	00000026 osEE_alarm_set_abs
501018a0 g       .inttab	00000000 __interrupt_197
80002740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_58
50100b40 g       .inttab	00000000 __interrupt_90
8000e24c g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80002c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_97
80000064 g     O .rodata	00000014 IfxMultican_TXD3_P11_12_OUT
70001a70 g     O .bss	00000150 stEcu1Can
50100960 g       .inttab	00000000 __interrupt_75
80008860 g     F .text	00000012 IfxScuCcu_initErayPllConfig
8000e120 g     F .text	0000001a osEE_change_context_from_running
80000050 g     O .rodata	00000014 IfxMultican_TXD3_P20_10_OUT
501002a0 g       .inttab	00000000 __interrupt_21
50101960 g       .inttab	00000000 __interrupt_203
8000a476 g     F .text	00000098 my_printf
8000ac72 g     F .text	0000000a setBeepCycle
70000db8 g     O .data	00000008 IfxPort_P11_2
80002560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_43
80002040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_2
80010966 g     F .text	00000002 __malloc_unlock
70001bcc g     O .bss	00000004 beepCnt
70000c98 g     O .data	00000008 IfxPort_P20_10
8000d588 g     F .text	0000005a SetRelAlarm
800032e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_151
70000ea0 g     O .data	00000008 IfxPort_P02_0
70000d58 g     O .data	00000008 IfxPort_P13_2
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_118
80002c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_99
80002680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_52
80009ddc g     F .text	00000656 usr_vsprintf
800041ea g     F .text	00000082 IfxMultican_MsgObj_readLongFrame
80009350 g     F .text	000000bc IfxScuCcu_enableExtClockOut0
50101500 g       .inttab	00000000 __interrupt_168
8000d780 g     F .text	0000007c SetEvent
70000c50 g     O .data	00000008 IfxPort_P20_9
50101460 g       .inttab	00000000 __interrupt_163
80003e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_244
80002380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_28
70000c38 g     O .data	00000008 IfxPort_P21_2
80003920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_201
70000db0 g     O .data	00000008 IfxPort_P11_3
8000d96c g     F .text	00000008 osEE_scheduler_task_wrapper_restore
8000bda8 g     F .text	0000000c SYSTEM_EnableProtectionExt
70019600 g     O .CPU0.ustack	00000000 __USTACK0
80003720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_185
80011326 g     F .text	00000050 memmove
80005456 g     F .text	0000001a IfxMultican_getIndex
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
70000e10 g     O .data	00000008 IfxPort_P10_6
8000aac6 g     F .text	0000000c runGpt12_T6
50101c60 g       .inttab	00000000 __interrupt_227
8000026c g     O .rodata	00000014 IfxMultican_RXD2B_P02_3_IN
80010968 g     F .text	00000056 _Balloc
8000bdc8 g     F .text	00000018 SYSTEM_Reset
70000cd8 g     O .data	00000008 IfxPort_P15_3
50101d80 g       .inttab	00000000 __interrupt_236
80003b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_216
800002d0 g     O .rodata	00000014 IfxMultican_RXD1B_P14_1_IN
50101040 g       .inttab	00000000 __interrupt_130
8000ab06 g     F .text	00000096 init_VADC
70000f28 g     O .data	00000008 IfxPort_P00_1
80007b76 g     F .text	0000019c IfxScuCcu_getModuleFrequency
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_213
800028e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_71
80000fa0 g       .traptab	00000000 __trap_5
800082bc g     F .text	000003f0 IfxScuCcu_init
8000a8cc g     F .text	0000003a _poll_uart0
501007e0 g       .inttab	00000000 __interrupt_63
80011f08 g     F .text	00000040 .hidden __gtdf2
8001199c  w    F .text	0000000a __errno
800037e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_191
80003380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_156
8000cf72 g     F .text	00000058 SuspendAllInterrupts
80002140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_10
80003180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_140
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_103
8000be34 g     F .text	00000058 SYSTEM_Idle
00001000 g       *ABS*	00000000 __USTACK0_SIZE
8000e2ba g     F .text	00000066 osEE_hal_terminate_ctx
70000a80 g     O .data	00000008 IfxPort_P40_1
8000ae28 g     F .text	0000001a setLED1
8000daf0 g     F .text	00000074 osEE_sn_priority_insert
70000b88 g     O .data	00000008 IfxPort_P23_4
80003480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_164
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_215
8000bd06 g     F .text	0000008e SYSTEM_GetCanClock
800000dc g     O .rodata	00000014 IfxMultican_TXD2_P02_2_OUT
8000d51a g     F .text	0000006e GetTaskState
8000dc00 g     F .text	00000020 osEE_task_event_set_mask
800097ae g     F .text	000000da IfxScuWdt_initCpuWatchdog
80006cd0 g     F .text	000000b6 IfxPort_setGroupModeOutput
80009dae g     F .text	0000002e _poll_uart3
80000294 g     O .rodata	00000014 IfxMultican_RXD1E_P02_10_IN
50100d60 g       .inttab	00000000 __interrupt_107
8000b57e g     F .text	00000004 Init_ToF
80002080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_4
8000602a g     F .text	00000028 IfxMultican_Can_MsgObj_isTransmitRequested
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80007e60 g     F .text	000000ac IfxScuCcu_getPllFrequency
80002a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_82
700044e0 g     O .bss	00000004 errno
8000bd94 g     F .text	00000006 SYSTEM_EnableInterrupts
80002e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_114
8000d68e g     F .text	0000005c GetAlarm
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
50100540 g       .inttab	00000000 __interrupt_42
50100aa0 g       .inttab	00000000 __interrupt_85
800022a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_21
80001060 g       .traptab	00000000 osEE_tc_trap_context
80009a38 g     F .text	00000048 IfxScuWdt_enableWatchdogWithDebugger
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_117
70000a78 g     O .data	00000008 IfxPort_P40_2
8000aab8 g     F .text	0000000e stopGpt12_T3
501008e0 g       .inttab	00000000 __interrupt_71
800027e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_63
80003560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_171
70000f30 g     O .data	00000008 IfxPort_P00_0
800023c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_30
8000614c g     F .text	000000ae IfxMultican_Can_Node_getConfig
800020c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_6
80003780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_188
50101620 g       .inttab	00000000 __interrupt_177
501011c0 g       .inttab	00000000 __interrupt_142
70000eb0 g     O .data	00000008 IfxPort_P01_6
8000af4c g     F .text	00000096 getSW2_Debounce
50100340 g       .inttab	00000000 __interrupt_26
50101aa0 g       .inttab	00000000 __interrupt_213
50100d20 g       .inttab	00000000 __interrupt_105
501001a0 g       .inttab	00000000 __interrupt_13
8000c1d6 g     F .text	00000088 FuncTask_Motor
80009470 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
50100160 g       .inttab	00000000 __interrupt_11
8000d828 g     F .text	00000048 ClearEvent
50100200 g       .inttab	00000000 __interrupt_16
80007588 g     F .text	00000190 IfxScuCcu_getCpuFrequency
80003d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_232
50101220 g       .inttab	00000000 __interrupt_145
50101840 g       .inttab	00000000 __interrupt_194
70000b48 g     O .data	00000008 IfxPort_P32_5
70000b58 g     O .data	00000008 IfxPort_P32_3
501006e0 g       .inttab	00000000 __interrupt_55
800028a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_69
70000cb8 g     O .data	00000008 IfxPort_P15_7
8000d974 g     F .text	000000c0 osEE_scheduler_task_wrapper_run
8000543a g     F .text	0000001c IfxMultican_setListCommand
70000bd0 g     O .data	00000008 IfxPort_P22_5
70000bc8 g     O .data	00000008 IfxPort_P22_6
70000ad8 g     O .data	00000008 IfxPort_P33_5
8000527c g     F .text	0000016a IfxMultican_deinit
80003f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_251
501014e0 g       .inttab	00000000 __interrupt_167
8000ae7a g     F .text	0000001e toggleLED2
8000aea8 g     F .text	00000010 getSW2
50100ce0 g       .inttab	00000000 __interrupt_103
800035c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_174
80005470 g     F .text	00000014 IfxMultican_getAddress
80003700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_184
800118e4 g     F .text	0000002c lock_wdtcon
80000378 g     O .rodata	00000080 IfxPort_cfg_indexMap
800061fa g     F .text	000002bc IfxMultican_Can_Node_init
8000dd9e g     F .text	00000024 osEE_scheduler_task_preemption_point
80010948 g     F .text	0000001c memcpy
80006618 g     F .text	0000009a IfxMultican_Can_getConfig
800021c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_14
501013c0 g       .inttab	00000000 __interrupt_158
50100100 g       .inttab	00000000 __interrupt_8
8000c3bc g     F .text	0000004e FuncBuzzer_Example
8000be8c g     F .text	00000050 SYSTEM_Sleep
50101060 g       .inttab	00000000 __interrupt_131
8000b1ce g     F .text	0000005c clear_lcdprint
50100480 g       .inttab	00000000 __interrupt_36
8000d870 g     F .text	0000002c GetCounterValue
8000e4f8 g     F .text	000011a4 _svfprintf_r
80011fc8 g     F .text	00000048 .hidden __floatsidf
8000da50 g     F .text	0000003c osEE_scheduler_rq_insert
8000b6b0 g     F .text	00000092 ReadUltrasonic_noFilt
80002940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_74
80011f88 g     F .text	00000040 .hidden __ltdf2
50100e20 g       .inttab	00000000 __interrupt_113
80000154 g     O .rodata	00000014 IfxMultican_TXD0_P34_1_OUT
80001110 g       .dtors	00000000 __DTOR_END__
70000e98 g     O .data	00000008 IfxPort_P02_1
80008872 g     F .text	000001e8 IfxScuCcu_setCpuFrequency
8000e14e g     F .text	00000022 osEE_idle_task_terminate
50100a20 g       .inttab	00000000 __interrupt_81
80003c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_228
8000c35c g     F .text	00000060 FuncUltrasonic_Example
80000168 g     O .rodata	00000014 IfxMultican_TXD0_P33_8_OUT
50101d20 g       .inttab	00000000 __interrupt_233
70000f18 g     O .data	00000008 IfxPort_P00_11
8000a7b0 g     F .text	00000034 _in_uart1
8000b83a g     F .text	00000046 InterruptInstall
70000ae8 g     O .data	00000008 IfxPort_P33_3
80000104 g     O .rodata	00000014 IfxMultican_TXD1_P14_0_OUT
501008c0 g       .inttab	00000000 __interrupt_70
80010f0e g     F .text	00000042 __fpclassifyd
800023a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_29
800094e0 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
80003a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_211
80002340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_26
80000f40 g       .traptab	00000000 __trap_2
80009678 g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
80002540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_42
8000dcca g     F .text	00000044 osEE_scheduler_task_unblocked
80002960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_75
80003820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_193
800033c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_158
501010e0 g       .inttab	00000000 __interrupt_135
70000a90 g     O .data	00000008 IfxPort_P34_5
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_102
00000000 g       *ABS*	00000000 NULL
8000c9c0 g     F .text	00000098 osEE_tc_initialize_system_timer
50101860 g       .inttab	00000000 __interrupt_195
80001040 g       .traptab	00000000 osEE_tc_trap_instruction
80000cf8 g     O .rodata	000000c8 __mprec_tens
50100da0 g       .inttab	00000000 __interrupt_109
800045d0 g     F .text	00000032 IfxMultican_Node_initRxPin
50101240 g       .inttab	00000000 __interrupt_146
8000bda4 g     F .text	00000004 SYSTEM_DisableProtection
80002260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_19
8000d316 g     F .text	000000a2 GetResource
50101d40 g       .inttab	00000000 __interrupt_234
70000c28 g     O .data	00000008 IfxPort_P21_4
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_214
800029a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_77
800001cc g     O .rodata	00000014 IfxMultican_RXD3E_P20_9_IN
8000a432 g     F .text	00000006 usr_sprintf
50100880 g       .inttab	00000000 __interrupt_68
800038a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_197
501016c0 g       .inttab	00000000 __interrupt_182
700044d8 g     O .bss	00000004 __malloc_top_pad
70004494 g     O .bss	00000004 flag
50101ec0 g       .inttab	00000000 __interrupt_246
80006052 g     F .text	00000028 IfxMultican_Can_MsgObj_isTxPending
800000c8 g     O .rodata	00000014 IfxMultican_TXD2_P10_3_OUT
80008a5a g     F .text	000001f6 IfxScuCcu_setGtmFrequency
80006e8c g     F .text	00000068 IfxPort_setPinModeLvdsHigh
8000e270 g     F .text	0000002c osEE_hal_ready2stacked
80002660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_51
70000c78 g     O .data	00000008 IfxPort_P20_14
8000aa4e g     F .text	0000005e init_gpt2
8001048c g     F .text	0000000a _localeconv_r
80003460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_163
80009b2c g     F .text	0000015a Driver_Can_Init
80010afa g     F .text	00000010 __i2b
8000d2ac g     F .text	0000006a Schedule
80003f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_250
50101e00 g       .inttab	00000000 __interrupt_240
501019a0 g       .inttab	00000000 __interrupt_205
80009136 g     F .text	0000021a IfxScuCcu_switchToBackupClock
80003100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_136
800096d4 g     F .text	00000070 IfxScuWdt_enableSafetyWatchdog
80003e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_240
80010f50 g     F .text	0000001e _sbrk_r
8000bf1c g     F .text	00000002 SYSTEM_DbgBreak
50100740 g       .inttab	00000000 __interrupt_58
80003040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_130
80002b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_89
70000e80 g     O .data	00000008 IfxPort_P02_2
800025c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_46
70000d20 g     O .data	00000008 IfxPort_P14_4
50101f40 g       .inttab	00000000 __interrupt_250
70000d68 g     O .data	00000008 IfxPort_P13_0
50100120 g       .inttab	00000000 __interrupt_9
501000e0 g       .inttab	00000000 __interrupt_7
70000ee8 g     O .data	00000008 IfxPort_P00_6
50101a40 g       .inttab	00000000 __interrupt_210
50101480 g       .inttab	00000000 __interrupt_164
70000cc0 g     O .data	00000008 IfxPort_P15_6
800027a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_61
80002800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_64
800002e4 g     O .rodata	00000014 IfxMultican_RXD1A_P15_3_IN
8000c276 g     F .text	0000001c FuncUART_Echo
8000021c g     O .rodata	00000014 IfxMultican_RXD3A_P00_3_IN
800122a8 g     F .text	000000ac .hidden __unpack_d
70000e90 g     O .data	00000008 IfxPort_P02_10
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
80006f36 g     F .text	0000003c IfxPort_setPinPadDriver
80000244 g     O .rodata	00000014 IfxMultican_RXD2D_P14_8_IN
50100d40 g       .inttab	00000000 __interrupt_106
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_246
80002480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_36
70000c88 g     O .data	00000008 IfxPort_P20_12
50101300 g       .inttab	00000000 __interrupt_152
700044d4 g     O .bss	00000004 __malloc_max_sbrked_mem
80002a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_81
50100ba0 g       .inttab	00000000 __interrupt_93
800010a0 g       .traptab	00000000 osEE_tc_trap_assertion
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_93
80009b18 g     F .text	0000000a getLEDKing
80008000 g       *ABS*	00000000 __A1_MEM
501003e0 g       .inttab	00000000 __interrupt_31
70000b40 g     O .data	00000008 IfxPort_P32_6
80002700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_56
8000ac7c g     F .text	00000060 Beep
80011b54 g     F .text	00000038 .hidden __adddf3
50100600 g       .inttab	00000000 __interrupt_48
8000d126 g     F .text	0000001a GetActiveApplicationMode
70000ec8 g     O .data	00000008 IfxPort_P01_3
50100440 g       .inttab	00000000 __interrupt_34
80008174 g     F .text	00000148 IfxScuCcu_getSriFrequency
8000ac4c g     F .text	00000026 Init_Buzzer_PWM
50101e20 g       .inttab	00000000 __interrupt_241
800030c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_134
50100fa0 g       .inttab	00000000 __interrupt_125
50101900 g       .inttab	00000000 __interrupt_200
8000cfca g     F .text	00000024 ResumeAllInterrupts
70000c20 g     O .data	00000008 IfxPort_P21_5
50100d00 g       .inttab	00000000 __interrupt_104
70000df8 g     O .data	00000008 IfxPort_P11_0
800036c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_182
800038e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_199
80008ffa g     F .text	0000013c IfxScuCcu_setSriFrequency
80012130 g     F .text	00000026 .hidden __umoddi3
80000370 g     O .rodata	00000008 IfxMultican_cfg_indexMap
80003740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_186
70019c00 g     O .CPU0.csa	00000000 __CSA0
80003840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_194
800033e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_159
80003280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_148
80005508 g     F .text	00000a64 IfxMultican_Can_MsgObj_init
80002180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_12
8000bef2 g     F .text	0000002a SYSTEM_EnaDisCache
800000f0 g     O .rodata	00000014 IfxMultican_TXD1_P15_2_OUT
80011786 g     F .text	0000001a tsim_abort
80000bec g     O .rodata	00000004 _global_impure_ptr
70000a60 g     O .data	00000008 IfxPort_P40_5
501017e0 g       .inttab	00000000 __interrupt_191
70000cf8 g     O .data	00000008 IfxPort_P14_9
50100f00 g       .inttab	00000000 __interrupt_120
80007718 g     F .text	0000018e IfxScuCcu_getFsi2Frequency
80011386 g     F .text	000003f0 _realloc_r
70000cd0 g     O .data	00000008 IfxPort_P15_4
70000e58 g     O .data	00000008 IfxPort_P02_7
70000c00 g     O .data	00000008 IfxPort_P22_1
8000aaac g     F .text	0000000c runGpt12_T3
70000bc0 g     O .data	00000008 IfxPort_P22_7
80006a5a g     F .text	00000060 IfxPort_enableEmergencyStop
50100920 g       .inttab	00000000 __interrupt_73
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_254
50100420 g       .inttab	00000000 __interrupt_33
50101bc0 g       .inttab	00000000 __interrupt_222
8000b50a g     F .text	00000010 stopChB
80012090 g     F .text	000000a0 .hidden __udivdi3
70008000 g       *ABS*	00000000 __A0_MEM
8000da8c g     F .text	00000064 osEE_scheduler_core_rq_preempt_stk
50101ca0 g       .inttab	00000000 __interrupt_229
80000cd0 g     O .rodata	00000028 __mprec_bigtens
800119a6 g     F .text	00000012 abort
50101580 g       .inttab	00000000 __interrupt_172
50101cc0 g       .inttab	00000000 __interrupt_230
8001205e g     F .text	00000032 .hidden __floatunsidf
8000bf1e g     F .text	00000008 StartupHook
8000b880 g     F .text	0000029c SYSTEM_Init
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_85
800066b2 g     F .text	0000007c IfxMultican_Can_getModuleFrequency
80010d5a g     F .text	00000042 __mcmp
800002a8 g     O .rodata	00000014 IfxMultican_RXD1D_P00_1_IN
800038c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_198
8000d140 g     F .text	0000006a ActivateTask
80003300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_152
50100520 g       .inttab	00000000 __interrupt_41
70001a6c g     O .bss	00000004 u32nuCanRxCnt
80002de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_111
50100a80 g       .inttab	00000000 __interrupt_84
800001f4 g     O .rodata	00000014 IfxMultican_RXD3C_P20_0_IN
501000c0 g       .inttab	00000000 __interrupt_6
80002420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_33
8000b830 g     F .text	0000000a InterruptInit
70004d10  w    O .bss	00000004 _my_errno
8000b4fa g     F .text	00000010 stopChA
8000a9c0 g     F .text	0000000a getcntDelay
80006aba g     F .text	0000004e IfxPort_getAddress
80000fe0 g       .traptab	00000000 __trap_7
80003760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_187
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
50101dc0 g       .inttab	00000000 __interrupt_238
8000e4a6 g     F .text	00000012 strtol
8000d4c6 g     F .text	00000054 GetTaskID
50101100 g       .inttab	00000000 __interrupt_136
800086c8 g     F .text	00000198 IfxScuCcu_initErayPll
50100c60 g       .inttab	00000000 __interrupt_99
80000208 g     O .rodata	00000014 IfxMultican_RXD3B_P32_2_IN
70000dc8 g     O .data	00000008 IfxPort_P11_14
501006c0 g       .inttab	00000000 __interrupt_54
80000230 g     O .rodata	00000014 IfxMultican_RXD2E_P10_2_IN
50101160 g       .inttab	00000000 __interrupt_139
70000e08 g     O .data	00000008 IfxPort_P10_7
800068e0 g     F .text	00000086 IfxMultican_Can_initModuleConfig
80003de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_239
80011776 g     F .text	00000002 __int_handler
70000a70 g     O .data	00000008 IfxPort_P40_3
80000480 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
70000e50 g     O .data	00000008 IfxPort_P02_8
800053f4 g     F .text	00000046 IfxMultican_resetModule
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
8000a9ac g     F .text	0000000a setLeftMotorDuty
8000a906 g     F .text	00000016 _out_uart0
80005484 g     F .text	00000084 IfxMultican_Can_MsgObj_getConfig
8000cfee g     F .text	00000068 SuspendOSInterrupts
80003a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_210
8000a91c g     F .text	0000007c IsrGpt2T6Handler
800095b0 g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
50100360 g       .inttab	00000000 __interrupt_27
8000ccd6 g     F .text	000000be osEE_tc_stm_set_clockpersec
80003a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_208
501001c0 g       .inttab	00000000 __interrupt_14
800031e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_143
80002d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_106
8000ddc2 g     F .text	00000044 osEE_scheduler_task_set_running
50101080 g       .inttab	00000000 __interrupt_132
8000bc76 g     F .text	00000090 SYSTEM_GetStmClock
b0008000 g     O *ABS*	00000000 _SMALL_DATA4_
8000bedc g     F .text	00000016 SYSTEM_IsCacheEnabled
70000dd8 g     O .data	00000008 IfxPort_P11_12
50101760 g       .inttab	00000000 __interrupt_187
8000cd94 g     F .text	000000c8 osEE_tc_stm_set_sr1
8000960a g     F .text	0000006e IfxScuWdt_disableSafetyWatchdog
80002c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_96
8000999e g     F .text	00000032 IfxScuWdt_serviceSafetyWatchdog
80010a52 g     F .text	00000042 __hi0bits
80002760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_59
70000d60 g     O .data	00000008 IfxPort_P13_1
80002e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_115
8000df04 g     F .text	00000152 osEE_counter_increment
700044e8 g     O .bss	00000800 Cdisptab
80012010 g     F .text	0000004e .hidden __fixdfsi
80003160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_139
8000dc3e g     F .text	00000064 osEE_scheduler_task_activated
8000743e g     F .text	0000014a IfxScuCcu_getBbbFrequency
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
70000c08 g     O .data	00000008 IfxPort_P22_0
70000b10 g     O .data	00000008 IfxPort_P33_12
70000b78 g     O .data	00000008 IfxPort_P23_6
70000ec0 g     O .data	00000008 IfxPort_P01_4
70000ad0 g     O .data	00000008 IfxPort_P33_6
80002f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_121
800078a6 g     F .text	00000190 IfxScuCcu_getFsiFrequency
80002100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_8
8000a9b6 g     F .text	0000000a setRightMotorDuty
80002580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_44
800053e6 g     F .text	0000000e IfxMultican_getSrcPointer
50100f80 g       .inttab	00000000 __interrupt_124
80003d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_234
800032a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_149
80009548 g     F .text	00000036 IfxScuWdt_clearCpuEndinit
50100c20 g       .inttab	00000000 __interrupt_97
8000c266 g     F .text	00000010 FuncBlink_LED
80002e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_113
80003320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_153
800025e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_47
70000e20 g     O .data	00000008 IfxPort_P10_4
80000190 g     O .rodata	00000014 IfxMultican_TXD0_P12_1_OUT
70000d28 g     O .data	00000008 IfxPort_P14_3
50100680 g       .inttab	00000000 __interrupt_52
800022e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_23
70000ce8 g     O .data	00000008 IfxPort_P15_1
501005e0 g       .inttab	00000000 __interrupt_47
70000cc8 g     O .data	00000008 IfxPort_P15_5
501013a0 g       .inttab	00000000 __interrupt_157
50101520 g       .inttab	00000000 __interrupt_169
800041e0 g     F .text	0000000a IfxMultican_MsgObj_getStatusFlag
70000eb8 g     O .data	00000008 IfxPort_P01_5
50101400 g       .inttab	00000000 __interrupt_160
50101be0 g       .inttab	00000000 __interrupt_223
80012170 g     F .text	00000026 .hidden __lshrdi3
70000da0 g     O .data	00000008 IfxPort_P11_5
800039a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_205
50100e00 g       .inttab	00000000 __interrupt_112
70000b00 g     O .data	00000008 IfxPort_P33_14
70000aa8 g     O .data	00000008 IfxPort_P34_2
80010c24 g     F .text	0000007c __pow5mult
50100b60 g       .inttab	00000000 __interrupt_91
70000ca8 g     O .data	00000008 IfxPort_P20_0
8000ae0e g     F .text	0000001a setHeadlampLED
50100980 g       .inttab	00000000 __interrupt_76
80000028 g     O .rodata	00000014 IfxMultican_TXD3_P32_3_OUT
50101de0 g       .inttab	00000000 __interrupt_239
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_255
70000ee0 g     O .data	00000008 IfxPort_P00_7
70000b30 g     O .data	00000008 IfxPort_P33_0
80002860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_67
80002e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_112
70000ae0 g     O .data	00000008 IfxPort_P33_4
70000b90 g     O .data	00000008 IfxPort_P23_3
70000f00 g     O .data	00000008 IfxPort_P00_3
70000ab8 g     O .data	00000008 IfxPort_P33_9
80009cc0 g     F .text	000000ac _init_uart3
8000dd0e g     F .text	00000090 osEE_scheduler_task_terminated
8000bbe6 g     F .text	00000090 SYSTEM_GetSysClock
80002460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_35
800036a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_181
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_245
70000af8 g     O .data	00000008 IfxPort_P33_15
8000d63c g     F .text	00000052 CancelAlarm
700019a1 g     O .bss	00000001 led_king
50101d60 g       .inttab	00000000 __interrupt_235
800041b8 g     F .text	00000022 IfxMultican_MsgObj_getPendingId
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
800117e6 g     F .text	00000026 _install_int_handler
80003b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_219
50101440 g       .inttab	00000000 __interrupt_162
50101020 g       .inttab	00000000 __interrupt_129
80002360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_27
800060d2 g     F .text	0000007a IfxMultican_Can_MsgObj_sendMessage
800037a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_189
80009794 g     F .text	0000001a IfxScuWdt_initConfig
80001100 g       .ctors	00000000 __CTOR_LIST__
80000f80 g       .traptab	00000000 __trap_4
8000cc3a g     F .text	0000009c osEE_tc_get_fsource
80009968 g     F .text	00000036 IfxScuWdt_serviceCpuWatchdog
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_247
501012c0 g       .inttab	00000000 __interrupt_150
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_86
50101740 g       .inttab	00000000 __interrupt_186
50100840 g       .inttab	00000000 __interrupt_66
80011910 g     F .text	00000020 unlock_safety_wdtcon
501016a0 g       .inttab	00000000 __interrupt_181
8000acdc g     F .text	0000001e IsrGpt120T3Handler_Beep
80002e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_116
70000a50 g     O .data	00000008 IfxPort_P40_7
8000e29c g     F .text	0000001e osEE_tc_change_context_from_isr2_end
80002a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_83
80010930 g     F .text	00000018 memchr
70000ab0 g     O .data	00000008 IfxPort_P34_1
80003400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_160
8001117a g     F .text	000001ac _free_r
8000b582 g     F .text	00000042 IsrUart1RxHandler_tof
80002220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_17
8000c292 g     F .text	0000003a FuncDCMotor_Example
800023e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_31
8000d954 g     F .text	00000018 GetISRID
70000c68 g     O .data	00000008 IfxPort_P20_6
8000e20e g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
70000c18 g     O .data	00000008 IfxPort_P21_6
50101660 g       .inttab	00000000 __interrupt_179
8000e058 g     F .text	0000004a osEE_alarm_set_rel
50100180 g       .inttab	00000000 __interrupt_12
50100140 g       .inttab	00000000 __interrupt_10
80001080 g       .traptab	00000000 osEE_tc_trap_bus
8000c2cc g     F .text	00000090 FuncTimer_Example
8000b124 g     F .text	00000042 write_data
80000280 g     O .rodata	00000014 IfxMultican_RXD2A_P15_1_IN
80007058 g     F .text	00000102 IfxScuCcu_calculateSysPllDividers
80004564 g     F .text	00000044 IfxMultican_MsgObj_setFilter
50101260 g       .inttab	00000000 __interrupt_147
70001580 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80003520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_169
50101880 g       .inttab	00000000 __interrupt_196
80004626 g     F .text	0000006a IfxMultican_Node_recoverBusOff
80003f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_249
80009764 g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800010e0 g       .traptab	00000000 osEE_tc_trap_nmi
8000003c g     O .rodata	00000014 IfxMultican_TXD3_P20_3_OUT
50101b00 g       .inttab	00000000 __interrupt_216
501009c0 g       .inttab	00000000 __interrupt_78
800020a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_5
50100f20 g       .inttab	00000000 __interrupt_121
80010ca0 g     F .text	000000ba __lshift
80003600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_176
50100c80 g       .inttab	00000000 __interrupt_100
00002000 g       *ABS*	00000000 __CSA_SIZE
8000bdc0 g     F .text	00000004 SYSTEM_EnableSecProtection
70000e38 g     O .data	00000008 IfxPort_P10_1
80010f6e g     F .text	000000f0 __ssprint_r
50101ea0 g       .inttab	00000000 __interrupt_245
50101f80 g       .inttab	00000000 __interrupt_252
5001bc00 g       .CPU2.csa	00000000 __CSA2
8000035c g     O .rodata	00000014 IfxMultican_RXD0A_P02_1_IN
8000b166 g     F .text	00000068 lcdprint_data
800034a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_165
80003c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_227
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
70000dc0 g     O .data	00000008 IfxPort_P11_15
80005f6c g     F .text	00000096 IfxMultican_Can_MsgObj_initConfig
50100040 g       .inttab	00000000 __interrupt_2
8000a998 g     F .text	0000000a getLeftMotorDuty
800027c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_62
8000c44e g     F .text	00000026 FuncADC_Example
70000b28 g     O .data	00000008 IfxPort_P33_1
50100900 g       .inttab	00000000 __interrupt_72
50101980 g       .inttab	00000000 __interrupt_204
50100ec0 g       .inttab	00000000 __interrupt_118
8001180c g     F .text	000000ac _init_vectab
50101c80 g       .inttab	00000000 __interrupt_228
80010b0a g     F .text	0000011a __multiply
00000001 g       *ABS*	00000000 _.
700044a8 g     O .bss	00000028 __malloc_current_mallinfo
80010e66 g     F .text	000000a8 __d2b
80003c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_226
800037c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_190
80003360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_155
70000d10 g     O .data	00000008 IfxPort_P14_6
70000bf0 g     O .data	00000008 IfxPort_P22_11
800026c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_54
70000a88 g     O .data	00000008 IfxPort_P40_0
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_125
80002b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_91
501014a0 g       .inttab	00000000 __interrupt_165
80004690 g     F .text	000004fa IfxMultican_Node_setBitTiming
50100300 g       .inttab	00000000 __interrupt_24
80003680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_180
70000e88 g     O .data	00000008 IfxPort_P02_11
80007df6 g     F .text	0000006a IfxScuCcu_getPllErayVcoFrequency
80001100 g       .ctors	00000000 __EH_FRAME_END__
80009d82 g     F .text	0000002c _in_uart3
80008c50 g     F .text	00000122 IfxScuCcu_setPll2ErayFrequency
6001bb00 g       .CPU1.istack	00000000 __ISTACK1
80003800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_192
800033a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_157
800072ca g     F .text	00000174 IfxScuCcu_getBaud2Frequency
80003240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_146
80002da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_109
80012354 g     F .text	000000a6 .hidden __fpcmp_parts_d
50100bc0 g       .inttab	00000000 __interrupt_94
50100e80 g       .inttab	00000000 __interrupt_116
70000aa0 g     O .data	00000008 IfxPort_P34_3
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
50100ae0 g       .inttab	00000000 __interrupt_87
8000db64 g     F .text	0000006c osEE_scheduler_core_pop_running
800021a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_13
8000aad2 g     F .text	0000000e stopGpt12_T6
80003f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_252
50100580 g       .inttab	00000000 __interrupt_44
80000258 g     O .rodata	00000014 IfxMultican_RXD2C_P32_6_IN
50101120 g       .inttab	00000000 __interrupt_137
8000e170 g     F .text	0000007c osEE_cpu_startos
50101340 g       .inttab	00000000 __interrupt_154
80003b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_218
70000be0 g     O .data	00000008 IfxPort_P22_3
80004314 g     F .text	00000188 IfxMultican_MsgObj_sendLongFrame
50101c00 g       .inttab	00000000 __interrupt_224
80000348 g     O .rodata	00000014 IfxMultican_RXD0B_P20_7_IN
80003e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_241
800029c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_78
80004160 g     F .text	00000058 IfxMultican_MsgObj_deinit
80006b08 g     F .text	000000c2 IfxPort_getIndex
800030a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_133
501018e0 g       .inttab	00000000 __interrupt_199
501004a0 g       .inttab	00000000 __interrupt_37
8000d7fc g     F .text	0000002c GetEvent
50100820 g       .inttab	00000000 __interrupt_65
70000d98 g     O .data	00000008 IfxPort_P11_6
50101640 g       .inttab	00000000 __interrupt_178
501016e0 g       .inttab	00000000 __interrupt_183
6001b600 g       .CPU1.ustack	00000000 __USTACK1
8000a9ca g     F .text	0000000a setcntDelay
70000d48 g     O .data	00000008 IfxPort_P14_0
8000dca2 g     F .text	00000028 osEE_scheduler_task_insert
80003be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_223
80002620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_49
80011d70 g     F .text	00000118 .hidden __divdf3
8000abc6 g     F .text	0000001a VADC_readResult
70001588 g     O .data	00000408 __malloc_av_
80002f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_120
8000413c g     F .text	00000018 IfxMultican_MsgObj_cancelSend
8000d45c g     F .text	0000006a ShutdownOS
80003060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_131
8000b4c0 g     F .text	0000003a movChB
800035e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_175
70018600 g     O .CPU0.ustack	00000000 __USTACK0_END
80003900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_200
80009b22 g     F .text	0000000a getTunnelStatus
80000f20 g       .traptab	00000000 __trap_1
80002120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_9
80011bcc g     F .text	000001a4 .hidden __muldf3
80002500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_40
80002520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_41
8000b376 g     F .text	00000002 delay_us
50101ac0 g       .inttab	00000000 __interrupt_214
80004b8a g     F .text	000004fa IfxMultican_Node_setFastBitTiming
70000a98 g     O .data	00000008 IfxPort_P34_4
70000e78 g     O .data	00000008 IfxPort_P02_3
70000d00 g     O .data	00000008 IfxPort_P14_8
501012a0 g       .inttab	00000000 __interrupt_149
80010964 g     F .text	00000002 __malloc_lock
50101200 g       .inttab	00000000 __interrupt_144
80011960 g     F .text	0000003c sbrk
80007d12 g     F .text	0000000e IfxScuCcu_getOsc0Frequency
80000000 g       .startup	00000000 BootModeHeader0
800010c0 g       .traptab	00000000 osEE_tc_trap_system
50100d80 g       .inttab	00000000 __interrupt_108
8000bfbe g     F .text	00000218 FuncDisplay_BodyStatus
8001105e g     F .text	00000062 _calloc_r
70000ba8 g     O .data	00000008 IfxPort_P23_0
00002000 g       *ABS*	00000000 __CSA0_SIZE
50100cc0 g       .inttab	00000000 __interrupt_102
8000802c g     F .text	00000148 IfxScuCcu_getSpbFrequency
80002820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_65
501007a0 g       .inttab	00000000 __interrupt_61
70000c90 g     O .data	00000008 IfxPort_P20_11
800024a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_37
8000bb1c g     F .text	0000000a SYSTEM_GetExtClock
50100b80 g       .inttab	00000000 __interrupt_92
8000bb26 g     F .text	000000c0 SYSTEM_GetCpuClock
80003d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_233
80003960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_203
80011376 g     F .text	00000010 memset
800002bc g     O .rodata	00000014 IfxMultican_RXD1C_P01_4_IN
800034e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_167
70000a48 g     O .data	00000008 IfxPort_P40_8
80002640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_50
8000c4e8 g     F .text	00000022 main
80009744 g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
8000abe0 g     F .text	00000056 delay_ms
50100240 g       .inttab	00000000 __interrupt_18
80002200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_16
700044d0 g     O .bss	00000004 __malloc_max_total_mem
8000a50e g     F .text	000001b0 my_scanf
8000e320 g       .text	00000000 __interrupt_1
80003540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_170
501004e0 g       .inttab	00000000 __interrupt_39
800123fa g     F .text	0000009c .hidden __udiv6432
50101360 g       .inttab	00000000 __interrupt_155
00000400 g       *ABS*	00000000 __ISTACK_SIZE
70000ef8 g     O .data	00000008 IfxPort_P00_4
8000715a g     F .text	00000170 IfxScuCcu_getBaud1Frequency
50101c40 g       .inttab	00000000 __interrupt_226
800025a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_45
80002b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_88
70000e30 g     O .data	00000008 IfxPort_P10_2
8000dbd0 g     F .text	00000018 osEE_task_activated
80005210 g     F .text	0000006c IfxMultican_calcTimingFromBTR
50101700 g       .inttab	00000000 __interrupt_184
5001bb00 g       .CPU2.istack	00000000 __ISTACK2
80000530 g     O .rodata	00000024 osEE_kdb_var
70000d50 g     O .data	00000008 IfxPort_P13_3
50100fc0 g       .inttab	00000000 __interrupt_126
50100dc0 g       .inttab	00000000 __interrupt_110
50101820 g       .inttab	00000000 __interrupt_193
50100400 g       .inttab	00000000 __interrupt_32
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
80009780 g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
8000e3a0 g     F .text	00000106 _strtol_r
70000e68 g     O .data	00000008 IfxPort_P02_5
70000b70 g     O .data	00000008 IfxPort_P23_7
80003b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_220
70000cb0 g     O .data	00000008 IfxPort_P15_8
80003020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_129
8000f7b8 g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
80010496 g     F .text	0000049a _malloc_r
80006ef4 g     F .text	00000042 IfxPort_setPinModeLvdsMedium
70000f08 g     O .data	00000008 IfxPort_P00_2
80000320 g     O .rodata	00000014 IfxMultican_RXD0D_P02_4_IN
800039e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_207
501015c0 g       .inttab	00000000 __interrupt_174
8000de80 g     F .text	00000060 osEE_counter_insert_abs_trigger
80000fc0 g       .traptab	00000000 ___trap_6
80003d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_235
800024e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_39
80002020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_1
50101b60 g       .inttab	00000000 __interrupt_219
80002a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_80
80008000 g       *ABS*	00000000 __A8_MEM
b0008000 g       *ABS*	00000000 __A9_MEM
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_231
50101fa0 g       .inttab	00000000 __interrupt_253
50100760 g       .inttab	00000000 __interrupt_59
80009a80 g     F .text	00000098 CAN_RX_HND
80003340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_154
8000a818 g     F .text	0000007c _init_uart0
80002c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_98
70000cf0 g     O .data	00000008 IfxPort_P15_0
70000d38 g     O .data	00000008 IfxPort_P14_10
8000b692 g     F .text	0000001e Init_Ultrasonics
8000672e g     F .text	000001b2 IfxMultican_Can_initModule
80000dc0 g     O .rodata	00000014 .hidden __thenan_df
50100620 g       .inttab	00000000 __interrupt_49
800110c0 g     F .text	000000ba _malloc_trim_r
50100ea0 g       .inttab	00000000 __interrupt_117
80001108 g       .ctors	00000000 __CTOR_END__
70004498 g     O .bss	00000001 dir
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
50101540 g       .inttab	00000000 __interrupt_170
50000000 g       *ABS*	00000000 __DSPR2_START
800028c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_70
70000ed0 g     O .data	00000008 IfxPort_P00_9
80000078 g     O .rodata	00000014 IfxMultican_TXD3_P00_2_OUT
8000d3b8 g     F .text	000000a4 ReleaseResource
80003da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_237
80001108 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
80003c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_224
501011e0 g       .inttab	00000000 __interrupt_143
800026a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_53
00001000 g       *ABS*	00000000 __USTACK1_SIZE
80002b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_90
70000b68 g     O .data	00000008 IfxPort_P32_0
8000b3fa g     F .text	00000094 Init_DCMotorPWM
8000940c g     F .text	00000064 IfxScuCcu_enableExtClockOut1
8000bde0 g     F .text	00000054 SYSTEM_IdleExt
80005084 g     F .text	0000018c IfxMultican_Node_setNominalBitTiming
80011ec8 g     F .text	00000040 .hidden __nedf2
80003a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_209
50100280 g       .inttab	00000000 __interrupt_20
70000c30 g     O .data	00000008 IfxPort_P21_3
8000bdb4 g     F .text	0000000c SYSTEM_DisableProtectionExt
80003880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_196
80007f0c g     F .text	0000006a IfxScuCcu_getPllVcoFrequency
800118b8 g     F .text	0000002c unlock_wdtcon
80008e94 g     F .text	00000166 IfxScuCcu_setSpbFrequency
80006002 g     F .text	00000028 IfxMultican_Can_MsgObj_isRxPending
800001e0 g     O .rodata	00000014 IfxMultican_RXD3D_P11_10_IN
80003220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_145
80002d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_108
50101d00 g       .inttab	00000000 __interrupt_232
501010c0 g       .inttab	00000000 __interrupt_134
800003f8 g     O .rodata	00000080 IfxPort_cfg_esrMasks
80002a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_84
70000d40 g     O .data	00000008 IfxPort_P14_1
80003500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_168
8000449c g     F .text	0000005e IfxMultican_MsgObj_sendMessage
70000bd8 g     O .data	00000008 IfxPort_P22_4
80002400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_32
80003000 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_128
80006bf2 g     F .text	0000002a IfxPort_setESR
501002c0 g       .inttab	00000000 __interrupt_22
8000b22a g     F .text	0000014c clear_two_lines
80003620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_177
8000e4b8 g     F .text	00000028 _vsprintf_r
80003120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_137
80002900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_72
8000a6be g     F .text	00000060 remove_null
8000e33c g       .text	00000000 __trap_6
80000140 g     O .rodata	00000014 IfxMultican_TXD1_P00_0_OUT
501007c0 g       .inttab	00000000 __interrupt_62
501012e0 g       .inttab	00000000 __interrupt_151
50101b40 g       .inttab	00000000 __interrupt_218
50100c00 g       .inttab	00000000 __interrupt_96
80000f00 g     F .traptab	00000000 TriCore_trap_table
80002600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_48
50100660 g       .inttab	00000000 __interrupt_51
50100b20 g       .inttab	00000000 __interrupt_89
8000d89c g     F .text	0000004a GetElapsedValue
70001158 g     O .data	00000004 _impure_ptr
501017c0 g       .inttab	00000000 __interrupt_190
501005c0 g       .inttab	00000000 __interrupt_46
501000a0 g       .inttab	00000000 __interrupt_5
50101420 g       .inttab	00000000 __interrupt_161
80003660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_179
80006bca g     F .text	00000028 IfxPort_resetESR
80004154 g     F .text	0000000c IfxMultican_MsgObj_clearStatusFlag
501014c0 g       .inttab	00000000 __interrupt_166
501009e0 g       .inttab	00000000 __interrupt_79
70000ba0 g     O .data	00000008 IfxPort_P23_1
8000b51a g     F .text	00000032 movChA_PWM
8000017c g     O .rodata	00000014 IfxMultican_TXD0_P20_8_OUT
501001e0 g       .inttab	00000000 __interrupt_15
70000da8 g     O .data	00000008 IfxPort_P11_4
501013e0 g       .inttab	00000000 __interrupt_159
50100e40 g       .inttab	00000000 __interrupt_114
800036e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_183
8000d6ea g     F .text	00000030 GetAlarmBase
70000b08 g     O .data	00000008 IfxPort_P33_13
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_230
50101ee0 g       .inttab	00000000 __interrupt_247
70000de0 g     O .data	00000008 IfxPort_P11_11
8000aaec g     F .text	0000000e stopGpt12_T4
00002000 g       *ABS*	00000000 __CSA1_SIZE
800022c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_22
8000cf44 g     F .text	00000014 DisableAllInterrupts
8000b5c4 g     F .text	000000ce getTofDistance
8000a438 g     F .text	0000003e my_puts
80006c1c g     F .text	000000b4 IfxPort_setGroupModeInput
00001000 g       *ABS*	00000000 __USTACK_SIZE
70004490 g     O .bss	00000004 pwm
70000af0 g     O .data	00000008 IfxPort_P33_2
8000d1aa g     F .text	000000b0 ChainTask
70000ac0 g     O .data	00000008 IfxPort_P33_8
80009d6c g     F .text	00000016 _out_uart3
501019c0 g       .inttab	00000000 __interrupt_206
50100fe0 g       .inttab	00000000 __interrupt_127
50100f40 g       .inttab	00000000 __interrupt_122
70000d88 g     O .data	00000008 IfxPort_P11_8
70000d90 g     O .data	00000008 IfxPort_P11_7
50100320 g       .inttab	00000000 __interrupt_25
70000e28 g     O .data	00000008 IfxPort_P10_3
70000f10 g     O .data	00000008 IfxPort_P00_12
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_101
501018c0 g       .inttab	00000000 __interrupt_198
8000030c g     O .rodata	00000014 IfxMultican_RXD0E_P33_7_IN
70000d78 g     O .data	00000008 IfxPort_P12_0
8000c974 g     F .text	0000004c osEE_tricore_system_timer_handler
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_126
800086ac g     F .text	0000001c IfxScuCcu_initConfig
80003b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_217
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_221
8000ae98 g     F .text	00000010 getSW1
80001000 g       .traptab	00000000 osEE_tc_trap_mmu
50100000 g     F .inttab	00000000 TriCore_int_table
70000ea8 g     O .data	00000008 IfxPort_P01_7
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_87
8000cec8 g     F .text	0000006e osEE_tc_delay
70000e40 g     O .data	00000008 IfxPort_P10_0
80000dd4 g     O .rodata	00000000 __clear_table
80011930 g     F .text	00000020 lock_safety_wdtcon
80007d52 g     F .text	000000a4 IfxScuCcu_getPllErayFrequency
501010a0 g       .inttab	00000000 __interrupt_133
50100560 g       .inttab	00000000 __interrupt_43
70000d08 g     O .data	00000008 IfxPort_P14_7
8000dbe8 g     F .text	00000018 osEE_task_end
50100ac0 g       .inttab	00000000 __interrupt_86
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_110
80002f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_124
800002f8 g     O .rodata	00000014 IfxMultican_RXD0G_P34_2_IN
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_222
80002240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_18
8000ab00 g     F .text	00000006 getGpt12_T4
50101920 g       .inttab	00000000 __interrupt_201
80002440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_34
80001100 g       .ctors	00000000 __EH_FRAME_BEGIN__
50101e40 g       .inttab	00000000 __interrupt_242
80002840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_66
50101180 g       .inttab	00000000 __interrupt_140
80003140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_138
8000de08 g     F .text	00000078 osEE_counter_insert_rel_trigger
80003e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_243
50101560 g       .inttab	00000000 __interrupt_171
80007f76 g     F .text	000000b6 IfxScuCcu_getSourceFrequency
800045b6 g     F .text	0000001a IfxMultican_Node_deinit
70000bb0 g     O .data	00000008 IfxPort_P22_9
8000e13a g     F .text	00000014 osEE_change_context_from_task_end
8000008c g     O .rodata	00000014 IfxMultican_TXD2_P32_5_OUT
50100220 g       .inttab	00000000 __interrupt_17
8000d71a g     F .text	00000066 WaitEvent
700019a4 g     O .bss	000000c8 stRxMsgData
80006966 g     F .text	000000f4 IfxPort_disableEmergencyStop
50101a00 g       .inttab	00000000 __interrupt_208
50101da0 g       .inttab	00000000 __interrupt_237
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_253
80003c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_225
50100700 g       .inttab	00000000 __interrupt_56
8000a9a2 g     F .text	0000000a getRightMotorDuty
501009a0 g       .inttab	00000000 __interrupt_77
80002880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_68
70000c58 g     O .data	00000008 IfxPort_P20_8
70000bb8 g     O .data	00000008 IfxPort_P22_8
70000c60 g     O .data	00000008 IfxPort_P20_7
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
50101280 g       .inttab	00000000 __interrupt_148
50100ca0 g       .inttab	00000000 __interrupt_101
8000d8e6 g     F .text	0000006e IncrementCounter
80000f60 g       .traptab	00000000 __trap_3
80002980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_76
70000df0 g     O .data	00000008 IfxPort_P11_1
50101f20 g       .inttab	00000000 __interrupt_249
5001b600 g       .CPU2.ustack	00000000 __USTACK2
50101e60 g       .inttab	00000000 __interrupt_243
50101940 g       .inttab	00000000 __interrupt_202
8000e0c8 g     F .text	00000028 osEE_alarm_cancel
80003940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_202
50101ce0 g       .inttab	00000000 __interrupt_231
800000a0 g     O .rodata	00000014 IfxMultican_TXD2_P15_0_OUT
8000ce5c g     F .text	0000006c osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80003260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_147
50100860 g       .inttab	00000000 __interrupt_67
80000020 g       .startup	00000000 BootModeIndex
50101f00 g       .inttab	00000000 __interrupt_248
501019e0 g       .inttab	00000000 __interrupt_207
80006552 g     F .text	000000c6 IfxMultican_Can_Node_sendToBusOff
70000000 g     O .data	00000a40 IfxPort_Pin_pinTable
800032c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_150
80003d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_236
70001584 g     O .data	00000004 __malloc_trim_threshold
800031a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_141
80002d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_104
501003a0 g       .inttab	00000000 __interrupt_29
8000dee0 g     F .text	00000024 osEE_counter_cancel_trigger
50100020 g       .inttab	00000000 ___interrupt_1
80010d9c g     F .text	000000ca __mdiff
800020e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_7
501015e0 g       .inttab	00000000 __interrupt_175
80002920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_73
8000dc20 g     F .text	0000001e osEE_activate_isr2
8000bf26 g     F .text	00000098 FuncLCD_IsIntunnel
8000afe2 g     F .text	00000100 init_lcd
70001150 g     O .data	00000004 __ctype_ptr__
80008d72 g     F .text	00000122 IfxScuCcu_setPll2Frequency
7000449c g     O .bss	00000004 duty
70000e70 g     O .data	00000008 IfxPort_P02_4
80000334 g     O .rodata	00000014 IfxMultican_RXD0C_P12_0_IN
50101ba0 g       .inttab	00000000 __interrupt_221
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_238
70000a68 g     O .data	00000008 IfxPort_P40_4
80020000 g       .startup	00000000 BootModeHeader1
8000ca58 g     F .text	000001e2 osEE_tc_set_pll_fsource
50101800 g       .inttab	00000000 __interrupt_192
80006d86 g     F .text	000000a4 IfxPort_setGroupPadDriver
50100a40 g       .inttab	00000000 __interrupt_82
800026e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_55
70001bc8 g     O .bss	00000004 beepOnOff
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_127
70000f20 g     O .data	00000008 IfxPort_P00_10
80002b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_92
8000aae0 g     F .text	0000000c runGpt12_T4
70000bf8 g     O .data	00000008 IfxPort_P22_10
8000e366 g     F .text	0000000a atoi
800001a4 g     O .rodata	00000014 IfxMultican_TXD0_P02_5_OUT
501002e0 g       .inttab	00000000 __interrupt_23
80000968 g     O .rodata	00000101 _ctype_
80002320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_25
800039c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_206
800029e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_79
80000e3c g     O .rodata	00000000 __copy_table
501011a0 g       .inttab	00000000 __interrupt_141
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
8000a7e4 g     F .text	00000034 _poll_uart1
8000ac36 g     F .text	00000016 Init_Buzzer
50100e60 g       .inttab	00000000 __interrupt_115
70000c80 g     O .data	00000008 IfxPort_P20_13
50101fc0 g       .inttab	00000000 __interrupt_254
50100720 g       .inttab	00000000 __interrupt_57
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_119
80011950 g     F .text	00000010 _exit
80002280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_20
80001020 g       .traptab	00000000 osEE_tc_trap_protection
80001000 g     F .traptab	00000000 __TRAPTAB
70000e60 g     O .data	00000008 IfxPort_P02_6
70000b80 g     O .data	00000008 IfxPort_P23_5
50101380 g       .inttab	00000000 __interrupt_156
800001b8 g     O .rodata	00000014 IfxMultican_TXD0_P02_0_OUT
00002000 g       *ABS*	00000000 __CSA2_SIZE
8000ae5c g     F .text	0000001e toggleLED1
800035a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_173
80004602 g     F .text	00000024 IfxMultican_Node_initTxPin
70000c48 g     O .data	00000008 IfxPort_P21_0
70004499 g     O .bss	00000001 ch
80009888 g     F .text	000000e0 IfxScuWdt_initSafetyWatchdog
50101a60 g       .inttab	00000000 __interrupt_211
50100800 g       .inttab	00000000 __interrupt_64
8000e38c g     F .text	00000014 strlen
50100de0 g       .inttab	00000000 __interrupt_111
501008a0 g       .inttab	00000000 __interrupt_69
800000b4 g     O .rodata	00000014 IfxMultican_TXD2_P14_10_OUT
80003860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_195
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
50101720 g       .inttab	00000000 __interrupt_185
8000012c g     O .rodata	00000014 IfxMultican_TXD1_P01_3_OUT
50101680 g       .inttab	00000000 __interrupt_180
80011f48 g     F .text	00000040 .hidden __gedf2
70000d30 g     O .data	00000008 IfxPort_P14_2
80000478 g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_94
70000e00 g     O .data	00000008 IfxPort_P10_8
50101a20 g       .inttab	00000000 __interrupt_209
80002720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_57
70000b38 g     O .data	00000008 IfxPort_P32_7
501003c0 g       .inttab	00000000 __interrupt_30
70000e48 g     O .data	00000008 IfxPort_P02_9
70000d70 g     O .data	00000008 IfxPort_P12_1
80003420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_161
80002f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_122
70000ac8 g     O .data	00000008 IfxPort_P33_7
80000f00 g       .traptab	00000000 __trap_0
8000b48e g     F .text	00000032 movChA
8000e370 g     F .text	0000001c strchr
70004d18 g     O .inttab	00000001 __HEAP_END
50100640 g       .inttab	00000000 __interrupt_50
8000c40a g     F .text	00000044 FuncTOF_Example
8000bda0 g     F .text	00000004 SYSTEM_EnableProtection
6001bc00 g       .CPU1.csa	00000000 __CSA1
50101780 g       .inttab	00000000 __interrupt_188
70000b20 g     O .data	00000008 IfxPort_P33_10
80007a36 g     F .text	00000140 IfxScuCcu_getMaxFrequency
50101f60 g       .inttab	00000000 __interrupt_251
50101b20 g       .inttab	00000000 __interrupt_217
50100be0 g       .inttab	00000000 __interrupt_95
8000cf58 g     F .text	0000001a EnableAllInterrupts
8000b54c g     F .text	00000032 movChB_PWM
8000ab9c g     F .text	0000002a VADC_startConversion
50100b00 g       .inttab	00000000 __interrupt_88
8000a894 g     F .text	00000038 _in_uart0
501005a0 g       .inttab	00000000 __interrupt_45
80006e2a g     F .text	00000062 IfxPort_setPinMode
8000c25e g     F .text	00000008 FuncTask_AEB
80003640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_178
70000b98 g     O .data	00000008 IfxPort_P23_2
8000607a g     F .text	00000058 IfxMultican_Can_MsgObj_readMessage
80002780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_60
8000a71e g     F .text	00000092 _init_uart1
8000e232 g     F .text	0000001a osEE_hal_restore_ctx
50101600 g       .inttab	00000000 __interrupt_176
80011b8c g     F .text	00000040 .hidden __subdf3
70000ef0 g     O .data	00000008 IfxPort_P00_5
50100780 g       .inttab	00000000 __interrupt_60
70008000 g     O *ABS*	00000000 _SMALL_DATA_
80003f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_248
700019a0 g     O .bss	00000001 tunnel_ok
80009a06 g     F .text	00000032 IfxScuWdt_setSafetyEndinit
80010a94 g     F .text	00000066 __lo0bits
800034c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_166
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
50100500 g       .inttab	00000000 __interrupt_40
70000a58 g     O .data	00000008 IfxPort_P40_6
70000ca0 g     O .data	00000008 IfxPort_P20_1
50100a60 g       .inttab	00000000 __interrupt_83
8000426c g     F .text	000000a8 IfxMultican_MsgObj_readMessage
8000ae42 g     F .text	0000001a setLED2
50100060 g       .inttab	00000000 __interrupt_3
50100460 g       .inttab	00000000 __interrupt_35
70000a40 g     O .data	00000008 IfxPort_P40_9
80003080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_132
50101000 g       .inttab	00000000 __interrupt_128
80007d20 g     F .text	00000032 IfxScuCcu_getOscFrequency
800064b6 g     F .text	0000009c IfxMultican_Can_Node_initConfig
8000d056 g     F .text	00000038 ResumeOSInterrupts
50100f60 g       .inttab	00000000 __interrupt_123
800030e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_135
800041da g     F .text	00000006 IfxMultican_MsgObj_getStatus
501004c0 g       .inttab	00000000 __interrupt_38
50100c40 g       .inttab	00000000 __interrupt_98
80003200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_144
80002d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_107
80002160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_11
80000554 g     O .rodata	0000000c osEE_cdb_var
501006a0 g       .inttab	00000000 __interrupt_53
80012196 g     F .text	00000112 .hidden __pack_d
70000de8 g     O .data	00000008 IfxPort_P11_10
8000d5e2 g     F .text	0000005a SetAbsAlarm
8000aeb8 g     F .text	00000094 getSW1_Debounce
8000d08e g     F .text	00000098 StartOS
70000c70 g     O .data	00000008 IfxPort_P20_3
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_229
70000ed8 g     O .data	00000008 IfxPort_P00_8
80003440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_162
8000a9d4 g     F .text	0000007a init_gpt1
800044fa g     F .text	0000006a IfxMultican_MsgObj_writeTxfifo
80000118 g     O .rodata	00000014 IfxMultican_TXD1_P02_9_OUT
50100940 g       .inttab	00000000 __interrupt_74
70000be8 g     O .data	00000008 IfxPort_P22_2
800109d0 g     F .text	00000082 __multadd
800109be g     F .text	00000012 _Bfree
8000b0e2 g     F .text	00000042 write_instruction
8000b378 g     F .text	00000082 Init_DCMotor
00000000         *UND*	00000000 __do_global_ctors
80008000 g     O *ABS*	00000000 _SMALL_DATA3_
80009c86 g     F .text	00000038 Driver_Can_TxTest
80003a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_212



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 85 62 	ja 8000c50a <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80000f00 <TriCore_trap_table>:
80000f00:	0d 00 00 02 	svlcx 
80000f04:	91 00 00 f7 	movh.a %a15,28672
80000f08:	19 f4 e8 34 	ld.w %d4,[%a15]19688 <70004ce8 <Tdisptab>>
80000f0c:	60 4f       	mov.a %a15,%d4
80000f0e:	02 f4       	mov %d4,%d15
80000f10:	2d 0f 00 00 	calli %a15
80000f14:	0d 00 40 02 	rslcx 
80000f18:	00 80       	rfe 
80000f1a:	00 00       	nop 
80000f1c:	00 00       	nop 
	...

80000f20 <__trap_1>:
80000f20:	0d 00 00 02 	svlcx 
80000f24:	91 00 00 f7 	movh.a %a15,28672
80000f28:	19 f4 ec 34 	ld.w %d4,[%a15]19692 <70004cec <Tdisptab+0x4>>
80000f2c:	60 4f       	mov.a %a15,%d4
80000f2e:	02 f4       	mov %d4,%d15
80000f30:	2d 0f 00 00 	calli %a15
80000f34:	0d 00 40 02 	rslcx 
80000f38:	00 80       	rfe 
80000f3a:	00 00       	nop 
80000f3c:	00 00       	nop 
	...

80000f40 <__trap_2>:
80000f40:	0d 00 00 02 	svlcx 
80000f44:	91 00 00 f7 	movh.a %a15,28672
80000f48:	19 f4 f0 34 	ld.w %d4,[%a15]19696 <70004cf0 <Tdisptab+0x8>>
80000f4c:	60 4f       	mov.a %a15,%d4
80000f4e:	02 f4       	mov %d4,%d15
80000f50:	2d 0f 00 00 	calli %a15
80000f54:	0d 00 40 02 	rslcx 
80000f58:	00 80       	rfe 
80000f5a:	00 00       	nop 
80000f5c:	00 00       	nop 
	...

80000f60 <__trap_3>:
80000f60:	0d 00 00 02 	svlcx 
80000f64:	91 00 00 f7 	movh.a %a15,28672
80000f68:	19 f4 f4 34 	ld.w %d4,[%a15]19700 <70004cf4 <Tdisptab+0xc>>
80000f6c:	60 4f       	mov.a %a15,%d4
80000f6e:	02 f4       	mov %d4,%d15
80000f70:	2d 0f 00 00 	calli %a15
80000f74:	0d 00 40 02 	rslcx 
80000f78:	00 80       	rfe 
80000f7a:	00 00       	nop 
80000f7c:	00 00       	nop 
	...

80000f80 <__trap_4>:
80000f80:	0d 00 00 02 	svlcx 
80000f84:	91 00 00 f7 	movh.a %a15,28672
80000f88:	19 f4 f8 34 	ld.w %d4,[%a15]19704 <70004cf8 <Tdisptab+0x10>>
80000f8c:	60 4f       	mov.a %a15,%d4
80000f8e:	02 f4       	mov %d4,%d15
80000f90:	2d 0f 00 00 	calli %a15
80000f94:	0d 00 40 02 	rslcx 
80000f98:	00 80       	rfe 
80000f9a:	00 00       	nop 
80000f9c:	00 00       	nop 
	...

80000fa0 <__trap_5>:
80000fa0:	0d 00 00 02 	svlcx 
80000fa4:	91 00 00 f7 	movh.a %a15,28672
80000fa8:	19 f4 fc 34 	ld.w %d4,[%a15]19708 <70004cfc <Tdisptab+0x14>>
80000fac:	60 4f       	mov.a %a15,%d4
80000fae:	02 f4       	mov %d4,%d15
80000fb0:	2d 0f 00 00 	calli %a15
80000fb4:	0d 00 40 02 	rslcx 
80000fb8:	00 80       	rfe 
80000fba:	00 00       	nop 
80000fbc:	00 00       	nop 
	...

80000fc0 <___trap_6>:
80000fc0:	1d 00 be 69 	j 8000e33c <__trap_6>
	...

80000fe0 <__trap_7>:
80000fe0:	0d 00 00 02 	svlcx 
80000fe4:	91 00 00 f7 	movh.a %a15,28672
80000fe8:	19 f4 c4 44 	ld.w %d4,[%a15]19716 <70004d04 <Tdisptab+0x1c>>
80000fec:	60 4f       	mov.a %a15,%d4
80000fee:	02 f4       	mov %d4,%d15
80000ff0:	2d 0f 00 00 	calli %a15
80000ff4:	0d 00 40 02 	rslcx 
80000ff8:	00 80       	rfe 
80000ffa:	00 00       	nop 
80000ffc:	00 00       	nop 
	...

80001000 <__TRAPTAB>:
80001000:	00 a0       	debug 
80001002:	1d ff ff ff 	j 80001000 <__TRAPTAB>
	...

80001020 <osEE_tc_trap_protection>:
80001020:	00 a0       	debug 
80001022:	1d ff ff ff 	j 80001020 <osEE_tc_trap_protection>
	...

80001040 <osEE_tc_trap_instruction>:
80001040:	00 a0       	debug 
80001042:	1d ff ff ff 	j 80001040 <osEE_tc_trap_instruction>
	...

80001060 <osEE_tc_trap_context>:
80001060:	00 a0       	debug 
80001062:	1d ff ff ff 	j 80001060 <osEE_tc_trap_context>
	...

80001080 <osEE_tc_trap_bus>:
80001080:	00 a0       	debug 
80001082:	1d ff ff ff 	j 80001080 <osEE_tc_trap_bus>
	...

800010a0 <osEE_tc_trap_assertion>:
800010a0:	00 a0       	debug 
800010a2:	1d ff ff ff 	j 800010a0 <osEE_tc_trap_assertion>
	...

800010c0 <osEE_tc_trap_system>:
800010c0:	00 a0       	debug 
800010c2:	1d ff ff ff 	j 800010c0 <osEE_tc_trap_system>
	...

800010e0 <osEE_tc_trap_nmi>:
800010e0:	00 a0       	debug 
800010e2:	1d ff ff ff 	j 800010e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001100 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001108 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_isr_dummy_entry_1>:
80002020:	3c 00       	j 80002020 <osEE_tc_isr_dummy_entry_1>
	...

80002040 <osEE_tc_isr_dummy_entry_2>:
80002040:	3c 00       	j 80002040 <osEE_tc_isr_dummy_entry_2>
	...

80002060 <osEE_tc_isr2_entry_3>:
80002060:	0d 00 00 02 	svlcx 
80002064:	82 04       	mov %d4,0
80002066:	1d 00 68 57 	j 8000cf36 <osEE_tc_isr2_wrapper>
	...

80002080 <osEE_tc_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_isr_dummy_entry_7>
	...

80002100 <osEE_tc_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_isr_dummy_entry_8>
	...

80002120 <osEE_tc_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_isr_dummy_entry_9>
	...

80002140 <osEE_tc_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_isr_dummy_entry_10>
	...

80002160 <osEE_tc_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_isr_dummy_entry_11>
	...

80002180 <osEE_tc_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_isr_dummy_entry_15>
	...

80002200 <osEE_tc_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_isr_dummy_entry_16>
	...

80002220 <osEE_tc_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_isr_dummy_entry_17>
	...

80002240 <osEE_tc_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_isr_dummy_entry_18>
	...

80002260 <osEE_tc_isr_dummy_entry_19>:
80002260:	3c 00       	j 80002260 <osEE_tc_isr_dummy_entry_19>
	...

80002280 <osEE_tc_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_isr_dummy_entry_23>
	...

80002300 <osEE_tc_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_isr_dummy_entry_24>
	...

80002320 <osEE_tc_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_isr_dummy_entry_25>
	...

80002340 <osEE_tc_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_isr_dummy_entry_26>
	...

80002360 <osEE_tc_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_isr_dummy_entry_27>
	...

80002380 <osEE_tc_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_isr_dummy_entry_31>
	...

80002400 <osEE_tc_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_isr_dummy_entry_32>
	...

80002420 <osEE_tc_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_isr_dummy_entry_33>
	...

80002440 <osEE_tc_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_isr_dummy_entry_34>
	...

80002460 <osEE_tc_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_isr_dummy_entry_35>
	...

80002480 <osEE_tc_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_isr_dummy_entry_39>
	...

80002500 <osEE_tc_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_isr_dummy_entry_40>
	...

80002520 <osEE_tc_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_isr_dummy_entry_41>
	...

80002540 <osEE_tc_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_isr_dummy_entry_42>
	...

80002560 <osEE_tc_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_isr_dummy_entry_43>
	...

80002580 <osEE_tc_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_isr_dummy_entry_47>
	...

80002600 <osEE_tc_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_isr_dummy_entry_48>
	...

80002620 <osEE_tc_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_isr_dummy_entry_49>
	...

80002640 <osEE_tc_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_isr_dummy_entry_50>
	...

80002660 <osEE_tc_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_isr_dummy_entry_51>
	...

80002680 <osEE_tc_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_isr_dummy_entry_55>
	...

80002700 <osEE_tc_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_isr_dummy_entry_56>
	...

80002720 <osEE_tc_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_isr_dummy_entry_57>
	...

80002740 <osEE_tc_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_isr_dummy_entry_58>
	...

80002760 <osEE_tc_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_isr_dummy_entry_59>
	...

80002780 <osEE_tc_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_isr_dummy_entry_63>
	...

80002800 <osEE_tc_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_isr_dummy_entry_64>
	...

80002820 <osEE_tc_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_isr_dummy_entry_65>
	...

80002840 <osEE_tc_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_isr_dummy_entry_66>
	...

80002860 <osEE_tc_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_isr_dummy_entry_67>
	...

80002880 <osEE_tc_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_isr_dummy_entry_71>
	...

80002900 <osEE_tc_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_isr_dummy_entry_72>
	...

80002920 <osEE_tc_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_isr_dummy_entry_73>
	...

80002940 <osEE_tc_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_isr_dummy_entry_74>
	...

80002960 <osEE_tc_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_isr_dummy_entry_75>
	...

80002980 <osEE_tc_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_isr_dummy_entry_127>
	...

80003000 <osEE_tc_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_isr_dummy_entry_128>
	...

80003020 <osEE_tc_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_isr_dummy_entry_129>
	...

80003040 <osEE_tc_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_isr_dummy_entry_130>
	...

80003060 <osEE_tc_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_isr_dummy_entry_131>
	...

80003080 <osEE_tc_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_isr_dummy_entry_135>
	...

80003100 <osEE_tc_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_isr_dummy_entry_136>
	...

80003120 <osEE_tc_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_isr_dummy_entry_137>
	...

80003140 <osEE_tc_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_isr_dummy_entry_138>
	...

80003160 <osEE_tc_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_isr_dummy_entry_139>
	...

80003180 <osEE_tc_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_isr_dummy_entry_143>
	...

80003200 <osEE_tc_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_isr_dummy_entry_144>
	...

80003220 <osEE_tc_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_isr_dummy_entry_145>
	...

80003240 <osEE_tc_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_isr_dummy_entry_146>
	...

80003260 <osEE_tc_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_isr_dummy_entry_147>
	...

80003280 <osEE_tc_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_isr_dummy_entry_151>
	...

80003300 <osEE_tc_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_isr_dummy_entry_152>
	...

80003320 <osEE_tc_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_isr_dummy_entry_153>
	...

80003340 <osEE_tc_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_isr_dummy_entry_154>
	...

80003360 <osEE_tc_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_isr_dummy_entry_155>
	...

80003380 <osEE_tc_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_isr_dummy_entry_159>
	...

80003400 <osEE_tc_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_isr_dummy_entry_160>
	...

80003420 <osEE_tc_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_isr_dummy_entry_161>
	...

80003440 <osEE_tc_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_isr_dummy_entry_162>
	...

80003460 <osEE_tc_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_isr_dummy_entry_163>
	...

80003480 <osEE_tc_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_isr_dummy_entry_167>
	...

80003500 <osEE_tc_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_isr_dummy_entry_168>
	...

80003520 <osEE_tc_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_isr_dummy_entry_169>
	...

80003540 <osEE_tc_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_isr_dummy_entry_170>
	...

80003560 <osEE_tc_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_isr_dummy_entry_171>
	...

80003580 <osEE_tc_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_isr_dummy_entry_175>
	...

80003600 <osEE_tc_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_isr_dummy_entry_176>
	...

80003620 <osEE_tc_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_isr_dummy_entry_177>
	...

80003640 <osEE_tc_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_isr_dummy_entry_178>
	...

80003660 <osEE_tc_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_isr_dummy_entry_179>
	...

80003680 <osEE_tc_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_isr_dummy_entry_183>
	...

80003700 <osEE_tc_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_isr_dummy_entry_184>
	...

80003720 <osEE_tc_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_isr_dummy_entry_185>
	...

80003740 <osEE_tc_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_isr_dummy_entry_186>
	...

80003760 <osEE_tc_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_isr_dummy_entry_187>
	...

80003780 <osEE_tc_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_isr_dummy_entry_191>
	...

80003800 <osEE_tc_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_isr_dummy_entry_192>
	...

80003820 <osEE_tc_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_isr_dummy_entry_193>
	...

80003840 <osEE_tc_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_isr_dummy_entry_194>
	...

80003860 <osEE_tc_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_isr_dummy_entry_195>
	...

80003880 <osEE_tc_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_isr_dummy_entry_199>
	...

80003900 <osEE_tc_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_isr_dummy_entry_200>
	...

80003920 <osEE_tc_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_isr_dummy_entry_201>
	...

80003940 <osEE_tc_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_isr_dummy_entry_202>
	...

80003960 <osEE_tc_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_isr_dummy_entry_203>
	...

80003980 <osEE_tc_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <IfxMultican_MsgObj_doReadLongFrame>:

IFX_STATIC void IfxMultican_MsgObj_doReadLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj       = IfxMultican_MsgObj_getPointer(mcan, msgObjId);

    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004000:	8f 54 00 30 	sh %d3,%d4,5
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
80004004:	1b 04 08 40 	addi %d4,%d4,128
80004008:	01 43 00 f6 	addsc.a %a15,%a4,%d3,0
8000400c:	8f 54 00 60 	sh %d6,%d4,5
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80004010:	da 08       	mov %d15,8
80004012:	01 46 00 36 	addsc.a %a3,%a4,%d6,0

IFX_STATIC void IfxMultican_MsgObj_doReadLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj       = IfxMultican_MsgObj_getPointer(mcan, msgObjId);

    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004016:	19 f5 04 01 	ld.w %d5,[%a15]4100
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
8000401a:	19 f2 04 01 	ld.w %d2,[%a15]4100
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
8000401e:	59 ff 1c 01 	st.w [%a15]4124,%d15
80004022:	4c 30       	ld.w %d15,[%a3]0

IFX_STATIC void IfxMultican_MsgObj_doReadLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj       = IfxMultican_MsgObj_getPointer(mcan, msgObjId);

    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004024:	8f f5 0f 51 	and %d5,%d5,255
80004028:	37 0f 64 fc 	extr.u %d15,%d15,24,4
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
8000402c:	37 02 68 24 	extr.u %d2,%d2,8,8

    /* copy the length code from hardware */
    IfxMultican_DataLengthCode lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);

    /* read the data from the data registers */
    if (lengthCode > IfxMultican_DataLengthCode_0) /* no.of bytes 0 to 8 */
80004030:	6e 6c       	jz %d15,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwObj->DATAL.U;
80004032:	19 f6 10 01 	ld.w %d6,[%a15]4112
80004036:	74 66       	st.w [%a6],%d6
        *data++ = hwObj->DATAH.U;
80004038:	19 f6 14 01 	ld.w %d6,[%a15]4116
8000403c:	59 66 04 00 	st.w [%a6]4,%d6
    }

    /* read from bottom message object extended data registers */
    if (lengthCode > IfxMultican_DataLengthCode_8)
80004040:	bf 9f 64 80 	jlt.u %d15,9,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA0.U;
80004044:	1b 05 08 60 	addi %d6,%d5,128
80004048:	8f 56 00 70 	sh %d7,%d6,5
8000404c:	01 47 00 f6 	addsc.a %a15,%a4,%d7,0
80004050:	48 06       	ld.w %d6,[%a15]0
80004052:	59 66 08 00 	st.w [%a6]8,%d6
    }

    if (lengthCode > IfxMultican_DataLengthCode_12)
80004056:	8b 9f 00 62 	eq %d6,%d15,9
8000405a:	df 06 57 80 	jne %d6,0,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA1.U;
8000405e:	8f 55 00 60 	sh %d6,%d5,5
80004062:	01 46 00 26 	addsc.a %a2,%a4,%d6,0
80004066:	19 25 04 01 	ld.w %d5,[%a2]4100
8000406a:	59 65 0c 00 	st.w [%a6]12,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_16)
8000406e:	8b af 00 52 	eq %d5,%d15,10
80004072:	df 05 4b 80 	jne %d5,0,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA2.U;
80004076:	19 25 08 01 	ld.w %d5,[%a2]4104
8000407a:	59 65 10 00 	st.w [%a6]16,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_20)
8000407e:	8b bf 00 52 	eq %d5,%d15,11
80004082:	df 05 43 80 	jne %d5,0,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA3.U;
80004086:	19 25 0c 01 	ld.w %d5,[%a2]4108
8000408a:	59 65 14 00 	st.w [%a6]20,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_24)
8000408e:	8b cf 00 52 	eq %d5,%d15,12
80004092:	df 05 3b 80 	jne %d5,0,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA4.U;
80004096:	19 25 10 01 	ld.w %d5,[%a2]4112
8000409a:	59 65 18 00 	st.w [%a6]24,%d5
        *data++ = hwBotObj->EDATA5.U;
8000409e:	19 25 14 01 	ld.w %d5,[%a2]4116
800040a2:	59 65 1c 00 	st.w [%a6]28,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_32)
800040a6:	8b df 00 52 	eq %d5,%d15,13
800040aa:	df 05 2f 80 	jne %d5,0,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA6.U;
800040ae:	19 25 18 01 	ld.w %d5,[%a2]4120
800040b2:	59 65 20 00 	st.w [%a6]32,%d5
        /* read from top message object extended data registers */
        *data++ = hwTopObj->EDATA0.U;
800040b6:	1b 02 08 50 	addi %d5,%d2,128
800040ba:	8f 55 00 70 	sh %d7,%d5,5
800040be:	01 47 00 f6 	addsc.a %a15,%a4,%d7,0
800040c2:	48 05       	ld.w %d5,[%a15]0
800040c4:	59 65 24 00 	st.w [%a6]36,%d5
        *data++ = hwTopObj->EDATA1.U;
800040c8:	8f 52 00 50 	sh %d5,%d2,5
800040cc:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
800040d0:	19 f2 04 01 	ld.w %d2,[%a15]4100
800040d4:	59 62 28 00 	st.w [%a6]40,%d2
        *data++ = hwTopObj->EDATA2.U;
800040d8:	19 f2 08 01 	ld.w %d2,[%a15]4104
800040dc:	59 62 2c 00 	st.w [%a6]44,%d2
    }

    if (lengthCode > IfxMultican_DataLengthCode_48)
800040e0:	8b ff 20 22 	ne %d2,%d15,15
800040e4:	df 02 12 80 	jne %d2,0,80004108 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwTopObj->EDATA3.U;
800040e8:	19 f2 0c 01 	ld.w %d2,[%a15]4108
800040ec:	59 62 30 00 	st.w [%a6]48,%d2
        *data++ = hwTopObj->EDATA4.U;
800040f0:	19 f2 10 01 	ld.w %d2,[%a15]4112
800040f4:	59 62 34 00 	st.w [%a6]52,%d2
        *data++ = hwTopObj->EDATA5.U;
800040f8:	19 f2 14 01 	ld.w %d2,[%a15]4116
800040fc:	59 62 38 00 	st.w [%a6]56,%d2
        *data   = hwTopObj->EDATA6.U;
80004100:	19 f2 18 01 	ld.w %d2,[%a15]4120
80004104:	59 62 3c 00 	st.w [%a6]60,%d2
    }

    msg->fastBitRate = hwObj->FCR.B.BRS;
80004108:	8f 54 00 60 	sh %d6,%d4,5
8000410c:	01 46 00 f6 	addsc.a %a15,%a4,%d6,0


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
80004110:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80004114:	48 02       	ld.w %d2,[%a15]0

    msg->lengthCode  = lengthCode;
80004116:	2c 54       	st.b [%a5]4,%d15
        *data++ = hwTopObj->EDATA4.U;
        *data++ = hwTopObj->EDATA5.U;
        *data   = hwTopObj->EDATA6.U;
    }

    msg->fastBitRate = hwObj->FCR.B.BRS;
80004118:	37 02 e1 22 	extr.u %d2,%d2,5,1
8000411c:	e9 52 10 00 	st.b [%a5]16,%d2
80004120:	19 4f 18 01 	ld.w %d15,[%a4]4120
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
80004124:	37 0f 7d 20 	extr.u %d2,%d15,0,29
80004128:	87 ff dd fe 	nor.t %d15,%d15,29,%d15,29
8000412c:	ab 2f a1 ff 	seln %d15,%d15,%d15,18
80004130:	8b 0f 00 71 	rsub %d7,%d15,0
80004134:	0f 72 20 70 	shas %d7,%d2,%d7

    msg->lengthCode  = lengthCode;

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
80004138:	74 57       	st.w [%a5],%d7
8000413a:	00 90       	ret 

8000413c <IfxMultican_MsgObj_cancelSend>:
{
    boolean         result = FALSE;
    Ifx_CAN_MO_CTR  ctr;
    Ifx_CAN_MO_STAT stat;

    stat.U = hwObj->STAT.U;
8000413c:	4c 47       	ld.w %d15,[%a4]28

    if ((stat.B.TXRQ != 0) && (stat.B.NEWDAT != 0))
8000413e:	3b 80 10 30 	mov %d3,264
80004142:	8f 8f 10 f1 	and %d15,%d15,264
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxMultican_MsgObj_cancelSend(Ifx_CAN_MO *hwObj)
{
    boolean         result = FALSE;
80004146:	82 02       	mov %d2,0
    Ifx_CAN_MO_CTR  ctr;
    Ifx_CAN_MO_STAT stat;

    stat.U = hwObj->STAT.U;

    if ((stat.B.TXRQ != 0) && (stat.B.NEWDAT != 0))
80004148:	3e 32       	jeq %d15,%d3,8000414c <IfxMultican_MsgObj_cancelSend+0x10>
        hwObj->CTR.U   = ctr.U;
        result         = TRUE;
    }

    return result;
}
8000414a:	00 90       	ret 
    stat.U = hwObj->STAT.U;

    if ((stat.B.TXRQ != 0) && (stat.B.NEWDAT != 0))
    {
        ctr.U          = 0;
        ctr.B.RESRTSEL = 1; /* take out from transmission */
8000414c:	da 40       	mov %d15,64
        hwObj->CTR.U   = ctr.U;
8000414e:	6c 47       	st.w [%a4]28,%d15
        result         = TRUE;
80004150:	82 12       	mov %d2,1
    }

    return result;
}
80004152:	00 90       	ret 

80004154 <IfxMultican_MsgObj_clearStatusFlag>:

void IfxMultican_MsgObj_clearStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;
80004154:	82 1f       	mov %d15,1
80004156:	0f 4f 00 40 	sh %d4,%d15,%d4

    hwObj->CTR.U = ctr.U;
8000415a:	59 44 1c 00 	st.w [%a4]28,%d4
8000415e:	00 90       	ret 

80004160 <IfxMultican_MsgObj_deinit>:

void IfxMultican_setListCommand(Ifx_CAN *mcan, uint32 cmd, uint32 arg2, uint32 arg1)
{
    Ifx_CAN_PANCTR panctr;

    panctr.B.PANAR1 = arg1;
80004160:	82 0f       	mov %d15,0
80004162:	37 4f 08 f8 	insert %d15,%d15,%d4,16,8
    panctr.B.PANAR2 = arg2;
80004166:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
    panctr.B.PANCMD = cmd;
8000416a:	b7 2f 08 f0 	insert %d15,%d15,2,0,8

    /** - write to CAN_PANCTR */
    mcan->PANCTR.U = panctr.U;
8000416e:	59 4f 04 70 	st.w [%a4]452,%d15
}


IFX_INLINE void IfxMultican_waitListReady(Ifx_CAN *mcan)
{
    while (mcan->PANCTR.B.BUSY != 0)
80004172:	19 4f 04 70 	ld.w %d15,[%a4]452
80004176:	37 0f 61 f4 	extr.u %d15,%d15,8,1
8000417a:	ee fc       	jnz %d15,80004172 <IfxMultican_MsgObj_deinit+0x12>
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
8000417c:	8f 54 00 20 	sh %d2,%d4,5
80004180:	01 42 00 f6 	addsc.a %a15,%a4,%d2,0

    hwObj->FCR.U   = 0x00000000UL;
80004184:	1b 04 08 40 	addi %d4,%d4,128
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
80004188:	bb f0 ff 2f 	mov.u %d2,65535
8000418c:	59 f2 1c 01 	st.w [%a15]4124,%d2

    hwObj->FCR.U   = 0x00000000UL;
80004190:	8f 54 00 20 	sh %d2,%d4,5
80004194:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
    hwObj->FGPR.U  = 0x00000000UL;
    hwObj->IPR.U   = 0x00000000UL;
    hwObj->AMR.U   = 0x3FFFFFFFUL;
80004198:	82 f2       	mov %d2,-1
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */

    hwObj->FCR.U   = 0x00000000UL;
8000419a:	6c 40       	st.w [%a4]0,%d15
    hwObj->FGPR.U  = 0x00000000UL;
8000419c:	59 ff 04 01 	st.w [%a15]4100,%d15
    hwObj->IPR.U   = 0x00000000UL;
800041a0:	59 ff 08 01 	st.w [%a15]4104,%d15
    hwObj->AMR.U   = 0x3FFFFFFFUL;
800041a4:	06 e2       	sh %d2,-2
800041a6:	59 f2 0c 01 	st.w [%a15]4108,%d2
    hwObj->DATAL.U = 0x00000000UL;
800041aa:	59 ff 10 01 	st.w [%a15]4112,%d15
    hwObj->DATAH.U = 0x00000000UL;
800041ae:	59 ff 14 01 	st.w [%a15]4116,%d15
    hwObj->AR.U    = 0x00000000UL;
800041b2:	59 ff 18 01 	st.w [%a15]4120,%d15
800041b6:	00 90       	ret 

800041b8 <IfxMultican_MsgObj_getPendingId>:
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
}


IfxMultican_MsgObjId IfxMultican_MsgObj_getPendingId(Ifx_CAN *mcan, IfxMultican_MsgObjGroup msgObjGroup)
{
800041b8:	01 44 02 46 	addsc.a %a4,%a4,%d4,2
    uint32               index    = mcan->MSID[msgObjGroup].U;
    IfxMultican_MsgObjId msgObjId = -1;
800041bc:	82 f2       	mov %d2,-1
}


IfxMultican_MsgObjId IfxMultican_MsgObj_getPendingId(Ifx_CAN *mcan, IfxMultican_MsgObjGroup msgObjGroup)
{
    uint32               index    = mcan->MSID[msgObjGroup].U;
800041be:	19 4f 00 60 	ld.w %d15,[%a4]384
    IfxMultican_MsgObjId msgObjId = -1;

    if (index != 0x20U)
800041c2:	8b 0f 02 32 	eq %d3,%d15,32
800041c6:	f6 39       	jnz %d3,800041d8 <IfxMultican_MsgObj_getPendingId+0x20>
    {
        mcan->MSPND[msgObjGroup].U = ~(1UL << index);
800041c8:	82 12       	mov %d2,1
800041ca:	0f f2 00 20 	sh %d2,%d2,%d15
800041ce:	46 02       	not %d2
800041d0:	59 42 00 50 	st.w [%a4]320,%d2
        msgObjId                   = index + (msgObjGroup << 5);
800041d4:	13 04 22 2f 	madd %d2,%d15,%d4,32
    }

    return msgObjId;
}
800041d8:	00 90       	ret 

800041da <IfxMultican_MsgObj_getStatus>:

IfxMultican_MsgObjStat IfxMultican_MsgObj_getStatus(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat status;

    status.U = hwObj->STAT.U;
800041da:	19 42 1c 00 	ld.w %d2,[%a4]28

    return status;
}
800041de:	00 90       	ret 

800041e0 <IfxMultican_MsgObj_getStatusFlag>:

boolean IfxMultican_MsgObj_getStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
    uint32 shift = (1U << flag);

    return (hwObj->STAT.U & shift) ? TRUE : FALSE;
800041e0:	19 42 1c 00 	ld.w %d2,[%a4]28
}
800041e4:	57 02 61 24 	extr.u %d2,%d2,%d4,1
800041e8:	00 90       	ret 

800041ea <IfxMultican_MsgObj_readLongFrame>:
IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
800041ea:	1b 04 08 20 	addi %d2,%d4,128
800041ee:	8f 52 00 30 	sh %d3,%d2,5
800041f2:	01 43 00 26 	addsc.a %a2,%a4,%d3,0
    return (hwObj->STAT.U & shift) ? TRUE : FALSE;
}


IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
800041f6:	40 4f       	mov.aa %a15,%a4
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
800041f8:	54 22       	ld.w %d2,[%a2]
    return (hwObj->STAT.U & shift) ? TRUE : FALSE;
}


IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
800041fa:	02 4f       	mov %d15,%d4
800041fc:	40 53       	mov.aa %a3,%a5
800041fe:	40 67       	mov.aa %a7,%a6
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
80004200:	6f 62 04 80 	jnz.t %d2,6,80004208 <IfxMultican_MsgObj_readLongFrame+0x1e>


IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;
80004204:	82 02       	mov %d2,0
80004206:	00 90       	ret 
    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;

    if (longFrame)
    {
        /* if new data available in the message object */
        if (hwObj->STAT.B.NEWDAT != 0)
80004208:	8f 54 00 80 	sh %d8,%d4,5
8000420c:	01 48 00 c6 	addsc.a %a12,%a4,%d8,0
80004210:	19 c2 1c 01 	ld.w %d2,[%a12]4124
80004214:	6f 32 05 80 	jnz.t %d2,3,8000421e <IfxMultican_MsgObj_readLongFrame+0x34>
                status |= IfxMultican_Status_messageLost;
            }
        }
        else
        {
            status = IfxMultican_Status_receiveEmpty;
80004218:	3b 00 04 20 	mov %d2,64
    {
        /* use normal read message API */
    }

    return status;
}
8000421c:	00 90       	ret 
8000421e:	40 3e       	mov.aa %a14,%a3
80004220:	40 7d       	mov.aa %a13,%a7
    {
        /* if new data available in the message object */
        if (hwObj->STAT.B.NEWDAT != 0)
        {
            Ifx_CAN_MO_STAT stat;
            IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);
80004222:	6d ff ef fe 	call 80004000 <IfxMultican_MsgObj_doReadLongFrame>
            stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */
80004226:	19 c9 1c 01 	ld.w %d9,[%a12]4124

            if (stat.B.RXUPD != 0)
            {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
                status = IfxMultican_Status_messageLost;
8000422a:	3b 00 08 20 	mov %d2,128
        {
            Ifx_CAN_MO_STAT stat;
            IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);
            stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */

            if (stat.B.RXUPD != 0)
8000422e:	6f 29 06 80 	jnz.t %d9,2,8000423a <IfxMultican_MsgObj_readLongFrame+0x50>
                {   /* Return message lost at 2nd read attempt, data will be read next time the API is called*/
                }
            }
            else
            {
                status = IfxMultican_Status_newData;
80004232:	3b 00 10 20 	mov %d2,256

            if (stat.B.RXUPD != 0)
            {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
                status = IfxMultican_Status_messageLost;
            }
            else if (stat.B.NEWDAT != 0)
80004236:	6f 39 0c 80 	jnz.t %d9,3,8000424e <IfxMultican_MsgObj_readLongFrame+0x64>
            else
            {
                status = IfxMultican_Status_newData;
            }

            if (stat.B.MSGLST != 0)
8000423a:	6f 49 f1 7f 	jz.t %d9,4,8000421c <IfxMultican_MsgObj_readLongFrame+0x32>
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
8000423e:	01 f8 00 f6 	addsc.a %a15,%a15,%d8,0
80004242:	da 10       	mov %d15,16
80004244:	59 ff 1c 01 	st.w [%a15]4124,%d15
            }

            if (stat.B.MSGLST != 0)
            {   /* At least on message has been lost */
                IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
                status |= IfxMultican_Status_messageLost;
80004248:	8f 02 48 21 	or %d2,%d2,128
8000424c:	00 90       	ret 
            else if (stat.B.NEWDAT != 0)
            {   /* Data might be inconsistent (update while reading), force massage lost flag, read new incoming data */
                Ifx_CAN_MO_STAT stat2;
                status = IfxMultican_Status_messageLost;
                /* perform read from the hardware */
                IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);
8000424e:	02 f4       	mov %d4,%d15
80004250:	40 f4       	mov.aa %a4,%a15
80004252:	40 e5       	mov.aa %a5,%a14
80004254:	40 d6       	mov.aa %a6,%a13
80004256:	6d ff d5 fe 	call 80004000 <IfxMultican_MsgObj_doReadLongFrame>

                stat2 = hwObj->STAT; /* Cache the status after reading */
8000425a:	19 c2 1c 01 	ld.w %d2,[%a12]4124

                if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
                {
                    status |= IfxMultican_Status_newData;
8000425e:	3b 00 18 f0 	mov %d15,384
                /* perform read from the hardware */
                IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);

                stat2 = hwObj->STAT; /* Cache the status after reading */

                if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
80004262:	8f c2 00 21 	and %d2,%d2,12
                {
                    status |= IfxMultican_Status_newData;
80004266:	ab 0f a8 22 	seln %d2,%d2,%d15,128
8000426a:	3c e8       	j 8000423a <IfxMultican_MsgObj_readLongFrame+0x50>

8000426c <IfxMultican_MsgObj_readMessage>:
IfxMultican_Status IfxMultican_MsgObj_readMessage(Ifx_CAN_MO *hwObj, IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
8000426c:	4c 47       	ld.w %d15,[%a4]28
            status |= IfxMultican_Status_messageLost;
        }
    }
    else
    {
        status = IfxMultican_Status_receiveEmpty;
8000426e:	3b 00 04 20 	mov %d2,64
IfxMultican_Status IfxMultican_MsgObj_readMessage(Ifx_CAN_MO *hwObj, IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
80004272:	ae 32       	jnz.t %d15,3,80004276 <IfxMultican_MsgObj_readMessage+0xa>
    {
        status = IfxMultican_Status_receiveEmpty;
    }

    return status;
}
80004274:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80004276:	3b 80 00 40 	mov %d4,8
8000427a:	59 44 1c 00 	st.w [%a4]28,%d4
{
    /* for standard message object and FIFO message objects*/
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);

    /* read the data from the data registers */
    msg->data[0] = hwObj->DATAL.U;
8000427e:	4c 44       	ld.w %d15,[%a4]16
80004280:	6c 52       	st.w [%a5]8,%d15
    msg->data[1] = hwObj->DATAH.U;
80004282:	4c 45       	ld.w %d15,[%a4]20
80004284:	6c 53       	st.w [%a5]12,%d15
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
80004286:	4c 40       	ld.w %d15,[%a4]0
80004288:	37 0f 64 fc 	extr.u %d15,%d15,24,4

    /* copy the length code from hardware */
    msg->lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);
8000428c:	2c 54       	st.b [%a5]4,%d15


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
8000428e:	4c 46       	ld.w %d15,[%a4]24
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
80004290:	37 0f 7d 20 	extr.u %d2,%d15,0,29
80004294:	87 ff dd fe 	nor.t %d15,%d15,29,%d15,29
80004298:	ab 2f a1 ff 	seln %d15,%d15,%d15,18
8000429c:	8b 0f 00 31 	rsub %d3,%d15,0
800042a0:	0f 32 20 30 	shas %d3,%d2,%d3

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
800042a4:	74 53       	st.w [%a5],%d3
    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
    {
        Ifx_CAN_MO_STAT stat;
        IfxMultican_MsgObj_doReadMessage(hwObj, msg);
        stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */
800042a6:	4c 47       	ld.w %d15,[%a4]28

        if (stat.B.RXUPD != 0)
        {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
            status = IfxMultican_Status_messageLost;
800042a8:	3b 00 08 20 	mov %d2,128
    {
        Ifx_CAN_MO_STAT stat;
        IfxMultican_MsgObj_doReadMessage(hwObj, msg);
        stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */

        if (stat.B.RXUPD != 0)
800042ac:	8f 4f 00 31 	and %d3,%d15,4
800042b0:	df 03 2b 80 	jne %d3,0,80004306 <IfxMultican_MsgObj_readMessage+0x9a>
            {   /* Return message lost at 2nd read attempt, data will be read next time the API is called*/
            }
        }
        else
        {
            status = IfxMultican_Status_newData;
800042b4:	3b 00 10 20 	mov %d2,256

        if (stat.B.RXUPD != 0)
        {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
            status = IfxMultican_Status_messageLost;
        }
        else if (stat.B.NEWDAT != 0)
800042b8:	6f 3f 27 00 	jz.t %d15,3,80004306 <IfxMultican_MsgObj_readMessage+0x9a>
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
800042bc:	59 44 1c 00 	st.w [%a4]28,%d4
{
    /* for standard message object and FIFO message objects*/
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);

    /* read the data from the data registers */
    msg->data[0] = hwObj->DATAL.U;
800042c0:	19 42 10 00 	ld.w %d2,[%a4]16
800042c4:	7b 00 00 52 	movh %d5,8192
800042c8:	59 52 08 00 	st.w [%a5]8,%d2
    msg->data[1] = hwObj->DATAH.U;
800042cc:	19 42 14 00 	ld.w %d2,[%a4]20
800042d0:	59 52 0c 00 	st.w [%a5]12,%d2
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
800042d4:	54 42       	ld.w %d2,[%a4]
800042d6:	37 02 64 2c 	extr.u %d2,%d2,24,4

    /* copy the length code from hardware */
    msg->lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);
800042da:	e9 52 04 00 	st.b [%a5]4,%d2


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
800042de:	19 42 18 00 	ld.w %d2,[%a4]24
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
800042e2:	37 02 7d 40 	extr.u %d4,%d2,0,29
800042e6:	26 52       	and %d2,%d5
800042e8:	ab 23 81 32 	sel %d3,%d2,%d3,18
800042ec:	8b 03 00 21 	rsub %d2,%d3,0
800042f0:	0f 24 20 20 	shas %d2,%d4,%d2

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
800042f4:	74 52       	st.w [%a5],%d2
            Ifx_CAN_MO_STAT stat2;
            status = IfxMultican_Status_messageLost;
            /* perform read from the hardware */
            IfxMultican_MsgObj_doReadMessage(hwObj, msg);

            stat2 = hwObj->STAT; /* Cache the status after reading */
800042f6:	19 42 1c 00 	ld.w %d2,[%a4]28

            if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
800042fa:	8f c2 00 31 	and %d3,%d2,12
            {
                status |= IfxMultican_Status_newData;
800042fe:	3b 00 18 20 	mov %d2,384
80004302:	ab 02 a8 23 	seln %d2,%d3,%d2,128
        else
        {
            status = IfxMultican_Status_newData;
        }

        if (stat.B.MSGLST != 0)
80004306:	6f 4f b7 7f 	jz.t %d15,4,80004274 <IfxMultican_MsgObj_readMessage+0x8>
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
8000430a:	da 10       	mov %d15,16
8000430c:	6c 47       	st.w [%a4]28,%d15
        }

        if (stat.B.MSGLST != 0)
        {   /* At least on message has been lost */
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
            status |= IfxMultican_Status_messageLost;
8000430e:	8f 02 48 21 	or %d2,%d2,128
    {
        status = IfxMultican_Status_receiveEmpty;
    }

    return status;
}
80004312:	00 90       	ret 

80004314 <IfxMultican_MsgObj_sendLongFrame>:
{
    Ifx_CAN_MO          *hwObj  = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status   status = IfxMultican_Status_ok;

    /* get the base address of top and bottom message objects */
    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004314:	8f 54 00 f0 	sh %d15,%d4,5
80004318:	10 4f       	addsc.a %a15,%a4,%d15,0
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
    Ifx_CAN_MO          *hwTopObj    = IfxMultican_MsgObj_getPointer(mcan, topMsgObjId);

    boolean              longFrame   = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
8000431a:	1b 04 08 40 	addi %d4,%d4,128
{
    Ifx_CAN_MO          *hwObj  = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status   status = IfxMultican_Status_ok;

    /* get the base address of top and bottom message objects */
    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
8000431e:	19 f2 04 01 	ld.w %d2,[%a15]4100
80004322:	8f f2 0f 61 	and %d6,%d2,255
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
80004326:	19 f2 04 01 	ld.w %d2,[%a15]4100
8000432a:	37 02 68 34 	extr.u %d3,%d2,8,8
    Ifx_CAN_MO          *hwTopObj    = IfxMultican_MsgObj_getPointer(mcan, topMsgObjId);

    boolean              longFrame   = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
8000432e:	8f 54 00 20 	sh %d2,%d4,5
80004332:	01 42 00 26 	addsc.a %a2,%a4,%d2,0
80004336:	54 22       	ld.w %d2,[%a2]
80004338:	6f 62 04 80 	jnz.t %d2,6,80004340 <IfxMultican_MsgObj_sendLongFrame+0x2c>
    /* standard frame */
    /* FDEN = 0/1, EDL = 0 and BRS = 0 (BRS = 1 also has no effect here) */
    else
    {
        /* use normal send message API */
        status = IfxMultican_Status_notInitialised;
8000433c:	82 12       	mov %d2,1
8000433e:	00 90       	ret 
    /* in either of the below cases, the two conditions FDEN = 0, EDl = 1 and BRS = 0/1 will not reach */
    /* long frame CAN FD */
    /* FDEN = 1, EDL = 1 and BRS = 0/1 */
    if (longFrame)
    {
        if (hwObj->STAT.B.TXRQ)
80004340:	19 f5 1c 01 	ld.w %d5,[%a15]4124
        {                           /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
            status = IfxMultican_Status_notSentBusy;
80004344:	3b 00 02 20 	mov %d2,32
    /* in either of the below cases, the two conditions FDEN = 0, EDl = 1 and BRS = 0/1 will not reach */
    /* long frame CAN FD */
    /* FDEN = 1, EDL = 1 and BRS = 0/1 */
    if (longFrame)
    {
        if (hwObj->STAT.B.TXRQ)
80004348:	6f 85 03 00 	jz.t %d5,8,8000434e <IfxMultican_MsgObj_sendLongFrame+0x3a>
        /* use normal send message API */
        status = IfxMultican_Status_notInitialised;
    }

    return status;
}
8000434c:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
8000434e:	59 f2 1c 01 	st.w [%a15]4124,%d2
        else
        {
            /* MSGVAL: Set message as not valid */
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);

            if (msg->lengthCode > IfxMultican_DataLengthCode_0) /* no.of bytes 0 to 8 */
80004352:	39 52 04 00 	ld.bu %d2,[%a5]4
80004356:	df 02 6f 00 	jeq %d2,0,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwObj->DATAL.U = *data++;
8000435a:	54 65       	ld.w %d5,[%a6]
8000435c:	59 f5 10 01 	st.w [%a15]4112,%d5
                hwObj->DATAH.U = *data++;
80004360:	19 62 04 00 	ld.w %d2,[%a6]4
80004364:	59 f2 14 01 	st.w [%a15]4116,%d2
            }

            /* load bottom message object extended data registers */
            if (msg->lengthCode > IfxMultican_DataLengthCode_8)
80004368:	39 52 04 00 	ld.bu %d2,[%a5]4
8000436c:	bf 92 64 80 	jlt.u %d2,9,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA0.U = *data++;
80004370:	1b 06 08 20 	addi %d2,%d6,128
80004374:	8f 52 00 50 	sh %d5,%d2,5
80004378:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
8000437c:	19 62 08 00 	ld.w %d2,[%a6]8
80004380:	68 02       	st.w [%a15]0,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_12)
80004382:	39 52 04 00 	ld.bu %d2,[%a5]4
80004386:	bf a2 57 80 	jlt.u %d2,10,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA1.U = *data++;
8000438a:	8f 56 00 50 	sh %d5,%d6,5
8000438e:	19 62 0c 00 	ld.w %d2,[%a6]12
80004392:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
80004396:	59 f2 04 01 	st.w [%a15]4100,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_16)
8000439a:	39 52 04 00 	ld.bu %d2,[%a5]4
8000439e:	bf b2 4b 80 	jlt.u %d2,11,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA2.U = *data++;
800043a2:	19 65 10 00 	ld.w %d5,[%a6]16
800043a6:	59 f5 08 01 	st.w [%a15]4104,%d5
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_20)
800043aa:	39 52 04 00 	ld.bu %d2,[%a5]4
800043ae:	bf c2 43 80 	jlt.u %d2,12,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA3.U = *data++;
800043b2:	19 62 14 00 	ld.w %d2,[%a6]20
800043b6:	59 f2 0c 01 	st.w [%a15]4108,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_24)
800043ba:	39 52 04 00 	ld.bu %d2,[%a5]4
800043be:	bf d2 3b 80 	jlt.u %d2,13,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA4.U = *data++;
800043c2:	19 65 18 00 	ld.w %d5,[%a6]24
800043c6:	59 f5 10 01 	st.w [%a15]4112,%d5
                hwBotObj->EDATA5.U = *data++;
800043ca:	19 62 1c 00 	ld.w %d2,[%a6]28
800043ce:	59 f2 14 01 	st.w [%a15]4116,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_32)
800043d2:	39 52 04 00 	ld.bu %d2,[%a5]4
800043d6:	bf e2 2f 80 	jlt.u %d2,14,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA6.U = *data++;
800043da:	19 65 20 00 	ld.w %d5,[%a6]32
                /* load bottom message object extended data registers */
                hwTopObj->EDATA0.U = *data++;
800043de:	1b 03 08 20 	addi %d2,%d3,128
                hwBotObj->EDATA5.U = *data++;
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_32)
            {
                hwBotObj->EDATA6.U = *data++;
800043e2:	59 f5 18 01 	st.w [%a15]4120,%d5
                /* load bottom message object extended data registers */
                hwTopObj->EDATA0.U = *data++;
800043e6:	8f 52 00 50 	sh %d5,%d2,5
800043ea:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
800043ee:	19 62 24 00 	ld.w %d2,[%a6]36
800043f2:	68 02       	st.w [%a15]0,%d2
                hwTopObj->EDATA1.U = *data++;
800043f4:	8f 53 00 20 	sh %d2,%d3,5
800043f8:	01 42 00 26 	addsc.a %a2,%a4,%d2,0
800043fc:	19 63 28 00 	ld.w %d3,[%a6]40
80004400:	59 23 04 01 	st.w [%a2]4100,%d3
                hwTopObj->EDATA2.U = *data++;
80004404:	19 65 2c 00 	ld.w %d5,[%a6]44
80004408:	59 25 08 01 	st.w [%a2]4104,%d5
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_48)
8000440c:	39 53 04 00 	ld.bu %d3,[%a5]4
80004410:	bf f3 12 80 	jlt.u %d3,15,80004434 <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwTopObj->EDATA3.U = *data++;
80004414:	19 62 30 00 	ld.w %d2,[%a6]48
80004418:	59 22 0c 01 	st.w [%a2]4108,%d2
                hwTopObj->EDATA4.U = *data++;
8000441c:	19 63 34 00 	ld.w %d3,[%a6]52
80004420:	59 23 10 01 	st.w [%a2]4112,%d3
                hwTopObj->EDATA5.U = *data++;
80004424:	19 65 38 00 	ld.w %d5,[%a6]56
80004428:	59 25 14 01 	st.w [%a2]4116,%d5
                hwTopObj->EDATA6.U = *data;
8000442c:	19 62 3c 00 	ld.w %d2,[%a6]60
80004430:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
80004434:	10 4f       	addsc.a %a15,%a4,%d15,0

            /* for long message */
            {
                /* set ID */
                boolean extendedFrame = IfxMultican_MsgObj_isExtendedFrame(hwObj);
                IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
80004436:	54 52       	ld.w %d2,[%a5]
80004438:	19 ff 18 01 	ld.w %d15,[%a15]4120
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
8000443c:	87 ff dd fe 	nor.t %d15,%d15,29,%d15,29
80004440:	ab 2f a1 ff 	seln %d15,%d15,%d15,18
80004444:	0f f2 00 f0 	sh %d15,%d2,%d15
80004448:	19 f2 18 01 	ld.w %d2,[%a15]4120
8000444c:	37 f2 1d f0 	insert %d15,%d2,%d15,0,29
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80004450:	8f 54 00 20 	sh %d2,%d4,5
80004454:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80004458:	59 ff 18 01 	st.w [%a15]4120,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
8000445c:	54 42       	ld.w %d2,[%a4]
8000445e:	0c 54       	ld.bu %d15,[%a5]4
80004460:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80004464:	6c 40       	st.w [%a4]0,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBitRateSwitch(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.BRS = enabled ? 1 : 0;
80004466:	39 5f 10 00 	ld.bu %d15,[%a5]16
8000446a:	ab 0f a2 2f 	seln %d2,%d15,%d15,32
8000446e:	4c 40       	ld.w %d15,[%a4]0
80004470:	8f 0f c2 f1 	andn %d15,%d15,32
80004474:	a6 2f       	or %d15,%d2
80004476:	6c 40       	st.w [%a4]0,%d15
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
80004478:	7b 80 00 f0 	movh %d15,8
8000447c:	59 ff 1c 01 	st.w [%a15]4124,%d15
80004480:	7b 00 02 f0 	movh %d15,32
80004484:	59 ff 1c 01 	st.w [%a15]4124,%d15
80004488:	7b 00 04 f0 	movh %d15,64
8000448c:	59 ff 1c 01 	st.w [%a15]4124,%d15
80004490:	7b 00 10 f0 	movh %d15,256
80004494:	59 ff 1c 01 	st.w [%a15]4124,%d15


IfxMultican_Status IfxMultican_MsgObj_sendLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj  = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status   status = IfxMultican_Status_ok;
80004498:	82 02       	mov %d2,0
8000449a:	00 90       	ret 

8000449c <IfxMultican_MsgObj_sendMessage>:

IfxMultican_Status IfxMultican_MsgObj_sendMessage(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
8000449c:	4c 47       	ld.w %d15,[%a4]28
    {                           /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
        status = IfxMultican_Status_notSentBusy;
8000449e:	3b 00 02 20 	mov %d2,32

IfxMultican_Status IfxMultican_MsgObj_sendMessage(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
800044a2:	37 0f 61 f4 	extr.u %d15,%d15,8,1
800044a6:	6e 02       	jz %d15,800044aa <IfxMultican_MsgObj_sendMessage+0xe>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
800044a8:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
800044aa:	59 42 1c 00 	st.w [%a4]28,%d2
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);

        /* for standard and FIFO message object */
        hwObj->DATAL.U = msg->data[0];  /* Set the new data */
800044ae:	19 52 08 00 	ld.w %d2,[%a5]8
800044b2:	59 42 10 00 	st.w [%a4]16,%d2
        hwObj->DATAH.U = msg->data[1];  /* Set the new data */
800044b6:	19 52 0c 00 	ld.w %d2,[%a5]12
800044ba:	59 42 14 00 	st.w [%a4]20,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
800044be:	19 42 18 00 	ld.w %d2,[%a4]24

        /* for standard and FIFO message object */
        {
            /* set ID */
            boolean extendedFrame = IfxMultican_MsgObj_isExtendedFrame(hwObj);
            IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
800044c2:	54 53       	ld.w %d3,[%a5]
800044c4:	37 02 e1 2e 	extr.u %d2,%d2,29,1
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
800044c8:	ab 2f 81 f2 	sel %d15,%d2,%d15,18
800044cc:	19 42 18 00 	ld.w %d2,[%a4]24
800044d0:	0f f3 00 f0 	sh %d15,%d3,%d15
800044d4:	37 f2 1d f0 	insert %d15,%d2,%d15,0,29
800044d8:	6c 46       	st.w [%a4]24,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
800044da:	54 42       	ld.w %d2,[%a4]
800044dc:	0c 54       	ld.bu %d15,[%a5]4
800044de:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
}


IfxMultican_Status IfxMultican_MsgObj_sendMessage(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;
800044e2:	82 02       	mov %d2,0
800044e4:	6c 40       	st.w [%a4]0,%d15
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
800044e6:	7b 80 00 f0 	movh %d15,8
800044ea:	6c 47       	st.w [%a4]28,%d15
800044ec:	7b 00 02 f0 	movh %d15,32
800044f0:	6c 47       	st.w [%a4]28,%d15
800044f2:	7b 00 10 f0 	movh %d15,256
800044f6:	6c 47       	st.w [%a4]28,%d15
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
800044f8:	00 90       	ret 

800044fa <IfxMultican_MsgObj_writeTxfifo>:

IfxMultican_Status IfxMultican_MsgObj_writeTxfifo(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
800044fa:	4c 47       	ld.w %d15,[%a4]28
    {
        /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
        status = IfxMultican_Status_notSentBusy;
800044fc:	3b 00 02 20 	mov %d2,32

IfxMultican_Status IfxMultican_MsgObj_writeTxfifo(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
80004500:	37 0f 61 f4 	extr.u %d15,%d15,8,1
80004504:	6e 02       	jz %d15,80004508 <IfxMultican_MsgObj_writeTxfifo+0xe>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
80004506:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80004508:	3b 00 20 20 	mov %d2,512
8000450c:	59 42 1c 00 	st.w [%a4]28,%d2
    {
        /* Clear TXEN0 to update the data FIFO message object  */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);

        /* for standard and FIFO message object */
        hwObj->DATAL.U = msg->data[0];      /* Set the new data */
80004510:	19 52 08 00 	ld.w %d2,[%a5]8
80004514:	59 42 10 00 	st.w [%a4]16,%d2
        hwObj->DATAH.U = msg->data[1];      /* Set the new data */
80004518:	19 52 0c 00 	ld.w %d2,[%a5]12
8000451c:	59 42 14 00 	st.w [%a4]20,%d2
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
80004520:	7b 00 20 20 	movh %d2,512
80004524:	59 42 1c 00 	st.w [%a4]28,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
80004528:	19 42 18 00 	ld.w %d2,[%a4]24

        /* for standard and FIFO message object */
        {
            /* set ID */
            boolean extendedFrame = IfxMultican_MsgObj_isExtendedFrame(hwObj);
            IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
8000452c:	54 53       	ld.w %d3,[%a5]
8000452e:	37 02 e1 2e 	extr.u %d2,%d2,29,1
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80004532:	ab 2f 81 f2 	sel %d15,%d2,%d15,18
80004536:	19 42 18 00 	ld.w %d2,[%a4]24
8000453a:	0f f3 00 f0 	sh %d15,%d3,%d15
8000453e:	37 f2 1d f0 	insert %d15,%d2,%d15,0,29
80004542:	6c 46       	st.w [%a4]24,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80004544:	54 42       	ld.w %d2,[%a4]
80004546:	0c 54       	ld.bu %d15,[%a5]4
80004548:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
}


IfxMultican_Status IfxMultican_MsgObj_writeTxfifo(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;
8000454c:	82 02       	mov %d2,0
8000454e:	6c 40       	st.w [%a4]0,%d15
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
80004550:	7b 80 00 f0 	movh %d15,8
80004554:	6c 47       	st.w [%a4]28,%d15
80004556:	7b 00 02 f0 	movh %d15,32
8000455a:	6c 47       	st.w [%a4]28,%d15
8000455c:	7b 00 10 f0 	movh %d15,256
80004560:	6c 47       	st.w [%a4]28,%d15
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
80004562:	00 90       	ret 

80004564 <IfxMultican_MsgObj_setFilter>:
void IfxMultican_MsgObj_setFilter(Ifx_CAN_MO *hwObj, boolean extend, uint32 id, uint32 accMask)
{
    Ifx_CAN_MO_CTR ctr;

    ctr.U           = 0;
    ctr.B.RESMSGVAL = 1;    /* MSGVAL: Set message as not valid */
80004564:	da 20       	mov %d15,32
    hwObj->CTR.U    = ctr.U;
80004566:	6c 47       	st.w [%a4]28,%d15

    hwObj->AMR.B.AM = accMask << ((extend != 0) ? 0 : 18);
80004568:	df 04 13 00 	jeq %d4,0,8000458e <IfxMultican_MsgObj_setFilter+0x2a>
8000456c:	4c 43       	ld.w %d15,[%a4]12
8000456e:	37 6f 1d 60 	insert %d6,%d15,%d6,0,29
    hwObj->AR.B.IDE = (id << ((extend != 0) ? 0 : 18)) | (extend << 29);
80004572:	82 0f       	mov %d15,0

    ctr.U           = 0;
    ctr.B.RESMSGVAL = 1;    /* MSGVAL: Set message as not valid */
    hwObj->CTR.U    = ctr.U;

    hwObj->AMR.B.AM = accMask << ((extend != 0) ? 0 : 18);
80004574:	59 46 0c 00 	st.w [%a4]12,%d6
    hwObj->AR.B.IDE = (id << ((extend != 0) ? 0 : 18)) | (extend << 29);
80004578:	0f f5 00 50 	sh %d5,%d5,%d15
8000457c:	4c 46       	ld.w %d15,[%a4]24
8000457e:	67 5f 1d 50 	ins.t %d5,%d15,29,%d5,0
80004582:	59 45 18 00 	st.w [%a4]24,%d5

    ctr.U           = 0;
    ctr.B.SETMSGVAL = 1;    /* MSGVAL: Set message as valid */
80004586:	7b 00 02 f0 	movh %d15,32
    hwObj->CTR.U    = ctr.U;
8000458a:	6c 47       	st.w [%a4]28,%d15
8000458c:	00 90       	ret 

    ctr.U           = 0;
    ctr.B.RESMSGVAL = 1;    /* MSGVAL: Set message as not valid */
    hwObj->CTR.U    = ctr.U;

    hwObj->AMR.B.AM = accMask << ((extend != 0) ? 0 : 18);
8000458e:	8f 26 01 60 	sh %d6,%d6,18
80004592:	b7 06 83 fe 	insert %d15,%d6,0,29,3
80004596:	19 46 0c 00 	ld.w %d6,[%a4]12
8000459a:	b7 06 1d 60 	insert %d6,%d6,0,0,29
8000459e:	a6 f6       	or %d6,%d15
800045a0:	59 46 0c 00 	st.w [%a4]12,%d6
    hwObj->AR.B.IDE = (id << ((extend != 0) ? 0 : 18)) | (extend << 29);
800045a4:	da 12       	mov %d15,18
800045a6:	3c e9       	j 80004578 <IfxMultican_MsgObj_setFilter+0x14>

800045a8 <IfxMultican_MsgObj_setStatusFlag>:
void IfxMultican_MsgObj_setStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);
800045a8:	1b 04 01 40 	addi %d4,%d4,16
800045ac:	82 1f       	mov %d15,1
800045ae:	0f 4f 00 f0 	sh %d15,%d15,%d4

    hwObj->CTR.U = ctr.U;
800045b2:	6c 47       	st.w [%a4]28,%d15
800045b4:	00 90       	ret 

800045b6 <IfxMultican_Node_deinit>:
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
800045b6:	82 1f       	mov %d15,1
800045b8:	6c 40       	st.w [%a4]0,%d15
    hwNode->SR.U    = 0x00000000;
800045ba:	82 0f       	mov %d15,0
800045bc:	6c 41       	st.w [%a4]4,%d15
    hwNode->IPR.U   = 0x00000000;
800045be:	6c 42       	st.w [%a4]8,%d15
    hwNode->PCR.U   = 0x00000000;
800045c0:	6c 43       	st.w [%a4]12,%d15
    hwNode->BTEVR.U = 0x00000000;
800045c2:	6c 44       	st.w [%a4]16,%d15
    hwNode->ECNT.U  = 0x00600000;
800045c4:	7b 00 06 20 	movh %d2,96
800045c8:	59 42 14 00 	st.w [%a4]20,%d2
    hwNode->FCR.U   = 0x00000000;
800045cc:	6c 46       	st.w [%a4]24,%d15
800045ce:	00 90       	ret 

800045d0 <IfxMultican_Node_initRxPin>:
}


boolean IfxMultican_Node_initRxPin(Ifx_CAN_N *hwNode, IfxMultican_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver)
{
800045d0:	40 4c       	mov.aa %a12,%a4
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800045d2:	99 54 08 00 	ld.a %a4,[%a5]8
800045d6:	02 5f       	mov %d15,%d5
800045d8:	8f f4 0f 51 	and %d5,%d4,255
800045dc:	39 54 0c 00 	ld.bu %d4,[%a5]12
800045e0:	40 5f       	mov.aa %a15,%a5
800045e2:	6d 00 24 14 	call 80006e2a <IfxPort_setPinMode>
    IfxPort_setPinModeInput(rxd->pin.port, rxd->pin.pinIndex, mode);
    IfxPort_setPinPadDriver(rxd->pin.port, rxd->pin.pinIndex, padDriver);
800045e6:	c8 24       	ld.a %a4,[%a15]8
800045e8:	02 f5       	mov %d5,%d15
800045ea:	08 c4       	ld.bu %d4,[%a15]12
800045ec:	6d 00 a5 14 	call 80006f36 <IfxPort_setPinPadDriver>
    hwNode->PCR.B.RXSEL = rxd->select;
800045f0:	19 c2 0c 00 	ld.w %d2,[%a12]12
800045f4:	39 ff 10 00 	ld.bu %d15,[%a15]16
800045f8:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3

    return TRUE;
}
800045fc:	82 12       	mov %d2,1

boolean IfxMultican_Node_initRxPin(Ifx_CAN_N *hwNode, IfxMultican_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeInput(rxd->pin.port, rxd->pin.pinIndex, mode);
    IfxPort_setPinPadDriver(rxd->pin.port, rxd->pin.pinIndex, padDriver);
    hwNode->PCR.B.RXSEL = rxd->select;
800045fe:	6c c3       	st.w [%a12]12,%d15

    return TRUE;
}
80004600:	00 90       	ret 

80004602 <IfxMultican_Node_initTxPin>:
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80004602:	99 54 08 00 	ld.a %a4,[%a5]8


boolean IfxMultican_Node_initTxPin(Ifx_CAN_N *hwNode, IfxMultican_Txd_Out *txd, IfxPort_OutputMode mode, IfxPort_PadDriver padDriver)
{
80004606:	02 5f       	mov %d15,%d5
80004608:	39 55 10 00 	ld.bu %d5,[%a5]16
8000460c:	40 5f       	mov.aa %a15,%a5
8000460e:	a6 45       	or %d5,%d4
80004610:	39 54 0c 00 	ld.bu %d4,[%a5]12
80004614:	6d 00 0b 14 	call 80006e2a <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(txd->pin.port, txd->pin.pinIndex, mode, txd->select);
    IfxPort_setPinPadDriver(txd->pin.port, txd->pin.pinIndex, padDriver);
80004618:	c8 24       	ld.a %a4,[%a15]8
8000461a:	08 c4       	ld.bu %d4,[%a15]12
8000461c:	02 f5       	mov %d5,%d15
8000461e:	6d 00 8c 14 	call 80006f36 <IfxPort_setPinPadDriver>

    return TRUE;
}
80004622:	82 12       	mov %d2,1
80004624:	00 90       	ret 

80004626 <IfxMultican_Node_recoverBusOff>:

IfxMultican_Status IfxMultican_Node_recoverBusOff(Ifx_CAN_N *hwNode)
{
    IfxMultican_Status status             = IfxMultican_Status_busOff;

    boolean            busOffState        = hwNode->SR.B.BOFF;
80004626:	4c 41       	ld.w %d15,[%a4]4
    boolean            errorWarningStatus = hwNode->SR.B.EWRN;
80004628:	19 43 04 00 	ld.w %d3,[%a4]4

IfxMultican_Status IfxMultican_Node_recoverBusOff(Ifx_CAN_N *hwNode)
{
    IfxMultican_Status status             = IfxMultican_Status_busOff;

    boolean            busOffState        = hwNode->SR.B.BOFF;
8000462c:	37 0f e1 f3 	extr.u %d15,%d15,7,1
    boolean            errorWarningStatus = hwNode->SR.B.EWRN;
80004630:	37 03 61 33 	extr.u %d3,%d3,6,1

    /* if the node is in bus off state, initiaite the recovery process */
    if ((busOffState != 0) && (hwNode->ECNT.B.TEC > 254))
80004634:	6e 24       	jz %d15,8000467c <IfxMultican_Node_recoverBusOff+0x56>
80004636:	19 42 14 00 	ld.w %d2,[%a4]20
8000463a:	37 02 68 24 	extr.u %d2,%d2,8,8
8000463e:	8b f2 2f 22 	ne %d2,%d2,255
80004642:	76 27       	jz %d2,80004650 <IfxMultican_Node_recoverBusOff+0x2a>
        /* disable node INIT = 1 */
        IfxMultican_Node_deactivate(hwNode);
    }

    /* during recovery process, if REC counter reaches 0x60 */
    else if ((busOffState != 0) && (errorWarningStatus != 0))
80004644:	0f f3 80 40 	and %d4,%d3,%d15
    {
        status = IfxMultican_Status_notInitialised;
80004648:	82 12       	mov %d2,1
        /* disable node INIT = 1 */
        IfxMultican_Node_deactivate(hwNode);
    }

    /* during recovery process, if REC counter reaches 0x60 */
    else if ((busOffState != 0) && (errorWarningStatus != 0))
8000464a:	df 04 19 00 	jeq %d4,0,8000467c <IfxMultican_Node_recoverBusOff+0x56>

        status = IfxMultican_Status_ok;
    }

    return status;
}
8000464e:	00 90       	ret 
    if ((busOffState != 0) && (hwNode->ECNT.B.TEC > 254))
    {
        status = IfxMultican_Status_busOff;

        /* reset error counters */
        hwNode->ECNT.B.TEC = 0x01;
80004650:	4c 45       	ld.w %d15,[%a4]20
    boolean            errorWarningStatus = hwNode->SR.B.EWRN;

    /* if the node is in bus off state, initiaite the recovery process */
    if ((busOffState != 0) && (hwNode->ECNT.B.TEC > 254))
    {
        status = IfxMultican_Status_busOff;
80004652:	3b 00 01 20 	mov %d2,16

        /* reset error counters */
        hwNode->ECNT.B.TEC = 0x01;
80004656:	b7 1f 08 f4 	insert %d15,%d15,1,8,8
8000465a:	6c 45       	st.w [%a4]20,%d15
        hwNode->ECNT.B.REC = 0x01;
8000465c:	4c 45       	ld.w %d15,[%a4]20
8000465e:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
80004662:	6c 45       	st.w [%a4]20,%d15

        /* clear error warning status */
        hwNode->SR.B.EWRN = 0;
80004664:	4c 41       	ld.w %d15,[%a4]4
80004666:	8f 0f c4 f1 	andn %d15,%d15,64
8000466a:	6c 41       	st.w [%a4]4,%d15

        /* clear ALERT status */
        hwNode->SR.B.ALERT = 0;
8000466c:	4c 41       	ld.w %d15,[%a4]4
8000466e:	8f 0f c2 f1 	andn %d15,%d15,32
80004672:	6c 41       	st.w [%a4]4,%d15
}


IFX_INLINE void IfxMultican_Node_deactivate(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.INIT = 1;
80004674:	4c 40       	ld.w %d15,[%a4]0
80004676:	96 01       	or %d15,1
80004678:	6c 40       	st.w [%a4]0,%d15
8000467a:	00 90       	ret 
    {
        status = IfxMultican_Status_notInitialised;
    }

    /* if the recovery process is been finished or not in Bus off mode */
    else if ((busOffState == 0) && (errorWarningStatus == 0))
8000467c:	a6 3f       	or %d15,%d3
}


IfxMultican_Status IfxMultican_Node_recoverBusOff(Ifx_CAN_N *hwNode)
{
    IfxMultican_Status status             = IfxMultican_Status_busOff;
8000467e:	3b 00 01 20 	mov %d2,16
    {
        status = IfxMultican_Status_notInitialised;
    }

    /* if the recovery process is been finished or not in Bus off mode */
    else if ((busOffState == 0) && (errorWarningStatus == 0))
80004682:	ee e6       	jnz %d15,8000464e <IfxMultican_Node_recoverBusOff+0x28>
}


IFX_INLINE void IfxMultican_Node_activate(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.INIT = 0;
80004684:	4c 40       	ld.w %d15,[%a4]0
    {
        /* enable node INIT = 0 */
        IfxMultican_Node_activate(hwNode);

        status = IfxMultican_Status_ok;
80004686:	82 02       	mov %d2,0
80004688:	8f 1f c0 f1 	andn %d15,%d15,1
8000468c:	6c 40       	st.w [%a4]0,%d15
    }

    return status;
}
8000468e:	00 90       	ret 

80004690 <IfxMultican_Node_setBitTiming>:
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80004690:	4b 05 61 51 	utof %d5,%d5
80004694:	7b 00 f8 93 	movh %d9,16256
80004698:	4b 59 51 90 	div.f %d9,%d9,%d5
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
8000469c:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
800046a0:	7b d0 d4 83 	movh %d8,15693
800046a4:	1b d8 cc 8c 	addi %d8,%d8,-13107
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800046a8:	7b d0 dc c3 	movh %d12,15821
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
800046ac:	4b 85 41 80 	mul.f %d8,%d5,%d8
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
800046b0:	3b 80 00 b0 	mov %d11,8
800046b4:	82 0a       	mov %d10,0
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
800046b6:	82 13       	mov %d3,1
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800046b8:	1b dc cc cc 	addi %d12,%d12,-13107
    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = moduleFreq / tempBRP;
800046bc:	4b 03 41 21 	itof %d2,%d3
800046c0:	4b 24 51 20 	div.f %d2,%d4,%d2
        tempTBAUD = Fquanta / baudrate;
800046c4:	4b 92 41 00 	mul.f %d0,%d2,%d9
800046c8:	4b 00 31 f1 	ftoiz %d15,%d0

        if (tempTBAUD == 0)
800046cc:	df 0f 4b 02 	jeq %d15,0,80004b62 <IfxMultican_Node_setBitTiming+0x4d2>
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
800046d0:	4b 0f 41 01 	itof %d0,%d15
800046d4:	4b 02 51 20 	div.f %d2,%d2,%d0
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
800046d8:	8b 8f 80 02 	ge %d0,%d15,8
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);
800046dc:	6b 05 31 22 	sub.f %d2,%d2,%d5
800046e0:	b7 02 81 2f 	insert %d2,%d2,0,31,1

        if (tempTBAUD < minTBAUD)
800046e4:	df 00 3f 02 	jeq %d0,0,80004b62 <IfxMultican_Node_setBitTiming+0x4d2>
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
800046e8:	4b 28 01 00 	cmp.f %d0,%d8,%d2
800046ec:	87 00 a2 00 	or.t %d0,%d0,2,%d0,1
800046f0:	8b af 41 12 	lt %d1,%d15,26
800046f4:	26 10       	and %d0,%d1
800046f6:	76 0a       	jz %d0,8000470a <IfxMultican_Node_setBitTiming+0x7a>
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800046f8:	4b c2 01 10 	cmp.f %d1,%d2,%d12
800046fc:	8b 5f 41 02 	lt %d0,%d15,21
80004700:	26 10       	and %d0,%d1
80004702:	f6 0d       	jnz %d0,8000471c <IfxMultican_Node_setBitTiming+0x8c>

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;
80004704:	02 28       	mov %d8,%d2
80004706:	0b 3f 10 a8 	mov %e10,%d15,%d3
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
8000470a:	c2 13       	add %d3,1
8000470c:	fd f0 d8 7f 	loop %a15,800046bc <IfxMultican_Node_setBitTiming+0x2c>
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
80004710:	f6 a4       	jnz %d10,80004718 <IfxMultican_Node_setBitTiming+0x88>
80004712:	3b f0 03 c0 	mov %d12,63
80004716:	3c 06       	j 80004722 <IfxMultican_Node_setBitTiming+0x92>
80004718:	02 bf       	mov %d15,%d11
8000471a:	02 a3       	mov %d3,%d10
8000471c:	c2 f3       	add %d3,-1
8000471e:	8f f3 03 c1 	and %d12,%d3,63

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004722:	7b 30 00 40 	movh %d4,3
80004726:	1b 04 81 49 	addi %d4,%d4,-26608
8000472a:	4b f4 01 42 	div %e4,%d4,%d15
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
8000472e:	4b 06 41 31 	itof %d3,%d6
80004732:	7b a0 e1 23 	movh %d2,15898

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004736:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004738:	0b 64 e0 40 	absdif %d4,%d4,%d6
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
8000473c:	1b a2 99 29 	addi %d2,%d2,-26214
80004740:	4b 23 41 30 	mul.f %d3,%d3,%d2
    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > (float)error)
80004744:	4b 04 41 41 	itof %d4,%d4
80004748:	4b 43 01 50 	cmp.f %d5,%d3,%d4
8000474c:	8f 45 00 51 	and %d5,%d5,4
80004750:	2b 43 50 25 	seln %d2,%d5,%d3,%d4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004754:	3f 60 17 02 	jlt %d0,%d6,80004b82 <IfxMultican_Node_setBitTiming+0x4f2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004758:	7b 20 00 40 	movh %d4,2
8000475c:	1b 04 10 47 	addi %d4,%d4,28928
80004760:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > (float)error)
80004764:	3b f0 00 30 	mov %d3,15

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004768:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
8000476a:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
8000476e:	4b 04 41 41 	itof %d4,%d4
80004772:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004776:	37 05 61 51 	extr.u %d5,%d5,2,1
8000477a:	ab 03 81 35 	sel %d3,%d5,%d3,16
8000477e:	2b 24 40 25 	sel %d2,%d5,%d4,%d2
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004782:	3f 60 f8 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004786:	7b 20 00 40 	movh %d4,2
8000478a:	1b 04 9f 44 	addi %d4,%d4,18928
8000478e:	4b f4 01 42 	div %e4,%d4,%d15
80004792:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004794:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80004798:	4b 04 41 41 	itof %d4,%d4
8000479c:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800047a0:	37 05 61 51 	extr.u %d5,%d5,2,1
800047a4:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800047a8:	ab e3 a0 35 	seln %d3,%d5,%d3,14
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800047ac:	3f 60 e3 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800047b0:	7b 20 00 40 	movh %d4,2
800047b4:	1b 04 2e 42 	addi %d4,%d4,8928
800047b8:	4b f4 01 42 	div %e4,%d4,%d15
800047bc:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800047be:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800047c2:	4b 04 41 41 	itof %d4,%d4
800047c6:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800047ca:	37 05 61 51 	extr.u %d5,%d5,2,1
800047ce:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800047d2:	ab d3 a0 35 	seln %d3,%d5,%d3,13
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800047d6:	3f 60 ce 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800047da:	7b 20 00 40 	movh %d4,2
800047de:	1b 04 bd 4f 	addi %d4,%d4,-1072
800047e2:	4b f4 01 42 	div %e4,%d4,%d15
800047e6:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800047e8:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800047ec:	4b 04 41 41 	itof %d4,%d4
800047f0:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800047f4:	37 05 61 51 	extr.u %d5,%d5,2,1
800047f8:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800047fc:	ab c3 a0 35 	seln %d3,%d5,%d3,12
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004800:	3f 60 b9 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004804:	7b 20 00 40 	movh %d4,2
80004808:	1b 04 4c 4d 	addi %d4,%d4,-11072
8000480c:	4b f4 01 42 	div %e4,%d4,%d15
80004810:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004812:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80004816:	4b 04 41 41 	itof %d4,%d4
8000481a:	4b 42 01 50 	cmp.f %d5,%d2,%d4
8000481e:	37 05 61 51 	extr.u %d5,%d5,2,1
80004822:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004826:	ab b3 a0 35 	seln %d3,%d5,%d3,11
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000482a:	3f 60 a4 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
8000482e:	7b 20 00 40 	movh %d4,2
80004832:	1b 04 db 4a 	addi %d4,%d4,-21072
80004836:	4b f4 01 42 	div %e4,%d4,%d15
8000483a:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
8000483c:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80004840:	4b 04 41 41 	itof %d4,%d4
80004844:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004848:	37 05 61 51 	extr.u %d5,%d5,2,1
8000484c:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004850:	ab a3 a0 35 	seln %d3,%d5,%d3,10
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004854:	3f 60 8f 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004858:	7b 20 00 40 	movh %d4,2
8000485c:	1b 04 6a 48 	addi %d4,%d4,-31072
80004860:	4b f4 01 42 	div %e4,%d4,%d15
80004864:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004866:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
8000486a:	4b 04 41 41 	itof %d4,%d4
8000486e:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004872:	37 05 61 51 	extr.u %d5,%d5,2,1
80004876:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
8000487a:	ab 93 a0 35 	seln %d3,%d5,%d3,9
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000487e:	3f 60 7a 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004882:	7b 10 00 40 	movh %d4,1
80004886:	1b 04 f9 45 	addi %d4,%d4,24464
8000488a:	4b f4 01 42 	div %e4,%d4,%d15
8000488e:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004890:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80004894:	4b 04 41 41 	itof %d4,%d4
80004898:	4b 42 01 50 	cmp.f %d5,%d2,%d4
8000489c:	37 05 61 51 	extr.u %d5,%d5,2,1
800048a0:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800048a4:	ab 83 a0 35 	seln %d3,%d5,%d3,8
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800048a8:	3f 60 65 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800048ac:	7b 10 00 40 	movh %d4,1
800048b0:	1b 04 88 43 	addi %d4,%d4,14464
800048b4:	4b f4 01 42 	div %e4,%d4,%d15
800048b8:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800048ba:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800048be:	4b 04 41 41 	itof %d4,%d4
800048c2:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800048c6:	37 05 61 51 	extr.u %d5,%d5,2,1
800048ca:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800048ce:	ab 73 a0 35 	seln %d3,%d5,%d3,7
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800048d2:	3f 60 50 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800048d6:	7b 10 00 40 	movh %d4,1
800048da:	1b 04 17 41 	addi %d4,%d4,4464
800048de:	4b f4 01 42 	div %e4,%d4,%d15
800048e2:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800048e4:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800048e8:	4b 04 41 41 	itof %d4,%d4
800048ec:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800048f0:	37 05 61 51 	extr.u %d5,%d5,2,1
800048f4:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800048f8:	ab 63 a0 35 	seln %d3,%d5,%d3,6
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800048fc:	3f 60 3b 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004900:	bb 00 a6 4e 	mov.u %d4,60000
80004904:	4b f4 01 42 	div %e4,%d4,%d15
80004908:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
8000490a:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
8000490e:	4b 04 41 41 	itof %d4,%d4
80004912:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004916:	37 05 61 51 	extr.u %d5,%d5,2,1
8000491a:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
8000491e:	ab 53 a0 35 	seln %d3,%d5,%d3,5
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004922:	3f 60 28 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004926:	bb 00 35 4c 	mov.u %d4,50000
8000492a:	4b f4 01 42 	div %e4,%d4,%d15
8000492e:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004930:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80004934:	4b 04 41 41 	itof %d4,%d4
80004938:	4b 42 01 50 	cmp.f %d5,%d2,%d4
8000493c:	37 05 61 51 	extr.u %d5,%d5,2,1
80004940:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004944:	ab 43 a0 35 	seln %d3,%d5,%d3,4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004948:	3f 60 15 00 	jlt %d0,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
8000494c:	bb 00 c4 49 	mov.u %d4,40000
80004950:	4b f4 01 42 	div %e4,%d4,%d15
80004954:	02 45       	mov %d5,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004956:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
8000495a:	4b 04 41 41 	itof %d4,%d4
8000495e:	4b 24 01 20 	cmp.f %d2,%d4,%d2
80004962:	6f 02 09 81 	jnz.t %d2,0,80004b74 <IfxMultican_Node_setBitTiming+0x4e4>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004966:	3f 65 06 00 	jlt %d5,%d6,80004972 <IfxMultican_Node_setBitTiming+0x2e2>

            break;  /* least possible error has already occured */
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
8000496a:	8b 03 01 22 	eq %d2,%d3,16
8000496e:	df 02 06 81 	jne %d2,0,80004b7a <IfxMultican_Node_setBitTiming+0x4ea>
80004972:	1b f3 ff af 	addi %d10,%d3,-1
80004976:	8f fa 00 a1 	and %d10,%d10,15
    {
        bestTSEG1 = minTSEG1;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;
8000497a:	52 33       	sub %d3,%d15,%d3
8000497c:	c2 f3       	add %d3,-1

    if (bestTSEG2 > maxTSEG2)
8000497e:	8b 93 80 22 	ge %d2,%d3,9
80004982:	df 02 36 80 	jne %d2,0,800049ee <IfxMultican_Node_setBitTiming+0x35e>
80004986:	1b f3 ff df 	addi %d13,%d3,-1
8000498a:	8f 7d 00 d1 	and %d13,%d13,7
    {
        bestTSEG2 = maxTSEG2;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
8000498e:	ff 23 33 00 	jge %d3,2,800049f4 <IfxMultican_Node_setBitTiming+0x364>
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004992:	3b 00 71 22 	mov %d2,10000
80004996:	4b f2 01 22 	div %e2,%d2,%d15
8000499a:	3b 00 e2 44 	mov %d4,20000
8000499e:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800049a2:	0b 72 e0 20 	absdif %d2,%d2,%d7
800049a6:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
800049aa:	4b 02 41 61 	itof %d6,%d2
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800049ae:	0b 74 e0 f0 	absdif %d15,%d4,%d7
800049b2:	1b 05 00 54 	addi %d5,%d5,16384
800049b6:	4b 56 01 30 	cmp.f %d3,%d6,%d5

        if (bestError > error)
800049ba:	4b 0f 41 f1 	itof %d15,%d15
800049be:	8f 43 00 31 	and %d3,%d3,4
800049c2:	2b 56 50 43 	seln %d4,%d3,%d6,%d5
800049c6:	4b 4f 01 40 	cmp.f %d4,%d15,%d4
800049ca:	37 04 61 40 	extr.u %d4,%d4,0,1
800049ce:	82 22       	mov %d2,2
800049d0:	ab 12 80 24 	sel %d2,%d4,%d2,1
        }
    }

    {
        Ifx_CAN_N_BTR nbtr;
        nbtr.U       = 0;
800049d4:	82 0f       	mov %d15,0
        nbtr.B.BRP   = bestBRP - 1;
800049d6:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nbtr.B.SJW   = bestSJW - 1;
800049da:	c2 f2       	add %d2,-1
800049dc:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);

        if (bestError > error)
800049e0:	82 1d       	mov %d13,1
    {
        Ifx_CAN_N_BTR nbtr;
        nbtr.U       = 0;
        nbtr.B.BRP   = bestBRP - 1;
        nbtr.B.SJW   = bestSJW - 1;
        nbtr.B.TSEG1 = bestTSEG1 - 1;
800049e2:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nbtr.B.TSEG2 = bestTSEG2 - 1;
        nbtr.B.DIV8  = 0;
800049e6:	37 df 04 f6 	insert %d15,%d15,%d13,12,4
        //nbtr.B.FTX = 0; /* TTCAN only */

        hwNode->BTR.U = nbtr.U;
800049ea:	6c 44       	st.w [%a4]16,%d15
800049ec:	00 90       	ret 
800049ee:	82 7d       	mov %d13,7

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;
800049f0:	3b 80 00 30 	mov %d3,8
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
800049f4:	3b 00 71 42 	mov %d4,10000
800049f8:	4b f4 01 42 	div %e4,%d4,%d15
800049fc:	3b 00 e2 04 	mov %d0,20000
80004a00:	4b f0 01 02 	div %e0,%d0,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004a04:	0b 74 e0 40 	absdif %d4,%d4,%d7
80004a08:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
80004a0c:	4b 04 41 41 	itof %d4,%d4
80004a10:	1b 05 00 54 	addi %d5,%d5,16384
80004a14:	4b 54 01 20 	cmp.f %d2,%d4,%d5
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004a18:	0b 70 e0 00 	absdif %d0,%d0,%d7
80004a1c:	8f 42 00 21 	and %d2,%d2,4
80004a20:	2b 54 50 42 	seln %d4,%d2,%d4,%d5

        if (bestError > error)
80004a24:	4b 00 41 51 	itof %d5,%d0
80004a28:	82 26       	mov %d6,2
80004a2a:	4b 45 01 20 	cmp.f %d2,%d5,%d4
80004a2e:	37 02 61 20 	extr.u %d2,%d2,0,1
80004a32:	4b 45 01 10 	cmp.f %d1,%d5,%d4
80004a36:	8f 41 00 11 	and %d1,%d1,4
80004a3a:	ab 16 80 22 	sel %d2,%d2,%d6,1
80004a3e:	2b 45 50 b1 	seln %d11,%d1,%d5,%d4
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004a42:	df 23 84 00 	jeq %d3,2,80004b4a <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004a46:	3b 00 53 87 	mov %d8,30000
80004a4a:	4b f8 01 82 	div %e8,%d8,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004a4e:	0b 78 e0 80 	absdif %d8,%d8,%d7

        if (bestError > error)
80004a52:	4b 08 41 81 	itof %d8,%d8
80004a56:	4b 8b 01 40 	cmp.f %d4,%d11,%d8
80004a5a:	4b 8b 01 00 	cmp.f %d0,%d11,%d8
80004a5e:	87 44 a0 40 	or.t %d4,%d4,0,%d4,1
80004a62:	8f 40 00 01 	and %d0,%d0,4
80004a66:	ab 32 80 24 	sel %d2,%d4,%d2,3
80004a6a:	2b 8b 50 10 	seln %d1,%d0,%d11,%d8
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004a6e:	df 33 6e 00 	jeq %d3,3,80004b4a <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004a72:	bb 00 c4 49 	mov.u %d4,40000
80004a76:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004a7a:	0b 74 e0 40 	absdif %d4,%d4,%d7

        if (bestError > error)
80004a7e:	4b 04 41 51 	itof %d5,%d4
80004a82:	4b 15 01 40 	cmp.f %d4,%d5,%d1
80004a86:	4b 15 01 60 	cmp.f %d6,%d5,%d1
80004a8a:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004a8e:	8f 46 00 61 	and %d6,%d6,4
80004a92:	ab 42 80 24 	sel %d2,%d4,%d2,4
80004a96:	2b 15 50 06 	seln %d0,%d6,%d5,%d1
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004a9a:	df 43 58 00 	jeq %d3,4,80004b4a <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004a9e:	bb 00 35 4c 	mov.u %d4,50000
80004aa2:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004aa6:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80004aaa:	4b 05 41 51 	itof %d5,%d5
80004aae:	4b 05 01 40 	cmp.f %d4,%d5,%d0
80004ab2:	4b 05 01 60 	cmp.f %d6,%d5,%d0
80004ab6:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004aba:	8f 46 00 61 	and %d6,%d6,4
80004abe:	ab 52 80 24 	sel %d2,%d4,%d2,5
80004ac2:	2b 05 50 66 	seln %d6,%d6,%d5,%d0
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004ac6:	df 53 42 00 	jeq %d3,5,80004b4a <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004aca:	bb 00 a6 4e 	mov.u %d4,60000
80004ace:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004ad2:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80004ad6:	4b 05 41 51 	itof %d5,%d5
80004ada:	4b 65 01 40 	cmp.f %d4,%d5,%d6
80004ade:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004ae2:	ab 62 80 24 	sel %d2,%d4,%d2,6
80004ae6:	4b 65 01 40 	cmp.f %d4,%d5,%d6
80004aea:	8f 44 00 41 	and %d4,%d4,4
80004aee:	2b 65 50 54 	seln %d5,%d4,%d5,%d6
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004af2:	df 63 2c 00 	jeq %d3,6,80004b4a <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004af6:	7b 10 00 00 	movh %d0,1
80004afa:	1b 00 17 01 	addi %d0,%d0,4464
80004afe:	4b f0 01 02 	div %e0,%d0,%d15
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004b02:	8b 83 20 32 	ne %d3,%d3,8
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004b06:	0b 70 e0 00 	absdif %d0,%d0,%d7

        if (bestError > error)
80004b0a:	4b 00 41 61 	itof %d6,%d0
80004b0e:	4b 56 01 40 	cmp.f %d4,%d6,%d5
80004b12:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004b16:	ab 72 80 24 	sel %d2,%d4,%d2,7
80004b1a:	4b 56 01 40 	cmp.f %d4,%d6,%d5
80004b1e:	8f 44 00 41 	and %d4,%d4,4
80004b22:	2b 56 50 64 	seln %d6,%d4,%d6,%d5
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004b26:	df 03 12 80 	jne %d3,0,80004b4a <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004b2a:	7b 10 00 40 	movh %d4,1
80004b2e:	1b 04 88 43 	addi %d4,%d4,14464
80004b32:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004b36:	0b 74 e0 f0 	absdif %d15,%d4,%d7

        if (bestError > error)
80004b3a:	4b 0f 41 f1 	itof %d15,%d15
80004b3e:	4b f6 01 70 	cmp.f %d7,%d6,%d15
80004b42:	87 77 a0 70 	or.t %d7,%d7,0,%d7,1
80004b46:	ab 82 80 27 	sel %d2,%d7,%d2,8
        }
    }

    {
        Ifx_CAN_N_BTR nbtr;
        nbtr.U       = 0;
80004b4a:	82 0f       	mov %d15,0
        nbtr.B.BRP   = bestBRP - 1;
80004b4c:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nbtr.B.SJW   = bestSJW - 1;
80004b50:	c2 f2       	add %d2,-1
80004b52:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
        nbtr.B.TSEG1 = bestTSEG1 - 1;
80004b56:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nbtr.B.TSEG2 = bestTSEG2 - 1;
        nbtr.B.DIV8  = 0;
80004b5a:	37 df 04 f6 	insert %d15,%d15,%d13,12,4
        //nbtr.B.FTX = 0; /* TTCAN only */

        hwNode->BTR.U = nbtr.U;
80004b5e:	6c 44       	st.w [%a4]16,%d15
80004b60:	00 90       	ret 
80004b62:	82 0c       	mov %d12,0
        bestBRP   = maxBRP;
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
80004b64:	df 0a df 7d 	jeq %d10,0,80004722 <IfxMultican_Node_setBitTiming+0x92>
80004b68:	c2 fa       	add %d10,-1
80004b6a:	8f fa 03 c1 	and %d12,%d10,63
80004b6e:	02 bf       	mov %d15,%d11
80004b70:	1d ff d9 fd 	j 80004722 <IfxMultican_Node_setBitTiming+0x92>
    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
80004b74:	82 33       	mov %d3,3
80004b76:	1d ff fe fe 	j 80004972 <IfxMultican_Node_setBitTiming+0x2e2>
80004b7a:	82 2a       	mov %d10,2
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
    {
        bestTSEG1 = minTSEG1;
80004b7c:	82 33       	mov %d3,3
80004b7e:	1d ff fe fe 	j 8000497a <IfxMultican_Node_setBitTiming+0x2ea>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004b82:	3b 00 01 30 	mov %d3,16
80004b86:	1d ff f6 fe 	j 80004972 <IfxMultican_Node_setBitTiming+0x2e2>

80004b8a <IfxMultican_Node_setFastBitTiming>:
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80004b8a:	4b 05 61 51 	utof %d5,%d5
80004b8e:	7b 00 f8 93 	movh %d9,16256
80004b92:	4b 59 51 90 	div.f %d9,%d9,%d5
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80004b96:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80004b9a:	7b d0 d4 83 	movh %d8,15693
80004b9e:	1b d8 cc 8c 	addi %d8,%d8,-13107
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80004ba2:	7b d0 dc c3 	movh %d12,15821
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80004ba6:	4b 85 41 80 	mul.f %d8,%d5,%d8
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
80004baa:	3b 80 00 b0 	mov %d11,8
80004bae:	82 0a       	mov %d10,0
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
80004bb0:	82 13       	mov %d3,1
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80004bb2:	1b dc cc cc 	addi %d12,%d12,-13107
    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = moduleFreq / tempBRP;
80004bb6:	4b 03 41 21 	itof %d2,%d3
80004bba:	4b 24 51 20 	div.f %d2,%d4,%d2
        tempTBAUD = Fquanta / baudrate;
80004bbe:	4b 92 41 00 	mul.f %d0,%d2,%d9
80004bc2:	4b 00 31 f1 	ftoiz %d15,%d0

        if (tempTBAUD == 0)
80004bc6:	df 0f 4b 02 	jeq %d15,0,8000505c <IfxMultican_Node_setFastBitTiming+0x4d2>
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
80004bca:	4b 0f 41 01 	itof %d0,%d15
80004bce:	4b 02 51 20 	div.f %d2,%d2,%d0
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
80004bd2:	8b 8f 80 02 	ge %d0,%d15,8
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);
80004bd6:	6b 05 31 22 	sub.f %d2,%d2,%d5
80004bda:	b7 02 81 2f 	insert %d2,%d2,0,31,1

        if (tempTBAUD < minTBAUD)
80004bde:	df 00 3f 02 	jeq %d0,0,8000505c <IfxMultican_Node_setFastBitTiming+0x4d2>
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
80004be2:	4b 28 01 00 	cmp.f %d0,%d8,%d2
80004be6:	87 00 a2 00 	or.t %d0,%d0,2,%d0,1
80004bea:	8b af 41 12 	lt %d1,%d15,26
80004bee:	26 10       	and %d0,%d1
80004bf0:	76 0a       	jz %d0,80004c04 <IfxMultican_Node_setFastBitTiming+0x7a>
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80004bf2:	4b c2 01 10 	cmp.f %d1,%d2,%d12
80004bf6:	8b 5f 41 02 	lt %d0,%d15,21
80004bfa:	26 10       	and %d0,%d1
80004bfc:	f6 0d       	jnz %d0,80004c16 <IfxMultican_Node_setFastBitTiming+0x8c>

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;
80004bfe:	02 28       	mov %d8,%d2
80004c00:	0b 3f 10 a8 	mov %e10,%d15,%d3
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
80004c04:	c2 13       	add %d3,1
80004c06:	fd f0 d8 7f 	loop %a15,80004bb6 <IfxMultican_Node_setFastBitTiming+0x2c>
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
80004c0a:	f6 a4       	jnz %d10,80004c12 <IfxMultican_Node_setFastBitTiming+0x88>
80004c0c:	3b f0 03 c0 	mov %d12,63
80004c10:	3c 06       	j 80004c1c <IfxMultican_Node_setFastBitTiming+0x92>
80004c12:	02 bf       	mov %d15,%d11
80004c14:	02 a3       	mov %d3,%d10
80004c16:	c2 f3       	add %d3,-1
80004c18:	8f f3 03 c1 	and %d12,%d3,63

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004c1c:	7b 30 00 40 	movh %d4,3
80004c20:	1b 04 81 49 	addi %d4,%d4,-26608
80004c24:	4b f4 01 42 	div %e4,%d4,%d15
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
80004c28:	4b 06 41 31 	itof %d3,%d6
80004c2c:	7b a0 e1 23 	movh %d2,15898

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004c30:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004c32:	0b 64 e0 40 	absdif %d4,%d4,%d6
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
80004c36:	1b a2 99 29 	addi %d2,%d2,-26214
80004c3a:	4b 23 41 30 	mul.f %d3,%d3,%d2
    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > error)
80004c3e:	4b 04 41 41 	itof %d4,%d4
80004c42:	4b 43 01 50 	cmp.f %d5,%d3,%d4
80004c46:	8f 45 00 51 	and %d5,%d5,4
80004c4a:	2b 43 50 25 	seln %d2,%d5,%d3,%d4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004c4e:	3f 60 17 02 	jlt %d0,%d6,8000507c <IfxMultican_Node_setFastBitTiming+0x4f2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004c52:	7b 20 00 40 	movh %d4,2
80004c56:	1b 04 10 47 	addi %d4,%d4,28928
80004c5a:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > error)
80004c5e:	3b f0 00 30 	mov %d3,15

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004c62:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004c64:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004c68:	4b 04 41 41 	itof %d4,%d4
80004c6c:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004c70:	37 05 61 51 	extr.u %d5,%d5,2,1
80004c74:	ab 03 81 35 	sel %d3,%d5,%d3,16
80004c78:	2b 24 40 25 	sel %d2,%d5,%d4,%d2
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004c7c:	3f 60 f8 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004c80:	7b 20 00 40 	movh %d4,2
80004c84:	1b 04 9f 44 	addi %d4,%d4,18928
80004c88:	4b f4 01 42 	div %e4,%d4,%d15
80004c8c:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004c8e:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004c92:	4b 04 41 41 	itof %d4,%d4
80004c96:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004c9a:	37 05 61 51 	extr.u %d5,%d5,2,1
80004c9e:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004ca2:	ab e3 a0 35 	seln %d3,%d5,%d3,14
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004ca6:	3f 60 e3 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004caa:	7b 20 00 40 	movh %d4,2
80004cae:	1b 04 2e 42 	addi %d4,%d4,8928
80004cb2:	4b f4 01 42 	div %e4,%d4,%d15
80004cb6:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004cb8:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004cbc:	4b 04 41 41 	itof %d4,%d4
80004cc0:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004cc4:	37 05 61 51 	extr.u %d5,%d5,2,1
80004cc8:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004ccc:	ab d3 a0 35 	seln %d3,%d5,%d3,13
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004cd0:	3f 60 ce 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004cd4:	7b 20 00 40 	movh %d4,2
80004cd8:	1b 04 bd 4f 	addi %d4,%d4,-1072
80004cdc:	4b f4 01 42 	div %e4,%d4,%d15
80004ce0:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004ce2:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004ce6:	4b 04 41 41 	itof %d4,%d4
80004cea:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004cee:	37 05 61 51 	extr.u %d5,%d5,2,1
80004cf2:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004cf6:	ab c3 a0 35 	seln %d3,%d5,%d3,12
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004cfa:	3f 60 b9 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004cfe:	7b 20 00 40 	movh %d4,2
80004d02:	1b 04 4c 4d 	addi %d4,%d4,-11072
80004d06:	4b f4 01 42 	div %e4,%d4,%d15
80004d0a:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004d0c:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004d10:	4b 04 41 41 	itof %d4,%d4
80004d14:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004d18:	37 05 61 51 	extr.u %d5,%d5,2,1
80004d1c:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004d20:	ab b3 a0 35 	seln %d3,%d5,%d3,11
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004d24:	3f 60 a4 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004d28:	7b 20 00 40 	movh %d4,2
80004d2c:	1b 04 db 4a 	addi %d4,%d4,-21072
80004d30:	4b f4 01 42 	div %e4,%d4,%d15
80004d34:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004d36:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004d3a:	4b 04 41 41 	itof %d4,%d4
80004d3e:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004d42:	37 05 61 51 	extr.u %d5,%d5,2,1
80004d46:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004d4a:	ab a3 a0 35 	seln %d3,%d5,%d3,10
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004d4e:	3f 60 8f 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004d52:	7b 20 00 40 	movh %d4,2
80004d56:	1b 04 6a 48 	addi %d4,%d4,-31072
80004d5a:	4b f4 01 42 	div %e4,%d4,%d15
80004d5e:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004d60:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004d64:	4b 04 41 41 	itof %d4,%d4
80004d68:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004d6c:	37 05 61 51 	extr.u %d5,%d5,2,1
80004d70:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004d74:	ab 93 a0 35 	seln %d3,%d5,%d3,9
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004d78:	3f 60 7a 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004d7c:	7b 10 00 40 	movh %d4,1
80004d80:	1b 04 f9 45 	addi %d4,%d4,24464
80004d84:	4b f4 01 42 	div %e4,%d4,%d15
80004d88:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004d8a:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004d8e:	4b 04 41 41 	itof %d4,%d4
80004d92:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004d96:	37 05 61 51 	extr.u %d5,%d5,2,1
80004d9a:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004d9e:	ab 83 a0 35 	seln %d3,%d5,%d3,8
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004da2:	3f 60 65 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004da6:	7b 10 00 40 	movh %d4,1
80004daa:	1b 04 88 43 	addi %d4,%d4,14464
80004dae:	4b f4 01 42 	div %e4,%d4,%d15
80004db2:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004db4:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004db8:	4b 04 41 41 	itof %d4,%d4
80004dbc:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004dc0:	37 05 61 51 	extr.u %d5,%d5,2,1
80004dc4:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004dc8:	ab 73 a0 35 	seln %d3,%d5,%d3,7
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004dcc:	3f 60 50 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004dd0:	7b 10 00 40 	movh %d4,1
80004dd4:	1b 04 17 41 	addi %d4,%d4,4464
80004dd8:	4b f4 01 42 	div %e4,%d4,%d15
80004ddc:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004dde:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004de2:	4b 04 41 41 	itof %d4,%d4
80004de6:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004dea:	37 05 61 51 	extr.u %d5,%d5,2,1
80004dee:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004df2:	ab 63 a0 35 	seln %d3,%d5,%d3,6
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004df6:	3f 60 3b 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004dfa:	bb 00 a6 4e 	mov.u %d4,60000
80004dfe:	4b f4 01 42 	div %e4,%d4,%d15
80004e02:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004e04:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004e08:	4b 04 41 41 	itof %d4,%d4
80004e0c:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004e10:	37 05 61 51 	extr.u %d5,%d5,2,1
80004e14:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004e18:	ab 53 a0 35 	seln %d3,%d5,%d3,5
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004e1c:	3f 60 28 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004e20:	bb 00 35 4c 	mov.u %d4,50000
80004e24:	4b f4 01 42 	div %e4,%d4,%d15
80004e28:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004e2a:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004e2e:	4b 04 41 41 	itof %d4,%d4
80004e32:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80004e36:	37 05 61 51 	extr.u %d5,%d5,2,1
80004e3a:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80004e3e:	ab 43 a0 35 	seln %d3,%d5,%d3,4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004e42:	3f 60 15 00 	jlt %d0,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80004e46:	bb 00 c4 49 	mov.u %d4,40000
80004e4a:	4b f4 01 42 	div %e4,%d4,%d15
80004e4e:	02 45       	mov %d5,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80004e50:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80004e54:	4b 04 41 41 	itof %d4,%d4
80004e58:	4b 24 01 20 	cmp.f %d2,%d4,%d2
80004e5c:	6f 02 09 81 	jnz.t %d2,0,8000506e <IfxMultican_Node_setFastBitTiming+0x4e4>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80004e60:	3f 65 06 00 	jlt %d5,%d6,80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

            break;  /* least possible error has already occured */
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
80004e64:	8b 03 01 22 	eq %d2,%d3,16
80004e68:	df 02 06 81 	jne %d2,0,80005074 <IfxMultican_Node_setFastBitTiming+0x4ea>
80004e6c:	1b f3 ff af 	addi %d10,%d3,-1
80004e70:	8f fa 00 a1 	and %d10,%d10,15
    {
        bestTSEG1 = minTSEG1;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;
80004e74:	52 33       	sub %d3,%d15,%d3
80004e76:	c2 f3       	add %d3,-1

    if (bestTSEG2 > maxTSEG2)
80004e78:	8b 93 80 22 	ge %d2,%d3,9
80004e7c:	df 02 36 80 	jne %d2,0,80004ee8 <IfxMultican_Node_setFastBitTiming+0x35e>
80004e80:	1b f3 ff df 	addi %d13,%d3,-1
80004e84:	8f 7d 00 d1 	and %d13,%d13,7
    {
        bestTSEG2 = maxTSEG2;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
80004e88:	ff 23 33 00 	jge %d3,2,80004eee <IfxMultican_Node_setFastBitTiming+0x364>
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004e8c:	3b 00 71 22 	mov %d2,10000
80004e90:	4b f2 01 22 	div %e2,%d2,%d15
80004e94:	3b 00 e2 44 	mov %d4,20000
80004e98:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004e9c:	0b 72 e0 20 	absdif %d2,%d2,%d7
80004ea0:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
80004ea4:	4b 02 41 61 	itof %d6,%d2
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004ea8:	0b 74 e0 f0 	absdif %d15,%d4,%d7
80004eac:	1b 05 00 54 	addi %d5,%d5,16384
80004eb0:	4b 56 01 30 	cmp.f %d3,%d6,%d5

        if (bestError > error)
80004eb4:	4b 0f 41 f1 	itof %d15,%d15
80004eb8:	8f 43 00 31 	and %d3,%d3,4
80004ebc:	2b 56 50 43 	seln %d4,%d3,%d6,%d5
80004ec0:	4b 4f 01 40 	cmp.f %d4,%d15,%d4
80004ec4:	37 04 61 40 	extr.u %d4,%d4,0,1
80004ec8:	82 22       	mov %d2,2
80004eca:	ab 12 80 24 	sel %d2,%d4,%d2,1
        }
    }

    {
        Ifx_CAN_N_FBTR nfbtr;
        nfbtr.U        = 0;
80004ece:	82 0f       	mov %d15,0
        nfbtr.B.FBRP   = bestBRP - 1;
80004ed0:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nfbtr.B.FSJW   = bestSJW - 1;
80004ed4:	c2 f2       	add %d2,-1
80004ed6:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);

        if (bestError > error)
80004eda:	82 1d       	mov %d13,1
    {
        Ifx_CAN_N_FBTR nfbtr;
        nfbtr.U        = 0;
        nfbtr.B.FBRP   = bestBRP - 1;
        nfbtr.B.FSJW   = bestSJW - 1;
        nfbtr.B.FTSEG1 = bestTSEG1 - 1;
80004edc:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nfbtr.B.FTSEG2 = bestTSEG2 - 1;
80004ee0:	37 df 03 f6 	insert %d15,%d15,%d13,12,3

        hwNode->FBTR.U = nfbtr.U;
80004ee4:	6c 4e       	st.w [%a4]56,%d15
80004ee6:	00 90       	ret 
80004ee8:	82 7d       	mov %d13,7

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;
80004eea:	3b 80 00 30 	mov %d3,8
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004eee:	3b 00 71 42 	mov %d4,10000
80004ef2:	4b f4 01 42 	div %e4,%d4,%d15
80004ef6:	3b 00 e2 04 	mov %d0,20000
80004efa:	4b f0 01 02 	div %e0,%d0,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004efe:	0b 74 e0 40 	absdif %d4,%d4,%d7
80004f02:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
80004f06:	4b 04 41 41 	itof %d4,%d4
80004f0a:	1b 05 00 54 	addi %d5,%d5,16384
80004f0e:	4b 54 01 20 	cmp.f %d2,%d4,%d5
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004f12:	0b 70 e0 00 	absdif %d0,%d0,%d7
80004f16:	8f 42 00 21 	and %d2,%d2,4
80004f1a:	2b 54 50 42 	seln %d4,%d2,%d4,%d5

        if (bestError > error)
80004f1e:	4b 00 41 51 	itof %d5,%d0
80004f22:	82 26       	mov %d6,2
80004f24:	4b 45 01 20 	cmp.f %d2,%d5,%d4
80004f28:	37 02 61 20 	extr.u %d2,%d2,0,1
80004f2c:	4b 45 01 10 	cmp.f %d1,%d5,%d4
80004f30:	8f 41 00 11 	and %d1,%d1,4
80004f34:	ab 16 80 22 	sel %d2,%d2,%d6,1
80004f38:	2b 45 50 b1 	seln %d11,%d1,%d5,%d4
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004f3c:	df 23 84 00 	jeq %d3,2,80005044 <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004f40:	3b 00 53 87 	mov %d8,30000
80004f44:	4b f8 01 82 	div %e8,%d8,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004f48:	0b 78 e0 80 	absdif %d8,%d8,%d7

        if (bestError > error)
80004f4c:	4b 08 41 81 	itof %d8,%d8
80004f50:	4b 8b 01 40 	cmp.f %d4,%d11,%d8
80004f54:	4b 8b 01 00 	cmp.f %d0,%d11,%d8
80004f58:	87 44 a0 40 	or.t %d4,%d4,0,%d4,1
80004f5c:	8f 40 00 01 	and %d0,%d0,4
80004f60:	ab 32 80 24 	sel %d2,%d4,%d2,3
80004f64:	2b 8b 50 10 	seln %d1,%d0,%d11,%d8
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004f68:	df 33 6e 00 	jeq %d3,3,80005044 <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004f6c:	bb 00 c4 49 	mov.u %d4,40000
80004f70:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004f74:	0b 74 e0 40 	absdif %d4,%d4,%d7

        if (bestError > error)
80004f78:	4b 04 41 51 	itof %d5,%d4
80004f7c:	4b 15 01 40 	cmp.f %d4,%d5,%d1
80004f80:	4b 15 01 60 	cmp.f %d6,%d5,%d1
80004f84:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004f88:	8f 46 00 61 	and %d6,%d6,4
80004f8c:	ab 42 80 24 	sel %d2,%d4,%d2,4
80004f90:	2b 15 50 06 	seln %d0,%d6,%d5,%d1
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004f94:	df 43 58 00 	jeq %d3,4,80005044 <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004f98:	bb 00 35 4c 	mov.u %d4,50000
80004f9c:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004fa0:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80004fa4:	4b 05 41 51 	itof %d5,%d5
80004fa8:	4b 05 01 40 	cmp.f %d4,%d5,%d0
80004fac:	4b 05 01 60 	cmp.f %d6,%d5,%d0
80004fb0:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004fb4:	8f 46 00 61 	and %d6,%d6,4
80004fb8:	ab 52 80 24 	sel %d2,%d4,%d2,5
80004fbc:	2b 05 50 66 	seln %d6,%d6,%d5,%d0
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004fc0:	df 53 42 00 	jeq %d3,5,80005044 <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004fc4:	bb 00 a6 4e 	mov.u %d4,60000
80004fc8:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80004fcc:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80004fd0:	4b 05 41 51 	itof %d5,%d5
80004fd4:	4b 65 01 40 	cmp.f %d4,%d5,%d6
80004fd8:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80004fdc:	ab 62 80 24 	sel %d2,%d4,%d2,6
80004fe0:	4b 65 01 40 	cmp.f %d4,%d5,%d6
80004fe4:	8f 44 00 41 	and %d4,%d4,4
80004fe8:	2b 65 50 54 	seln %d5,%d4,%d5,%d6
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004fec:	df 63 2c 00 	jeq %d3,6,80005044 <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80004ff0:	7b 10 00 00 	movh %d0,1
80004ff4:	1b 00 17 01 	addi %d0,%d0,4464
80004ff8:	4b f0 01 02 	div %e0,%d0,%d15
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80004ffc:	8b 83 20 32 	ne %d3,%d3,8
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005000:	0b 70 e0 00 	absdif %d0,%d0,%d7

        if (bestError > error)
80005004:	4b 00 41 61 	itof %d6,%d0
80005008:	4b 56 01 40 	cmp.f %d4,%d6,%d5
8000500c:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005010:	ab 72 80 24 	sel %d2,%d4,%d2,7
80005014:	4b 56 01 40 	cmp.f %d4,%d6,%d5
80005018:	8f 44 00 41 	and %d4,%d4,4
8000501c:	2b 56 50 64 	seln %d6,%d4,%d6,%d5
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005020:	df 03 12 80 	jne %d3,0,80005044 <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005024:	7b 10 00 40 	movh %d4,1
80005028:	1b 04 88 43 	addi %d4,%d4,14464
8000502c:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005030:	0b 74 e0 f0 	absdif %d15,%d4,%d7

        if (bestError > error)
80005034:	4b 0f 41 f1 	itof %d15,%d15
80005038:	4b f6 01 70 	cmp.f %d7,%d6,%d15
8000503c:	87 77 a0 70 	or.t %d7,%d7,0,%d7,1
80005040:	ab 82 80 27 	sel %d2,%d7,%d2,8
        }
    }

    {
        Ifx_CAN_N_FBTR nfbtr;
        nfbtr.U        = 0;
80005044:	82 0f       	mov %d15,0
        nfbtr.B.FBRP   = bestBRP - 1;
80005046:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nfbtr.B.FSJW   = bestSJW - 1;
8000504a:	c2 f2       	add %d2,-1
8000504c:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
        nfbtr.B.FTSEG1 = bestTSEG1 - 1;
80005050:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nfbtr.B.FTSEG2 = bestTSEG2 - 1;
80005054:	37 df 03 f6 	insert %d15,%d15,%d13,12,3

        hwNode->FBTR.U = nfbtr.U;
80005058:	6c 4e       	st.w [%a4]56,%d15
8000505a:	00 90       	ret 
8000505c:	82 0c       	mov %d12,0
        bestBRP   = maxBRP;
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
8000505e:	df 0a df 7d 	jeq %d10,0,80004c1c <IfxMultican_Node_setFastBitTiming+0x92>
80005062:	c2 fa       	add %d10,-1
80005064:	8f fa 03 c1 	and %d12,%d10,63
80005068:	02 bf       	mov %d15,%d11
8000506a:	1d ff d9 fd 	j 80004c1c <IfxMultican_Node_setFastBitTiming+0x92>
    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
8000506e:	82 33       	mov %d3,3
80005070:	1d ff fe fe 	j 80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>
80005074:	82 2a       	mov %d10,2
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
    {
        bestTSEG1 = minTSEG1;
80005076:	82 33       	mov %d3,3
80005078:	1d ff fe fe 	j 80004e74 <IfxMultican_Node_setFastBitTiming+0x2ea>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000507c:	3b 00 01 30 	mov %d3,16
80005080:	1d ff f6 fe 	j 80004e6c <IfxMultican_Node_setFastBitTiming+0x2e2>

80005084 <IfxMultican_Node_setNominalBitTiming>:
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005084:	4b 05 61 51 	utof %d5,%d5
80005088:	7b 00 f8 93 	movh %d9,16256
8000508c:	4b 59 51 90 	div.f %d9,%d9,%d5
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005090:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005094:	7b d0 d4 83 	movh %d8,15693
80005098:	1b d8 cc 8c 	addi %d8,%d8,-13107
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
8000509c:	7b d0 dc c3 	movh %d12,15821
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
800050a0:	4b 85 41 80 	mul.f %d8,%d5,%d8
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
800050a4:	3b 80 00 b0 	mov %d11,8
800050a8:	82 0a       	mov %d10,0
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
800050aa:	82 13       	mov %d3,1
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800050ac:	1b dc cc cc 	addi %d12,%d12,-13107
    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = moduleFreq / tempBRP;
800050b0:	4b 03 41 21 	itof %d2,%d3
800050b4:	4b 24 51 20 	div.f %d2,%d4,%d2
        tempTBAUD = Fquanta / baudrate;
800050b8:	4b 92 41 f0 	mul.f %d15,%d2,%d9
800050bc:	4b 0f 31 f1 	ftoiz %d15,%d15

        if (tempTBAUD == 0)
800050c0:	df 0f 98 00 	jeq %d15,0,800051f0 <IfxMultican_Node_setNominalBitTiming+0x16c>
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
800050c4:	4b 0f 41 01 	itof %d0,%d15
800050c8:	4b 02 51 20 	div.f %d2,%d2,%d0
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
800050cc:	8b 8f 80 02 	ge %d0,%d15,8
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);
800050d0:	6b 05 31 22 	sub.f %d2,%d2,%d5
800050d4:	b7 02 81 2f 	insert %d2,%d2,0,31,1

        if (tempTBAUD < minTBAUD)
800050d8:	df 00 8c 00 	jeq %d0,0,800051f0 <IfxMultican_Node_setNominalBitTiming+0x16c>
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
800050dc:	4b 28 01 00 	cmp.f %d0,%d8,%d2
800050e0:	87 00 a2 00 	or.t %d0,%d0,2,%d0,1
800050e4:	8b 2f 46 12 	lt %d1,%d15,98
800050e8:	26 10       	and %d0,%d1
800050ea:	76 0a       	jz %d0,800050fe <IfxMultican_Node_setNominalBitTiming+0x7a>
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800050ec:	4b c2 01 10 	cmp.f %d1,%d2,%d12
800050f0:	8b 5f 41 02 	lt %d0,%d15,21
800050f4:	26 10       	and %d0,%d1
800050f6:	f6 0d       	jnz %d0,80005110 <IfxMultican_Node_setNominalBitTiming+0x8c>

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;
800050f8:	02 28       	mov %d8,%d2
800050fa:	0b 3f 10 a8 	mov %e10,%d15,%d3
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
800050fe:	c2 13       	add %d3,1
80005100:	fd f0 d8 7f 	loop %a15,800050b0 <IfxMultican_Node_setNominalBitTiming+0x2c>
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
80005104:	f6 a4       	jnz %d10,8000510c <IfxMultican_Node_setNominalBitTiming+0x88>
80005106:	3b f0 03 90 	mov %d9,63
8000510a:	3c 06       	j 80005116 <IfxMultican_Node_setNominalBitTiming+0x92>
8000510c:	02 bf       	mov %d15,%d11
8000510e:	02 a3       	mov %d3,%d10
80005110:	c2 f3       	add %d3,-1
80005112:	8f f3 03 91 	and %d9,%d3,63
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
80005116:	4b 06 41 41 	itof %d4,%d6
8000511a:	7b a0 e1 23 	movh %d2,15898
8000511e:	1b a2 99 29 	addi %d2,%d2,-26214
80005122:	7b a0 00 00 	movh %d0,10
80005126:	4b 24 41 40 	mul.f %d4,%d4,%d2
8000512a:	1b 00 b1 0e 	addi %d0,%d0,-5360

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
8000512e:	3b 00 04 10 	mov %d1,64
80005132:	3b 00 04 50 	mov %d5,64
80005136:	c5 0f 3d 00 	lea %a15,3d <_.+0x3c>
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
8000513a:	4b f0 01 22 	div %e2,%d0,%d15
8000513e:	02 28       	mov %d8,%d2
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005140:	0b 62 e0 20 	absdif %d2,%d2,%d6

        if (bestError > error)
80005144:	4b 02 41 21 	itof %d2,%d2
80005148:	4b 42 01 30 	cmp.f %d3,%d2,%d4
8000514c:	37 03 61 30 	extr.u %d3,%d3,0,1
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
80005150:	2b 24 50 43 	seln %d4,%d3,%d4,%d2
80005154:	2b 15 50 53 	seln %d5,%d3,%d5,%d1
        }

        if (tempSamplePoint < samplePoint)
80005158:	3f 68 0b 00 	jlt %d8,%d6,8000516e <IfxMultican_Node_setNominalBitTiming+0xea>
    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
8000515c:	c2 f1       	add %d1,-1
8000515e:	1b 00 8f 0d 	addi %d0,%d0,-10000
80005162:	fd f0 ec 7f 	loop %a15,8000513a <IfxMultican_Node_setNominalBitTiming+0xb6>

            break;  /* least possible error has already occured */
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
80005166:	8b 05 04 22 	eq %d2,%d5,64
8000516a:	df 02 50 80 	jne %d2,0,8000520a <IfxMultican_Node_setNominalBitTiming+0x186>
8000516e:	1b f5 ff 8f 	addi %d8,%d5,-1
80005172:	8f f8 03 81 	and %d8,%d8,63
    {
        bestTSEG1 = minTSEG1;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;
80005176:	52 55       	sub %d5,%d15,%d5
80005178:	c2 f5       	add %d5,-1

    if (bestTSEG2 > maxTSEG2)
8000517a:	8b 15 82 22 	ge %d2,%d5,33
8000517e:	df 02 41 80 	jne %d2,0,80005200 <IfxMultican_Node_setNominalBitTiming+0x17c>
80005182:	1b f5 ff af 	addi %d10,%d5,-1
80005186:	8f fa 01 a1 	and %d10,%d10,31
    {
        bestTSEG2 = maxTSEG2;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
8000518a:	ff 25 04 00 	jge %d5,2,80005192 <IfxMultican_Node_setNominalBitTiming+0x10e>
8000518e:	82 1a       	mov %d10,1
    {
        bestTSEG2 = minTSEG2;
80005190:	82 25       	mov %d5,2
80005192:	60 5f       	mov.a %a15,%d5
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best SJW */
    bestError = 10000;
80005194:	7b c0 61 24 	movh %d2,17948
80005198:	1b 02 00 24 	addi %d2,%d2,16384
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
8000519c:	82 10       	mov %d0,1
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
8000519e:	82 16       	mov %d6,1
800051a0:	3b 00 71 12 	mov %d1,10000
800051a4:	b0 ff       	add.a %a15,-1
800051a6:	73 16 0a 40 	mul %d4,%d6,%d1
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
800051aa:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800051ae:	0b 74 e0 40 	absdif %d4,%d4,%d7

        if (bestError > error)
800051b2:	4b 04 41 31 	itof %d3,%d4
800051b6:	4b 23 01 40 	cmp.f %d4,%d3,%d2
800051ba:	37 04 61 40 	extr.u %d4,%d4,0,1
800051be:	2b 06 40 04 	sel %d0,%d4,%d6,%d0
800051c2:	4b 23 01 40 	cmp.f %d4,%d3,%d2
800051c6:	8f 44 00 41 	and %d4,%d4,4
800051ca:	2b 23 50 24 	seln %d2,%d4,%d3,%d2
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
800051ce:	c2 16       	add %d6,1
800051d0:	fd f0 eb 7f 	loop %a15,800051a6 <IfxMultican_Node_setNominalBitTiming+0x122>
        }
    }

    {
        Ifx_CAN_N_BTEVR nbtevr;
        nbtevr.U       = 0;
800051d4:	82 0f       	mov %d15,0
        nbtevr.B.BRP   = bestBRP - 1;
800051d6:	37 9f 06 f0 	insert %d15,%d15,%d9,0,6
        nbtevr.B.SJW   = bestSJW - 1;
800051da:	c2 f0       	add %d0,-1
800051dc:	37 0f 04 f4 	insert %d15,%d15,%d0,8,4
        nbtevr.B.TSEG1 = bestTSEG1 - 1;
800051e0:	37 8f 06 fb 	insert %d15,%d15,%d8,22,6
        nbtevr.B.TSEG2 = bestTSEG2 - 1;
800051e4:	37 af 05 f8 	insert %d15,%d15,%d10,16,5
        nbtevr.B.DIV8  = 0;
800051e8:	b7 0f 81 f7 	insert %d15,%d15,0,15,1
        //nbtr.B.FTX = 0; /* TTCAN only */

        hwNode->BTEVR.U = nbtevr.U;
800051ec:	6c 44       	st.w [%a4]16,%d15
800051ee:	00 90       	ret 
800051f0:	82 09       	mov %d9,0
        bestBRP   = maxBRP;
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
800051f2:	df 0a 92 7f 	jeq %d10,0,80005116 <IfxMultican_Node_setNominalBitTiming+0x92>
800051f6:	c2 fa       	add %d10,-1
800051f8:	8f fa 03 91 	and %d9,%d10,63
800051fc:	02 bf       	mov %d15,%d11
800051fe:	3c 8c       	j 80005116 <IfxMultican_Node_setNominalBitTiming+0x92>
80005200:	3b f0 01 a0 	mov %d10,31

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;
80005204:	3b 00 02 50 	mov %d5,32
80005208:	3c c5       	j 80005192 <IfxMultican_Node_setNominalBitTiming+0x10e>
8000520a:	82 28       	mov %d8,2
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
    {
        bestTSEG1 = minTSEG1;
8000520c:	82 35       	mov %d5,3
8000520e:	3c b4       	j 80005176 <IfxMultican_Node_setNominalBitTiming+0xf2>

80005210 <IfxMultican_calcTimingFromBTR>:
void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
80005210:	37 05 64 04 	extr.u %d0,%d5,8,4
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
80005214:	37 05 63 f6 	extr.u %d15,%d5,12,3
void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
80005218:	c2 10       	add %d0,1
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;
8000521a:	bb 00 00 68 	mov.u %d6,32768
8000521e:	c2 2f       	add %d15,2


void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
80005220:	8f f5 03 71 	and %d7,%d5,63
    uint32        tempSJW   = 1U + nbtr.B.SJW;
80005224:	37 05 62 33 	extr.u %d3,%d5,6,2
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;
80005228:	3b 80 00 20 	mov %d2,8
8000522c:	26 65       	and %d5,%d6

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;
8000522e:	42 0f       	add %d15,%d0
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;
80005230:	ab 12 80 65 	sel %d6,%d5,%d2,1
80005234:	03 f7 0a 5f 	madd %d5,%d15,%d7,%d15

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80005238:	e2 65       	mul %d5,%d6

void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
8000523a:	c2 13       	add %d3,1
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
8000523c:	7b c0 61 24 	movh %d2,17948
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80005240:	4b 05 41 51 	itof %d5,%d5
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
80005244:	1b 02 00 24 	addi %d2,%d2,16384
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80005248:	4b 54 51 40 	div.f %d4,%d4,%d5
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
8000524c:	4b 03 41 31 	itof %d3,%d3
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80005250:	4b 04 71 51 	ftouz %d5,%d4
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
80005254:	4b 00 41 41 	itof %d4,%d0
80005258:	4b 0f 41 f1 	itof %d15,%d15
8000525c:	4b 24 41 40 	mul.f %d4,%d4,%d2
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80005260:	4b 23 41 20 	mul.f %d2,%d3,%d2
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
80005264:	4b f4 51 40 	div.f %d4,%d4,%d15
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80005268:	74 45       	st.w [%a4],%d5
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
8000526a:	4b f2 51 f0 	div.f %d15,%d2,%d15
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
8000526e:	4b 04 71 41 	ftouz %d4,%d4
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80005272:	4b 0f 71 f1 	ftouz %d15,%d15
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
80005276:	b4 54       	st.h [%a5],%d4
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80005278:	ac 60       	st.h [%a6]0,%d15
8000527a:	00 90       	ret 

8000527c <IfxMultican_deinit>:
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
8000527c:	bb f0 ff 6f 	mov.u %d6,65535
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
}


void IfxMultican_deinit(Ifx_CAN *mcan)
{
80005280:	40 4f       	mov.aa %a15,%a4
80005282:	82 03       	mov %d3,0
    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */

    hwObj->FCR.U   = 0x00000000UL;
    hwObj->FGPR.U  = 0x00000000UL;
    hwObj->IPR.U   = 0x00000000UL;
    hwObj->AMR.U   = 0x3FFFFFFFUL;
80005284:	9b f6 ff 53 	addih %d5,%d6,16383
{
    // should use kernel reset functionality!
    uint16 i;

    /* Ifx_CAN.CLC is reset last */
    for (i = 0; i < IFXMULTICAN_NUM_MESSAGE_OBJECTS; i++)
80005288:	c5 03 3f 30 	lea %a3,ff <_.+0xfe>

void IfxMultican_setListCommand(Ifx_CAN *mcan, uint32 cmd, uint32 arg2, uint32 arg1)
{
    Ifx_CAN_PANCTR panctr;

    panctr.B.PANAR1 = arg1;
8000528c:	37 32 08 28 	insert %d2,%d2,%d3,16,8
    panctr.B.PANAR2 = arg2;
80005290:	b7 02 08 2c 	insert %d2,%d2,0,24,8
    panctr.B.PANCMD = cmd;
80005294:	b7 22 08 20 	insert %d2,%d2,2,0,8

    /** - write to CAN_PANCTR */
    mcan->PANCTR.U = panctr.U;
80005298:	59 f2 04 70 	st.w [%a15]452,%d2
}


IFX_INLINE void IfxMultican_waitListReady(Ifx_CAN *mcan)
{
    while (mcan->PANCTR.B.BUSY != 0)
8000529c:	19 ff 04 70 	ld.w %d15,[%a15]452
800052a0:	37 0f 61 f4 	extr.u %d15,%d15,8,1
800052a4:	ee fc       	jnz %d15,8000529c <IfxMultican_deinit+0x20>
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
800052a6:	8f 53 00 40 	sh %d4,%d3,5
800052aa:	01 f4 00 26 	addsc.a %a2,%a15,%d4,0

    hwObj->FCR.U   = 0x00000000UL;
800052ae:	1b 03 08 40 	addi %d4,%d3,128
800052b2:	8f 54 00 70 	sh %d7,%d4,5
800052b6:	01 f7 00 46 	addsc.a %a4,%a15,%d7,0
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
800052ba:	59 26 1c 01 	st.w [%a2]4124,%d6

    hwObj->FCR.U   = 0x00000000UL;
800052be:	6c 40       	st.w [%a4]0,%d15
    hwObj->FGPR.U  = 0x00000000UL;
800052c0:	59 2f 04 01 	st.w [%a2]4100,%d15
    hwObj->IPR.U   = 0x00000000UL;
800052c4:	59 2f 08 01 	st.w [%a2]4104,%d15
    hwObj->AMR.U   = 0x3FFFFFFFUL;
800052c8:	59 25 0c 01 	st.w [%a2]4108,%d5
    hwObj->DATAL.U = 0x00000000UL;
800052cc:	59 2f 10 01 	st.w [%a2]4112,%d15
    hwObj->DATAH.U = 0x00000000UL;
800052d0:	59 2f 14 01 	st.w [%a2]4116,%d15
    hwObj->AR.U    = 0x00000000UL;
800052d4:	59 2f 18 01 	st.w [%a2]4120,%d15
800052d8:	c2 13       	add %d3,1
{
    // should use kernel reset functionality!
    uint16 i;

    /* Ifx_CAN.CLC is reset last */
    for (i = 0; i < IFXMULTICAN_NUM_MESSAGE_OBJECTS; i++)
800052da:	fd 30 d9 7f 	loop %a3,8000528c <IfxMultican_deinit+0x10>
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
800052de:	82 19       	mov %d9,1
800052e0:	59 f9 00 80 	st.w [%a15]512,%d9
    hwNode->SR.U    = 0x00000000;
800052e4:	59 ff 04 80 	st.w [%a15]516,%d15
    hwNode->IPR.U   = 0x00000000;
800052e8:	59 ff 08 80 	st.w [%a15]520,%d15
    hwNode->PCR.U   = 0x00000000;
800052ec:	59 ff 0c 80 	st.w [%a15]524,%d15
    hwNode->BTEVR.U = 0x00000000;
800052f0:	59 ff 10 80 	st.w [%a15]528,%d15
    hwNode->ECNT.U  = 0x00600000;
800052f4:	7b 00 06 20 	movh %d2,96
800052f8:	59 f2 14 80 	st.w [%a15]532,%d2
    hwNode->FCR.U   = 0x00000000;
800052fc:	59 ff 18 80 	st.w [%a15]536,%d15
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
80005300:	59 f9 00 c0 	st.w [%a15]768,%d9
    hwNode->SR.U    = 0x00000000;
80005304:	59 ff 04 c0 	st.w [%a15]772,%d15
    hwNode->IPR.U   = 0x00000000;
80005308:	59 ff 08 c0 	st.w [%a15]776,%d15
    hwNode->PCR.U   = 0x00000000;
8000530c:	59 ff 0c c0 	st.w [%a15]780,%d15
    hwNode->BTEVR.U = 0x00000000;
80005310:	59 ff 10 c0 	st.w [%a15]784,%d15
    hwNode->ECNT.U  = 0x00600000;
80005314:	59 f2 14 c0 	st.w [%a15]788,%d2
    hwNode->FCR.U   = 0x00000000;
80005318:	59 ff 18 c0 	st.w [%a15]792,%d15
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
8000531c:	59 f9 40 00 	st.w [%a15]1024,%d9
    hwNode->SR.U    = 0x00000000;
80005320:	59 ff 44 00 	st.w [%a15]1028,%d15
    hwNode->IPR.U   = 0x00000000;
80005324:	59 ff 48 00 	st.w [%a15]1032,%d15
    hwNode->PCR.U   = 0x00000000;
80005328:	59 ff 4c 00 	st.w [%a15]1036,%d15
    hwNode->BTEVR.U = 0x00000000;
8000532c:	59 ff 50 00 	st.w [%a15]1040,%d15
    hwNode->ECNT.U  = 0x00600000;
80005330:	59 f2 54 00 	st.w [%a15]1044,%d2
    hwNode->FCR.U   = 0x00000000;
80005334:	59 ff 58 00 	st.w [%a15]1048,%d15
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
80005338:	59 f9 40 40 	st.w [%a15]1280,%d9
    hwNode->SR.U    = 0x00000000;
8000533c:	59 ff 44 40 	st.w [%a15]1284,%d15
    hwNode->IPR.U   = 0x00000000;
80005340:	59 ff 48 40 	st.w [%a15]1288,%d15
    hwNode->PCR.U   = 0x00000000;
80005344:	59 ff 4c 40 	st.w [%a15]1292,%d15
    hwNode->BTEVR.U = 0x00000000;
80005348:	59 ff 50 40 	st.w [%a15]1296,%d15
    hwNode->ECNT.U  = 0x00600000;
8000534c:	59 f2 54 40 	st.w [%a15]1300,%d2
        IfxMultican_Node_deinit(hwNode);
    }

    for (i = 0; i < IFXMULTICAN_NUM_SRC; i++)
    {
        MODULE_SRC.CAN.CAN[0].INT[i].U = 0x00000000;
80005350:	91 40 00 2f 	movh.a %a2,61444
80005354:	d9 22 00 08 	lea %a2,[%a2]-32768 <f0038000 <_SMALL_DATA4_+0x40030000>>
    hwNode->SR.U    = 0x00000000;
    hwNode->IPR.U   = 0x00000000;
    hwNode->PCR.U   = 0x00000000;
    hwNode->BTEVR.U = 0x00000000;
    hwNode->ECNT.U  = 0x00600000;
    hwNode->FCR.U   = 0x00000000;
80005358:	59 ff 58 40 	st.w [%a15]1304 <f0038000 <_SMALL_DATA4_+0x40030000>>,%d15
        IfxMultican_Node_deinit(hwNode);
    }

    for (i = 0; i < IFXMULTICAN_NUM_SRC; i++)
    {
        MODULE_SRC.CAN.CAN[0].INT[i].U = 0x00000000;
8000535c:	59 2f 80 40 	st.w [%a2]2304 <f0040900 <_SMALL_DATA4_+0x40038900>>,%d15
80005360:	59 2f 84 40 	st.w [%a2]2308 <f0040904 <_SMALL_DATA4_+0x40038904>>,%d15
80005364:	59 2f 88 40 	st.w [%a2]2312 <f0040908 <_SMALL_DATA4_+0x40038908>>,%d15
80005368:	59 2f 8c 40 	st.w [%a2]2316 <f004090c <_SMALL_DATA4_+0x4003890c>>,%d15
8000536c:	59 2f 90 40 	st.w [%a2]2320 <f0040910 <_SMALL_DATA4_+0x40038910>>,%d15
80005370:	59 2f 94 40 	st.w [%a2]2324 <f0040914 <_SMALL_DATA4_+0x40038914>>,%d15
80005374:	59 2f 98 40 	st.w [%a2]2328 <f0040918 <_SMALL_DATA4_+0x40038918>>,%d15
80005378:	59 2f 9c 40 	st.w [%a2]2332 <f004091c <_SMALL_DATA4_+0x4003891c>>,%d15
8000537c:	59 2f a0 40 	st.w [%a2]2336 <f0040920 <_SMALL_DATA4_+0x40038920>>,%d15
80005380:	59 2f a4 40 	st.w [%a2]2340 <f0040924 <_SMALL_DATA4_+0x40038924>>,%d15
80005384:	59 2f a8 40 	st.w [%a2]2344 <f0040928 <_SMALL_DATA4_+0x40038928>>,%d15
80005388:	59 2f ac 40 	st.w [%a2]2348 <f004092c <_SMALL_DATA4_+0x4003892c>>,%d15
8000538c:	59 2f b0 40 	st.w [%a2]2352 <f0040930 <_SMALL_DATA4_+0x40038930>>,%d15
80005390:	59 2f b4 40 	st.w [%a2]2356 <f0040934 <_SMALL_DATA4_+0x40038934>>,%d15
80005394:	59 2f b8 40 	st.w [%a2]2360 <f0040938 <_SMALL_DATA4_+0x40038938>>,%d15
80005398:	59 2f bc 40 	st.w [%a2]2364 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    }

    for (i = 0; i < 8; i++)
    {
        mcan->MSPND[i].U = 0x00000000;
8000539c:	59 ff 00 50 	st.w [%a15]320 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053a0:	59 ff 04 50 	st.w [%a15]324 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053a4:	59 ff 08 50 	st.w [%a15]328 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053a8:	59 ff 0c 50 	st.w [%a15]332 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053ac:	59 ff 10 50 	st.w [%a15]336 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053b0:	59 ff 14 50 	st.w [%a15]340 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053b4:	59 ff 18 50 	st.w [%a15]344 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
800053b8:	59 ff 1c 50 	st.w [%a15]348 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    }

    mcan->MSIMASK.U = 0x00000000;
800053bc:	59 ff 00 70 	st.w [%a15]448 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    mcan->MCR.U     = 0x00000000;
800053c0:	59 ff 08 70 	st.w [%a15]456 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800053c4:	6d 00 c0 21 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
800053c8:	02 24       	mov %d4,%d2
    }

    mcan->MSIMASK.U = 0x00000000;
    mcan->MCR.U     = 0x00000000;
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800053ca:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
800053cc:	6d 00 be 20 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        mcan->FDR.U = 0x00000000;
        IfxScuWdt_setCpuEndinit(passwd);
800053d0:	02 84       	mov %d4,%d8
    mcan->MSIMASK.U = 0x00000000;
    mcan->MCR.U     = 0x00000000;
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        mcan->FDR.U = 0x00000000;
800053d2:	68 3f       	st.w [%a15]12,%d15
        IfxScuWdt_setCpuEndinit(passwd);
800053d4:	6d 00 fe 22 	call 800099d0 <IfxScuWdt_setCpuEndinit>
        IfxScuWdt_clearCpuEndinit(passwd);
800053d8:	02 84       	mov %d4,%d8
800053da:	6d 00 b7 20 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        mcan->CLC.U = 0x00000001;
800053de:	68 09       	st.w [%a15]0,%d9
        IfxScuWdt_setCpuEndinit(passwd);
800053e0:	02 84       	mov %d4,%d8
800053e2:	1d 00 f7 22 	j 800099d0 <IfxScuWdt_setCpuEndinit>

800053e6 <IfxMultican_getSrcPointer>:
}


volatile Ifx_SRC_SRCR *IfxMultican_getSrcPointer(Ifx_CAN *mcan, IfxMultican_SrcId srcId)
{
    return &(MODULE_SRC.CAN.CAN[0].INT[srcId]);
800053e6:	06 24       	sh %d4,2
800053e8:	60 4f       	mov.a %a15,%d4
800053ea:	d9 f2 80 48 	lea %a2,[%a15]-30464
}
800053ee:	11 42 00 2f 	addih.a %a2,%a2,61444
800053f2:	00 90       	ret 

800053f4 <IfxMultican_resetModule>:


void IfxMultican_resetModule(Ifx_CAN *can)
{
800053f4:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800053f6:	6d 00 a7 21 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800053fa:	02 24       	mov %d4,%d2
}


void IfxMultican_resetModule(Ifx_CAN *can)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800053fc:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800053fe:	6d 00 a5 20 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    can->KRST0.B.RST = 1;           /* Only if both Kernel reset bits are set a reset is executed */
80005402:	19 ff 34 30 	ld.w %d15,[%a15]244
    can->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80005406:	02 84       	mov %d4,%d8
void IfxMultican_resetModule(Ifx_CAN *can)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    can->KRST0.B.RST = 1;           /* Only if both Kernel reset bits are set a reset is executed */
80005408:	96 01       	or %d15,1
8000540a:	59 ff 34 30 	st.w [%a15]244,%d15
    can->KRST1.B.RST = 1;
8000540e:	19 ff 30 30 	ld.w %d15,[%a15]240
80005412:	96 01       	or %d15,1
80005414:	59 ff 30 30 	st.w [%a15]240,%d15
    IfxScuWdt_setCpuEndinit(passwd);
80005418:	6d 00 dc 22 	call 800099d0 <IfxScuWdt_setCpuEndinit>

    while (0 == can->KRST0.B.RSTSTAT)   /* Wait until reset is executed */
8000541c:	19 ff 34 30 	ld.w %d15,[%a15]244
80005420:	6f 1f fe 7f 	jz.t %d15,1,8000541c <IfxMultican_resetModule+0x28>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80005424:	02 84       	mov %d4,%d8
80005426:	6d 00 91 20 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    can->KRSTCLR.B.CLR = 1;         /* Clear Kernel reset status bit */
8000542a:	19 ff 2c 30 	ld.w %d15,[%a15]236
    IfxScuWdt_setCpuEndinit(passwd);
8000542e:	02 84       	mov %d4,%d8
    while (0 == can->KRST0.B.RSTSTAT)   /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    can->KRSTCLR.B.CLR = 1;         /* Clear Kernel reset status bit */
80005430:	96 01       	or %d15,1
80005432:	59 ff 2c 30 	st.w [%a15]236,%d15
    IfxScuWdt_setCpuEndinit(passwd);
80005436:	1d 00 cd 22 	j 800099d0 <IfxScuWdt_setCpuEndinit>

8000543a <IfxMultican_setListCommand>:

void IfxMultican_setListCommand(Ifx_CAN *mcan, uint32 cmd, uint32 arg2, uint32 arg1)
{
    Ifx_CAN_PANCTR panctr;

    panctr.B.PANAR1 = arg1;
8000543a:	82 0f       	mov %d15,0
8000543c:	37 6f 08 f8 	insert %d15,%d15,%d6,16,8
    panctr.B.PANAR2 = arg2;
80005440:	37 5f 08 fc 	insert %d15,%d15,%d5,24,8
    panctr.B.PANCMD = cmd;
80005444:	37 4f 08 f0 	insert %d15,%d15,%d4,0,8

    /** - write to CAN_PANCTR */
    mcan->PANCTR.U = panctr.U;
80005448:	59 4f 04 70 	st.w [%a4]452,%d15
8000544c:	19 4f 04 70 	ld.w %d15,[%a4]452
80005450:	6f 8f fe ff 	jnz.t %d15,8,8000544c <IfxMultican_setListCommand+0x12>

    IfxMultican_waitListReady(mcan);
}
80005454:	00 90       	ret 

80005456 <IfxMultican_getIndex>:

    result = IfxMultican_Index_none;

    for (index = 0; index < IFXMULTICAN_NUM_MODULES; index++)
    {
        if (IfxMultican_cfg_indexMap[index].module == multican)
80005456:	91 00 00 f8 	movh.a %a15,32768
8000545a:	d9 f2 30 d0 	lea %a2,[%a15]880 <80000370 <IfxMultican_cfg_indexMap>>
8000545e:	99 ff 30 d0 	ld.a %a15,[%a15]880 <80000370 <IfxMultican_cfg_indexMap>>
IfxMultican_Index IfxMultican_getIndex(Ifx_CAN *multican)
{
    uint32            index;
    IfxMultican_Index result;

    result = IfxMultican_Index_none;
80005462:	82 f2       	mov %d2,-1

    for (index = 0; index < IFXMULTICAN_NUM_MODULES; index++)
    {
        if (IfxMultican_cfg_indexMap[index].module == multican)
80005464:	7d 4f 03 00 	jeq.a %a15,%a4,8000546a <IfxMultican_getIndex+0x14>
            break;
        }
    }

    return result;
}
80005468:	00 90       	ret 

    for (index = 0; index < IFXMULTICAN_NUM_MODULES; index++)
    {
        if (IfxMultican_cfg_indexMap[index].module == multican)
        {
            result = (IfxMultican_Index)IfxMultican_cfg_indexMap[index].index;
8000546a:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
        }
    }

    return result;
}
8000546e:	00 90       	ret 

80005470 <IfxMultican_getAddress>:
    {
        module = (Ifx_CAN *)IfxMultican_cfg_indexMap[multican].module;
    }
    else
    {
        module = NULL_PTR;
80005470:	a0 02       	mov.a %a2,0

Ifx_CAN *IfxMultican_getAddress(IfxMultican_Index multican)
{
    Ifx_CAN *module;

    if (multican < IFXMULTICAN_NUM_MODULES)
80005472:	4e 48       	jgtz %d4,80005482 <IfxMultican_getAddress+0x12>
    {
        module = (Ifx_CAN *)IfxMultican_cfg_indexMap[multican].module;
80005474:	91 00 00 f8 	movh.a %a15,32768
80005478:	d9 ff 30 d0 	lea %a15,[%a15]880 <80000370 <IfxMultican_cfg_indexMap>>
8000547c:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80005480:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
80005482:	00 90       	ret 

80005484 <IfxMultican_Can_MsgObj_getConfig>:
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxMultican_Can_MsgObj_getConfig(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Can_MsgObjConfig *config)
{
    Ifx_CAN_MO    *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
80005484:	cc 40       	ld.a %a15,[%a4]0
80005486:	19 43 04 00 	ld.w %d3,[%a4]4
    config->control.extendedFrame       = ar.B.IDE;
    config->control.matchingId          = amr.B.MIDE;

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
    config->acceptanceMask              = amr.B.AM >> ((config->control.extendedFrame != 0) ? 0 : 18);
8000548a:	82 06       	mov %d6,0
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxMultican_Can_MsgObj_getConfig(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Can_MsgObjConfig *config)
{
    Ifx_CAN_MO    *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
8000548c:	4c f0       	ld.w %d15,[%a15]0

    Ifx_CAN_MO_AR  ar;
    Ifx_CAN_MO_AMR amr;
    Ifx_CAN_MO_FCR fcr;

    ar.U                                = hwObj->AR.U;
8000548e:	13 03 22 2f 	madd %d2,%d15,%d3,32
    amr.U                               = hwObj->AMR.U;
    fcr.U                               = hwObj->FCR.U;
80005492:	1b 03 08 30 	addi %d3,%d3,128
80005496:	13 03 22 4f 	madd %d4,%d15,%d3,32

    Ifx_CAN_MO_AR  ar;
    Ifx_CAN_MO_AMR amr;
    Ifx_CAN_MO_FCR fcr;

    ar.U                                = hwObj->AR.U;
8000549a:	60 2f       	mov.a %a15,%d2
    amr.U                               = hwObj->AMR.U;
    fcr.U                               = hwObj->FCR.U;
8000549c:	60 42       	mov.a %a2,%d4

    Ifx_CAN_MO_AR  ar;
    Ifx_CAN_MO_AMR amr;
    Ifx_CAN_MO_FCR fcr;

    ar.U                                = hwObj->AR.U;
8000549e:	19 f2 18 01 	ld.w %d2,[%a15]4120
    amr.U                               = hwObj->AMR.U;
800054a2:	19 f5 0c 01 	ld.w %d5,[%a15]4108
    fcr.U                               = hwObj->FCR.U;
800054a6:	54 23       	ld.w %d3,[%a2]

    config->frame                       = (hwObj->STAT.B.DIR != 0) ? IfxMultican_Frame_transmit : IfxMultican_Frame_receive;
800054a8:	19 ff 1c 01 	ld.w %d15,[%a15]4124
    config->control.messageLen          = (IfxMultican_DataLengthCode)fcr.B.DLC;
    config->control.extendedFrame       = ar.B.IDE;
    config->control.matchingId          = amr.B.MIDE;

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
800054ac:	8f 22 1e 40 	sh %d4,%d2,-30

    ar.U                                = hwObj->AR.U;
    amr.U                               = hwObj->AMR.U;
    fcr.U                               = hwObj->FCR.U;

    config->frame                       = (hwObj->STAT.B.DIR != 0) ? IfxMultican_Frame_transmit : IfxMultican_Frame_receive;
800054b0:	37 0f e1 f5 	extr.u %d15,%d15,11,1
800054b4:	e9 5f 1c 00 	st.b [%a5]28,%d15

    config->control.singleDataTransfer  = fcr.B.SDT;
800054b8:	0c 5c       	ld.bu %d15,[%a5]12
800054ba:	67 3f 00 fb 	ins.t %d15,%d15,0,%d3,22
800054be:	2c 5c       	st.b [%a5]12,%d15
    config->control.messageLen          = (IfxMultican_DataLengthCode)fcr.B.DLC;
800054c0:	37 03 64 fc 	extr.u %d15,%d3,24,4
800054c4:	2c 5d       	st.b [%a5]13,%d15
    config->control.extendedFrame       = ar.B.IDE;
800054c6:	0c 5e       	ld.bu %d15,[%a5]14
800054c8:	67 2f 80 fe 	ins.t %d15,%d15,0,%d2,29
    config->control.matchingId          = amr.B.MIDE;
800054cc:	67 5f 81 fe 	ins.t %d15,%d15,1,%d5,29
800054d0:	2c 5e       	st.b [%a5]14,%d15

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
800054d2:	19 57 0c 00 	ld.w %d7,[%a5]12
800054d6:	b7 02 83 fe 	insert %d15,%d2,0,29,3
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
    config->acceptanceMask              = amr.B.AM >> ((config->control.extendedFrame != 0) ? 0 : 18);
800054da:	37 05 7d 50 	extr.u %d5,%d5,0,29
    config->control.singleDataTransfer  = fcr.B.SDT;
    config->control.messageLen          = (IfxMultican_DataLengthCode)fcr.B.DLC;
    config->control.extendedFrame       = ar.B.IDE;
    config->control.matchingId          = amr.B.MIDE;

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
800054de:	ef 07 08 80 	jnz.t %d7,16,800054ee <IfxMultican_Can_MsgObj_getConfig+0x6a>
800054e2:	8f ef 3e f0 	sha %d15,%d15,-18
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
800054e6:	8f 22 1e 40 	sh %d4,%d2,-30
    config->acceptanceMask              = amr.B.AM >> ((config->control.extendedFrame != 0) ? 0 : 18);
800054ea:	3b 20 01 60 	mov %d6,18
800054ee:	6c 59       	st.w [%a5]36,%d15
800054f0:	8b 06 00 f1 	rsub %d15,%d6,0
800054f4:	0f f5 20 f0 	shas %d15,%d5,%d15
800054f8:	6c 58       	st.w [%a5]32,%d15
    config->control.singleTransmitTrial = fcr.B.STT;
800054fa:	0c 5c       	ld.bu %d15,[%a5]12
800054fc:	e9 54 28 00 	st.b [%a5]40,%d4
80005500:	67 3f 81 fb 	ins.t %d15,%d15,1,%d3,23
80005504:	2c 5c       	st.b [%a5]12,%d15
80005506:	00 90       	ret 

80005508 <IfxMultican_Can_MsgObj_init>:
}


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
    msgObj->node        = config->node;
80005508:	d4 52       	ld.a %a2,[%a5]
    msgObj->msgObjId    = config->msgObjId;
    msgObj->msgObjCount = config->msgObjCount;
    msgObj->fifoPointer = 0;
8000550a:	82 0f       	mov %d15,0


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
    msgObj->node        = config->node;
    msgObj->msgObjId    = config->msgObjId;
8000550c:	19 5b 04 00 	ld.w %d11,[%a5]4
    msgObj->msgObjCount = config->msgObjCount;
80005510:	b9 5c 08 00 	ld.hu %d12,[%a5]8
    msgObj->fifoPointer = 0;

    Ifx_CAN           *mcanSFR   = msgObj->node->mcan;
80005514:	d4 2c       	ld.a %a12,[%a2]
IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
    msgObj->node        = config->node;
    msgObj->msgObjId    = config->msgObjId;
    msgObj->msgObjCount = config->msgObjCount;
    msgObj->fifoPointer = 0;
80005516:	6c 43       	st.w [%a4]12,%d15

    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcanSFR, msgObj->msgObjId);

    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (config->control.messageLen > IfxMultican_DataLengthCode_8) ? TRUE : FALSE;
80005518:	0c 5d       	ld.bu %d15,[%a5]13
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
8000551a:	80 c2       	mov.d %d2,%a12
8000551c:	8b 9f a0 f2 	ge.u %d15,%d15,9
80005520:	60 fd       	mov.a %a13,%d15

    /* check for the receive frame */
    boolean            receiveFrame = (config->frame == IfxMultican_Frame_receive) ||
80005522:	39 5f 1c 00 	ld.bu %d15,[%a5]28
80005526:	1b 0b 08 a0 	addi %d10,%d11,128
8000552a:	13 0a 22 82 	madd %d8,%d2,%d10,32
                                      (config->frame == IfxMultican_Frame_remoteAnswer) ||
8000552e:	92 e2       	add %d2,%d15,-2
80005530:	8b 22 60 32 	lt.u %d3,%d2,2
80005534:	8b 0f e0 34 	or.eq %d3,%d15,0
    config->control.singleTransmitTrial = fcr.B.STT;
}


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
80005538:	20 18       	sub.a %sp,24
    msgObj->node        = config->node;
8000553a:	f4 42       	st.a [%a4],%a2
    msgObj->msgObjId    = config->msgObjId;
8000553c:	59 4b 04 00 	st.w [%a4]4,%d11
    msgObj->msgObjCount = config->msgObjCount;
80005540:	f9 4c 08 00 	st.h [%a4]8,%d12
80005544:	59 a3 04 00 	st.w [%sp]4,%d3
                                      (config->frame == IfxMultican_Frame_remoteAnswer) ||
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
80005548:	c2 ff       	add %d15,-1
    config->control.singleTransmitTrial = fcr.B.STT;
}


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
8000554a:	40 4e       	mov.aa %a14,%a4
8000554c:	40 5f       	mov.aa %a15,%a5
                                      (config->frame == IfxMultican_Frame_remoteAnswer) ||
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
8000554e:	bf 3f c6 82 	jlt.u %d15,3,80005ada <IfxMultican_Can_MsgObj_init+0x5d2>
80005552:	4c 5b       	ld.w %d15,[%a5]44
80005554:	7b 10 00 20 	movh %d2,1
80005558:	26 f2       	and %d2,%d15
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;

    if (config->msgObjId == config->firstSlaveObjId)
8000555a:	4c 5e       	ld.w %d15,[%a5]56
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;
8000555c:	8b 02 20 d2 	ne %d13,%d2,0

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
80005560:	0b fb 00 31 	eq %d3,%d11,%d15
80005564:	59 a3 14 00 	st.w [%sp]20,%d3
    if (config->msgObjId == config->firstSlaveObjId)
    {
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
80005568:	df 02 e6 02 	jeq %d2,0,80005b34 <IfxMultican_Can_MsgObj_init+0x62c>
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
8000556c:	82 03       	mov %d3,0
8000556e:	8b 2c a0 22 	ge.u %d2,%d12,2
80005572:	74 a3       	st.w [%sp],%d3
80005574:	59 a3 08 00 	st.w [%sp]8,%d3

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;
80005578:	82 0e       	mov %d14,0
8000557a:	59 a3 0c 00 	st.w [%sp]12,%d3
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
        transmitFifo = (config->msgObjCount > 1) && (transmitFrame);
    }

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);
8000557e:	26 d2       	and %d2,%d13
    uint32 i;

    /* for standard and FIFO (Tx & Rx) base objects */
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005580:	60 84       	mov.a %a4,%d8
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
        transmitFifo = (config->msgObjCount > 1) && (transmitFrame);
    }

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);
80005582:	59 a2 10 00 	st.w [%sp]16,%d2
    uint32 i;

    /* for standard and FIFO (Tx & Rx) base objects */
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005586:	82 54       	mov %d4,5
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;

    /* select the first slave object */
    if (!config->firstSlaveObjId)
    {                              // if not selected
        firstSlaveObjId = config->msgObjId + 1;
80005588:	1b 1b 00 20 	addi %d2,%d11,1
8000558c:	6a 2f       	cmovn %d15,%d15,%d2
    uint32 i;

    /* for standard and FIFO (Tx & Rx) base objects */
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
8000558e:	6d ff e3 f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RXPND */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
80005592:	60 84       	mov.a %a4,%d8
80005594:	82 04       	mov %d4,0
80005596:	6d ff df f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset TXPND */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitPending);
8000559a:	60 84       	mov.a %a4,%d8
8000559c:	82 14       	mov %d4,1
8000559e:	6d ff db f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RXUPD */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveUpdating);
800055a2:	60 84       	mov.a %a4,%d8
800055a4:	82 24       	mov %d4,2
800055a6:	6d ff d7 f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset NEWDAT */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);
800055aa:	60 84       	mov.a %a4,%d8
800055ac:	82 34       	mov %d4,3
800055ae:	6d ff d3 f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset MSGLST */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
800055b2:	60 84       	mov.a %a4,%d8
800055b4:	82 44       	mov %d4,4
800055b6:	6d ff cf f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RTSEL */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveTransmitSelected);
800055ba:	60 84       	mov.a %a4,%d8
800055bc:	82 64       	mov %d4,6
800055be:	6d ff cb f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RXPND */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
800055c2:	60 84       	mov.a %a4,%d8
800055c4:	3b 80 00 40 	mov %d4,8
800055c8:	6d ff c6 f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>
        /* Configuration of the CAN Message Object List Structure */
        /* Allocate MO for the node associated list */
        {
            /* for standard, gateway and FIFO (Tx & Rx) base objects  */
            /* Append message object to the end of the list */
            IfxMultican_setListCommand(mcanSFR, 0x2, msgObj->node->nodeId + 1, msgObj->msgObjId);
800055cc:	d4 e2       	ld.a %a2,[%a14]
800055ce:	40 c4       	mov.aa %a4,%a12
800055d0:	82 24       	mov %d4,2
800055d2:	79 25 08 00 	ld.b %d5,[%a2]8
800055d6:	19 e6 04 00 	ld.w %d6,[%a14]4
800055da:	c2 15       	add %d5,1
800055dc:	6d ff 2f ff 	call 8000543a <IfxMultican_setListCommand>

            /* long frame CAN FD */
            if (longFrame)
800055e0:	bd 0d 37 83 	jnz.a %a13,80005c4e <IfxMultican_Can_MsgObj_init+0x746>
            }

            /* for all standard FIFO (Tx and Rx) and gateway FIFO slave objects */
            if (config->msgObjCount > 1)
            {
                for (i = 0; i < config->msgObjCount; i++)
800055e4:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800055e8:	82 09       	mov %d9,0
800055ea:	bf 22 10 80 	jlt.u %d2,2,8000560a <IfxMultican_Can_MsgObj_init+0x102>
                {
                    objId = firstSlaveObjId + i;

                    IfxMultican_setListCommand(mcanSFR, 0x2, msgObj->node->nodeId + 1, objId);
800055ee:	d4 e2       	ld.a %a2,[%a14]
800055f0:	12 96       	add %d6,%d15,%d9
800055f2:	40 c4       	mov.aa %a4,%a12
800055f4:	79 25 08 00 	ld.b %d5,[%a2]8
800055f8:	82 24       	mov %d4,2
800055fa:	c2 15       	add %d5,1
800055fc:	6d ff 1f ff 	call 8000543a <IfxMultican_setListCommand>
            }

            /* for all standard FIFO (Tx and Rx) and gateway FIFO slave objects */
            if (config->msgObjCount > 1)
            {
                for (i = 0; i < config->msgObjCount; i++)
80005600:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005604:	c2 19       	add %d9,1
80005606:	3f 29 f4 ff 	jlt.u %d9,%d2,800055ee <IfxMultican_Can_MsgObj_init+0xe6>
                    IfxMultican_setListCommand(mcanSFR, 0x2, msgObj->node->nodeId + 1, objId);
                }
            }
        }

        if ((config->frame == IfxMultican_Frame_receive) || (config->frame == IfxMultican_Frame_remoteAnswer))
8000560a:	39 f2 1c 00 	ld.bu %d2,[%a15]28
8000560e:	8b 32 00 32 	eq %d3,%d2,3
80005612:	8b 02 e0 34 	or.eq %d3,%d2,0
80005616:	df 03 16 83 	jne %d3,0,80005c42 <IfxMultican_Can_MsgObj_init+0x73a>
            /*  set RXEN, in case of recieve frame or remote answer*/
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveEnable);
        }

        /*  in case of transmit frame */
        if ((transmitFrame) && (config->gatewayTransfers != 1))
8000561a:	19 a2 08 00 	ld.w %d2,[%sp]8
8000561e:	df 02 3a 02 	jeq %d2,0,80005a92 <IfxMultican_Can_MsgObj_init+0x58a>
80005622:	48 b2       	ld.w %d2,[%a15]44
80005624:	ef 02 25 02 	jz.t %d2,16,80005a6e <IfxMultican_Can_MsgObj_init+0x566>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
        }
        else
        {
            /*  clear DIR, in case of receive frame or gateway transfers*/
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
80005628:	60 84       	mov.a %a4,%d8
8000562a:	3b b0 00 40 	mov %d4,11
8000562e:	6d ff 93 f5 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>
        }
    }
    {
        /* for standard message object */
        if (config->msgObjCount == 1)
80005632:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005636:	df 12 40 02 	jeq %d2,1,80005ab6 <IfxMultican_Can_MsgObj_init+0x5ae>
                /* select standard object for FCR.MMC */
                IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_standard);
            }
        }
        /* for receive FIFO base object */
        else if (receiveFifo)
8000563a:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000563e:	df 03 69 02 	jeq %d3,0,80005b10 <IfxMultican_Can_MsgObj_init+0x608>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005642:	8f 5a 00 40 	sh %d4,%d10,5
80005646:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
8000564a:	82 04       	mov %d4,0
8000564c:	54 22       	ld.w %d2,[%a2]
8000564e:	b7 12 04 20 	insert %d2,%d2,1,0,4
80005652:	74 22       	st.w [%a2],%d2
        else
        {}

        /* for standard and FIFO (Tx & Rx) base objects  */
        /* enable receive interrupt FCR.RXIE if choosen in case of receive frame */
        boolean receiveInterruptEnabled = (config->rxInterrupt.enabled) && (receiveFrame);
80005654:	39 f2 2a 00 	ld.bu %d2,[%a15]42
}


IFX_INLINE void IfxMultican_MsgObj_setReceiveInterrupt(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.RXIE = enabled ? 1 : 0;
80005658:	19 a3 04 00 	ld.w %d3,[%sp]4
8000565c:	8f 5a 00 50 	sh %d5,%d10,5
80005660:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
80005664:	8b 02 20 22 	ne %d2,%d2,0
80005668:	26 32       	and %d2,%d3
8000566a:	8f 02 01 30 	sh %d3,%d2,16
8000566e:	54 22       	ld.w %d2,[%a2]
80005670:	b7 02 01 28 	insert %d2,%d2,0,16,1
80005674:	a6 32       	or %d2,%d3
80005676:	74 22       	st.w [%a2],%d2
        IfxMultican_MsgObj_setReceiveInterrupt(hwObj, receiveInterruptEnabled);

        /* enable transmit interrupt FCR.TXIE if choosen in case of transmit frame */
        boolean transmitInterruptEnabled = (config->txInterrupt.enabled) && (transmitFrame);
80005678:	39 f2 2c 00 	ld.bu %d2,[%a15]44
}


IFX_INLINE void IfxMultican_MsgObj_setTransmitInterrupt(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.TXIE = enabled ? 1 : 0;
8000567c:	54 a3       	ld.w %d3,[%sp]
8000567e:	8b 02 20 22 	ne %d2,%d2,0
80005682:	26 32       	and %d2,%d3
80005684:	8f 12 01 30 	sh %d3,%d2,17
80005688:	54 22       	ld.w %d2,[%a2]
8000568a:	b7 02 81 28 	insert %d2,%d2,0,17,1
8000568e:	a6 32       	or %d2,%d3
80005690:	74 22       	st.w [%a2],%d2
        IfxMultican_MsgObj_setTransmitInterrupt(hwObj, transmitInterruptEnabled);

        /* set FCR.RMM in case of remote answer */
        boolean remoteMonitoringEnabled = (config->frame == IfxMultican_Frame_remoteAnswer);
80005692:	39 f2 1c 00 	ld.bu %d2,[%a15]28
}


IFX_INLINE void IfxMultican_MsgObj_setRemoteMonitoring(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.RMM = enabled ? 1 : 0;
80005696:	8b 32 00 22 	eq %d2,%d2,3
8000569a:	8f 52 01 30 	sh %d3,%d2,21
8000569e:	54 22       	ld.w %d2,[%a2]
800056a0:	b7 02 81 2a 	insert %d2,%d2,0,21,1
800056a4:	a6 32       	or %d2,%d3
800056a6:	74 22       	st.w [%a2],%d2
        IfxMultican_MsgObj_setRemoteMonitoring(hwObj, remoteMonitoringEnabled);

        /* only in case of transmit frame; in receive frame case these bits will be set by the hardware */
        if (transmitFrame)
800056a8:	54 a2       	ld.w %d2,[%sp]
800056aa:	df 02 19 00 	jeq %d2,0,800056dc <IfxMultican_Can_MsgObj_init+0x1d4>
        {
            /* long frame CAN FD */
            /* FDEN = 1, EDL = 1 and BRS = 0/1 */
            /* in case of recieve Msg Obj, it recieves long and long+fast frames */
            if (config->node->fastNode && longFrame)
800056ae:	c8 03       	ld.a %a3,[%a15]0
800056b0:	80 d3       	mov.d %d3,%a13
800056b2:	39 32 09 00 	ld.bu %d2,[%a3]9
800056b6:	8b 02 20 22 	ne %d2,%d2,0
800056ba:	26 32       	and %d2,%d3
800056bc:	df 02 b2 02 	jeq %d2,0,80005c20 <IfxMultican_Can_MsgObj_init+0x718>
}


IFX_INLINE void IfxMultican_MsgObj_setExtendedDataLength(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.FDF = enabled ? 1 : 0;
800056c0:	54 22       	ld.w %d2,[%a2]
800056c2:	8f 02 44 21 	or %d2,%d2,64
800056c6:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
800056c8:	54 23       	ld.w %d3,[%a2]
800056ca:	08 d2       	ld.bu %d2,[%a15]13
800056cc:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800056d0:	74 22       	st.w [%a2],%d2

                /* set data length code FCR.DLC */
                IfxMultican_MsgObj_setDataLengthCode(hwObj, config->control.messageLen);

                /* set bit rate switch (fast bit rate enable/disable) */
                IfxMultican_MsgObj_setBitRateSwitch(hwObj, config->control.fastBitRate);
800056d2:	48 63       	ld.w %d3,[%a15]24
}


IFX_INLINE void IfxMultican_MsgObj_setBitRateSwitch(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.BRS = enabled ? 1 : 0;
800056d4:	54 22       	ld.w %d2,[%a2]
800056d6:	67 32 05 20 	ins.t %d2,%d2,5,%d3,0
800056da:	74 22       	st.w [%a2],%d2
                IfxMultican_MsgObj_setDataLengthCode(hwObj, config->control.messageLen);
            }
        }

        /* only for standard message object */
        if ((config->msgObjCount == 1) && (!gatewaySourceObj))
800056dc:	b9 f3 08 00 	ld.hu %d3,[%a15]8
800056e0:	07 dd 00 20 	nand.t %d2,%d13,0,%d13,0
800056e4:	8b 13 00 24 	and.eq %d2,%d3,1
800056e8:	df 02 63 02 	jeq %d2,0,80005bae <IfxMultican_Can_MsgObj_init+0x6a6>
        {
            /* set single transmit trial FCR.STT if choosen */
            IfxMultican_MsgObj_setSingleTransmitTrial(hwObj, config->control.singleTransmitTrial);
800056ec:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setSingleTransmitTrial(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.STT = enabled ? 1 : 0;
800056ee:	8f 5a 00 50 	sh %d5,%d10,5
800056f2:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
800056f6:	37 02 e1 20 	extr.u %d2,%d2,1,1
800056fa:	8f 72 01 30 	sh %d3,%d2,23
800056fe:	54 22       	ld.w %d2,[%a2]
80005700:	b7 02 81 2b 	insert %d2,%d2,0,23,1
80005704:	a6 32       	or %d2,%d3
80005706:	74 22       	st.w [%a2],%d2

            /* set single data transfer FCR.SDT if choosen */
            IfxMultican_MsgObj_setSingleDataTransfer(hwObj, config->control.singleDataTransfer);
80005708:	48 33       	ld.w %d3,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setSingleDataTransfer(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.SDT = enabled ? 1 : 0;
8000570a:	54 22       	ld.w %d2,[%a2]
8000570c:	67 32 16 20 	ins.t %d2,%d2,22,%d3,0
80005710:	74 22       	st.w [%a2],%d2
        }
    }

    {
        /* for standard message object */
        if (config->msgObjCount == 1)
80005712:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005716:	df 12 5c 02 	jeq %d2,1,80005bce <IfxMultican_Can_MsgObj_init+0x6c6>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
8000571a:	06 5b       	sh %d11,5
8000571c:	01 cb 00 26 	addsc.a %a2,%a12,%d11,0
80005720:	59 ab 04 00 	st.w [%sp]4,%d11
80005724:	19 23 04 01 	ld.w %d3,[%a2]4100
80005728:	8f ff 0f 21 	and %d2,%d15,255
8000572c:	8f f3 cf 31 	andn %d3,%d3,255
80005730:	a6 23       	or %d3,%d2
80005732:	59 23 04 01 	st.w [%a2]4100,%d3
        {
            /* set bottom pointer FGPR.BOT, to the next message object (first FIFO slave object) */
            IfxMultican_MsgObj_setBottomObjectPointer(hwObj, firstSlaveObjId);

            /* store the first slave object Id as the fifoPointer in msgObj structure for FIFO transfers */
            msgObj->fifoPointer = firstSlaveObjId;
80005736:	6c e3       	st.w [%a14]12,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80005738:	19 23 04 01 	ld.w %d3,[%a2]4100
    {
        firstSlaveObjId = config->firstSlaveObjId;
    }

    /* select the last slave object */
    lastSlaveObjId = firstSlaveObjId + (config->msgObjCount - 1);
8000573c:	c2 fc       	add %d12,-1
8000573e:	42 fc       	add %d12,%d15
80005740:	37 c3 08 34 	insert %d3,%d3,%d12,8,8
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
80005744:	8f 02 01 20 	sh %d2,%d2,16
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80005748:	59 23 04 01 	st.w [%a2]4100,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
8000574c:	19 23 04 01 	ld.w %d3,[%a2]4100
80005750:	b7 03 08 38 	insert %d3,%d3,0,16,8
80005754:	a6 32       	or %d2,%d3
80005756:	59 22 04 01 	st.w [%a2]4100,%d2
            /* set start of FIFO (current pointer) FGPR.CUR, to first FIFO slave object (bottom pointer) */
            IfxMultican_MsgObj_setCurrentObjectPointer(hwObj, firstSlaveObjId);

            bottomEqualsCurrent = TRUE; /*S/w Flag*/

            if (receiveFifo || transmitFifo)
8000575a:	19 a2 0c 00 	ld.w %d2,[%sp]12
            IfxMultican_MsgObj_setTopObjectPointer(hwObj, lastSlaveObjId);

            /* set start of FIFO (current pointer) FGPR.CUR, to first FIFO slave object (bottom pointer) */
            IfxMultican_MsgObj_setCurrentObjectPointer(hwObj, firstSlaveObjId);

            bottomEqualsCurrent = TRUE; /*S/w Flag*/
8000575e:	82 13       	mov %d3,1

            if (receiveFifo || transmitFifo)
80005760:	a6 e2       	or %d2,%d14
80005762:	8f f2 0f 21 	and %d2,%d2,255
            IfxMultican_MsgObj_setTopObjectPointer(hwObj, lastSlaveObjId);

            /* set start of FIFO (current pointer) FGPR.CUR, to first FIFO slave object (bottom pointer) */
            IfxMultican_MsgObj_setCurrentObjectPointer(hwObj, firstSlaveObjId);

            bottomEqualsCurrent = TRUE; /*S/w Flag*/
80005766:	59 a3 08 00 	st.w [%sp]8,%d3

            if (receiveFifo || transmitFifo)
8000576a:	76 28       	jz %d2,8000577a <IfxMultican_Can_MsgObj_init+0x272>
}


IFX_INLINE void IfxMultican_MsgObj_setSelectObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.SEL = objNumber;
8000576c:	19 22 04 01 	ld.w %d2,[%a2]4100
            {
                /* set select object pointer FGPR.SEL to one object before last FIFO slave object */
                IfxMultican_MsgObj_setSelectObjectPointer(hwObj, lastSlaveObjId - 1);
80005770:	c2 fc       	add %d12,-1
80005772:	37 c2 08 cc 	insert %d12,%d2,%d12,24,8
80005776:	59 2c 04 01 	st.w [%a2]4100,%d12
    }

    {
        /* for standard, gateway and FIFO (Tx & Rx) base objects  */
        /* set the given acceptance mask */
        IfxMultican_MsgObj_setAcceptanceMask(hwObj, config->acceptanceMask, config->control.extendedFrame);
8000577a:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setAcceptanceMask(Ifx_CAN_MO *hwObj, uint32 mask, boolean extendedFrame)
{
    hwObj->AMR.B.AM = mask << ((extendedFrame != 0) ? 0 : 18);
8000577c:	19 a5 04 00 	ld.w %d5,[%sp]4
80005780:	48 84       	ld.w %d4,[%a15]32
80005782:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
80005786:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
8000578a:	ab 22 a1 22 	seln %d2,%d2,%d2,18
8000578e:	0f 24 00 20 	sh %d2,%d4,%d2
80005792:	19 24 0c 01 	ld.w %d4,[%a2]4108
80005796:	82 03       	mov %d3,0
80005798:	37 24 1d 20 	insert %d2,%d4,%d2,0,29
8000579c:	59 22 0c 01 	st.w [%a2]4108,%d2

        /* enable matching ID if choosen */
        IfxMultican_MsgObj_setMatchingId(hwObj, config->control.matchingId);
800057a0:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setMatchingId(Ifx_CAN_MO *hwObj, boolean matchingId)
{
    hwObj->AMR.B.MIDE = matchingId;
800057a2:	37 02 e1 28 	extr.u %d2,%d2,17,1
800057a6:	8f d2 01 40 	sh %d4,%d2,29
800057aa:	19 22 0c 01 	ld.w %d2,[%a2]4108
800057ae:	b7 02 81 2e 	insert %d2,%d2,0,29,1
800057b2:	a6 42       	or %d2,%d4
800057b4:	59 22 0c 01 	st.w [%a2]4108,%d2
    }

    {
        /* for standard, gateway  and FIFO (Tx & Rx) base objects  */
        /* set message ID */
        IfxMultican_MsgObj_setMessageId(hwObj, config->messageId, config->control.extendedFrame);
800057b8:	48 32       	ld.w %d2,[%a15]12
800057ba:	48 94       	ld.w %d4,[%a15]36
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
800057bc:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
800057c0:	ab 22 a1 22 	seln %d2,%d2,%d2,18
800057c4:	0f 24 00 20 	sh %d2,%d4,%d2
800057c8:	19 24 18 01 	ld.w %d4,[%a2]4120
800057cc:	37 24 1d 20 	insert %d2,%d4,%d2,0,29
800057d0:	59 22 18 01 	st.w [%a2]4120,%d2

        /* set identifier extension if extended frame is choosen */
        IfxMultican_MsgObj_setIdentifierExtension(hwObj, config->control.extendedFrame);
800057d4:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setIdentifierExtension(Ifx_CAN_MO *hwObj, boolean extension)
{
    hwObj->AR.B.IDE = extension;
800057d6:	37 02 61 28 	extr.u %d2,%d2,16,1
800057da:	8f d2 01 40 	sh %d4,%d2,29
800057de:	19 22 18 01 	ld.w %d2,[%a2]4120
800057e2:	b7 02 81 2e 	insert %d2,%d2,0,29,1
800057e6:	a6 42       	or %d2,%d4
800057e8:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setPriorityClass(Ifx_CAN_MO *hwObj, IfxMultican_Priority priority)
{
    hwObj->AR.B.PRI = priority;
800057ec:	19 24 18 01 	ld.w %d4,[%a2]4120
800057f0:	39 f2 28 00 	ld.bu %d2,[%a15]40
800057f4:	37 24 02 2f 	insert %d2,%d4,%d2,30,2
800057f8:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
800057fc:	59 23 10 01 	st.w [%a2]4112,%d3
    hwObj->DATAH.U = 0;
80005800:	59 23 14 01 	st.w [%a2]4116,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setReceiveInterruptNodePointer(Ifx_CAN_MO *hwObj, IfxMultican_SrcId srcId)
{
    hwObj->IPR.B.RXINP = srcId;
80005804:	19 23 08 01 	ld.w %d3,[%a2]4104
80005808:	39 f2 2b 00 	ld.bu %d2,[%a15]43
8000580c:	37 23 04 20 	insert %d2,%d3,%d2,0,4
80005810:	59 22 08 01 	st.w [%a2]4104,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setTransmitInterruptNodePointer(Ifx_CAN_MO *hwObj, IfxMultican_SrcId srcId)
{
    hwObj->IPR.B.TXINP = srcId;
80005814:	19 23 08 01 	ld.w %d3,[%a2]4104
80005818:	39 f2 2d 00 	ld.bu %d2,[%a15]45
8000581c:	37 23 04 22 	insert %d2,%d3,%d2,4,4
80005820:	59 22 08 01 	st.w [%a2]4104,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessagePendingNumber(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjId messageNumber)
{
    hwObj->IPR.B.MPN = messageNumber;
80005824:	39 e2 04 00 	ld.bu %d2,[%a14]4
80005828:	8f 82 00 30 	sh %d3,%d2,8
8000582c:	19 22 08 01 	ld.w %d2,[%a2]4104
80005830:	b7 02 08 24 	insert %d2,%d2,0,8,8
80005834:	a6 32       	or %d2,%d3
80005836:	59 22 08 01 	st.w [%a2]4104,%d2
        /* set IPR.MNP */
        IfxMultican_MsgObj_setMessagePendingNumber(hwObj, msgObj->msgObjId);
    }

    /* for each receive FIFO slave object */
    if (receiveFifo)
8000583a:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000583e:	df 02 25 00 	jeq %d2,0,80005888 <IfxMultican_Can_MsgObj_init+0x380>
    {
        for (i = 0; i < config->msgObjCount; i++)
80005842:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005846:	df 02 b0 00 	jeq %d2,0,800059a6 <IfxMultican_Can_MsgObj_init+0x49e>
8000584a:	82 09       	mov %d9,0
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
8000584c:	82 0b       	mov %d11,0
8000584e:	12 9c       	add %d12,%d15,%d9
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80005850:	1b 0c 08 20 	addi %d2,%d12,128
80005854:	8f 52 00 30 	sh %d3,%d2,5
80005858:	01 c3 00 d6 	addsc.a %a13,%a12,%d3,0
            objId = firstSlaveObjId + i; /* increment the message object ID */

            Ifx_CAN_MO *hwSlaveObj = IfxMultican_MsgObj_getPointer(mcanSFR, objId);

            /* clear all RXEN flag */
            IfxMultican_MsgObj_clearStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_receiveEnable);
8000585c:	82 74       	mov %d4,7
8000585e:	40 d4       	mov.aa %a4,%a13
80005860:	6d ff 7a f4 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80005864:	08 d2       	ld.bu %d2,[%a15]13
80005866:	54 d3       	ld.w %d3,[%a13]
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80005868:	8f 5c 00 40 	sh %d4,%d12,5
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
8000586c:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80005870:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80005874:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80005876:	59 2b 10 01 	st.w [%a2]4112,%d11
    hwObj->DATAH.U = 0;
8000587a:	59 2b 14 01 	st.w [%a2]4116,%d11
    }

    /* for each receive FIFO slave object */
    if (receiveFifo)
    {
        for (i = 0; i < config->msgObjCount; i++)
8000587e:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005882:	c2 19       	add %d9,1
80005884:	3f 29 e5 ff 	jlt.u %d9,%d2,8000584e <IfxMultican_Can_MsgObj_init+0x346>
            IfxMultican_MsgObj_clearDataRegisters(hwSlaveObj);
        }
    }

    /* for each transmit FIFO slave object */
    if (transmitFifo)
80005888:	df 0e 8f 00 	jeq %d14,0,800059a6 <IfxMultican_Can_MsgObj_init+0x49e>
    {
        /* configure each transmit FIFO slave object as an independent transmit object */
        for (i = 0; i < config->msgObjCount; i++)
8000588c:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005890:	df 02 8b 00 	jeq %d2,0,800059a6 <IfxMultican_Can_MsgObj_init+0x49e>
80005894:	02 f9       	mov %d9,%d15
80005896:	82 0b       	mov %d11,0
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80005898:	82 0c       	mov %d12,0
8000589a:	3c 07       	j 800058a8 <IfxMultican_Can_MsgObj_init+0x3a0>
8000589c:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800058a0:	c2 1b       	add %d11,1
800058a2:	c2 19       	add %d9,1
800058a4:	7f 2b 81 80 	jge.u %d11,%d2,800059a6 <IfxMultican_Can_MsgObj_init+0x49e>
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
800058a8:	1b 09 08 20 	addi %d2,%d9,128
800058ac:	8f 52 00 50 	sh %d5,%d2,5
800058b0:	01 c5 00 d6 	addsc.a %a13,%a12,%d5,0

            /* set filtering priority */
            IfxMultican_MsgObj_setPriorityClass(hwSlaveObj, config->priority);

            /*  set TXEN0  */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
800058b4:	3b 90 00 40 	mov %d4,9
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
800058b8:	54 d2       	ld.w %d2,[%a13]
800058ba:	40 d4       	mov.aa %a4,%a13
800058bc:	b7 32 04 20 	insert %d2,%d2,3,0,4
800058c0:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
800058c2:	39 e2 04 00 	ld.bu %d2,[%a14]4
800058c6:	8f 02 01 30 	sh %d3,%d2,16
800058ca:	8f 59 00 20 	sh %d2,%d9,5
800058ce:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800058d2:	19 22 04 01 	ld.w %d2,[%a2]4100
800058d6:	b7 02 08 28 	insert %d2,%d2,0,16,8
800058da:	a6 32       	or %d2,%d3
800058dc:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
800058e0:	54 d3       	ld.w %d3,[%a13]
800058e2:	08 d2       	ld.bu %d2,[%a15]13
800058e4:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800058e8:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
800058ea:	59 2c 10 01 	st.w [%a2]4112,%d12
    hwObj->DATAH.U = 0;
800058ee:	59 2c 14 01 	st.w [%a2]4116,%d12

            /* clear DATAL and DATAH registers */
            IfxMultican_MsgObj_clearDataRegisters(hwSlaveObj);

            /* set the given acceptance mask */
            IfxMultican_MsgObj_setAcceptanceMask(hwSlaveObj, config->acceptanceMask, config->control.extendedFrame);
800058f2:	48 32       	ld.w %d2,[%a15]12
800058f4:	48 83       	ld.w %d3,[%a15]32
}


IFX_INLINE void IfxMultican_MsgObj_setAcceptanceMask(Ifx_CAN_MO *hwObj, uint32 mask, boolean extendedFrame)
{
    hwObj->AMR.B.AM = mask << ((extendedFrame != 0) ? 0 : 18);
800058f6:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
800058fa:	ab 22 a1 22 	seln %d2,%d2,%d2,18
800058fe:	0f 23 00 20 	sh %d2,%d3,%d2
80005902:	19 23 0c 01 	ld.w %d3,[%a2]4108
80005906:	37 23 1d 20 	insert %d2,%d3,%d2,0,29
8000590a:	59 22 0c 01 	st.w [%a2]4108,%d2

            /* enable matching ID if choosen */
            IfxMultican_MsgObj_setMatchingId(hwSlaveObj, config->control.matchingId);
8000590e:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setMatchingId(Ifx_CAN_MO *hwObj, boolean matchingId)
{
    hwObj->AMR.B.MIDE = matchingId;
80005910:	37 02 e1 28 	extr.u %d2,%d2,17,1
80005914:	8f d2 01 30 	sh %d3,%d2,29
80005918:	19 22 0c 01 	ld.w %d2,[%a2]4108
8000591c:	b7 02 81 2e 	insert %d2,%d2,0,29,1
80005920:	a6 32       	or %d2,%d3
80005922:	59 22 0c 01 	st.w [%a2]4108,%d2

            /* set message ID */
            IfxMultican_MsgObj_setMessageId(hwSlaveObj, config->messageId, config->control.extendedFrame);
80005926:	48 32       	ld.w %d2,[%a15]12
80005928:	48 93       	ld.w %d3,[%a15]36
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
8000592a:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
8000592e:	ab 22 a1 22 	seln %d2,%d2,%d2,18
80005932:	0f 23 00 20 	sh %d2,%d3,%d2
80005936:	19 23 18 01 	ld.w %d3,[%a2]4120
8000593a:	37 23 1d 20 	insert %d2,%d3,%d2,0,29
8000593e:	59 22 18 01 	st.w [%a2]4120,%d2

            /* set identifier extension if extended frame is choosen */
            IfxMultican_MsgObj_setIdentifierExtension(hwSlaveObj, config->control.extendedFrame);
80005942:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setIdentifierExtension(Ifx_CAN_MO *hwObj, boolean extension)
{
    hwObj->AR.B.IDE = extension;
80005944:	37 02 61 28 	extr.u %d2,%d2,16,1
80005948:	8f d2 01 30 	sh %d3,%d2,29
8000594c:	19 22 18 01 	ld.w %d2,[%a2]4120
80005950:	b7 02 81 2e 	insert %d2,%d2,0,29,1
80005954:	a6 32       	or %d2,%d3
80005956:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setPriorityClass(Ifx_CAN_MO *hwObj, IfxMultican_Priority priority)
{
    hwObj->AR.B.PRI = priority;
8000595a:	19 23 18 01 	ld.w %d3,[%a2]4120
8000595e:	39 f2 28 00 	ld.bu %d2,[%a15]40
80005962:	37 23 02 2f 	insert %d2,%d3,%d2,30,2
80005966:	59 22 18 01 	st.w [%a2]4120,%d2

            /* set filtering priority */
            IfxMultican_MsgObj_setPriorityClass(hwSlaveObj, config->priority);

            /*  set TXEN0  */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
8000596a:	6d ff 1f f6 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

            /* MSGVAL: Set message as valid */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
8000596e:	40 d4       	mov.aa %a4,%a13
80005970:	82 54       	mov %d4,5
80005972:	6d ff 1b f6 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

            /* clear all TXEN1 flags expect for the slave object in the FGPR.CUR of the base FIFO object */
            if (objId == firstSlaveObjId)
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80005976:	40 d4       	mov.aa %a4,%a13
80005978:	3b a0 00 40 	mov %d4,10

            /* MSGVAL: Set message as valid */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);

            /* clear all TXEN1 flags expect for the slave object in the FGPR.CUR of the base FIFO object */
            if (objId == firstSlaveObjId)
8000597c:	5f 9f f8 00 	jeq %d15,%d9,80005b6c <IfxMultican_Can_MsgObj_init+0x664>
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
            }
            else
            {
                IfxMultican_MsgObj_clearStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80005980:	6d ff ea f3 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>
            }

            /*  set DIR, in case of transmit frame or remote answer*/
            if ((config->frame == IfxMultican_Frame_transmit) || (config->frame == IfxMultican_Frame_remoteAnswer))
80005984:	39 f2 1c 00 	ld.bu %d2,[%a15]28
80005988:	8f d2 0f 21 	and %d2,%d2,253
8000598c:	df 12 88 ff 	jne %d2,1,8000589c <IfxMultican_Can_MsgObj_init+0x394>
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageDirection);
80005990:	40 d4       	mov.aa %a4,%a13
80005992:	3b b0 00 40 	mov %d4,11
80005996:	6d ff 09 f6 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

    /* for each transmit FIFO slave object */
    if (transmitFifo)
    {
        /* configure each transmit FIFO slave object as an independent transmit object */
        for (i = 0; i < config->msgObjCount; i++)
8000599a:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000599e:	c2 1b       	add %d11,1
800059a0:	c2 19       	add %d9,1
800059a2:	3f 2b 83 ff 	jlt.u %d11,%d2,800058a8 <IfxMultican_Can_MsgObj_init+0x3a0>
            }
        }
    }

    /* for standard and receive FIFO base objects */
    if (config->frame == IfxMultican_Frame_receive)
800059a6:	39 f2 1c 00 	ld.bu %d2,[%a15]28
800059aa:	df 02 42 01 	jeq %d2,0,80005c2e <IfxMultican_Can_MsgObj_init+0x726>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
800059ae:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800059b2:	bf 22 33 80 	jlt.u %d2,2,80005a18 <IfxMultican_Can_MsgObj_init+0x510>
800059b6:	df 0e 90 01 	jeq %d14,0,80005cd6 <IfxMultican_Can_MsgObj_init+0x7ce>
800059ba:	19 a3 10 00 	ld.w %d3,[%sp]16
800059be:	df 03 2d 80 	jne %d3,0,80005a18 <IfxMultican_Can_MsgObj_init+0x510>
800059c2:	19 a3 14 00 	ld.w %d3,[%sp]20
800059c6:	df 03 d7 00 	jeq %d3,0,80005b74 <IfxMultican_Can_MsgObj_init+0x66c>
800059ca:	19 a3 08 00 	ld.w %d3,[%sp]8
800059ce:	df 03 16 82 	jne %d3,0,80005dfa <IfxMultican_Can_MsgObj_init+0x8f2>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
800059d2:	8f 5a 00 40 	sh %d4,%d10,5
800059d6:	01 c4 00 36 	addsc.a %a3,%a12,%d4,0
800059da:	12 34       	add %d4,%d15,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
800059dc:	8f 54 00 50 	sh %d5,%d4,5
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
800059e0:	c2 f2       	add %d2,-1
800059e2:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
800059e6:	1b 14 00 60 	addi %d6,%d4,1
800059ea:	0b 23 00 21 	eq %d2,%d3,%d2
800059ee:	2b 6f 40 22 	sel %d2,%d2,%d15,%d6
800059f2:	8f f2 0f 51 	and %d5,%d2,255
800059f6:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
800059fa:	c2 13       	add %d3,1
800059fc:	8f f2 cf 41 	andn %d4,%d2,255
80005a00:	0f 54 a0 20 	or %d2,%d4,%d5
80005a04:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005a08:	54 32       	ld.w %d2,[%a3]
80005a0a:	b7 22 04 20 	insert %d2,%d2,2,0,4
80005a0e:	74 32       	st.w [%a3],%d2
80005a10:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005a14:	3f 23 e3 ff 	jlt.u %d3,%d2,800059da <IfxMultican_Can_MsgObj_init+0x4d2>
                }
            }
        }
    }

    if (gatewaySourceObj)
80005a18:	df 0d 29 00 	jeq %d13,0,80005a6a <IfxMultican_Can_MsgObj_init+0x562>
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCodeCopy(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.DLCC = enabled ? 1 : 0;
80005a1c:	8f 5a 00 50 	sh %d5,%d10,5
80005a20:	01 c5 00 c6 	addsc.a %a12,%a12,%d5,0
    {
        /* set FCR.DLCC if chosen*/
        IfxMultican_MsgObj_setDataLengthCodeCopy(hwObj, config->gatewayConfig.copyDataLengthCode);
80005a24:	48 c2       	ld.w %d2,[%a15]48
80005a26:	4c c0       	ld.w %d15,[%a12]0
80005a28:	67 2f 0a f0 	ins.t %d15,%d15,10,%d2,0
80005a2c:	6c c0       	st.w [%a12]0,%d15

        /* set FCR.DATC if chosen*/
        IfxMultican_MsgObj_setDataCopy(hwObj, config->gatewayConfig.copyData);
80005a2e:	4c fc       	ld.w %d15,[%a15]48
}


IFX_INLINE void IfxMultican_MsgObj_setDataCopy(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.DATC = enabled ? 1 : 0;
80005a30:	37 0f e1 f0 	extr.u %d15,%d15,1,1
80005a34:	8f bf 00 20 	sh %d2,%d15,11
80005a38:	4c c0       	ld.w %d15,[%a12]0
80005a3a:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80005a3e:	a6 2f       	or %d15,%d2
80005a40:	6c c0       	st.w [%a12]0,%d15

        /* set FCR.IDC if chosen*/
        IfxMultican_MsgObj_setIdentifierCopy(hwObj, config->gatewayConfig.copyId);
80005a42:	4c fc       	ld.w %d15,[%a15]48
}


IFX_INLINE void IfxMultican_MsgObj_setIdentifierCopy(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.IDC = enabled ? 1 : 0;
80005a44:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80005a48:	8f 9f 00 20 	sh %d2,%d15,9
80005a4c:	4c c0       	ld.w %d15,[%a12]0
80005a4e:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80005a52:	a6 2f       	or %d15,%d2
80005a54:	6c c0       	st.w [%a12]0,%d15

        /* set FCR.GDFS if chosen*/
        IfxMultican_MsgObj_setGatewayDataFrameSend(hwObj, config->gatewayConfig.enableTransmit);
80005a56:	4c fc       	ld.w %d15,[%a15]48
}


IFX_INLINE void IfxMultican_MsgObj_setGatewayDataFrameSend(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.GDFS = enabled ? 1 : 0;
80005a58:	37 0f e1 f1 	extr.u %d15,%d15,3,1
80005a5c:	8f 8f 00 20 	sh %d2,%d15,8
80005a60:	4c c0       	ld.w %d15,[%a12]0
80005a62:	8f 0f d0 f1 	andn %d15,%d15,256
80005a66:	a6 2f       	or %d15,%d2
80005a68:	6c c0       	st.w [%a12]0,%d15
    }

    return status;
}
80005a6a:	82 02       	mov %d2,0
80005a6c:	00 90       	ret 

        /*  in case of transmit frame */
        if ((transmitFrame) && (config->gatewayTransfers != 1))
        {
            /*  set TXEN0  */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
80005a6e:	60 84       	mov.a %a4,%d8
80005a70:	3b 90 00 40 	mov %d4,9
80005a74:	6d ff 9a f5 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

            /*  set TXEN1  */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80005a78:	60 84       	mov.a %a4,%d8
80005a7a:	3b a0 00 40 	mov %d4,10
80005a7e:	6d ff 95 f5 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

            /*  reset RTSEL */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveTransmitSelected);
80005a82:	60 84       	mov.a %a4,%d8
80005a84:	82 64       	mov %d4,6
80005a86:	6d ff 91 f5 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

            /* MSGVAL: Set message as valid */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005a8a:	60 84       	mov.a %a4,%d8
80005a8c:	82 54       	mov %d4,5
80005a8e:	6d ff 8d f5 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
        }

        if (((config->frame == IfxMultican_Frame_transmit) || (config->frame == IfxMultican_Frame_remoteAnswer)) && (config->gatewayTransfers != 1))
80005a92:	39 f2 1c 00 	ld.bu %d2,[%a15]28
80005a96:	8f d2 0f 21 	and %d2,%d2,253
80005a9a:	df 12 c7 fd 	jne %d2,1,80005628 <IfxMultican_Can_MsgObj_init+0x120>
80005a9e:	48 b2       	ld.w %d2,[%a15]44
80005aa0:	ef 02 c4 fd 	jnz.t %d2,16,80005628 <IfxMultican_Can_MsgObj_init+0x120>
        {
            /*  set DIR, in case of transmit frame or remote answer*/
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
80005aa4:	60 84       	mov.a %a4,%d8
80005aa6:	3b b0 00 40 	mov %d4,11
80005aaa:	6d ff 7f f5 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
        }
    }
    {
        /* for standard message object */
        if (config->msgObjCount == 1)
80005aae:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005ab2:	df 12 c4 fd 	jne %d2,1,8000563a <IfxMultican_Can_MsgObj_init+0x132>
        {
            /* gateway transfers */
            if (gatewaySourceObj)
80005ab6:	df 0d fc 00 	jeq %d13,0,80005cae <IfxMultican_Can_MsgObj_init+0x7a6>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005aba:	8f 5a 00 30 	sh %d3,%d10,5
80005abe:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80005ac2:	54 22       	ld.w %d2,[%a2]
80005ac4:	b7 42 04 20 	insert %d2,%d2,4,0,4
80005ac8:	74 22       	st.w [%a2],%d2
            {
                /* select Gateway Source mode for FCR.MMC */
                IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_gatewaySource);

                /* select the gateway destination object as the next object if not selected */
                if (!config->gatewayConfig.gatewayDstObjId)
80005aca:	48 d4       	ld.w %d4,[%a15]52
80005acc:	df 04 c4 fd 	jne %d4,0,80005654 <IfxMultican_Can_MsgObj_init+0x14c>
                {
                    gatewayDstObjId = msgObj->msgObjId + 1;
80005ad0:	19 e4 04 00 	ld.w %d4,[%a14]4
80005ad4:	c2 14       	add %d4,1
80005ad6:	1d ff bf fd 	j 80005654 <IfxMultican_Can_MsgObj_init+0x14c>

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);
80005ada:	4c 5b       	ld.w %d15,[%a5]44
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
80005adc:	ef 0f 40 80 	jnz.t %d15,16,80005b5c <IfxMultican_Can_MsgObj_init+0x654>
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;

    if (config->msgObjId == config->firstSlaveObjId)
80005ae0:	4c 5e       	ld.w %d15,[%a5]56
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
80005ae2:	82 13       	mov %d3,1
80005ae4:	0b fb 00 21 	eq %d2,%d11,%d15
80005ae8:	59 a2 14 00 	st.w [%sp]20,%d2
80005aec:	74 a3       	st.w [%sp],%d3
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
80005aee:	82 12       	mov %d2,1
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
80005af0:	19 a3 04 00 	ld.w %d3,[%sp]4
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
80005af4:	59 a2 08 00 	st.w [%sp]8,%d2
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
80005af8:	8b 2c a0 22 	ge.u %d2,%d12,2
80005afc:	26 23       	and %d3,%d2
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;
80005afe:	82 0d       	mov %d13,0
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
80005b00:	df 03 26 00 	jeq %d3,0,80005b4c <IfxMultican_Can_MsgObj_init+0x644>
80005b04:	82 13       	mov %d3,1
80005b06:	59 a3 0c 00 	st.w [%sp]12,%d3
80005b0a:	54 ae       	ld.w %d14,[%sp]
80005b0c:	1d ff 39 fd 	j 8000557e <IfxMultican_Can_MsgObj_init+0x76>
        {
            /* select receive FIFO base object for FCR.MMC */
            IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_receiveFifoBase);
        }
        /* for transmit FIFO base object */
        else if (transmitFifo)
80005b10:	df 0e ab 80 	jne %d14,0,80005c66 <IfxMultican_Can_MsgObj_init+0x75e>
        {
            /* select transmit FIFO base object for FCR.MMC */
            IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_transmitFifoBase);
        }
        /* for gateway FIFO source object */
        else if (gatewayFifo)
80005b14:	19 a2 10 00 	ld.w %d2,[%sp]16

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80005b18:	82 04       	mov %d4,0
        {
            /* select transmit FIFO base object for FCR.MMC */
            IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_transmitFifoBase);
        }
        /* for gateway FIFO source object */
        else if (gatewayFifo)
80005b1a:	df 02 9d 7d 	jeq %d2,0,80005654 <IfxMultican_Can_MsgObj_init+0x14c>
80005b1e:	8f 5a 00 30 	sh %d3,%d10,5
80005b22:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80005b26:	02 e4       	mov %d4,%d14
80005b28:	54 22       	ld.w %d2,[%a2]
80005b2a:	b7 42 04 20 	insert %d2,%d2,4,0,4
80005b2e:	74 22       	st.w [%a2],%d2
80005b30:	1d ff 92 fd 	j 80005654 <IfxMultican_Can_MsgObj_init+0x14c>
80005b34:	82 03       	mov %d3,0
80005b36:	82 02       	mov %d2,0
80005b38:	59 a3 08 00 	st.w [%sp]8,%d3
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
80005b3c:	19 a3 04 00 	ld.w %d3,[%sp]4
80005b40:	74 a2       	st.w [%sp],%d2
80005b42:	8b 2c a0 22 	ge.u %d2,%d12,2
80005b46:	26 23       	and %d3,%d2
80005b48:	df 03 de ff 	jne %d3,0,80005b04 <IfxMultican_Can_MsgObj_init+0x5fc>
80005b4c:	59 a3 0c 00 	st.w [%sp]12,%d3
80005b50:	82 0e       	mov %d14,0
        transmitFifo = (config->msgObjCount > 1) && (transmitFrame);
80005b52:	df 02 16 7d 	jeq %d2,0,8000557e <IfxMultican_Can_MsgObj_init+0x76>
80005b56:	54 ae       	ld.w %d14,[%sp]
80005b58:	1d ff 13 fd 	j 8000557e <IfxMultican_Can_MsgObj_init+0x76>
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;

    if (config->msgObjId == config->firstSlaveObjId)
80005b5c:	4c 5e       	ld.w %d15,[%a5]56
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;
80005b5e:	82 1d       	mov %d13,1

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
80005b60:	0b fb 00 31 	eq %d3,%d11,%d15
80005b64:	59 a3 14 00 	st.w [%sp]20,%d3
80005b68:	1d ff 02 fd 	j 8000556c <IfxMultican_Can_MsgObj_init+0x64>
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);

            /* clear all TXEN1 flags expect for the slave object in the FGPR.CUR of the base FIFO object */
            if (objId == firstSlaveObjId)
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80005b6c:	6d ff 1e f5 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
80005b70:	1d ff 0a ff 	j 80005984 <IfxMultican_Can_MsgObj_init+0x47c>
80005b74:	12 34       	add %d4,%d15,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005b76:	8f 54 00 50 	sh %d5,%d4,5
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005b7a:	c2 f2       	add %d2,-1
80005b7c:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80005b80:	1b 14 00 60 	addi %d6,%d4,1
80005b84:	0b 32 00 21 	eq %d2,%d2,%d3
80005b88:	2b 6f 40 22 	sel %d2,%d2,%d15,%d6
80005b8c:	8f f2 0f 51 	and %d5,%d2,255
80005b90:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005b94:	c2 13       	add %d3,1
80005b96:	8f f2 cf 41 	andn %d4,%d2,255
80005b9a:	0f 54 a0 20 	or %d2,%d4,%d5
80005b9e:	59 22 04 01 	st.w [%a2]4100,%d2
80005ba2:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005ba6:	3f 23 e7 ff 	jlt.u %d3,%d2,80005b74 <IfxMultican_Can_MsgObj_init+0x66c>
80005baa:	1d ff 37 ff 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
}


IFX_INLINE void IfxMultican_MsgObj_setSingleTransmitTrial(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.STT = enabled ? 1 : 0;
80005bae:	8f 5a 00 20 	sh %d2,%d10,5
80005bb2:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80005bb6:	54 22       	ld.w %d2,[%a2]
80005bb8:	b7 02 81 2b 	insert %d2,%d2,0,23,1
80005bbc:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setSingleDataTransfer(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.SDT = enabled ? 1 : 0;
80005bbe:	54 22       	ld.w %d2,[%a2]
80005bc0:	b7 02 01 2b 	insert %d2,%d2,0,22,1
80005bc4:	74 22       	st.w [%a2],%d2
        }
    }

    {
        /* for standard message object */
        if (config->msgObjCount == 1)
80005bc6:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005bca:	df 12 a8 fd 	jne %d2,1,8000571a <IfxMultican_Can_MsgObj_init+0x212>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005bce:	06 5b       	sh %d11,5
80005bd0:	59 ab 04 00 	st.w [%sp]4,%d11
80005bd4:	01 cb 00 26 	addsc.a %a2,%a12,%d11,0
        {
            /* long frame CAN FD */
            if (longFrame)
80005bd8:	bd 0d 52 80 	jnz.a %a13,80005c7c <IfxMultican_Can_MsgObj_init+0x774>

                /* set top pointer FGPR.TOP */
                IfxMultican_MsgObj_setTopObjectPointer(hwObj, config->control.topMsgObjId);
            }
            /* standard gateway transfers */
            else if (gatewaySourceObj)
80005bdc:	df 0d 08 01 	jeq %d13,0,80005dec <IfxMultican_Can_MsgObj_init+0x8e4>
80005be0:	19 22 04 01 	ld.w %d2,[%a2]4100
80005be4:	8f f4 0f 41 	and %d4,%d4,255
80005be8:	8f f2 cf 21 	andn %d2,%d2,255
80005bec:	a6 42       	or %d2,%d4
80005bee:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80005bf2:	19 22 04 01 	ld.w %d2,[%a2]4100
80005bf6:	8f 84 00 30 	sh %d3,%d4,8
80005bfa:	b7 02 08 24 	insert %d2,%d2,0,8,8
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
80005bfe:	8f 04 01 40 	sh %d4,%d4,16
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80005c02:	a6 32       	or %d2,%d3
80005c04:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
80005c08:	19 22 04 01 	ld.w %d2,[%a2]4100

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;
80005c0c:	82 05       	mov %d5,0
80005c0e:	b7 02 08 28 	insert %d2,%d2,0,16,8
80005c12:	a6 24       	or %d4,%d2
80005c14:	59 24 04 01 	st.w [%a2]4100,%d4
80005c18:	59 a5 08 00 	st.w [%sp]8,%d5
80005c1c:	1d ff af fd 	j 8000577a <IfxMultican_Can_MsgObj_init+0x272>
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80005c20:	08 d2       	ld.bu %d2,[%a15]13
80005c22:	54 23       	ld.w %d3,[%a2]
80005c24:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
80005c28:	74 22       	st.w [%a2],%d2
80005c2a:	1d ff 59 fd 	j 800056dc <IfxMultican_Can_MsgObj_init+0x1d4>

    /* for standard and receive FIFO base objects */
    if (config->frame == IfxMultican_Frame_receive)
    {
        /*  set RTSEL */
        IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveTransmitSelected);
80005c2e:	60 84       	mov.a %a4,%d8
80005c30:	82 64       	mov %d4,6
80005c32:	6d ff bb f4 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>

        /* MSGVAL: Set message as valid */
        IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005c36:	60 84       	mov.a %a4,%d8
80005c38:	82 54       	mov %d4,5
80005c3a:	6d ff b7 f4 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
80005c3e:	1d ff b8 fe 	j 800059ae <IfxMultican_Can_MsgObj_init+0x4a6>
        }

        if ((config->frame == IfxMultican_Frame_receive) || (config->frame == IfxMultican_Frame_remoteAnswer))
        {
            /*  set RXEN, in case of recieve frame or remote answer*/
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveEnable);
80005c42:	60 84       	mov.a %a4,%d8
80005c44:	82 74       	mov %d4,7
80005c46:	6d ff b1 f4 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
80005c4a:	1d ff e8 fc 	j 8000561a <IfxMultican_Can_MsgObj_init+0x112>
            /* long frame CAN FD */
            if (longFrame)
            {
                /* Allocate MO with extended Data fields slected by FGPR.B.TOP and FGPR.B.BOT, for the unallocated list (0) */
                /* Append message object to the end of the list(0) */
                IfxMultican_setListCommand(mcanSFR, 0x2, 0, config->control.topMsgObjId);
80005c4e:	40 c4       	mov.aa %a4,%a12
80005c50:	48 46       	ld.w %d6,[%a15]16
80005c52:	d2 24       	mov %e4,2
80005c54:	6d ff f3 fb 	call 8000543a <IfxMultican_setListCommand>
                IfxMultican_setListCommand(mcanSFR, 0x2, 0, config->control.bottomMsgObjId);
80005c58:	40 c4       	mov.aa %a4,%a12
80005c5a:	d2 24       	mov %e4,2
80005c5c:	48 56       	ld.w %d6,[%a15]20
80005c5e:	6d ff ee fb 	call 8000543a <IfxMultican_setListCommand>
80005c62:	1d ff c1 fc 	j 800055e4 <IfxMultican_Can_MsgObj_init+0xdc>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005c66:	8f 5a 00 50 	sh %d5,%d10,5
80005c6a:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80005c6e:	82 04       	mov %d4,0
80005c70:	54 22       	ld.w %d2,[%a2]
80005c72:	b7 22 04 20 	insert %d2,%d2,2,0,4
80005c76:	74 22       	st.w [%a2],%d2
80005c78:	1d ff ee fc 	j 80005654 <IfxMultican_Can_MsgObj_init+0x14c>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005c7c:	19 22 04 01 	ld.w %d2,[%a2]4100
80005c80:	39 f3 14 00 	ld.bu %d3,[%a15]20
80005c84:	8f f2 cf 21 	andn %d2,%d2,255
80005c88:	a6 32       	or %d2,%d3
80005c8a:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80005c8e:	39 f2 10 00 	ld.bu %d2,[%a15]16
80005c92:	8f 82 00 30 	sh %d3,%d2,8
80005c96:	19 22 04 01 	ld.w %d2,[%a2]4100
80005c9a:	b7 02 08 24 	insert %d2,%d2,0,8,8
80005c9e:	a6 32       	or %d2,%d3
80005ca0:	59 22 04 01 	st.w [%a2]4100,%d2

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;
80005ca4:	82 03       	mov %d3,0
80005ca6:	59 a3 08 00 	st.w [%sp]8,%d3
80005caa:	1d ff 68 fd 	j 8000577a <IfxMultican_Can_MsgObj_init+0x272>
                    gatewayDstObjId = config->gatewayConfig.gatewayDstObjId;
                }
            }
            /* long frame CAN FD */
            /* FDEN = 1, EDL = 1 and BRS = 0/1 */
            else if (config->node->fastNode && longFrame)
80005cae:	c8 02       	ld.a %a2,[%a15]0
80005cb0:	80 d4       	mov.d %d4,%a13
80005cb2:	39 22 09 00 	ld.bu %d2,[%a2]9
80005cb6:	8b 02 20 22 	ne %d2,%d2,0
80005cba:	26 42       	and %d2,%d4
80005cbc:	df 02 49 00 	jeq %d2,0,80005d4e <IfxMultican_Can_MsgObj_init+0x846>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005cc0:	8f 5a 00 50 	sh %d5,%d10,5
80005cc4:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80005cc8:	82 04       	mov %d4,0
80005cca:	54 22       	ld.w %d2,[%a2]
80005ccc:	b7 52 04 20 	insert %d2,%d2,5,0,4
80005cd0:	74 22       	st.w [%a2],%d2
80005cd2:	1d ff c1 fc 	j 80005654 <IfxMultican_Can_MsgObj_init+0x14c>
80005cd6:	19 a2 08 00 	ld.w %d2,[%sp]8
80005cda:	df 02 45 80 	jne %d2,0,80005d64 <IfxMultican_Can_MsgObj_init+0x85c>
80005cde:	19 a3 10 00 	ld.w %d3,[%sp]16
80005ce2:	df 03 33 81 	jne %d3,0,80005f48 <IfxMultican_Can_MsgObj_init+0xa40>
80005ce6:	19 a2 14 00 	ld.w %d2,[%sp]20
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005cea:	82 08       	mov %d8,0
80005cec:	df 02 07 01 	jeq %d2,0,80005efa <IfxMultican_Can_MsgObj_init+0x9f2>
80005cf0:	8f 5a 00 50 	sh %d5,%d10,5
80005cf4:	01 c5 00 d6 	addsc.a %a13,%a12,%d5,0
80005cf8:	12 89       	add %d9,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80005cfa:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005cfe:	8f 52 00 30 	sh %d3,%d2,5
80005d02:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80005d06:	82 54       	mov %d4,5
80005d08:	6d ff 50 f4 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005d0c:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005d10:	1b 19 00 40 	addi %d4,%d9,1
80005d14:	c2 f2       	add %d2,-1
80005d16:	0b 82 10 21 	ne %d2,%d2,%d8
80005d1a:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005d1e:	8f 59 00 40 	sh %d4,%d9,5
80005d22:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80005d26:	8f f2 0f 31 	and %d3,%d2,255
80005d2a:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005d2e:	c2 18       	add %d8,1
80005d30:	8f f2 cf 21 	andn %d2,%d2,255
80005d34:	a6 32       	or %d2,%d3
80005d36:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005d3a:	54 d2       	ld.w %d2,[%a13]
80005d3c:	b7 22 04 20 	insert %d2,%d2,2,0,4
80005d40:	74 d2       	st.w [%a13],%d2
80005d42:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005d46:	3f 28 d9 ff 	jlt.u %d8,%d2,80005cf8 <IfxMultican_Can_MsgObj_init+0x7f0>
80005d4a:	1d ff 67 fe 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
80005d4e:	8f 5a 00 20 	sh %d2,%d10,5
80005d52:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80005d56:	82 04       	mov %d4,0
80005d58:	54 22       	ld.w %d2,[%a2]
80005d5a:	8f f2 c0 21 	andn %d2,%d2,15
80005d5e:	74 22       	st.w [%a2],%d2
80005d60:	1d ff 7a fc 	j 80005654 <IfxMultican_Can_MsgObj_init+0x14c>
80005d64:	19 a2 14 00 	ld.w %d2,[%sp]20
80005d68:	df 02 8c 00 	jeq %d2,0,80005e80 <IfxMultican_Can_MsgObj_init+0x978>
80005d6c:	19 a2 10 00 	ld.w %d2,[%sp]16
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005d70:	82 08       	mov %d8,0
80005d72:	df 02 76 80 	jne %d2,0,80005e5e <IfxMultican_Can_MsgObj_init+0x956>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005d76:	19 a5 04 00 	ld.w %d5,[%sp]4
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005d7a:	8f 5a 00 40 	sh %d4,%d10,5
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005d7e:	01 c5 00 e6 	addsc.a %a14,%a12,%d5,0
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005d82:	01 c4 00 d6 	addsc.a %a13,%a12,%d4,0
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005d86:	d9 ee 04 01 	lea %a14,[%a14]4100
80005d8a:	12 89       	add %d9,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80005d8c:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005d90:	8f 52 00 30 	sh %d3,%d2,5
80005d94:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80005d98:	82 54       	mov %d4,5
80005d9a:	6d ff 07 f4 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005d9e:	b9 f2 08 00 	ld.hu %d2,[%a15]8
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80005da2:	1b 19 00 40 	addi %d4,%d9,1
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005da6:	c2 f2       	add %d2,-1
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80005da8:	0b 82 10 21 	ne %d2,%d2,%d8
80005dac:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005db0:	8f 59 00 40 	sh %d4,%d9,5
80005db4:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80005db8:	8f f2 0f 31 	and %d3,%d2,255
80005dbc:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005dc0:	c2 18       	add %d8,1
80005dc2:	8f f2 cf 21 	andn %d2,%d2,255
80005dc6:	a6 32       	or %d2,%d3
80005dc8:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005dcc:	54 d2       	ld.w %d2,[%a13]
80005dce:	b7 22 04 20 	insert %d2,%d2,2,0,4
80005dd2:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005dd4:	54 e2       	ld.w %d2,[%a14]
80005dd6:	08 43       	ld.bu %d3,[%a15]4
80005dd8:	8f f2 cf 21 	andn %d2,%d2,255
80005ddc:	a6 32       	or %d2,%d3
80005dde:	74 e2       	st.w [%a14],%d2
80005de0:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005de4:	3f 28 d3 ff 	jlt.u %d8,%d2,80005d8a <IfxMultican_Can_MsgObj_init+0x882>
80005de8:	1d ff 18 fe 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;
80005dec:	82 02       	mov %d2,0
}


IFX_INLINE void IfxMultican_MsgObj_clearFifoGatewayPointers(Ifx_CAN_MO *hwObj)
{
    hwObj->FGPR.U = 0x0000000U;
80005dee:	59 2d 04 01 	st.w [%a2]4100,%d13
80005df2:	59 a2 08 00 	st.w [%sp]8,%d2
80005df6:	1d ff c2 fc 	j 8000577a <IfxMultican_Can_MsgObj_init+0x272>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005dfa:	19 a5 04 00 	ld.w %d5,[%sp]4
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005dfe:	8f 5a 00 40 	sh %d4,%d10,5
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005e02:	01 c5 00 46 	addsc.a %a4,%a12,%d5,0
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005e06:	01 c4 00 36 	addsc.a %a3,%a12,%d4,0
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005e0a:	82 03       	mov %d3,0
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005e0c:	d9 44 04 01 	lea %a4,[%a4]4100
80005e10:	12 34       	add %d4,%d15,%d3
80005e12:	8f 54 00 50 	sh %d5,%d4,5
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005e16:	c2 f2       	add %d2,-1
80005e18:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80005e1c:	1b 14 00 60 	addi %d6,%d4,1
80005e20:	0b 23 00 21 	eq %d2,%d3,%d2
80005e24:	2b 6f 40 22 	sel %d2,%d2,%d15,%d6
80005e28:	8f f2 0f 51 	and %d5,%d2,255
80005e2c:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005e30:	c2 13       	add %d3,1
80005e32:	8f f2 cf 41 	andn %d4,%d2,255
80005e36:	0f 54 a0 20 	or %d2,%d4,%d5
80005e3a:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80005e3e:	54 32       	ld.w %d2,[%a3]
80005e40:	b7 22 04 20 	insert %d2,%d2,2,0,4
80005e44:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005e46:	54 42       	ld.w %d2,[%a4]
80005e48:	08 44       	ld.bu %d4,[%a15]4
80005e4a:	8f f2 cf 21 	andn %d2,%d2,255
80005e4e:	a6 42       	or %d2,%d4
80005e50:	74 42       	st.w [%a4],%d2
80005e52:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005e56:	3f 23 dd ff 	jlt.u %d3,%d2,80005e10 <IfxMultican_Can_MsgObj_init+0x908>
80005e5a:	1d ff df fd 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
80005e5e:	12 82       	add %d2,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80005e60:	1b 02 08 20 	addi %d2,%d2,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005e64:	8f 52 00 30 	sh %d3,%d2,5
80005e68:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80005e6c:	82 54       	mov %d4,5
80005e6e:	6d ff 9d f3 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005e72:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005e76:	c2 18       	add %d8,1
80005e78:	3f 28 f3 ff 	jlt.u %d8,%d2,80005e5e <IfxMultican_Can_MsgObj_init+0x956>
80005e7c:	1d ff ce fd 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
80005e80:	19 a3 10 00 	ld.w %d3,[%sp]16
80005e84:	82 08       	mov %d8,0
80005e86:	df 03 13 00 	jeq %d3,0,80005eac <IfxMultican_Can_MsgObj_init+0x9a4>
80005e8a:	12 82       	add %d2,%d15,%d8
80005e8c:	1b 02 08 20 	addi %d2,%d2,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005e90:	8f 52 00 40 	sh %d4,%d2,5
80005e94:	01 c4 00 46 	addsc.a %a4,%a12,%d4,0
80005e98:	82 54       	mov %d4,5
80005e9a:	6d ff 87 f3 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005e9e:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005ea2:	c2 18       	add %d8,1
80005ea4:	3f 28 f3 ff 	jlt.u %d8,%d2,80005e8a <IfxMultican_Can_MsgObj_init+0x982>
80005ea8:	1d ff b8 fd 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
80005eac:	12 89       	add %d9,%d15,%d8
80005eae:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005eb2:	8f 52 00 50 	sh %d5,%d2,5
80005eb6:	01 c5 00 46 	addsc.a %a4,%a12,%d5,0
80005eba:	82 54       	mov %d4,5
80005ebc:	6d ff 76 f3 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005ec0:	b9 f2 08 00 	ld.hu %d2,[%a15]8
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005ec4:	8f 59 00 30 	sh %d3,%d9,5
80005ec8:	c2 f2       	add %d2,-1
80005eca:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80005ece:	0b 82 10 21 	ne %d2,%d2,%d8
80005ed2:	1b 19 00 40 	addi %d4,%d9,1
80005ed6:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
80005eda:	8f f2 0f 31 	and %d3,%d2,255
80005ede:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005ee2:	c2 18       	add %d8,1
80005ee4:	8f f2 cf 21 	andn %d2,%d2,255
80005ee8:	a6 32       	or %d2,%d3
80005eea:	59 22 04 01 	st.w [%a2]4100,%d2
80005eee:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005ef2:	3f 28 dd ff 	jlt.u %d8,%d2,80005eac <IfxMultican_Can_MsgObj_init+0x9a4>
80005ef6:	1d ff 91 fd 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
80005efa:	12 89       	add %d9,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80005efc:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005f00:	8f 52 00 30 	sh %d3,%d2,5
80005f04:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80005f08:	82 54       	mov %d4,5
80005f0a:	6d ff 4f f3 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005f0e:	b9 f2 08 00 	ld.hu %d2,[%a15]8
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80005f12:	1b 19 00 40 	addi %d4,%d9,1
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80005f16:	c2 f2       	add %d2,-1
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80005f18:	0b 82 10 21 	ne %d2,%d2,%d8
80005f1c:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80005f20:	8f 59 00 40 	sh %d4,%d9,5
80005f24:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80005f28:	8f f2 0f 31 	and %d3,%d2,255
80005f2c:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005f30:	c2 18       	add %d8,1
80005f32:	8f f2 cf 21 	andn %d2,%d2,255
80005f36:	a6 32       	or %d2,%d3
80005f38:	59 22 04 01 	st.w [%a2]4100,%d2
80005f3c:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005f40:	3f 28 dd ff 	jlt.u %d8,%d2,80005efa <IfxMultican_Can_MsgObj_init+0x9f2>
80005f44:	1d ff 6a fd 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>
80005f48:	82 08       	mov %d8,0
80005f4a:	12 82       	add %d2,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80005f4c:	1b 02 08 20 	addi %d2,%d2,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80005f50:	8f 52 00 40 	sh %d4,%d2,5
80005f54:	01 c4 00 46 	addsc.a %a4,%a12,%d4,0
80005f58:	82 54       	mov %d4,5
80005f5a:	6d ff 27 f3 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80005f5e:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80005f62:	c2 18       	add %d8,1
80005f64:	3f 28 f3 ff 	jlt.u %d8,%d2,80005f4a <IfxMultican_Can_MsgObj_init+0xa42>
80005f68:	1d ff 58 fd 	j 80005a18 <IfxMultican_Can_MsgObj_init+0x510>

80005f6c <IfxMultican_Can_MsgObj_initConfig>:
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
    config->msgObjId                         = 0;
    config->msgObjCount                      = 1;
80005f6c:	82 12       	mov %d2,1
80005f6e:	f9 42 08 00 	st.h [%a4]8,%d2

    config->control.messageLen               = IfxMultican_DataLengthCode_8;
80005f72:	3b 80 00 20 	mov %d2,8
80005f76:	e9 42 0d 00 	st.b [%a4]13,%d2

    config->control.topMsgObjId              = 252;
80005f7a:	3b c0 0f 20 	mov %d2,252
80005f7e:	59 42 10 00 	st.w [%a4]16,%d2
    config->control.bottomMsgObjId           = 253;
80005f82:	3b d0 0f 20 	mov %d2,253
80005f86:	59 42 14 00 	st.w [%a4]20,%d2
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */
80005f8a:	39 42 18 00 	ld.bu %d2,[%a4]24
void IfxMultican_Can_MsgObj_initConfig(IfxMultican_Can_MsgObjConfig *config, IfxMultican_Can_Node *node)
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
    config->msgObjId                         = 0;
80005f8e:	82 0f       	mov %d15,0

    config->control.messageLen               = IfxMultican_DataLengthCode_8;

    config->control.topMsgObjId              = 252;
    config->control.bottomMsgObjId           = 253;
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */
80005f90:	8f 12 c0 21 	andn %d2,%d2,1
80005f94:	e9 42 18 00 	st.b [%a4]24,%d2

    config->control.extendedFrame            = FALSE;
80005f98:	39 42 0e 00 	ld.bu %d2,[%a4]14

void IfxMultican_Can_MsgObj_initConfig(IfxMultican_Can_MsgObjConfig *config, IfxMultican_Can_Node *node)
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
80005f9c:	f4 45       	st.a [%a4],%a5
    config->control.topMsgObjId              = 252;
    config->control.bottomMsgObjId           = 253;
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */

    config->control.extendedFrame            = FALSE;
    config->control.matchingId               = FALSE;
80005f9e:	8f 32 c0 21 	andn %d2,%d2,3
80005fa2:	e9 42 0e 00 	st.b [%a4]14,%d2
    config->control.singleDataTransfer       = FALSE;
80005fa6:	39 42 0c 00 	ld.bu %d2,[%a4]12
void IfxMultican_Can_MsgObj_initConfig(IfxMultican_Can_MsgObjConfig *config, IfxMultican_Can_Node *node)
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
    config->msgObjId                         = 0;
80005faa:	6c 41       	st.w [%a4]4,%d15
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */

    config->control.extendedFrame            = FALSE;
    config->control.matchingId               = FALSE;
    config->control.singleDataTransfer       = FALSE;
    config->control.singleTransmitTrial      = FALSE;
80005fac:	8f 32 c0 21 	andn %d2,%d2,3
80005fb0:	e9 42 0c 00 	st.b [%a4]12,%d2
    config->acceptanceMask                   = 0x7FFFFFFFUL;
80005fb4:	82 f2       	mov %d2,-1
80005fb6:	06 f2       	sh %d2,-1
80005fb8:	59 42 20 00 	st.w [%a4]32,%d2
    config->messageId                        = 0;

    config->frame                            = IfxMultican_Frame_receive;
    config->priority                         = IfxMultican_Priority_CAN_ID;
80005fbc:	82 22       	mov %d2,2
80005fbe:	e9 42 28 00 	st.b [%a4]40,%d2
    config->txInterrupt.enabled              = FALSE;
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;

    config->firstSlaveObjId                  = 0;

    config->gatewayTransfers                 = FALSE;
80005fc2:	39 42 2e 00 	ld.bu %d2,[%a4]46
    config->control.extendedFrame            = FALSE;
    config->control.matchingId               = FALSE;
    config->control.singleDataTransfer       = FALSE;
    config->control.singleTransmitTrial      = FALSE;
    config->acceptanceMask                   = 0x7FFFFFFFUL;
    config->messageId                        = 0;
80005fc6:	6c 49       	st.w [%a4]36,%d15
    config->txInterrupt.enabled              = FALSE;
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;

    config->firstSlaveObjId                  = 0;

    config->gatewayTransfers                 = FALSE;
80005fc8:	8f 12 c0 21 	andn %d2,%d2,1
80005fcc:	e9 42 2e 00 	st.b [%a4]46,%d2
    config->gatewayConfig.copyDataLengthCode = TRUE;
80005fd0:	39 42 30 00 	ld.bu %d2,[%a4]48
    config->control.singleDataTransfer       = FALSE;
    config->control.singleTransmitTrial      = FALSE;
    config->acceptanceMask                   = 0x7FFFFFFFUL;
    config->messageId                        = 0;

    config->frame                            = IfxMultican_Frame_receive;
80005fd4:	e9 4f 1c 00 	st.b [%a4]28,%d15
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;

    config->firstSlaveObjId                  = 0;

    config->gatewayTransfers                 = FALSE;
    config->gatewayConfig.copyDataLengthCode = TRUE;
80005fd8:	b7 12 01 20 	insert %d2,%d2,1,0,1
    config->gatewayConfig.copyData           = TRUE;
80005fdc:	b7 12 81 20 	insert %d2,%d2,1,1,1
    config->gatewayConfig.copyId             = TRUE;
80005fe0:	b7 12 01 21 	insert %d2,%d2,1,2,1
    config->gatewayConfig.enableTransmit     = TRUE;
80005fe4:	b7 12 81 21 	insert %d2,%d2,1,3,1
    config->acceptanceMask                   = 0x7FFFFFFFUL;
    config->messageId                        = 0;

    config->frame                            = IfxMultican_Frame_receive;
    config->priority                         = IfxMultican_Priority_CAN_ID;
    config->rxInterrupt.enabled              = FALSE;
80005fe8:	e9 4f 2a 00 	st.b [%a4]42,%d15
    config->rxInterrupt.srcId                = IfxMultican_SrcId_0;
80005fec:	e9 4f 2b 00 	st.b [%a4]43,%d15
    config->txInterrupt.enabled              = FALSE;
80005ff0:	e9 4f 2c 00 	st.b [%a4]44,%d15
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;
80005ff4:	e9 4f 2d 00 	st.b [%a4]45,%d15

    config->firstSlaveObjId                  = 0;
80005ff8:	6c 4e       	st.w [%a4]56,%d15

    config->gatewayTransfers                 = FALSE;
    config->gatewayConfig.copyDataLengthCode = TRUE;
    config->gatewayConfig.copyData           = TRUE;
    config->gatewayConfig.copyId             = TRUE;
    config->gatewayConfig.enableTransmit     = TRUE;
80005ffa:	e9 42 30 00 	st.b [%a4]48,%d2
    config->gatewayConfig.gatewayDstObjId    = 0;
80005ffe:	6c 4d       	st.w [%a4]52,%d15
80006000:	00 90       	ret 

80006002 <IfxMultican_Can_MsgObj_isRxPending>:
}


boolean IfxMultican_Can_MsgObj_isRxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006002:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->fifoPointer);
80006006:	cc 40       	ld.a %a15,[%a4]0
}


boolean IfxMultican_Can_MsgObj_isRxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006008:	bf 2f 0f 80 	jlt.u %d15,2,80006026 <IfxMultican_Can_MsgObj_isRxPending+0x24>
8000600c:	4c 43       	ld.w %d15,[%a4]12
8000600e:	c8 04       	ld.a %a4,[%a15]0
80006010:	1b 0f 08 f0 	addi %d15,%d15,128
}


IFX_INLINE boolean IfxMultican_MsgObj_isRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat msgStatus = IfxMultican_MsgObj_getStatus(hwObj);
80006014:	8f 5f 00 20 	sh %d2,%d15,5
80006018:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8000601c:	6d ff df f0 	call 800041da <IfxMultican_MsgObj_getStatus>
    return msgStatus.B.RXPND ? TRUE : FALSE;
80006020:	8f 12 00 21 	and %d2,%d2,1
    else
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
        return IfxMultican_MsgObj_isRxPending(hwObj);
    }
}
80006024:	00 90       	ret 
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006026:	4c 41       	ld.w %d15,[%a4]4
80006028:	3c f3       	j 8000600e <IfxMultican_Can_MsgObj_isRxPending+0xc>

8000602a <IfxMultican_Can_MsgObj_isTransmitRequested>:


boolean IfxMultican_Can_MsgObj_isTransmitRequested(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
8000602a:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->fifoPointer);
8000602e:	cc 40       	ld.a %a15,[%a4]0
}


boolean IfxMultican_Can_MsgObj_isTransmitRequested(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006030:	bf 2f 0f 80 	jlt.u %d15,2,8000604e <IfxMultican_Can_MsgObj_isTransmitRequested+0x24>
80006034:	4c 43       	ld.w %d15,[%a4]12
80006036:	c8 04       	ld.a %a4,[%a15]0
80006038:	1b 0f 08 f0 	addi %d15,%d15,128
}


IFX_INLINE boolean IfxMultican_MsgObj_isTransmitRequested(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat msgStatus = IfxMultican_MsgObj_getStatus(hwObj);
8000603c:	8f 5f 00 20 	sh %d2,%d15,5
80006040:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
80006044:	6d ff cb f0 	call 800041da <IfxMultican_MsgObj_getStatus>
    return msgStatus.B.TXRQ ? TRUE : FALSE;
80006048:	37 02 61 24 	extr.u %d2,%d2,8,1
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);

        return IfxMultican_MsgObj_isTransmitRequested(hwObj);
    }
}
8000604c:	00 90       	ret 
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
8000604e:	4c 41       	ld.w %d15,[%a4]4
80006050:	3c f3       	j 80006036 <IfxMultican_Can_MsgObj_isTransmitRequested+0xc>

80006052 <IfxMultican_Can_MsgObj_isTxPending>:


boolean IfxMultican_Can_MsgObj_isTxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006052:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->fifoPointer);
80006056:	cc 40       	ld.a %a15,[%a4]0
}


boolean IfxMultican_Can_MsgObj_isTxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006058:	bf 2f 0f 80 	jlt.u %d15,2,80006076 <IfxMultican_Can_MsgObj_isTxPending+0x24>
8000605c:	4c 43       	ld.w %d15,[%a4]12
8000605e:	c8 04       	ld.a %a4,[%a15]0
80006060:	1b 0f 08 f0 	addi %d15,%d15,128
}


IFX_INLINE boolean IfxMultican_MsgObj_isTxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat msgStatus = IfxMultican_MsgObj_getStatus(hwObj);
80006064:	8f 5f 00 20 	sh %d2,%d15,5
80006068:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8000606c:	6d ff b7 f0 	call 800041da <IfxMultican_MsgObj_getStatus>
    return msgStatus.B.TXPND ? TRUE : FALSE;
80006070:	37 02 e1 20 	extr.u %d2,%d2,1,1
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);

        return IfxMultican_MsgObj_isTxPending(hwObj);
    }
}
80006074:	00 90       	ret 
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006076:	4c 41       	ld.w %d15,[%a4]4
80006078:	3c f3       	j 8000605e <IfxMultican_Can_MsgObj_isTxPending+0xc>

8000607a <IfxMultican_Can_MsgObj_readMessage>:
IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
8000607a:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
8000607e:	80 44       	mov.d %d4,%a4
80006080:	80 43       	mov.d %d3,%a4
80006082:	1b c4 00 20 	addi %d2,%d4,12
80006086:	c2 43       	add %d3,4
80006088:	8b 2f 60 f2 	lt.u %d15,%d15,2
8000608c:	2b 23 40 ff 	sel %d15,%d15,%d3,%d2
80006090:	60 f2       	mov.a %a2,%d15
    }
}


IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
80006092:	40 4f       	mov.aa %a15,%a4
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
80006094:	54 28       	ld.w %d8,[%a2]
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006096:	d4 42       	ld.a %a2,[%a4]
80006098:	1b 08 08 20 	addi %d2,%d8,128
}


IFX_INLINE void IfxMultican_MsgObj_clearRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
8000609c:	82 04       	mov %d4,0
8000609e:	4c 20       	ld.w %d15,[%a2]0
    }
}


IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
800060a0:	40 5d       	mov.aa %a13,%a5
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
800060a2:	13 02 22 3f 	madd %d3,%d15,%d2,32
}


IFX_INLINE void IfxMultican_MsgObj_clearRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
800060a6:	60 34       	mov.a %a4,%d3
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
800060a8:	60 3c       	mov.a %a12,%d3
}


IFX_INLINE void IfxMultican_MsgObj_clearRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
800060aa:	6d ff 55 f0 	call 80004154 <IfxMultican_MsgObj_clearStatusFlag>

    /* clear pending flag */
    IfxMultican_MsgObj_clearRxPending(hwObj);

    /* read the message object */
    status = IfxMultican_MsgObj_readMessage(hwObj, msg);
800060ae:	40 c4       	mov.aa %a4,%a12
800060b0:	40 d5       	mov.aa %a5,%a13
800060b2:	6d ff dd f0 	call 8000426c <IfxMultican_MsgObj_readMessage>

    /* if successfull: */
    if (status & IfxMultican_Status_newData)
800060b6:	6f 82 0d 00 	jz.t %d2,8,800060d0 <IfxMultican_Can_MsgObj_readMessage+0x56>
    {
        if (msgObj->msgObjCount > 1)
800060ba:	b9 f3 08 00 	ld.hu %d3,[%a15]8
800060be:	bf 23 09 80 	jlt.u %d3,2,800060d0 <IfxMultican_Can_MsgObj_readMessage+0x56>
}


IFX_INLINE IfxMultican_MsgObjId IfxMultican_MsgObj_getBottomObjectPointer(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_MsgObjId)(hwObj->FGPR.B.BOT);
800060c2:	13 08 22 4f 	madd %d4,%d15,%d8,32
800060c6:	60 42       	mov.a %a2,%d4
800060c8:	19 2f 04 01 	ld.w %d15,[%a2]4100
800060cc:	16 ff       	and %d15,255
800060ce:	68 3f       	st.w [%a15]12,%d15
        else
        {}
    }

    return status;
}
800060d0:	00 90       	ret 

800060d2 <IfxMultican_Can_MsgObj_sendMessage>:
IfxMultican_Status IfxMultican_Can_MsgObj_sendMessage(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
800060d2:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    return status;
}


IfxMultican_Status IfxMultican_Can_MsgObj_sendMessage(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Message *msg)
{
800060d6:	40 4f       	mov.aa %a15,%a4
800060d8:	40 5c       	mov.aa %a12,%a5
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
800060da:	bf 2f 2c 80 	jlt.u %d15,2,80006132 <IfxMultican_Can_MsgObj_sendMessage+0x60>
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
800060de:	19 42 04 00 	ld.w %d2,[%a4]4
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;

        Ifx_CAN_MO *hwBaseObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
800060e2:	d4 42       	ld.a %a2,[%a4]
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
800060e4:	19 48 0c 00 	ld.w %d8,[%a4]12
800060e8:	d4 24       	ld.a %a4,[%a2]
800060ea:	1b 02 08 f0 	addi %d15,%d2,128

        Ifx_CAN_MO *hwBaseObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);

        /* set message as valid, in case of FIFO MSGVAL of base object has to be set before setting it to each slave object */
        IfxMultican_MsgObj_setStatusFlag(hwBaseObj, IfxMultican_MsgObjStatusFlag_messageValid);
800060ee:	8f 5f 00 30 	sh %d3,%d15,5
800060f2:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
800060f6:	82 54       	mov %d4,5
800060f8:	6d ff 58 f2 	call 800045a8 <IfxMultican_MsgObj_setStatusFlag>
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
800060fc:	c8 02       	ld.a %a2,[%a15]0
800060fe:	1b 08 08 20 	addi %d2,%d8,128
80006102:	4c 20       	ld.w %d15,[%a2]0
80006104:	13 02 22 3f 	madd %d3,%d15,%d2,32

    if (msgObj->msgObjCount > 1)
80006108:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000610c:	60 34       	mov.a %a4,%d3
8000610e:	bf 22 1b 80 	jlt.u %d2,2,80006144 <IfxMultican_Can_MsgObj_sendMessage+0x72>
    {
        /* send the message */
        status = IfxMultican_MsgObj_writeTxfifo(hwObj, msg);
80006112:	40 c5       	mov.aa %a5,%a12
80006114:	6d ff f3 f1 	call 800044fa <IfxMultican_MsgObj_writeTxfifo>
        /* send the message */
        status = IfxMultican_MsgObj_sendMessage(hwObj, msg);
    }

    /* if successfull: */
    if (status == IfxMultican_Status_ok)
80006118:	f6 2c       	jnz %d2,80006130 <IfxMultican_Can_MsgObj_sendMessage+0x5e>
    {
        if (msgObj->msgObjCount > 1)
8000611a:	b9 f3 08 00 	ld.hu %d3,[%a15]8
8000611e:	bf 23 09 80 	jlt.u %d3,2,80006130 <IfxMultican_Can_MsgObj_sendMessage+0x5e>
}


IFX_INLINE IfxMultican_MsgObjId IfxMultican_MsgObj_getBottomObjectPointer(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_MsgObjId)(hwObj->FGPR.B.BOT);
80006122:	13 08 22 3f 	madd %d3,%d15,%d8,32
80006126:	60 32       	mov.a %a2,%d3
80006128:	19 2f 04 01 	ld.w %d15,[%a2]4100
8000612c:	16 ff       	and %d15,255
8000612e:	68 3f       	st.w [%a15]12,%d15
        else
        {}
    }

    return status;
}
80006130:	00 90       	ret 
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006132:	d4 42       	ld.a %a2,[%a4]
        IfxMultican_MsgObj_setStatusFlag(hwBaseObj, IfxMultican_MsgObjStatusFlag_messageValid);
    }
    else
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
80006134:	19 48 04 00 	ld.w %d8,[%a4]4
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006138:	4c 20       	ld.w %d15,[%a2]0
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
8000613a:	1b 08 08 20 	addi %d2,%d8,128
8000613e:	13 02 22 3f 	madd %d3,%d15,%d2,32
80006142:	60 34       	mov.a %a4,%d3
        status = IfxMultican_MsgObj_writeTxfifo(hwObj, msg);
    }
    else
    {
        /* send the message */
        status = IfxMultican_MsgObj_sendMessage(hwObj, msg);
80006144:	40 c5       	mov.aa %a5,%a12
80006146:	6d ff ab f1 	call 8000449c <IfxMultican_MsgObj_sendMessage>
8000614a:	3c e7       	j 80006118 <IfxMultican_Can_MsgObj_sendMessage+0x46>

8000614c <IfxMultican_Can_Node_getConfig>:
{
    Ifx_CAN_N      *hwNode = node->node;

    IfxMultican_Can mcan;

    mcan.mcan = node->mcan;
8000614c:	d4 4d       	ld.a %a13,[%a4]
    return status;
}


void IfxMultican_Can_Node_getConfig(IfxMultican_Can_Node *node, IfxMultican_Can_NodeConfig *config)
{
8000614e:	40 5f       	mov.aa %a15,%a5
    Ifx_CAN_N      *hwNode = node->node;
80006150:	99 4c 04 00 	ld.a %a12,[%a4]4
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
80006154:	19 df 08 70 	ld.w %d15,[%a13]456
80006158:	16 0f       	and %d15,15

void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
8000615a:	9e 1c       	jeq %d15,1,80006192 <IfxMultican_Can_Node_getConfig+0x46>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
8000615c:	df 2f 42 00 	jeq %d15,2,800061e0 <IfxMultican_Can_Node_getConfig+0x94>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
80006160:	9e 45       	jeq %d15,4,8000618a <IfxMultican_Can_Node_getConfig+0x3e>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
80006162:	82 04       	mov %d4,0

    mcan.mcan = node->mcan;

    float32         fcan = IfxMultican_Can_getModuleFrequency(&mcan);

    IfxMultican_calcTimingFromBTR(fcan, hwNode->BTR.U, &config->baudrate, &config->samplePoint, &config->synchJumpWidth);
80006164:	19 c5 10 00 	ld.w %d5,[%a12]16
80006168:	d9 f4 08 00 	lea %a4,[%a15]8
8000616c:	d9 f5 0c 00 	lea %a5,[%a15]12
80006170:	d9 f6 0e 00 	lea %a6,[%a15]14
80006174:	6d ff 4e f8 	call 80005210 <IfxMultican_calcTimingFromBTR>

    config->loopBackMode = (hwNode->PCR.B.LBM != 0) ? TRUE : FALSE;
80006178:	4c c3       	ld.w %d15,[%a12]12
8000617a:	37 0f 61 f4 	extr.u %d15,%d15,8,1
8000617e:	28 6f       	st.b [%a15]6,%d15
    config->analyzerMode = (hwNode->CR.B.CALM != 0) ? TRUE : FALSE;
80006180:	4c c0       	ld.w %d15,[%a12]0
80006182:	37 0f e1 f3 	extr.u %d15,%d15,7,1
80006186:	28 5f       	st.b [%a15]5,%d15
80006188:	00 90       	ret 
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
8000618a:	6d 00 e4 0d 	call 80007d52 <IfxScuCcu_getPllErayFrequency>
8000618e:	02 24       	mov %d4,%d2
80006190:	3c ea       	j 80006164 <IfxMultican_Can_Node_getConfig+0x18>
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006192:	6d 00 f2 0e 	call 80007f76 <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
80006196:	91 30 00 2f 	movh.a %a2,61443
8000619a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000619e:	54 23       	ld.w %d3,[%a2]
    {
        canFrequency = 0.0f;
800061a0:	82 0f       	mov %d15,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
800061a2:	8f f3 00 31 	and %d3,%d3,15
800061a6:	76 38       	jz %d3,800061b6 <IfxMultican_Can_Node_getConfig+0x6a>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
800061a8:	54 24       	ld.w %d4,[%a2]
800061aa:	8f f4 00 41 	and %d4,%d4,15
800061ae:	4b 04 41 41 	itof %d4,%d4
800061b2:	4b 42 51 f0 	div.f %d15,%d2,%d4
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
800061b6:	19 d2 0c 00 	ld.w %d2,[%a13]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
800061ba:	19 d4 0c 00 	ld.w %d4,[%a13]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
800061be:	37 02 62 27 	extr.u %d2,%d2,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
800061c2:	b7 04 16 45 	insert %d4,%d4,0,10,22
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
800061c6:	df 12 11 00 	jeq %d2,1,800061e8 <IfxMultican_Can_Node_getConfig+0x9c>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
800061ca:	4b 04 41 41 	itof %d4,%d4
800061ce:	7b 00 a8 33 	movh %d3,14976
800061d2:	4b 34 41 40 	mul.f %d4,%d4,%d3
800061d6:	4b f4 41 40 	mul.f %d4,%d4,%d15

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
800061da:	df 22 c4 ff 	jne %d2,2,80006162 <IfxMultican_Can_Node_getConfig+0x16>
800061de:	3c c3       	j 80006164 <IfxMultican_Can_Node_getConfig+0x18>
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
800061e0:	6d 00 99 0d 	call 80007d12 <IfxScuCcu_getOsc0Frequency>
800061e4:	02 24       	mov %d4,%d2
800061e6:	3c bf       	j 80006164 <IfxMultican_Can_Node_getConfig+0x18>
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
800061e8:	3b 00 40 20 	mov %d2,1024
800061ec:	0b 42 80 40 	sub %d4,%d2,%d4
800061f0:	4b 04 41 41 	itof %d4,%d4
800061f4:	4b 4f 51 40 	div.f %d4,%d15,%d4
800061f8:	3c b6       	j 80006164 <IfxMultican_Can_Node_getConfig+0x18>

800061fa <IfxMultican_Can_Node_init>:
}


IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
800061fa:	79 5f 04 00 	ld.b %d15,[%a5]4
800061fe:	d4 5e       	ld.a %a14,[%a5]
}


IFX_INLINE Ifx_CAN_N *IfxMultican_Node_getPointer(Ifx_CAN *mcan, IfxMultican_NodeId node)
{
    return &(mcan->N[node]);
80006200:	92 29       	add %d9,%d15,2
80006202:	8f 89 00 20 	sh %d2,%d9,8
80006206:	01 e2 00 c6 	addsc.a %a12,%a14,%d2,0
    IfxMultican_Status status = IfxMultican_Status_ok;

    node->mcan     = config->module;
    node->node     = hwNode;
    node->nodeId   = config->nodeId;
    node->fastNode = FALSE;
8000620a:	82 02       	mov %d2,0
8000620c:	e9 42 09 00 	st.b [%a4]9,%d2
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
    IfxMultican_Status status = IfxMultican_Status_ok;

    node->mcan     = config->module;
    node->node     = hwNode;
    node->nodeId   = config->nodeId;
80006210:	2c 48       	st.b [%a4]8,%d15
IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
    IfxMultican_Status status = IfxMultican_Status_ok;

    node->mcan     = config->module;
80006212:	f4 4e       	st.a [%a4],%a14
    node->node     = hwNode;
80006214:	b5 4c 04 00 	st.a [%a4]4,%a12
}


IFX_INLINE void IfxMultican_Node_resetControlRegister(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U = 0x00000041U;
80006218:	3b 10 04 20 	mov %d2,65
8000621c:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setTransferInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.TRIE = enabled ? 1 : 0;
8000621e:	39 52 36 00 	ld.bu %d2,[%a5]54
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
80006222:	8f 8f 00 a0 	sh %d10,%d15,8
}


IFX_INLINE void IfxMultican_Node_setTransferInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.TRIE = enabled ? 1 : 0;
80006226:	ab 22 a0 32 	seln %d3,%d2,%d2,2
8000622a:	54 c2       	ld.w %d2,[%a12]
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
8000622c:	01 ea 00 26 	addsc.a %a2,%a14,%d10,0
}


IFX_INLINE void IfxMultican_Node_setTransferInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.TRIE = enabled ? 1 : 0;
80006230:	8f 22 c0 21 	andn %d2,%d2,2
80006234:	a6 32       	or %d2,%d3
80006236:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setLastErrorCodeInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.LECIE = enabled ? 1 : 0;
80006238:	39 52 38 00 	ld.bu %d2,[%a5]56
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
8000623c:	82 0f       	mov %d15,0
}


IFX_INLINE void IfxMultican_Node_setLastErrorCodeInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.LECIE = enabled ? 1 : 0;
8000623e:	ab 42 a0 32 	seln %d3,%d2,%d2,4
80006242:	54 c2       	ld.w %d2,[%a12]
    config->analyzerMode = (hwNode->CR.B.CALM != 0) ? TRUE : FALSE;
}


IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
80006244:	40 5f       	mov.aa %a15,%a5
80006246:	8f 42 c0 21 	andn %d2,%d2,4
8000624a:	a6 32       	or %d2,%d3
8000624c:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setAlertInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.ALIE = enabled ? 1 : 0;
8000624e:	39 52 3a 00 	ld.bu %d2,[%a5]58
80006252:	20 08       	sub.a %sp,8
80006254:	ab 82 a0 32 	seln %d3,%d2,%d2,8
80006258:	54 c2       	ld.w %d2,[%a12]
8000625a:	40 4d       	mov.aa %a13,%a4
8000625c:	8f 82 c0 21 	andn %d2,%d2,8
80006260:	a6 32       	or %d2,%d3
80006262:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setAnalyzerMode(Ifx_CAN_N *hwNode, boolean mode)
{
    hwNode->CR.B.CALM = mode != FALSE;
80006264:	39 52 05 00 	ld.bu %d2,[%a5]5
80006268:	ab 02 a8 32 	seln %d3,%d2,%d2,128
8000626c:	54 c2       	ld.w %d2,[%a12]
8000626e:	8f 02 c8 21 	andn %d2,%d2,128
80006272:	a6 32       	or %d2,%d3
80006274:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_activate(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.INIT = 0;
80006276:	54 c2       	ld.w %d2,[%a12]
80006278:	8f 12 c0 21 	andn %d2,%d2,1
8000627c:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
8000627e:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setTransferInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.TRINP = srcId;
80006282:	19 22 08 80 	ld.w %d2,[%a2]520
80006286:	39 5f 37 00 	ld.bu %d15,[%a5]55
8000628a:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
8000628e:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setLastErrorCodeInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.LECINP = srcId;
80006292:	19 22 08 80 	ld.w %d2,[%a2]520
80006296:	39 5f 39 00 	ld.bu %d15,[%a5]57
8000629a:	37 f2 04 f2 	insert %d15,%d2,%d15,4,4
8000629e:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setAlertInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.ALINP = srcId;
800062a2:	39 5f 3b 00 	ld.bu %d15,[%a5]59
800062a6:	19 22 08 80 	ld.w %d2,[%a2]520
800062aa:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
800062ae:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setFrameCounterInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.CFCINP = srcId;
800062b2:	39 5f 3d 00 	ld.bu %d15,[%a5]61
800062b6:	19 22 08 80 	ld.w %d2,[%a2]520
800062ba:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
800062be:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setTimerEventInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.TEINP = srcId;
800062c2:	19 22 08 80 	ld.w %d2,[%a2]520
800062c6:	39 5f 3f 00 	ld.bu %d15,[%a5]63
800062ca:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
800062ce:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_resetErrorCounters(Ifx_CAN_N *hwNode)
{
    hwNode->ECNT.U = 0x00600000U;
800062d2:	7b 00 06 f0 	movh %d15,96
800062d6:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setReceiveErrorCounter(Ifx_CAN_N *hwNode, uint8 value)
{
    hwNode->ECNT.B.REC = value;
800062da:	19 2f 14 80 	ld.w %d15,[%a2]532
800062de:	8f ff cf f1 	andn %d15,%d15,255
800062e2:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setTransmitErrorCounter(Ifx_CAN_N *hwNode, uint8 value)
{
    hwNode->ECNT.B.TEC = value;
800062e6:	19 2f 14 80 	ld.w %d15,[%a2]532
800062ea:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
800062ee:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setErrorWarningLevel(Ifx_CAN_N *hwNode, uint8 level)
{
    hwNode->ECNT.B.EWRNLVL = level;
800062f2:	39 5f 35 00 	ld.bu %d15,[%a5]53
800062f6:	8f 0f 01 20 	sh %d2,%d15,16
800062fa:	19 2f 14 80 	ld.w %d15,[%a2]532
800062fe:	b7 0f 08 f8 	insert %d15,%d15,0,16,8
80006302:	a6 2f       	or %d15,%d2
80006304:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setLoopBackMode(Ifx_CAN_N *hwNode, boolean mode)
{
    hwNode->PCR.B.LBM = mode != FALSE;
80006308:	39 52 06 00 	ld.bu %d2,[%a5]6
8000630c:	3b 00 10 f0 	mov %d15,256
80006310:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80006314:	19 2f 0c 80 	ld.w %d15,[%a2]524
80006318:	8f 0f d0 f1 	andn %d15,%d15,256
8000631c:	a6 2f       	or %d15,%d2
8000631e:	59 2f 0c 80 	st.w [%a2]524,%d15
    }

    {                           /* NPCR write enabled only of NCR.CCE set */
        IfxMultican_Node_setLoopBackMode(hwNode, config->loopBackMode);

        if (config->txPin != NULL_PTR)
80006322:	99 55 30 00 	ld.a %a5,[%a5]48


IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
    IfxMultican_Status status = IfxMultican_Status_ok;
80006326:	82 0f       	mov %d15,0
    }

    {                           /* NPCR write enabled only of NCR.CCE set */
        IfxMultican_Node_setLoopBackMode(hwNode, config->loopBackMode);

        if (config->txPin != NULL_PTR)
80006328:	bc 5a       	jz.a %a5,8000633c <IfxMultican_Can_Node_init+0x142>
        {
            status |= (IfxMultican_Node_initTxPin(hwNode, config->txPin, config->txPinMode, config->pinDriver) ? IfxMultican_Status_ok : IfxMultican_Status_wrongPin);
8000632a:	40 c4       	mov.aa %a4,%a12
8000632c:	39 f4 34 00 	ld.bu %d4,[%a15]52
80006330:	39 f5 00 10 	ld.bu %d5,[%a15]64
80006334:	6d ff 67 f1 	call 80004602 <IfxMultican_Node_initTxPin>
80006338:	ab 4f 80 f2 	sel %d15,%d2,%d15,4
        }

        if (config->rxPin != NULL_PTR)
8000633c:	c8 a5       	ld.a %a5,[%a15]40
8000633e:	bc 5e       	jz.a %a5,8000635a <IfxMultican_Can_Node_init+0x160>
        {
            status |= (IfxMultican_Node_initRxPin(hwNode, config->rxPin, config->rxPinMode, config->pinDriver) ? IfxMultican_Status_ok : IfxMultican_Status_wrongPin);
80006340:	40 c4       	mov.aa %a4,%a12
80006342:	79 f4 2c 00 	ld.b %d4,[%a15]44
80006346:	39 f5 00 10 	ld.bu %d5,[%a15]64
8000634a:	6d ff 43 f1 	call 800045d0 <IfxMultican_Node_initRxPin>
8000634e:	82 03       	mov %d3,0
80006350:	ab 43 20 22 	caddn %d2,%d2,%d3,4
80006354:	a6 2f       	or %d15,%d2
80006356:	37 0f 70 f0 	extr.u %d15,%d15,0,16
        }
    }

    {
        IfxMultican_Can mcan;
        mcan.mcan = node->mcan;
8000635a:	d4 d2       	ld.a %a2,[%a13]
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
8000635c:	19 22 08 70 	ld.w %d2,[%a2]456
80006360:	8f f2 00 21 	and %d2,%d2,15

void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
80006364:	df 12 6e 00 	jeq %d2,1,80006440 <IfxMultican_Can_Node_init+0x246>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
80006368:	df 22 98 00 	jeq %d2,2,80006498 <IfxMultican_Can_Node_init+0x29e>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
8000636c:	df 42 66 00 	jeq %d2,4,80006438 <IfxMultican_Can_Node_init+0x23e>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
80006370:	82 08       	mov %d8,0
        IfxMultican_Can mcan;
        mcan.mcan = node->mcan;

        float32         fcan = IfxMultican_Can_getModuleFrequency(&mcan);

        if (!config->flexibleDataRate)
80006372:	39 f2 10 00 	ld.bu %d2,[%a15]16
80006376:	df 02 57 00 	jeq %d2,0,80006424 <IfxMultican_Can_Node_init+0x22a>
}


IFX_INLINE void IfxMultican_Node_setFastNode(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.INIT = 1;
8000637a:	8f 89 00 20 	sh %d2,%d9,8
8000637e:	01 e2 00 36 	addsc.a %a3,%a14,%d2,0
        else
        {
            IfxMultican_Node_setFastNode(hwNode, TRUE);
            node->fastNode = TRUE;

            IfxMultican_Node_setNominalBitTiming(hwNode, fcan, config->fdConfig.nominalBaudrate, config->fdConfig.nominalSamplePoint, config->fdConfig.nominalSynchJumpWidth);
80006382:	40 c4       	mov.aa %a4,%a12
80006384:	54 32       	ld.w %d2,[%a3]
80006386:	02 84       	mov %d4,%d8
80006388:	8f 12 40 21 	or %d2,%d2,1
8000638c:	74 32       	st.w [%a3],%d2
    hwNode->CR.B.FDEN = enabled ? 1 : 0;
8000638e:	54 32       	ld.w %d2,[%a3]
80006390:	b7 f2 81 24 	insert %d2,%d2,15,9,1
80006394:	74 32       	st.w [%a3],%d2
    hwNode->CR.B.INIT = 0;
80006396:	54 32       	ld.w %d2,[%a3]
80006398:	8f 12 c0 21 	andn %d2,%d2,1
8000639c:	74 32       	st.w [%a3],%d2
            IfxMultican_Node_setBitTiming(hwNode, fcan, config->baudrate, config->samplePoint, config->synchJumpWidth);
        }
        else
        {
            IfxMultican_Node_setFastNode(hwNode, TRUE);
            node->fastNode = TRUE;
8000639e:	82 12       	mov %d2,1
800063a0:	e9 d2 09 00 	st.b [%a13]9,%d2

            IfxMultican_Node_setNominalBitTiming(hwNode, fcan, config->fdConfig.nominalBaudrate, config->fdConfig.nominalSamplePoint, config->fdConfig.nominalSynchJumpWidth);
800063a4:	48 55       	ld.w %d5,[%a15]20
800063a6:	b9 f6 1a 00 	ld.hu %d6,[%a15]26
800063aa:	b9 f7 18 00 	ld.hu %d7,[%a15]24
800063ae:	6d ff 6b f6 	call 80005084 <IfxMultican_Node_setNominalBitTiming>
            IfxMultican_Node_setFastBitTiming(hwNode, fcan, config->fdConfig.fastBaudrate, config->fdConfig.fastSamplePoint, config->fdConfig.fastSynchJumpWidth);
800063b2:	40 c4       	mov.aa %a4,%a12
800063b4:	02 84       	mov %d4,%d8
800063b6:	48 75       	ld.w %d5,[%a15]28
800063b8:	b9 f6 22 00 	ld.hu %d6,[%a15]34
800063bc:	b9 f7 20 00 	ld.hu %d7,[%a15]32
800063c0:	6d ff e5 f3 	call 80004b8a <IfxMultican_Node_setFastBitTiming>

            if (config->fdConfig.loopDelayOffset)
800063c4:	b9 f2 24 00 	ld.hu %d2,[%a15]36
800063c8:	76 2f       	jz %d2,800063e6 <IfxMultican_Can_Node_init+0x1ec>
}


IFX_INLINE void IfxMultican_Node_setTransceiverDelayCompensationOffset(Ifx_CAN_N *hwNode, uint16 value)
{
    hwNode->TDCR.B.TDCO = value;
800063ca:	01 ea 00 36 	addsc.a %a3,%a14,%d10,0
800063ce:	19 33 3c 80 	ld.w %d3,[%a3]572
800063d2:	37 23 04 24 	insert %d2,%d3,%d2,8,4
800063d6:	59 32 3c 80 	st.w [%a3]572,%d2
}


IFX_INLINE void IfxMultican_Node_setTransceiverDelayCompensation(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->TDCR.B.TDC = enabled ? 1 : 0;
800063da:	19 32 3c 80 	ld.w %d2,[%a3]572
800063de:	b7 f2 81 27 	insert %d2,%d2,15,15,1
800063e2:	59 32 3c 80 	st.w [%a3]572,%d2
}


IFX_INLINE void IfxMultican_Node_setFrameCounterMode(Ifx_CAN_N *hwNode, IfxMultican_FrameCounterMode mode)
{
    hwNode->FCR.B.CFMOD = mode;
800063e6:	01 ea 00 26 	addsc.a %a2,%a14,%d10,0
}


IFX_INLINE void IfxMultican_Node_disableConfigurationChange(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.CCE = 0U;
800063ea:	8f 89 00 90 	sh %d9,%d9,8
}


IFX_INLINE void IfxMultican_Node_setFrameCounterMode(Ifx_CAN_N *hwNode, IfxMultican_FrameCounterMode mode)
{
    hwNode->FCR.B.CFMOD = mode;
800063ee:	19 22 18 80 	ld.w %d2,[%a2]536
}


IFX_INLINE void IfxMultican_Node_disableConfigurationChange(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.CCE = 0U;
800063f2:	01 e9 00 e6 	addsc.a %a14,%a14,%d9,0
}


IFX_INLINE void IfxMultican_Node_setFrameCounterMode(Ifx_CAN_N *hwNode, IfxMultican_FrameCounterMode mode)
{
    hwNode->FCR.B.CFMOD = mode;
800063f6:	b7 12 82 29 	insert %d2,%d2,1,19,2
800063fa:	59 22 18 80 	st.w [%a2]536,%d2
}


IFX_INLINE void IfxMultican_Node_setFrameCounterInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->FCR.B.CFCIE = enabled ? 1 : 0;
800063fe:	39 f3 3c 00 	ld.bu %d3,[%a15]60
80006402:	7b 00 04 20 	movh %d2,64
80006406:	ab 02 80 33 	sel %d3,%d3,%d2,0
8000640a:	19 22 18 80 	ld.w %d2,[%a2]536
8000640e:	b7 02 01 2b 	insert %d2,%d2,0,22,1
80006412:	a6 32       	or %d2,%d3
80006414:	59 22 18 80 	st.w [%a2]536,%d2
}


IFX_INLINE void IfxMultican_Node_disableConfigurationChange(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.CCE = 0U;
80006418:	54 e2       	ld.w %d2,[%a14]
8000641a:	8f 02 c4 21 	andn %d2,%d2,64
8000641e:	74 e2       	st.w [%a14],%d2

    IfxMultican_Node_disableConfigurationChange(hwNode);
    /* Configuration of the TTCAN Functionality: Not implemented */

    return status;
}
80006420:	02 f2       	mov %d2,%d15
80006422:	00 90       	ret 

        float32         fcan = IfxMultican_Can_getModuleFrequency(&mcan);

        if (!config->flexibleDataRate)
        {
            IfxMultican_Node_setBitTiming(hwNode, fcan, config->baudrate, config->samplePoint, config->synchJumpWidth);
80006424:	40 c4       	mov.aa %a4,%a12
80006426:	02 84       	mov %d4,%d8
80006428:	48 25       	ld.w %d5,[%a15]8
8000642a:	b9 f6 0c 00 	ld.hu %d6,[%a15]12
8000642e:	b9 f7 0e 00 	ld.hu %d7,[%a15]14
80006432:	6d ff 2f f1 	call 80004690 <IfxMultican_Node_setBitTiming>
80006436:	3c d8       	j 800063e6 <IfxMultican_Can_Node_init+0x1ec>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
80006438:	6d 00 8d 0c 	call 80007d52 <IfxScuCcu_getPllErayFrequency>
8000643c:	02 28       	mov %d8,%d2
8000643e:	3c 9a       	j 80006372 <IfxMultican_Can_Node_init+0x178>
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006440:	b5 a2 04 00 	st.a [%sp]4,%a2
80006444:	6d 00 99 0d 	call 80007f76 <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
80006448:	91 30 00 3f 	movh.a %a3,61443
8000644c:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006450:	54 34       	ld.w %d4,[%a3]
    {
        canFrequency = 0.0f;
80006452:	82 03       	mov %d3,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
80006454:	8f f4 00 41 	and %d4,%d4,15
80006458:	99 a2 04 00 	ld.a %a2,[%sp]4
8000645c:	76 48       	jz %d4,8000646c <IfxMultican_Can_Node_init+0x272>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
8000645e:	54 38       	ld.w %d8,[%a3]
80006460:	8f f8 00 81 	and %d8,%d8,15
80006464:	4b 08 41 81 	itof %d8,%d8
80006468:	4b 82 51 30 	div.f %d3,%d2,%d8
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
8000646c:	19 22 0c 00 	ld.w %d2,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80006470:	19 28 0c 00 	ld.w %d8,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
80006474:	37 02 62 27 	extr.u %d2,%d2,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80006478:	b7 08 16 85 	insert %d8,%d8,0,10,22
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
8000647c:	df 12 13 00 	jeq %d2,1,800064a2 <IfxMultican_Can_Node_init+0x2a8>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
80006480:	4b 08 41 81 	itof %d8,%d8
80006484:	7b 00 a8 43 	movh %d4,14976
80006488:	4b 48 41 80 	mul.f %d8,%d8,%d4
8000648c:	4b 38 41 80 	mul.f %d8,%d8,%d3

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
80006490:	df 22 70 ff 	jne %d2,2,80006370 <IfxMultican_Can_Node_init+0x176>
80006494:	1d ff 6f ff 	j 80006372 <IfxMultican_Can_Node_init+0x178>
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
80006498:	6d 00 3d 0c 	call 80007d12 <IfxScuCcu_getOsc0Frequency>
8000649c:	02 28       	mov %d8,%d2
8000649e:	1d ff 6a ff 	j 80006372 <IfxMultican_Can_Node_init+0x178>
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
800064a2:	3b 00 40 20 	mov %d2,1024
800064a6:	0b 82 80 80 	sub %d8,%d2,%d8
800064aa:	4b 08 41 81 	itof %d8,%d8
800064ae:	4b 83 51 80 	div.f %d8,%d3,%d8
800064b2:	1d ff 60 ff 	j 80006372 <IfxMultican_Can_Node_init+0x178>

800064b6 <IfxMultican_Can_Node_initConfig>:
}


void IfxMultican_Can_Node_initConfig(IfxMultican_Can_NodeConfig *config, IfxMultican_Can *mcan)
{
    config->module                         = mcan->mcan;
800064b6:	4c 50       	ld.w %d15,[%a5]0
    config->nodeId                         = IfxMultican_NodeId_0;

    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
800064b8:	7b 80 00 40 	movh %d4,8
    config->samplePoint                    = 8000;
800064bc:	3b 00 f4 21 	mov %d2,8000
    config->nodeId                         = IfxMultican_NodeId_0;

    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
800064c0:	1b 04 12 4a 	addi %d4,%d4,-24288
}


void IfxMultican_Can_Node_initConfig(IfxMultican_Can_NodeConfig *config, IfxMultican_Can *mcan)
{
    config->module                         = mcan->mcan;
800064c4:	6c 40       	st.w [%a4]0,%d15

    config->nodeId                         = IfxMultican_NodeId_0;
800064c6:	82 0f       	mov %d15,0
800064c8:	2c 44       	st.b [%a4]4,%d15

    config->loopBackMode                   = FALSE;
800064ca:	2c 46       	st.b [%a4]6,%d15
    config->analyzerMode                   = FALSE;
800064cc:	2c 45       	st.b [%a4]5,%d15

    config->baudrate                       = 500000;
    config->samplePoint                    = 8000;
800064ce:	f9 42 0c 00 	st.h [%a4]12,%d2
    config->synchJumpWidth                 = 2000;

    config->flexibleDataRate               = FALSE;
800064d2:	e9 4f 10 00 	st.b [%a4]16,%d15

    config->fdConfig.nominalBaudrate       = 500000;
    config->fdConfig.nominalSynchJumpWidth = 2000;
    config->fdConfig.nominalSamplePoint    = 8000;
800064d6:	f9 42 1a 00 	st.h [%a4]26,%d2
    config->fdConfig.fastBaudrate          = 1000000;
800064da:	8f 14 00 f0 	sh %d15,%d4,1
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
800064de:	f9 42 22 00 	st.h [%a4]34,%d2
    config->fdConfig.loopDelayOffset       = 0;

    config->rxPin                          = NULL_PTR;
800064e2:	82 02       	mov %d2,0
    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
    config->samplePoint                    = 8000;
    config->synchJumpWidth                 = 2000;
800064e4:	3b 00 7d 30 	mov %d3,2000
    config->flexibleDataRate               = FALSE;

    config->fdConfig.nominalBaudrate       = 500000;
    config->fdConfig.nominalSynchJumpWidth = 2000;
    config->fdConfig.nominalSamplePoint    = 8000;
    config->fdConfig.fastBaudrate          = 1000000;
800064e8:	6c 47       	st.w [%a4]28,%d15
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;

    config->rxPin                          = NULL_PTR;
800064ea:	59 42 28 00 	st.w [%a4]40,%d2
    config->fdConfig.nominalSynchJumpWidth = 2000;
    config->fdConfig.nominalSamplePoint    = 8000;
    config->fdConfig.fastBaudrate          = 1000000;
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;
800064ee:	82 0f       	mov %d15,0

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
    config->txPin                          = NULL_PTR;
800064f0:	59 42 30 00 	st.w [%a4]48,%d2
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
800064f4:	3b 00 f8 2f 	mov %d2,-128
    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
    config->samplePoint                    = 8000;
    config->synchJumpWidth                 = 2000;
800064f8:	f9 43 0e 00 	st.h [%a4]14,%d3

    config->flexibleDataRate               = FALSE;

    config->fdConfig.nominalBaudrate       = 500000;
    config->fdConfig.nominalSynchJumpWidth = 2000;
800064fc:	f9 43 18 00 	st.h [%a4]24,%d3
    config->fdConfig.nominalSamplePoint    = 8000;
    config->fdConfig.fastBaudrate          = 1000000;
    config->fdConfig.fastSynchJumpWidth    = 2000;
80006500:	f9 43 20 00 	st.h [%a4]32,%d3
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;
80006504:	f9 4f 24 00 	st.h [%a4]36,%d15

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
80006508:	3b 00 01 30 	mov %d3,16
    config->txPin                          = NULL_PTR;
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
8000650c:	e9 42 34 00 	st.b [%a4]52,%d2
    config->pinDriver                      = IfxPort_PadDriver_cmosAutomotiveSpeed2; //previously hardcoded as this value for Tx pins.Now pad driver option is being given in IfxMultican_Node_initRxPin() and IfxMultican_Node_initTxPin()

    config->transferInterrupt.enabled      = FALSE;
80006510:	e9 4f 36 00 	st.b [%a4]54,%d15

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
    config->txPin                          = NULL_PTR;
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
    config->pinDriver                      = IfxPort_PadDriver_cmosAutomotiveSpeed2; //previously hardcoded as this value for Tx pins.Now pad driver option is being given in IfxMultican_Node_initRxPin() and IfxMultican_Node_initTxPin()
80006514:	82 12       	mov %d2,1

    config->transferInterrupt.enabled      = FALSE;
    config->transferInterrupt.srcId        = IfxMultican_SrcId_0;
80006516:	e9 4f 37 00 	st.b [%a4]55,%d15

    config->lastErrorCodeInterrupt.enabled = FALSE;
8000651a:	e9 4f 38 00 	st.b [%a4]56,%d15
    config->lastErrorCodeInterrupt.srcId   = IfxMultican_SrcId_0;
8000651e:	e9 4f 39 00 	st.b [%a4]57,%d15

    config->alertInterrupt.enabled         = FALSE;
80006522:	e9 4f 3a 00 	st.b [%a4]58,%d15
    config->alertInterrupt.srcId           = IfxMultican_SrcId_0;
80006526:	e9 4f 3b 00 	st.b [%a4]59,%d15

    config->frameCounterInterrupt.enabled  = FALSE;
8000652a:	e9 4f 3c 00 	st.b [%a4]60,%d15
    config->frameCounterInterrupt.srcId    = IfxMultican_SrcId_0;
8000652e:	e9 4f 3d 00 	st.b [%a4]61,%d15

    config->timerInterrupt.enabled         = FALSE;
80006532:	e9 4f 3e 00 	st.b [%a4]62,%d15
    config->timerInterrupt.srcId           = IfxMultican_SrcId_0;
80006536:	e9 4f 3f 00 	st.b [%a4]63,%d15

    config->errorWarningLevel              = 96;
8000653a:	da 60       	mov %d15,96
    config->nodeId                         = IfxMultican_NodeId_0;

    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
8000653c:	59 44 08 00 	st.w [%a4]8,%d4
    config->samplePoint                    = 8000;
    config->synchJumpWidth                 = 2000;

    config->flexibleDataRate               = FALSE;

    config->fdConfig.nominalBaudrate       = 500000;
80006540:	59 44 14 00 	st.w [%a4]20,%d4
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
80006544:	e9 43 2c 00 	st.b [%a4]44,%d3
    config->txPin                          = NULL_PTR;
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
    config->pinDriver                      = IfxPort_PadDriver_cmosAutomotiveSpeed2; //previously hardcoded as this value for Tx pins.Now pad driver option is being given in IfxMultican_Node_initRxPin() and IfxMultican_Node_initTxPin()
80006548:	e9 42 00 10 	st.b [%a4]64,%d2
    config->frameCounterInterrupt.srcId    = IfxMultican_SrcId_0;

    config->timerInterrupt.enabled         = FALSE;
    config->timerInterrupt.srcId           = IfxMultican_SrcId_0;

    config->errorWarningLevel              = 96;
8000654c:	e9 4f 35 00 	st.b [%a4]53,%d15
80006550:	00 90       	ret 

80006552 <IfxMultican_Can_Node_sendToBusOff>:
{
    uint32 i, counter;

    for (counter = 1; counter < 256; counter = counter * 2)
    {
        node->node->ECNT.B.TEC = counter;
80006552:	cc 41       	ld.a %a15,[%a4]4
80006554:	4c f5       	ld.w %d15,[%a15]20
80006556:	b7 1f 08 f4 	insert %d15,%d15,1,8,8
8000655a:	68 5f       	st.w [%a15]20,%d15
8000655c:	cc 41       	ld.a %a15,[%a4]4
8000655e:	4c f5       	ld.w %d15,[%a15]20
80006560:	b7 2f 08 f4 	insert %d15,%d15,2,8,8
80006564:	68 5f       	st.w [%a15]20,%d15
80006566:	cc 41       	ld.a %a15,[%a4]4
80006568:	4c f5       	ld.w %d15,[%a15]20
8000656a:	b7 4f 08 f4 	insert %d15,%d15,4,8,8
8000656e:	68 5f       	st.w [%a15]20,%d15
80006570:	cc 41       	ld.a %a15,[%a4]4
80006572:	4c f5       	ld.w %d15,[%a15]20
80006574:	b7 8f 08 f4 	insert %d15,%d15,8,8,8
80006578:	68 5f       	st.w [%a15]20,%d15
8000657a:	cc 41       	ld.a %a15,[%a4]4
8000657c:	4c f5       	ld.w %d15,[%a15]20
8000657e:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
80006582:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
80006586:	68 5f       	st.w [%a15]20,%d15
80006588:	cc 41       	ld.a %a15,[%a4]4
8000658a:	4c f5       	ld.w %d15,[%a15]20
8000658c:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
80006590:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80006594:	68 5f       	st.w [%a15]20,%d15
80006596:	cc 41       	ld.a %a15,[%a4]4
80006598:	4c f5       	ld.w %d15,[%a15]20
8000659a:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
8000659e:	b7 ff 01 f7 	insert %d15,%d15,15,14,1
800065a2:	68 5f       	st.w [%a15]20,%d15
800065a4:	cc 41       	ld.a %a15,[%a4]4
800065a6:	4c f5       	ld.w %d15,[%a15]20
800065a8:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
800065ac:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
800065b0:	68 5f       	st.w [%a15]20,%d15
    }

    for (i = 0; i < 10; ++i)
    {
        node->node->ECNT.B.TEC = ++counter;
800065b2:	cc 41       	ld.a %a15,[%a4]4
800065b4:	4c f5       	ld.w %d15,[%a15]20
800065b6:	b7 1f 08 f4 	insert %d15,%d15,1,8,8
800065ba:	68 5f       	st.w [%a15]20,%d15
800065bc:	cc 41       	ld.a %a15,[%a4]4
800065be:	4c f5       	ld.w %d15,[%a15]20
800065c0:	b7 2f 08 f4 	insert %d15,%d15,2,8,8
800065c4:	68 5f       	st.w [%a15]20,%d15
800065c6:	cc 41       	ld.a %a15,[%a4]4
800065c8:	4c f5       	ld.w %d15,[%a15]20
800065ca:	b7 3f 08 f4 	insert %d15,%d15,3,8,8
800065ce:	68 5f       	st.w [%a15]20,%d15
800065d0:	cc 41       	ld.a %a15,[%a4]4
800065d2:	4c f5       	ld.w %d15,[%a15]20
800065d4:	b7 4f 08 f4 	insert %d15,%d15,4,8,8
800065d8:	68 5f       	st.w [%a15]20,%d15
800065da:	cc 41       	ld.a %a15,[%a4]4
800065dc:	4c f5       	ld.w %d15,[%a15]20
800065de:	b7 5f 08 f4 	insert %d15,%d15,5,8,8
800065e2:	68 5f       	st.w [%a15]20,%d15
800065e4:	cc 41       	ld.a %a15,[%a4]4
800065e6:	4c f5       	ld.w %d15,[%a15]20
800065e8:	b7 6f 08 f4 	insert %d15,%d15,6,8,8
800065ec:	68 5f       	st.w [%a15]20,%d15
800065ee:	cc 41       	ld.a %a15,[%a4]4
800065f0:	4c f5       	ld.w %d15,[%a15]20
800065f2:	b7 7f 08 f4 	insert %d15,%d15,7,8,8
800065f6:	68 5f       	st.w [%a15]20,%d15
800065f8:	cc 41       	ld.a %a15,[%a4]4
800065fa:	4c f5       	ld.w %d15,[%a15]20
800065fc:	b7 8f 08 f4 	insert %d15,%d15,8,8,8
80006600:	68 5f       	st.w [%a15]20,%d15
80006602:	cc 41       	ld.a %a15,[%a4]4
80006604:	4c f5       	ld.w %d15,[%a15]20
80006606:	b7 9f 08 f4 	insert %d15,%d15,9,8,8
8000660a:	68 5f       	st.w [%a15]20,%d15
8000660c:	cc 41       	ld.a %a15,[%a4]4
8000660e:	4c f5       	ld.w %d15,[%a15]20
80006610:	b7 af 08 f4 	insert %d15,%d15,10,8,8
80006614:	68 5f       	st.w [%a15]20,%d15
80006616:	00 90       	ret 

80006618 <IfxMultican_Can_getConfig>:
}


void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);
80006618:	d4 42       	ld.a %a2,[%a4]
    }
}


void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
8000661a:	20 08       	sub.a %sp,8
8000661c:	40 5f       	mov.aa %a15,%a5
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
8000661e:	19 2f 08 70 	ld.w %d15,[%a2]456
80006622:	16 0f       	and %d15,15
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);
80006624:	2c 54       	st.b [%a5]4,%d15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
80006626:	1e 18       	jeq %d15,1,80006636 <IfxMultican_Can_getConfig+0x1e>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
80006628:	df 2f 33 00 	jeq %d15,2,8000668e <IfxMultican_Can_getConfig+0x76>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
8000662c:	df 4f 35 00 	jeq %d15,4,80006696 <IfxMultican_Can_getConfig+0x7e>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
80006630:	82 0f       	mov %d15,0
80006632:	68 2f       	st.w [%a15]8,%d15
80006634:	00 90       	ret 
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006636:	b5 a4 04 00 	st.a [%sp]4,%a4
8000663a:	6d 00 9e 0c 	call 80007f76 <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
8000663e:	91 30 00 2f 	movh.a %a2,61443
80006642:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006646:	54 23       	ld.w %d3,[%a2]
    {
        canFrequency = 0.0f;
80006648:	82 0f       	mov %d15,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
8000664a:	8f f3 00 31 	and %d3,%d3,15
8000664e:	99 a4 04 00 	ld.a %a4,[%sp]4
80006652:	76 37       	jz %d3,80006660 <IfxMultican_Can_getConfig+0x48>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
80006654:	4c 20       	ld.w %d15,[%a2]0
80006656:	16 0f       	and %d15,15
80006658:	4b 0f 41 f1 	itof %d15,%d15
8000665c:	4b f2 51 f0 	div.f %d15,%d2,%d15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
    {
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
80006660:	d4 42       	ld.a %a2,[%a4]
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
80006662:	19 22 0c 00 	ld.w %d2,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80006666:	19 23 0c 00 	ld.w %d3,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
8000666a:	37 02 62 27 	extr.u %d2,%d2,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
8000666e:	b7 03 16 35 	insert %d3,%d3,0,10,22
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
80006672:	df 12 16 00 	jeq %d2,1,8000669e <IfxMultican_Can_getConfig+0x86>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
80006676:	df 22 dd ff 	jne %d2,2,80006630 <IfxMultican_Can_getConfig+0x18>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
8000667a:	4b 03 41 31 	itof %d3,%d3
8000667e:	7b 00 a8 23 	movh %d2,14976
80006682:	4b 23 41 30 	mul.f %d3,%d3,%d2
80006686:	4b f3 41 f0 	mul.f %d15,%d3,%d15
8000668a:	68 2f       	st.w [%a15]8,%d15
8000668c:	00 90       	ret 
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
8000668e:	6d 00 42 0b 	call 80007d12 <IfxScuCcu_getOsc0Frequency>
80006692:	68 22       	st.w [%a15]8,%d2
80006694:	00 90       	ret 
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
80006696:	6d 00 5e 0b 	call 80007d52 <IfxScuCcu_getPllErayFrequency>
8000669a:	68 22       	st.w [%a15]8,%d2
8000669c:	00 90       	ret 
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
8000669e:	3b 00 40 20 	mov %d2,1024
800066a2:	0b 32 80 30 	sub %d3,%d2,%d3
800066a6:	4b 03 41 31 	itof %d3,%d3
800066aa:	4b 3f 51 f0 	div.f %d15,%d15,%d3
800066ae:	68 2f       	st.w [%a15]8,%d15
800066b0:	00 90       	ret 

800066b2 <IfxMultican_Can_getModuleFrequency>:
}


void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);
800066b2:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
800066b4:	19 ff 08 70 	ld.w %d15,[%a15]456
800066b8:	16 0f       	and %d15,15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
800066ba:	1e 17       	jeq %d15,1,800066c8 <IfxMultican_Can_getModuleFrequency+0x16>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
800066bc:	df 2f 2c 00 	jeq %d15,2,80006714 <IfxMultican_Can_getModuleFrequency+0x62>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
800066c0:	df 4f 2c 00 	jeq %d15,4,80006718 <IfxMultican_Can_getModuleFrequency+0x66>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
800066c4:	82 02       	mov %d2,0
800066c6:	00 90       	ret 
800066c8:	40 4f       	mov.aa %a15,%a4
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800066ca:	6d 00 56 0c 	call 80007f76 <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
800066ce:	91 30 00 2f 	movh.a %a2,61443
800066d2:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800066d6:	54 23       	ld.w %d3,[%a2]
    {
        canFrequency = 0.0f;
800066d8:	82 0f       	mov %d15,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
800066da:	8f f3 00 31 	and %d3,%d3,15
800066de:	76 37       	jz %d3,800066ec <IfxMultican_Can_getModuleFrequency+0x3a>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
800066e0:	4c 20       	ld.w %d15,[%a2]0
800066e2:	16 0f       	and %d15,15
800066e4:	4b 0f 41 f1 	itof %d15,%d15
800066e8:	4b f2 51 f0 	div.f %d15,%d2,%d15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
    {
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
800066ec:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
800066ee:	48 33       	ld.w %d3,[%a15]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
800066f0:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
800066f2:	37 03 62 37 	extr.u %d3,%d3,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
800066f6:	b7 02 16 25 	insert %d2,%d2,0,10,22
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
800066fa:	df 13 11 00 	jeq %d3,1,8000671c <IfxMultican_Can_getModuleFrequency+0x6a>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
800066fe:	4b 02 41 21 	itof %d2,%d2
80006702:	7b 00 a8 43 	movh %d4,14976
80006706:	4b 42 41 20 	mul.f %d2,%d2,%d4
8000670a:	4b f2 41 20 	mul.f %d2,%d2,%d15

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
8000670e:	df 23 db ff 	jne %d3,2,800066c4 <IfxMultican_Can_getModuleFrequency+0x12>
    IfxMultican_Can_Config config;

    IfxMultican_Can_getConfig(mcan, &config);

    return config.moduleFreq;
}
80006712:	00 90       	ret 
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
80006714:	1d 00 ff 0a 	j 80007d12 <IfxScuCcu_getOsc0Frequency>
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
80006718:	1d 00 1d 0b 	j 80007d52 <IfxScuCcu_getPllErayFrequency>
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
8000671c:	3b 00 40 30 	mov %d3,1024
80006720:	0b 23 80 20 	sub %d2,%d3,%d2
80006724:	4b 02 41 21 	itof %d2,%d2
80006728:	4b 2f 51 20 	div.f %d2,%d15,%d2
8000672c:	00 90       	ret 

8000672e <IfxMultican_Can_initModule>:
}


IfxMultican_Status IfxMultican_Can_initModule(IfxMultican_Can *mcan, const IfxMultican_Can_Config *config)
{
    Ifx_CAN *mcanSFR = config->module;
8000672e:	cc 50       	ld.a %a15,[%a5]0
    mcan->mcan = mcanSFR;

    uint16   stepValue, dividerMode, i;

    /* currently supports only fclc */
    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
80006730:	0c 54       	ld.bu %d15,[%a5]4
    return config.moduleFreq;
}


IfxMultican_Status IfxMultican_Can_initModule(IfxMultican_Can *mcan, const IfxMultican_Can_Config *config)
{
80006732:	40 4d       	mov.aa %a13,%a4
    Ifx_CAN *mcanSFR = config->module;

    mcan->mcan = mcanSFR;
80006734:	ec 40       	st.a [%a4]0,%a15
    return config.moduleFreq;
}


IfxMultican_Status IfxMultican_Can_initModule(IfxMultican_Can *mcan, const IfxMultican_Can_Config *config)
{
80006736:	40 5c       	mov.aa %a12,%a5
    Ifx_CAN *mcanSFR = config->module;
80006738:	40 f2       	mov.aa %a2,%a15
    mcan->mcan = mcanSFR;

    uint16   stepValue, dividerMode, i;

    /* currently supports only fclc */
    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
8000673a:	df 1f 51 00 	jeq %d15,1,800067dc <IfxMultican_Can_initModule+0xae>
}


IFX_INLINE void IfxMultican_waitListReady(Ifx_CAN *mcan)
{
    while (mcan->PANCTR.B.BUSY != 0)
8000673e:	19 2f 04 70 	ld.w %d15,[%a2]452
80006742:	37 0f 61 f4 	extr.u %d15,%d15,8,1
80006746:	ee fc       	jnz %d15,8000673e <IfxMultican_Can_initModule+0x10>
}


IFX_INLINE void IfxMultican_clearPendingMessageNotification(Ifx_CAN *mcan, uint16 list)
{
    mcan->MSPND[list].U = 0x0;
80006748:	59 ff 00 50 	st.w [%a15]320,%d15
8000674c:	59 ff 04 50 	st.w [%a15]324,%d15
80006750:	59 ff 08 50 	st.w [%a15]328,%d15
80006754:	59 ff 0c 50 	st.w [%a15]332,%d15
80006758:	59 ff 10 50 	st.w [%a15]336,%d15
8000675c:	59 ff 14 50 	st.w [%a15]340,%d15
80006760:	59 ff 18 50 	st.w [%a15]344,%d15
80006764:	59 ff 1c 50 	st.w [%a15]348,%d15
}


IFX_INLINE void IfxMultican_clearMessagePendingSeletor(Ifx_CAN *mcan)
{
    mcan->MCR.B.MPSEL = 0x0U;
80006768:	19 ff 08 70 	ld.w %d15,[%a15]456
8000676c:	b7 0f 04 f6 	insert %d15,%d15,0,12,4
80006770:	59 ff 08 70 	st.w [%a15]456,%d15
}


IFX_INLINE void IfxMultican_setMessageIndexMask(Ifx_CAN *mcan, uint32 mask)
{
    mcan->MSIMASK.U = mask;
80006774:	82 ff       	mov %d15,-1
80006776:	59 ff 00 70 	st.w [%a15]448,%d15
8000677a:	82 0f       	mov %d15,0
8000677c:	3c 0a       	j 80006790 <IfxMultican_Can_initModule+0x62>
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
8000677e:	54 22       	ld.w %d2,[%a2]
80006780:	c2 1f       	add %d15,1
80006782:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80006786:	74 22       	st.w [%a2],%d2
    IfxMultican_setMessageIndexMask(mcanSFR, 0xFFFFFFFF);

    /* Configure interrupt node pointers */
    IfxMultican_SrcId srcId;

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
80006788:	8b 0f 21 22 	ne %d2,%d15,16
8000678c:	df 02 26 00 	jeq %d2,0,800067d8 <IfxMultican_Can_initModule+0xaa>
    {
        volatile Ifx_SRC_SRCR *srcPointer = IfxMultican_getSrcPointer(mcanSFR, srcId);
80006790:	8f ff 0f 41 	and %d4,%d15,255
80006794:	40 f4       	mov.aa %a4,%a15
80006796:	6d ff 28 f6 	call 800053e6 <IfxMultican_getSrcPointer>
8000679a:	90 c3       	addsc.a %a3,%a12,%d15,2
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000679c:	54 24       	ld.w %d4,[%a2]
        IfxSrc_init(srcPointer, config->nodePointer[srcId].typeOfService, config->nodePointer[srcId].priority);
8000679e:	b9 32 0c 00 	ld.hu %d2,[%a3]12
800067a2:	8f f4 cf 41 	andn %d4,%d4,255
800067a6:	8f f2 0f 51 	and %d5,%d2,255
800067aa:	a6 54       	or %d4,%d5
800067ac:	39 33 0e 00 	ld.bu %d3,[%a3]14
800067b0:	74 24       	st.w [%a2],%d4
    src->B.TOS  = typOfService;
800067b2:	54 24       	ld.w %d4,[%a2]
800067b4:	37 34 82 35 	insert %d3,%d4,%d3,11,2
800067b8:	74 23       	st.w [%a2],%d3
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800067ba:	54 23       	ld.w %d3,[%a2]
800067bc:	b7 f3 81 3c 	insert %d3,%d3,15,25,1
800067c0:	74 23       	st.w [%a2],%d3

        if (config->nodePointer[srcId].priority)
800067c2:	df 02 de ff 	jne %d2,0,8000677e <IfxMultican_Can_initModule+0x50>
}


IFX_INLINE void IfxSrc_disable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 0;
800067c6:	54 22       	ld.w %d2,[%a2]
800067c8:	c2 1f       	add %d15,1
800067ca:	b7 02 01 25 	insert %d2,%d2,0,10,1
800067ce:	74 22       	st.w [%a2],%d2
    IfxMultican_setMessageIndexMask(mcanSFR, 0xFFFFFFFF);

    /* Configure interrupt node pointers */
    IfxMultican_SrcId srcId;

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
800067d0:	8b 0f 21 22 	ne %d2,%d15,16
800067d4:	df 02 de ff 	jne %d2,0,80006790 <IfxMultican_Can_initModule+0x62>
            IfxSrc_disable(srcPointer);
        }
    }

    return IfxMultican_Status_ok;
}
800067d8:	82 02       	mov %d2,0
800067da:	00 90       	ret 
        {
            uint16  stepN, stepF;
            boolean normalDiv;
            float32 freqN, freqF;

            float32 fsys = IfxScuCcu_getSpbFrequency();
800067dc:	6d 00 28 0c 	call 8000802c <IfxScuCcu_getSpbFrequency>

            /* Normal divider mode */
            stepN = (uint16)__minf(__maxf(0, 1024.0f - (fsys / config->moduleFreq)), 1023);
800067e0:	19 c3 08 00 	ld.w %d3,[%a12]8
800067e4:	7b 00 48 64 	movh %d6,17536
800067e8:	4b 32 51 40 	div.f %d4,%d2,%d3
800067ec:	7b 00 f8 53 	movh %d5,16256
800067f0:	4b 64 01 f0 	cmp.f %d15,%d4,%d6
800067f4:	4b 54 01 70 	cmp.f %d7,%d4,%d5
800067f8:	87 f7 22 71 	or.t %d7,%d7,2,%d15,2
800067fc:	3b f0 3f f0 	mov %d15,1023
80006800:	df 07 15 00 	jeq %d7,0,8000682a <IfxMultican_Can_initModule+0xfc>
80006804:	6b 04 31 f6 	sub.f %d15,%d6,%d4
80006808:	3b 00 40 50 	mov %d5,1024
8000680c:	4b 0f 71 f1 	ftouz %d15,%d15
80006810:	4b 64 01 70 	cmp.f %d7,%d4,%d6
80006814:	37 0f 70 f0 	extr.u %d15,%d15,0,16
80006818:	87 77 a0 70 	or.t %d7,%d7,0,%d7,1
8000681c:	a2 f5       	sub %d5,%d15
8000681e:	4b 05 41 51 	itof %d5,%d5
80006822:	ab 0f 80 f7 	sel %d15,%d7,%d15,0
80006826:	2b 65 40 57 	sel %d5,%d7,%d5,%d6
            freqN = fsys / (1024 - stepN);

            /* Fractional divider mode */
            stepF       = (uint16)__minf(((config->moduleFreq * 1024) / fsys), 1023);
8000682a:	7b 00 48 84 	movh %d8,17536
8000682e:	4b 83 41 80 	mul.f %d8,%d3,%d8
80006832:	7b 00 48 64 	movh %d6,17536
80006836:	4b 28 51 80 	div.f %d8,%d8,%d2
8000683a:	1b 06 00 6c 	addi %d6,%d6,-16384

            float32 fsys = IfxScuCcu_getSpbFrequency();

            /* Normal divider mode */
            stepN = (uint16)__minf(__maxf(0, 1024.0f - (fsys / config->moduleFreq)), 1023);
            freqN = fsys / (1024 - stepN);
8000683e:	4b 52 51 50 	div.f %d5,%d2,%d5

            /* Fractional divider mode */
            stepF       = (uint16)__minf(((config->moduleFreq * 1024) / fsys), 1023);
80006842:	4b 68 01 70 	cmp.f %d7,%d8,%d6
80006846:	4b 08 71 81 	ftouz %d8,%d8
8000684a:	37 08 70 80 	extr.u %d8,%d8,0,16
8000684e:	4b 08 41 41 	itof %d4,%d8
80006852:	6f 07 05 80 	jnz.t %d7,0,8000685c <IfxMultican_Can_initModule+0x12e>
80006856:	02 64       	mov %d4,%d6
80006858:	3b f0 3f 80 	mov %d8,1023
8000685c:	7b 00 a8 63 	movh %d6,14976
80006860:	4b 62 41 20 	mul.f %d2,%d2,%d6
            freqF       = (fsys * stepF) / 1024;

            normalDiv   = (__absf(config->moduleFreq - freqN) <= __absf(config->moduleFreq - freqF));
80006864:	6b 05 31 53 	sub.f %d5,%d3,%d5
80006868:	6b 42 71 23 	msub.f %d2,%d3,%d2,%d4
8000686c:	b7 05 81 5f 	insert %d5,%d5,0,31,1
80006870:	82 1a       	mov %d10,1
80006872:	b7 02 81 2f 	insert %d2,%d2,0,31,1

            stepValue   = (normalDiv != 0) ? stepN : stepF;
80006876:	4b 25 01 20 	cmp.f %d2,%d5,%d2
8000687a:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
8000687e:	2b 8f 40 82 	sel %d8,%d2,%d15,%d8
80006882:	ab 2a 80 a2 	sel %d10,%d2,%d10,2
            dividerMode = (normalDiv != 0) ? 1 : 2;
        }

        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006886:	6d 00 5f 17 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
8000688a:	02 24       	mov %d4,%d2

            stepValue   = (normalDiv != 0) ? stepN : stepF;
            dividerMode = (normalDiv != 0) ? 1 : 2;
        }

        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000688c:	02 29       	mov %d9,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
8000688e:	6d 00 5d 16 	call 80009548 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxMultican_enableModule(Ifx_CAN *mcan)
{
    mcan->CLC.B.DISR = 0U;
80006892:	4c f0       	ld.w %d15,[%a15]0
80006894:	8f 1f c0 f1 	andn %d15,%d15,1
80006898:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxMultican_disableSleepMode(Ifx_CAN *mcan)
{
    mcan->CLC.B.EDIS = 1U;
8000689a:	4c f0       	ld.w %d15,[%a15]0
8000689c:	96 08       	or %d15,8
8000689e:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE boolean IfxMultican_isModuleEnabled(Ifx_CAN *mcan)
{
    return mcan->CLC.B.DISS == 0;
800068a0:	4c f0       	ld.w %d15,[%a15]0
        /* Enable module, disregard Sleep Mode request */
        IfxMultican_enableModule(mcanSFR);
        IfxMultican_disableSleepMode(mcanSFR);

        /* Wait until module is enabled */
        while (IfxMultican_isModuleEnabled(mcanSFR) == FALSE)
800068a2:	6f 1f ff ff 	jnz.t %d15,1,800068a0 <IfxMultican_Can_initModule+0x172>
}


IFX_INLINE void IfxMultican_setInputClock(Ifx_CAN *mcan, IfxMultican_ClockSelect clockSelect)
{
    mcan->MCR.B.CLKSEL = clockSelect;
800068a6:	19 ff 08 70 	ld.w %d15,[%a15]456
}


IFX_INLINE void IfxMultican_setFractionalDividerMode(Ifx_CAN *mcan, uint16 mode)
{
    mcan->FDR.B.DM = mode;
800068aa:	8f ea 00 20 	sh %d2,%d10,14
}


IFX_INLINE void IfxMultican_setInputClock(Ifx_CAN *mcan, IfxMultican_ClockSelect clockSelect)
{
    mcan->MCR.B.CLKSEL = clockSelect;
800068ae:	8f ff c0 f1 	andn %d15,%d15,15
800068b2:	59 ff 08 70 	st.w [%a15]456,%d15
800068b6:	19 ff 08 70 	ld.w %d15,[%a15]456
        IfxMultican_setInputClock(mcanSFR, IfxMultican_ClockSelect_noClock);
        IfxMultican_setInputClock(mcanSFR, IfxMultican_ClockSelect_fclc); /* Selects Fclc = Fspb */

        IfxMultican_setFractionalDividerStepValue(mcanSFR, stepValue);
        IfxMultican_setFractionalDividerMode(mcanSFR, dividerMode);
        IfxScuWdt_setCpuEndinit(passwd);
800068ba:	02 94       	mov %d4,%d9
800068bc:	b7 1f 04 f0 	insert %d15,%d15,1,0,4
800068c0:	59 ff 08 70 	st.w [%a15]456,%d15
}


IFX_INLINE void IfxMultican_setFractionalDividerStepValue(Ifx_CAN *mcan, uint16 stepValue)
{
    mcan->FDR.B.STEP = stepValue;
800068c4:	4c f3       	ld.w %d15,[%a15]12
800068c6:	37 8f 0a 80 	insert %d8,%d15,%d8,0,10
800068ca:	68 38       	st.w [%a15]12,%d8
}


IFX_INLINE void IfxMultican_setFractionalDividerMode(Ifx_CAN *mcan, uint16 mode)
{
    mcan->FDR.B.DM = mode;
800068cc:	4c f3       	ld.w %d15,[%a15]12
800068ce:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
800068d2:	a6 2f       	or %d15,%d2
800068d4:	68 3f       	st.w [%a15]12,%d15
800068d6:	6d 00 7d 18 	call 800099d0 <IfxScuWdt_setCpuEndinit>
800068da:	d4 d2       	ld.a %a2,[%a13]
800068dc:	1d ff 31 ff 	j 8000673e <IfxMultican_Can_initModule+0x10>

800068e0 <IfxMultican_Can_initModuleConfig>:
    IfxMultican_SrcId srcId;
    /** - take over module pointer */
    config->module = mcan;

    /** - Selected input clock is from CLC */
    config->clockSelect = IfxMultican_ClockSelect_fclc;
800068e0:	82 1f       	mov %d15,1
800068e2:	2c 44       	st.b [%a4]4,%d15

void IfxMultican_Can_initModuleConfig(IfxMultican_Can_Config *config, Ifx_CAN *mcan)
{
    IfxMultican_SrcId srcId;
    /** - take over module pointer */
    config->module = mcan;
800068e4:	f4 45       	st.a [%a4],%a5
    return IfxMultican_Status_ok;
}


void IfxMultican_Can_initModuleConfig(IfxMultican_Can_Config *config, Ifx_CAN *mcan)
{
800068e6:	40 4f       	mov.aa %a15,%a4

    /** - Selected input clock is from CLC */
    config->clockSelect = IfxMultican_ClockSelect_fclc;

    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();
800068e8:	6d 00 a2 0b 	call 8000802c <IfxScuCcu_getSpbFrequency>

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800068ec:	82 0f       	mov %d15,0

    /** - Selected input clock is from CLC */
    config->clockSelect = IfxMultican_ClockSelect_fclc;

    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();
800068ee:	68 22       	st.w [%a15]8,%d2

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800068f0:	a8 6f       	st.h [%a15]12,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800068f2:	28 ef       	st.b [%a15]14,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800068f4:	a8 8f       	st.h [%a15]16,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800068f6:	e9 ff 12 00 	st.b [%a15]18,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800068fa:	a8 af       	st.h [%a15]20,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800068fc:	e9 ff 16 00 	st.b [%a15]22,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006900:	a8 cf       	st.h [%a15]24,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006902:	e9 ff 1a 00 	st.b [%a15]26,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006906:	a8 ef       	st.h [%a15]28,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006908:	e9 ff 1e 00 	st.b [%a15]30,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000690c:	f9 ff 20 00 	st.h [%a15]32,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006910:	e9 ff 22 00 	st.b [%a15]34,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006914:	f9 ff 24 00 	st.h [%a15]36,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006918:	e9 ff 26 00 	st.b [%a15]38,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000691c:	f9 ff 28 00 	st.h [%a15]40,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006920:	e9 ff 2a 00 	st.b [%a15]42,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006924:	f9 ff 2c 00 	st.h [%a15]44,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006928:	e9 ff 2e 00 	st.b [%a15]46,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000692c:	f9 ff 30 00 	st.h [%a15]48,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006930:	e9 ff 32 00 	st.b [%a15]50,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006934:	f9 ff 34 00 	st.h [%a15]52,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006938:	e9 ff 36 00 	st.b [%a15]54,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000693c:	f9 ff 38 00 	st.h [%a15]56,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006940:	e9 ff 3a 00 	st.b [%a15]58,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006944:	f9 ff 3c 00 	st.h [%a15]60,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006948:	e9 ff 3e 00 	st.b [%a15]62,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000694c:	f9 ff 00 10 	st.h [%a15]64,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006950:	e9 ff 02 10 	st.b [%a15]66,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80006954:	f9 ff 04 10 	st.h [%a15]68,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006958:	e9 ff 06 10 	st.b [%a15]70,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000695c:	f9 ff 08 10 	st.h [%a15]72,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80006960:	e9 ff 0a 10 	st.b [%a15]74,%d15
80006964:	00 90       	ret 

80006966 <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80006966:	91 00 00 28 	movh.a %a2,32768
8000696a:	d9 2f 38 f0 	lea %a15,[%a2]1016 <800003f8 <IfxPort_cfg_esrMasks>>
8000696e:	99 22 38 f0 	ld.a %a2,[%a2]1016 <800003f8 <IfxPort_cfg_esrMasks>>
80006972:	7d 42 58 00 	jeq.a %a2,%a4,80006a22 <IfxPort_disableEmergencyStop+0xbc>
80006976:	c8 22       	ld.a %a2,[%a15]8
80006978:	7d 42 57 00 	jeq.a %a2,%a4,80006a26 <IfxPort_disableEmergencyStop+0xc0>
8000697c:	c8 42       	ld.a %a2,[%a15]16
8000697e:	7d 42 56 00 	jeq.a %a2,%a4,80006a2a <IfxPort_disableEmergencyStop+0xc4>
80006982:	c8 62       	ld.a %a2,[%a15]24
80006984:	7d 42 55 00 	jeq.a %a2,%a4,80006a2e <IfxPort_disableEmergencyStop+0xc8>
80006988:	c8 82       	ld.a %a2,[%a15]32
8000698a:	7d 42 54 00 	jeq.a %a2,%a4,80006a32 <IfxPort_disableEmergencyStop+0xcc>
8000698e:	c8 a2       	ld.a %a2,[%a15]40
80006990:	7d 42 53 00 	jeq.a %a2,%a4,80006a36 <IfxPort_disableEmergencyStop+0xd0>
80006994:	c8 c2       	ld.a %a2,[%a15]48
80006996:	7d 42 52 00 	jeq.a %a2,%a4,80006a3a <IfxPort_disableEmergencyStop+0xd4>
8000699a:	c8 e2       	ld.a %a2,[%a15]56
8000699c:	7d 42 51 00 	jeq.a %a2,%a4,80006a3e <IfxPort_disableEmergencyStop+0xd8>
800069a0:	99 f2 00 10 	ld.a %a2,[%a15]64
800069a4:	7d 42 4f 00 	jeq.a %a2,%a4,80006a42 <IfxPort_disableEmergencyStop+0xdc>
800069a8:	99 f2 08 10 	ld.a %a2,[%a15]72
800069ac:	7d 42 4d 00 	jeq.a %a2,%a4,80006a46 <IfxPort_disableEmergencyStop+0xe0>
800069b0:	99 f2 10 10 	ld.a %a2,[%a15]80
800069b4:	7d 42 4b 00 	jeq.a %a2,%a4,80006a4a <IfxPort_disableEmergencyStop+0xe4>
800069b8:	99 f2 18 10 	ld.a %a2,[%a15]88
800069bc:	7d 42 49 00 	jeq.a %a2,%a4,80006a4e <IfxPort_disableEmergencyStop+0xe8>
800069c0:	99 f2 20 10 	ld.a %a2,[%a15]96
800069c4:	7d 42 47 00 	jeq.a %a2,%a4,80006a52 <IfxPort_disableEmergencyStop+0xec>
800069c8:	99 f2 28 10 	ld.a %a2,[%a15]104
800069cc:	7d 42 45 00 	jeq.a %a2,%a4,80006a56 <IfxPort_disableEmergencyStop+0xf0>
800069d0:	99 f2 30 10 	ld.a %a2,[%a15]112
800069d4:	7d 42 09 00 	jeq.a %a2,%a4,800069e6 <IfxPort_disableEmergencyStop+0x80>
800069d8:	99 f2 38 10 	ld.a %a2,[%a15]120
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800069dc:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800069de:	da 0f       	mov %d15,15
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800069e0:	7d 42 04 00 	jeq.a %a2,%a4,800069e8 <IfxPort_disableEmergencyStop+0x82>
            break;
        }
    }

    return result;
}
800069e4:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800069e6:	da 0e       	mov %d15,14
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800069e8:	d0 ff       	addsc.a %a15,%a15,%d15,3
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800069ea:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800069ec:	b9 ff 04 00 	ld.hu %d15,[%a15]4
800069f0:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
800069f4:	6e f8       	jz %d15,800069e4 <IfxPort_disableEmergencyStop+0x7e>
800069f6:	02 48       	mov %d8,%d4
800069f8:	40 4f       	mov.aa %a15,%a4
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800069fa:	6d 00 a5 16 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800069fe:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006a00:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006a02:	6d 00 a3 15 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
80006a06:	82 12       	mov %d2,1
80006a08:	d9 f4 10 10 	lea %a4,[%a15]80
80006a0c:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006a10:	d2 06       	mov %e6,0
80006a12:	02 27       	mov %d7,%d2
80006a14:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80006a18:	02 f4       	mov %d4,%d15
80006a1a:	6d 00 db 17 	call 800099d0 <IfxScuWdt_setCpuEndinit>
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
            {
                IfxPort_resetESR(port, pinIndex);
                result = TRUE;
80006a1e:	82 12       	mov %d2,1
            break;
        }
    }

    return result;
}
80006a20:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80006a22:	82 0f       	mov %d15,0
80006a24:	3c e2       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a26:	82 1f       	mov %d15,1
80006a28:	3c e0       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a2a:	82 2f       	mov %d15,2
80006a2c:	3c de       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a2e:	82 3f       	mov %d15,3
80006a30:	3c dc       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a32:	82 4f       	mov %d15,4
80006a34:	3c da       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a36:	82 5f       	mov %d15,5
80006a38:	3c d8       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a3a:	82 6f       	mov %d15,6
80006a3c:	3c d6       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a3e:	82 7f       	mov %d15,7
80006a40:	3c d4       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a42:	da 08       	mov %d15,8
80006a44:	3c d2       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a46:	da 09       	mov %d15,9
80006a48:	3c d0       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a4a:	da 0a       	mov %d15,10
80006a4c:	3c ce       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a4e:	da 0b       	mov %d15,11
80006a50:	3c cc       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a52:	da 0c       	mov %d15,12
80006a54:	3c ca       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>
80006a56:	da 0d       	mov %d15,13
80006a58:	3c c8       	j 800069e8 <IfxPort_disableEmergencyStop+0x82>

80006a5a <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80006a5a:	82 18       	mov %d8,1
80006a5c:	0f 48 00 80 	sh %d8,%d8,%d4
80006a60:	91 00 00 d8 	movh.a %a13,32768
80006a64:	40 4c       	mov.aa %a12,%a4
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006a66:	53 18 40 a0 	mul.u %e10,%d8,1
    sint32  portIndex;
    boolean result = FALSE;
80006a6a:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80006a6c:	82 0f       	mov %d15,0
80006a6e:	d9 dd 38 f0 	lea %a13,[%a13]1016 <800003f8 <IfxPort_cfg_esrMasks>>
void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
80006a72:	d9 4e 10 10 	lea %a14,[%a4]80 <800003f8 <IfxPort_cfg_esrMasks>>
80006a76:	3c 06       	j 80006a82 <IfxPort_enableEmergencyStop+0x28>
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80006a78:	c2 1f       	add %d15,1
80006a7a:	8b 0f 21 32 	ne %d3,%d15,16
80006a7e:	df 03 1d 00 	jeq %d3,0,80006ab8 <IfxPort_enableEmergencyStop+0x5e>
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80006a82:	d0 df       	addsc.a %a15,%a13,%d15,3
80006a84:	c8 02       	ld.a %a2,[%a15]0
80006a86:	7d c2 f9 ff 	jne.a %a2,%a12,80006a78 <IfxPort_enableEmergencyStop+0x1e>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80006a8a:	b9 f3 04 00 	ld.hu %d3,[%a15]4
80006a8e:	26 83       	and %d3,%d8
80006a90:	df 03 f4 7f 	jeq %d3,0,80006a78 <IfxPort_enableEmergencyStop+0x1e>
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006a94:	6d 00 58 16 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006a98:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006a9a:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006a9c:	6d 00 56 15 	call 80009548 <IfxScuWdt_clearCpuEndinit>

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006aa0:	02 8b       	mov %d11,%d8
80006aa2:	49 ea 40 08 	ldmst [%a14]0,%e10
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
    IfxScuWdt_setCpuEndinit(passwd);
80006aa6:	02 94       	mov %d4,%d9
80006aa8:	6d 00 94 17 	call 800099d0 <IfxScuWdt_setCpuEndinit>
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80006aac:	c2 1f       	add %d15,1
80006aae:	8b 0f 21 32 	ne %d3,%d15,16
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
            {
                IfxPort_setESR(port, pinIndex);
                result = TRUE;
80006ab2:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80006ab4:	df 03 e7 ff 	jne %d3,0,80006a82 <IfxPort_enableEmergencyStop+0x28>
            }
        }
    }

    return result;
}
80006ab8:	00 90       	ret 

80006aba <IfxPort_getAddress>:


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
80006aba:	91 00 00 38 	movh.a %a3,32768
80006abe:	82 0f       	mov %d15,0
80006ac0:	d9 33 38 d0 	lea %a3,[%a3]888 <80000378 <IfxPort_cfg_indexMap>>
80006ac4:	3c 0a       	j 80006ad8 <IfxPort_getAddress+0x1e>
80006ac6:	c2 12       	add %d2,1
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80006ac8:	8f f2 0f 21 	and %d2,%d2,255
80006acc:	8b 02 61 22 	lt.u %d2,%d2,16
80006ad0:	26 32       	and %d2,%d3
80006ad2:	c2 1f       	add %d15,1
80006ad4:	df 02 19 00 	jeq %d2,0,80006b06 <IfxPort_getAddress+0x4c>
80006ad8:	8f ff 0f 31 	and %d3,%d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80006adc:	01 33 03 f6 	addsc.a %a15,%a3,%d3,3
80006ae0:	8f ff 0f 21 	and %d2,%d15,255
80006ae4:	48 15       	ld.w %d5,[%a15]4
80006ae6:	82 13       	mov %d3,1
80006ae8:	a0 02       	mov.a %a2,0
80006aea:	5f 45 ee ff 	jne %d5,%d4,80006ac6 <IfxPort_getAddress+0xc>
        {
            module = IfxPort_cfg_indexMap[i].module;
80006aee:	c8 02       	ld.a %a2,[%a15]0
80006af0:	c2 12       	add %d2,1
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80006af2:	8f f2 0f 21 	and %d2,%d2,255
80006af6:	01 02 80 34 	eqz.a %d3,%a2
80006afa:	8b 02 61 22 	lt.u %d2,%d2,16
80006afe:	26 32       	and %d2,%d3
80006b00:	c2 1f       	add %d15,1
80006b02:	df 02 eb ff 	jne %d2,0,80006ad8 <IfxPort_getAddress+0x1e>

        i++;
    }

    return module;
}
80006b06:	00 90       	ret 

80006b08 <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80006b08:	91 00 00 28 	movh.a %a2,32768
80006b0c:	d9 2f 38 d0 	lea %a15,[%a2]888 <80000378 <IfxPort_cfg_indexMap>>
80006b10:	99 22 38 d0 	ld.a %a2,[%a2]888 <80000378 <IfxPort_cfg_indexMap>>
80006b14:	7d 42 3f 00 	jeq.a %a2,%a4,80006b92 <IfxPort_getIndex+0x8a>
80006b18:	c8 22       	ld.a %a2,[%a15]8
80006b1a:	7d 42 3e 00 	jeq.a %a2,%a4,80006b96 <IfxPort_getIndex+0x8e>
80006b1e:	c8 42       	ld.a %a2,[%a15]16
80006b20:	7d 42 3d 00 	jeq.a %a2,%a4,80006b9a <IfxPort_getIndex+0x92>
80006b24:	c8 62       	ld.a %a2,[%a15]24
80006b26:	7d 42 3c 00 	jeq.a %a2,%a4,80006b9e <IfxPort_getIndex+0x96>
80006b2a:	c8 82       	ld.a %a2,[%a15]32
80006b2c:	7d 42 3b 00 	jeq.a %a2,%a4,80006ba2 <IfxPort_getIndex+0x9a>
80006b30:	c8 a2       	ld.a %a2,[%a15]40
80006b32:	7d 42 3a 00 	jeq.a %a2,%a4,80006ba6 <IfxPort_getIndex+0x9e>
80006b36:	c8 c2       	ld.a %a2,[%a15]48
80006b38:	7d 42 39 00 	jeq.a %a2,%a4,80006baa <IfxPort_getIndex+0xa2>
80006b3c:	c8 e2       	ld.a %a2,[%a15]56
80006b3e:	7d 42 38 00 	jeq.a %a2,%a4,80006bae <IfxPort_getIndex+0xa6>
80006b42:	99 f2 00 10 	ld.a %a2,[%a15]64
80006b46:	7d 42 36 00 	jeq.a %a2,%a4,80006bb2 <IfxPort_getIndex+0xaa>
80006b4a:	99 f2 08 10 	ld.a %a2,[%a15]72
80006b4e:	7d 42 34 00 	jeq.a %a2,%a4,80006bb6 <IfxPort_getIndex+0xae>
80006b52:	99 f2 10 10 	ld.a %a2,[%a15]80
80006b56:	7d 42 32 00 	jeq.a %a2,%a4,80006bba <IfxPort_getIndex+0xb2>
80006b5a:	99 f2 18 10 	ld.a %a2,[%a15]88
80006b5e:	7d 42 30 00 	jeq.a %a2,%a4,80006bbe <IfxPort_getIndex+0xb6>
80006b62:	99 f2 20 10 	ld.a %a2,[%a15]96
80006b66:	7d 42 2e 00 	jeq.a %a2,%a4,80006bc2 <IfxPort_getIndex+0xba>
80006b6a:	99 f2 28 10 	ld.a %a2,[%a15]104
80006b6e:	7d 42 2c 00 	jeq.a %a2,%a4,80006bc6 <IfxPort_getIndex+0xbe>
80006b72:	99 f2 30 10 	ld.a %a2,[%a15]112
80006b76:	7d 42 09 00 	jeq.a %a2,%a4,80006b88 <IfxPort_getIndex+0x80>
80006b7a:	99 f2 38 10 	ld.a %a2,[%a15]120
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
80006b7e:	82 f2       	mov %d2,-1

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80006b80:	da 0f       	mov %d15,15
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80006b82:	7d 42 04 00 	jeq.a %a2,%a4,80006b8a <IfxPort_getIndex+0x82>
            break;
        }
    }

    return result;
}
80006b86:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80006b88:	da 0e       	mov %d15,14
    {
        if (IfxPort_cfg_indexMap[index].module == port)
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
80006b8a:	d0 ff       	addsc.a %a15,%a15,%d15,3
80006b8c:	79 f2 04 00 	ld.b %d2,[%a15]4
            break;
        }
    }

    return result;
}
80006b90:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80006b92:	82 0f       	mov %d15,0
80006b94:	3c fb       	j 80006b8a <IfxPort_getIndex+0x82>
80006b96:	82 1f       	mov %d15,1
80006b98:	3c f9       	j 80006b8a <IfxPort_getIndex+0x82>
80006b9a:	82 2f       	mov %d15,2
80006b9c:	3c f7       	j 80006b8a <IfxPort_getIndex+0x82>
80006b9e:	82 3f       	mov %d15,3
80006ba0:	3c f5       	j 80006b8a <IfxPort_getIndex+0x82>
80006ba2:	82 4f       	mov %d15,4
80006ba4:	3c f3       	j 80006b8a <IfxPort_getIndex+0x82>
80006ba6:	82 5f       	mov %d15,5
80006ba8:	3c f1       	j 80006b8a <IfxPort_getIndex+0x82>
80006baa:	82 6f       	mov %d15,6
80006bac:	3c ef       	j 80006b8a <IfxPort_getIndex+0x82>
80006bae:	82 7f       	mov %d15,7
80006bb0:	3c ed       	j 80006b8a <IfxPort_getIndex+0x82>
80006bb2:	da 08       	mov %d15,8
80006bb4:	3c eb       	j 80006b8a <IfxPort_getIndex+0x82>
80006bb6:	da 09       	mov %d15,9
80006bb8:	3c e9       	j 80006b8a <IfxPort_getIndex+0x82>
80006bba:	da 0a       	mov %d15,10
80006bbc:	3c e7       	j 80006b8a <IfxPort_getIndex+0x82>
80006bbe:	da 0b       	mov %d15,11
80006bc0:	3c e5       	j 80006b8a <IfxPort_getIndex+0x82>
80006bc2:	da 0c       	mov %d15,12
80006bc4:	3c e3       	j 80006b8a <IfxPort_getIndex+0x82>
80006bc6:	da 0d       	mov %d15,13
80006bc8:	3c e1       	j 80006b8a <IfxPort_getIndex+0x82>

80006bca <IfxPort_resetESR>:
    return result;
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
80006bca:	40 4f       	mov.aa %a15,%a4
80006bcc:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006bce:	6d 00 bb 15 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006bd2:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006bd4:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006bd6:	6d 00 b9 14 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
80006bda:	82 12       	mov %d2,1
80006bdc:	d9 f4 10 10 	lea %a4,[%a15]80
80006be0:	0f 82 00 20 	sh %d2,%d2,%d8
80006be4:	d2 06       	mov %e6,0
80006be6:	02 27       	mov %d7,%d2
80006be8:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80006bec:	02 f4       	mov %d4,%d15
80006bee:	1d 00 f1 16 	j 800099d0 <IfxScuWdt_setCpuEndinit>

80006bf2 <IfxPort_setESR>:
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
80006bf2:	40 4f       	mov.aa %a15,%a4
80006bf4:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006bf6:	6d 00 a7 15 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006bfa:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006bfc:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006bfe:	6d 00 a5 14 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
80006c02:	82 12       	mov %d2,1
80006c04:	0f 82 00 20 	sh %d2,%d2,%d8
80006c08:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006c0c:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006c10:	02 27       	mov %d7,%d2
80006c12:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80006c16:	02 f4       	mov %d4,%d15
80006c18:	1d 00 dc 16 	j 800099d0 <IfxScuWdt_setCpuEndinit>

80006c1c <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006c1c:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
80006c1e:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006c20:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80006c22:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006c24:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80006c26:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006c28:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80006c2a:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006c2c:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80006c2e:	78 07       	st.w [%sp]28,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80006c30:	8b 04 a1 f2 	ge.u %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80006c34:	0f 45 00 50 	sh %d5,%d5,%d4

    for (i = pinIndex; i < 16; i++)
80006c38:	ee 23       	jnz %d15,80006c7e <IfxPort_setGroupModeInput+0x62>
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006c3a:	8b f4 00 f1 	rsub %d15,%d4,15
80006c3e:	60 ff       	mov.a %a15,%d15
80006c40:	3b 80 0f 30 	mov %d3,248
    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
80006c44:	57 05 61 f4 	extr.u %d15,%d5,%d4,1
80006c48:	6e 18       	jz %d15,80006c78 <IfxPort_setGroupModeInput+0x5c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006c4a:	8f 34 c0 21 	andn %d2,%d4,3
80006c4e:	d9 a3 20 00 	lea %a3,[%sp]32
80006c52:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80006c56:	8f 34 00 f1 	and %d15,%d4,3
80006c5a:	06 3f       	sh %d15,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80006c5c:	19 27 f0 ff 	ld.w %d7,[%a2]-16
80006c60:	0f f3 00 20 	sh %d2,%d3,%d15
80006c64:	a6 72       	or %d2,%d7
80006c66:	59 22 f0 ff 	st.w [%a2]-16,%d2
            iocrVal[index]  |= (mode) << shift;
80006c6a:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80006c6e:	0f f6 00 f0 	sh %d15,%d6,%d15
80006c72:	a6 2f       	or %d15,%d2
80006c74:	59 2f e0 ff 	st.w [%a2]-32,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80006c78:	c2 14       	add %d4,1
80006c7a:	fd f0 e5 7f 	loop %a15,80006c44 <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006c7e:	58 04       	ld.w %d15,[%sp]16
80006c80:	6e 08       	jz %d15,80006c90 <IfxPort_setGroupModeInput+0x74>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006c82:	d9 4f 10 00 	lea %a15,[%a4]16
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006c86:	54 a2       	ld.w %d2,[%sp]
80006c88:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006c8a:	02 f3       	mov %d3,%d15
80006c8c:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006c90:	58 05       	ld.w %d15,[%sp]20
80006c92:	6e 09       	jz %d15,80006ca4 <IfxPort_setGroupModeInput+0x88>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006c94:	d9 4f 14 00 	lea %a15,[%a4]20
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006c98:	19 a2 04 00 	ld.w %d2,[%sp]4
80006c9c:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006c9e:	02 f3       	mov %d3,%d15
80006ca0:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006ca4:	58 06       	ld.w %d15,[%sp]24
80006ca6:	6e 09       	jz %d15,80006cb8 <IfxPort_setGroupModeInput+0x9c>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006ca8:	d9 4f 18 00 	lea %a15,[%a4]24
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006cac:	19 a2 08 00 	ld.w %d2,[%sp]8
80006cb0:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006cb2:	02 f3       	mov %d3,%d15
80006cb4:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006cb8:	58 07       	ld.w %d15,[%sp]28
80006cba:	6e 0a       	jz %d15,80006cce <IfxPort_setGroupModeInput+0xb2>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006cbc:	d9 44 1c 00 	lea %a4,[%a4]28
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006cc0:	19 a2 0c 00 	ld.w %d2,[%sp]12
80006cc4:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006cc6:	02 f3       	mov %d3,%d15
80006cc8:	49 42 40 08 	ldmst [%a4]0,%e2
80006ccc:	00 90       	ret 
80006cce:	00 90       	ret 

80006cd0 <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006cd0:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
80006cd2:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006cd4:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80006cd6:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006cd8:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80006cda:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006cdc:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80006cde:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80006ce0:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80006ce2:	78 07       	st.w [%sp]28,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80006ce4:	8b 04 a1 f2 	ge.u %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80006ce8:	0f 45 00 50 	sh %d5,%d5,%d4

    for (i = pinIndex; i < 16; i++)
80006cec:	ee 24       	jnz %d15,80006d34 <IfxPort_setGroupModeOutput+0x64>
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006cee:	8b f4 00 f1 	rsub %d15,%d4,15
80006cf2:	60 ff       	mov.a %a15,%d15
80006cf4:	3b 80 0f 70 	mov %d7,248
    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
80006cf8:	57 05 61 f4 	extr.u %d15,%d5,%d4,1
80006cfc:	6e 19       	jz %d15,80006d2e <IfxPort_setGroupModeOutput+0x5e>
        {
            uint32 index = i / 4;
80006cfe:	8f e4 1f 20 	sh %d2,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006d02:	d9 a3 20 00 	lea %a3,[%sp]32
80006d06:	01 32 02 26 	addsc.a %a2,%a3,%d2,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80006d0a:	8f 34 00 f1 	and %d15,%d4,3
80006d0e:	06 3f       	sh %d15,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
80006d10:	a6 62       	or %d2,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006d12:	0f f7 00 30 	sh %d3,%d7,%d15
80006d16:	19 20 f0 ff 	ld.w %d0,[%a2]-16
            iocrVal[index]  |= (mode | index) << shift;
80006d1a:	0f f2 00 f0 	sh %d15,%d2,%d15
80006d1e:	19 22 e0 ff 	ld.w %d2,[%a2]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006d22:	a6 03       	or %d3,%d0
            iocrVal[index]  |= (mode | index) << shift;
80006d24:	a6 2f       	or %d15,%d2
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80006d26:	59 23 f0 ff 	st.w [%a2]-16,%d3
            iocrVal[index]  |= (mode | index) << shift;
80006d2a:	59 2f e0 ff 	st.w [%a2]-32,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80006d2e:	c2 14       	add %d4,1
80006d30:	fd f0 e4 7f 	loop %a15,80006cf8 <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006d34:	58 04       	ld.w %d15,[%sp]16
80006d36:	6e 08       	jz %d15,80006d46 <IfxPort_setGroupModeOutput+0x76>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006d38:	d9 4f 10 00 	lea %a15,[%a4]16
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006d3c:	54 a2       	ld.w %d2,[%sp]
80006d3e:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006d40:	02 f3       	mov %d3,%d15
80006d42:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006d46:	58 05       	ld.w %d15,[%sp]20
80006d48:	6e 09       	jz %d15,80006d5a <IfxPort_setGroupModeOutput+0x8a>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006d4a:	d9 4f 14 00 	lea %a15,[%a4]20
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006d4e:	19 a2 04 00 	ld.w %d2,[%sp]4
80006d52:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006d54:	02 f3       	mov %d3,%d15
80006d56:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006d5a:	58 06       	ld.w %d15,[%sp]24
80006d5c:	6e 09       	jz %d15,80006d6e <IfxPort_setGroupModeOutput+0x9e>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006d5e:	d9 4f 18 00 	lea %a15,[%a4]24
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006d62:	19 a2 08 00 	ld.w %d2,[%sp]8
80006d66:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006d68:	02 f3       	mov %d3,%d15
80006d6a:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80006d6e:	58 07       	ld.w %d15,[%sp]28
80006d70:	6e 0a       	jz %d15,80006d84 <IfxPort_setGroupModeOutput+0xb4>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80006d72:	d9 44 1c 00 	lea %a4,[%a4]28
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006d76:	19 a2 0c 00 	ld.w %d2,[%sp]12
80006d7a:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006d7c:	02 f3       	mov %d3,%d15
80006d7e:	49 42 40 08 	ldmst [%a4]0,%e2
80006d82:	00 90       	ret 
80006d84:	00 90       	ret 

80006d86 <IfxPort_setGroupPadDriver>:
    }
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80006d86:	20 10       	sub.a %sp,16
80006d88:	02 4f       	mov %d15,%d4
80006d8a:	02 5a       	mov %d10,%d5
80006d8c:	40 4c       	mov.aa %a12,%a4
80006d8e:	02 68       	mov %d8,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006d90:	6d 00 da 14 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006d94:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006d96:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006d98:	6d 00 d8 13 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80006d9c:	82 03       	mov %d3,0
80006d9e:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80006da0:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80006da4:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80006da8:	59 a3 0c 00 	st.w [%sp]12,%d3
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80006dac:	8b 0f a1 22 	ge.u %d2,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80006db0:	0f fa 00 50 	sh %d5,%d10,%d15

        for (i = pinIndex; i < 16; i++)
80006db4:	df 02 36 80 	jne %d2,0,80006e20 <IfxPort_setGroupPadDriver+0x9a>
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80006db8:	8b ff 00 21 	rsub %d2,%d15,15
80006dbc:	60 2f       	mov.a %a15,%d2
        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
80006dbe:	57 05 61 3f 	extr.u %d3,%d5,%d15,1
80006dc2:	df 03 18 00 	jeq %d3,0,80006df2 <IfxPort_setGroupPadDriver+0x6c>
            {
                uint32 index = i / 8;
80006dc6:	8f df 1f 70 	sh %d7,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80006dca:	d9 a3 10 00 	lea %a3,[%sp]16
80006dce:	01 37 02 26 	addsc.a %a2,%a3,%d7,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80006dd2:	8f 7f 00 31 	and %d3,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80006dd6:	19 27 f8 ff 	ld.w %d7,[%a2]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80006dda:	06 23       	sh %d3,2
                pdrMask[index] |= (0xFUL << shift);
                pdrVal[index]  |= (padDriver << shift);
80006ddc:	19 22 f0 ff 	ld.w %d2,[%a2]-16
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80006de0:	d7 f7 04 73 	insert %d7,%d7,15,%d3,4
                pdrVal[index]  |= (padDriver << shift);
80006de4:	0f 38 00 30 	sh %d3,%d8,%d3
80006de8:	a6 23       	or %d3,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80006dea:	59 27 f8 ff 	st.w [%a2]-8,%d7
                pdrVal[index]  |= (padDriver << shift);
80006dee:	59 23 f0 ff 	st.w [%a2]-16,%d3
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80006df2:	c2 1f       	add %d15,1
80006df4:	fd f0 e5 7f 	loop %a15,80006dbe <IfxPort_setGroupPadDriver+0x38>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80006df8:	19 a2 08 00 	ld.w %d2,[%sp]8
80006dfc:	58 03       	ld.w %d15,[%sp]12
80006dfe:	76 28       	jz %d2,80006e0e <IfxPort_setGroupPadDriver+0x88>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80006e00:	d9 cf 00 10 	lea %a15,[%a12]64
80006e04:	54 a6       	ld.w %d6,[%sp]
80006e06:	82 07       	mov %d7,0
80006e08:	02 27       	mov %d7,%d2
80006e0a:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80006e0e:	6e 09       	jz %d15,80006e20 <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80006e10:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006e14:	19 a6 04 00 	ld.w %d6,[%sp]4
80006e18:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006e1a:	02 f7       	mov %d7,%d15
80006e1c:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80006e20:	02 94       	mov %d4,%d9
}
80006e22:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80006e26:	1d 00 d5 15 	j 800099d0 <IfxScuWdt_setCpuEndinit>

80006e2a <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80006e2a:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80006e2e:	8f 34 00 81 	and %d8,%d4,3

    if (port == &MODULE_P40)
80006e32:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80006e36:	20 08       	sub.a %sp,8
80006e38:	02 4f       	mov %d15,%d4
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80006e3a:	d9 4f 10 00 	lea %a15,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80006e3e:	8f e4 1f 90 	sh %d9,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80006e42:	06 38       	sh %d8,3

    if (port == &MODULE_P40)
80006e44:	7d 24 0e 00 	jeq.a %a4,%a2,80006e60 <IfxPort_setPinMode+0x36>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80006e48:	da ff       	mov %d15,255
80006e4a:	01 f9 02 f6 	addsc.a %a15,%a15,%d9,2
80006e4e:	0f 8f 00 f0 	sh %d15,%d15,%d8
80006e52:	0f 85 00 20 	sh %d2,%d5,%d8
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006e56:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006e58:	02 f3       	mov %d3,%d15
80006e5a:	49 f2 40 08 	ldmst [%a15]0,%e2
80006e5e:	00 90       	ret 
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006e60:	74 a5       	st.w [%sp],%d5
80006e62:	b5 a4 04 00 	st.a [%sp]4,%a4
80006e66:	6d 00 6f 14 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80006e6a:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006e6c:	02 2a       	mov %d10,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80006e6e:	6d 00 6d 13 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80006e72:	99 a4 04 00 	ld.a %a4,[%sp]4
        IfxScuWdt_setCpuEndinit(passwd);
80006e76:	02 a4       	mov %d4,%d10

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80006e78:	19 42 20 10 	ld.w %d2,[%a4]96
80006e7c:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80006e80:	59 4f 20 10 	st.w [%a4]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80006e84:	6d 00 a6 15 	call 800099d0 <IfxScuWdt_setCpuEndinit>
80006e88:	54 a5       	ld.w %d5,[%sp]
80006e8a:	3c df       	j 80006e48 <IfxPort_setPinMode+0x1e>

80006e8c <IfxPort_setPinModeLvdsHigh>:
    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80006e8c:	0b 45 10 88 	mov %e8,%d5,%d4
80006e90:	40 4f       	mov.aa %a15,%a4
80006e92:	02 6a       	mov %d10,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006e94:	6d 00 58 14 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006e98:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006e9a:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006e9c:	6d 00 56 13 	call 80009548 <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80006ea0:	37 09 48 50 	extr %d5,%d9,0,8
80006ea4:	bf 05 13 00 	jlt %d5,0,80006eca <IfxPort_setPinModeLvdsHigh+0x3e>
    {
        if (pinIndex < 2)
80006ea8:	bf 28 0e 80 	jlt.u %d8,2,80006ec4 <IfxPort_setPinModeLvdsHigh+0x38>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80006eac:	19 f2 24 20 	ld.w %d2,[%a15]164
80006eb0:	37 a2 01 a0 	insert %d10,%d2,%d10,0,1
80006eb4:	59 fa 24 20 	st.w [%a15]164,%d10
            port->LPCR1.B_P21.RX_DIS    = 0;
80006eb8:	19 f2 24 20 	ld.w %d2,[%a15]164
80006ebc:	8f 22 c0 21 	andn %d2,%d2,2
80006ec0:	59 f2 24 20 	st.w [%a15]164,%d2
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
        port->LPCR2.B.TX_DIS    = 0;
        port->LPCR2.B.TX_PD     = 0;
    }

    IfxScuWdt_setCpuEndinit(passwd);
80006ec4:	02 f4       	mov %d4,%d15
80006ec6:	1d 00 85 15 	j 800099d0 <IfxScuWdt_setCpuEndinit>
            port->LPCR1.B_P21.RX_DIS    = 0;
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80006eca:	19 f2 28 20 	ld.w %d2,[%a15]168
        port->LPCR2.B.TX_DIS    = 0;
        port->LPCR2.B.TX_PD     = 0;
    }

    IfxScuWdt_setCpuEndinit(passwd);
80006ece:	02 f4       	mov %d4,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80006ed0:	67 a2 0c a0 	ins.t %d10,%d2,12,%d10,0
80006ed4:	59 fa 28 20 	st.w [%a15]168,%d10
        port->LPCR2.B.TX_DIS    = 0;
80006ed8:	19 f2 28 20 	ld.w %d2,[%a15]168
80006edc:	b7 02 81 26 	insert %d2,%d2,0,13,1
80006ee0:	59 f2 28 20 	st.w [%a15]168,%d2
        port->LPCR2.B.TX_PD     = 0;
80006ee4:	19 f2 28 20 	ld.w %d2,[%a15]168
80006ee8:	b7 02 01 27 	insert %d2,%d2,0,14,1
80006eec:	59 f2 28 20 	st.w [%a15]168,%d2
    }

    IfxScuWdt_setCpuEndinit(passwd);
80006ef0:	1d 00 70 15 	j 800099d0 <IfxScuWdt_setCpuEndinit>

80006ef4 <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80006ef4:	0b 65 10 a8 	mov %e10,%d5,%d6
80006ef8:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80006efa:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80006efe:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80006f00:	6d 00 22 14 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006f04:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80006f06:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006f08:	6d 00 20 13 	call 80009548 <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80006f0c:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80006f0e:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80006f12:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80006f16:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80006f1a:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80006f1e:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80006f22:	0f 2b 00 50 	sh %d5,%d11,%d2
80006f26:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80006f28:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80006f2a:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80006f2c:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80006f30:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80006f32:	1d 00 4f 15 	j 800099d0 <IfxScuWdt_setCpuEndinit>

80006f36 <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80006f36:	0b 45 10 88 	mov %e8,%d5,%d4
80006f3a:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006f3c:	6d 00 04 14 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80006f40:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006f42:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80006f44:	6d 00 02 13 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80006f48:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80006f4c:	06 22       	sh %d2,2
80006f4e:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80006f50:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80006f54:	3b f0 00 30 	mov %d3,15
80006f58:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80006f5c:	0f 23 00 30 	sh %d3,%d3,%d2
80006f60:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80006f64:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80006f66:	02 37       	mov %d7,%d3
80006f68:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80006f6c:	02 f4       	mov %d4,%d15
80006f6e:	1d 00 31 15 	j 800099d0 <IfxScuWdt_setCpuEndinit>
	...

80006f74 <IfxScuCcu_wait>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80006f74:	91 30 00 ff 	movh.a %a15,61443
80006f78:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006f7c:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80006f7e:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80006f82:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80006f86:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80006f8a:	df 02 2c 00 	jeq %d2,0,80006fe2 <IfxScuCcu_wait+0x6e>
80006f8e:	df 12 41 80 	jne %d2,1,80007010 <IfxScuCcu_wait+0x9c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80006f92:	91 30 00 ff 	movh.a %a15,61443
80006f96:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006f9a:	48 02       	ld.w %d2,[%a15]0
80006f9c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80006fa0:	df 02 3a 80 	jne %d2,0,80007014 <IfxScuCcu_wait+0xa0>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80006fa4:	91 30 00 ff 	movh.a %a15,61443
80006fa8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006fac:	48 52       	ld.w %d2,[%a15]20
80006fae:	6f 02 40 80 	jnz.t %d2,0,8000702e <IfxScuCcu_wait+0xba>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80006fb2:	48 52       	ld.w %d2,[%a15]20
80006fb4:	6f 32 46 80 	jnz.t %d2,3,80007040 <IfxScuCcu_wait+0xcc>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80006fb8:	48 65       	ld.w %d5,[%a15]24
80006fba:	48 72       	ld.w %d2,[%a15]28
80006fbc:	37 05 e7 54 	extr.u %d5,%d5,9,7
80006fc0:	8f f2 07 31 	and %d3,%d2,127
80006fc4:	48 62       	ld.w %d2,[%a15]24
80006fc6:	c2 15       	add %d5,1
80006fc8:	37 02 64 2c 	extr.u %d2,%d2,24,4
80006fcc:	4b 05 41 51 	itof %d5,%d5
80006fd0:	c2 12       	add %d2,1
80006fd2:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80006fd6:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80006fda:	4b 02 41 21 	itof %d2,%d2
80006fde:	4b 2f 51 f0 	div.f %d15,%d15,%d2
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80006fe2:	91 30 00 ff 	movh.a %a15,61443
80006fe6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006fea:	48 02       	ld.w %d2,[%a15]0
80006fec:	37 02 64 24 	extr.u %d2,%d2,8,4
80006ff0:	4b 02 41 21 	itof %d2,%d2
80006ff4:	4b 2f 51 f0 	div.f %d15,%d15,%d2


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80006ff8:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80006ffc:	4b 4f 41 40 	mul.f %d4,%d15,%d4
80007000:	4b 04 71 41 	ftouz %d4,%d4
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80007004:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80007008:	a2 2f       	sub %d15,%d2
8000700a:	3f 4f fd ff 	jlt.u %d15,%d4,80007004 <IfxScuCcu_wait+0x90>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
8000700e:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007010:	82 0f       	mov %d15,0
80007012:	3c e8       	j 80006fe2 <IfxScuCcu_wait+0x6e>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007014:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007016:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007018:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000701c:	df 12 c4 ff 	jne %d2,1,80006fa4 <IfxScuCcu_wait+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007020:	91 00 00 f7 	movh.a %a15,28672
80007024:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007028:	4b 0f 61 f1 	utof %d15,%d15
8000702c:	3c bc       	j 80006fa4 <IfxScuCcu_wait+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
8000702e:	48 72       	ld.w %d2,[%a15]28
80007030:	37 02 67 28 	extr.u %d2,%d2,16,7
80007034:	c2 12       	add %d2,1
80007036:	4b 02 41 21 	itof %d2,%d2
8000703a:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000703e:	3c d2       	j 80006fe2 <IfxScuCcu_wait+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007040:	4c f7       	ld.w %d15,[%a15]28
80007042:	7b f0 cb 24 	movh %d2,19647
80007046:	16 7f       	and %d15,127
80007048:	c2 1f       	add %d15,1
8000704a:	4b 0f 41 f1 	itof %d15,%d15
8000704e:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007052:	4b f2 51 f0 	div.f %d15,%d2,%d15
80007056:	3c c6       	j 80006fe2 <IfxScuCcu_wait+0x6e>

80007058 <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80007058:	7b e0 e4 30 	movh %d3,3662
8000705c:	1b 13 c0 31 	addi %d3,%d3,7169
80007060:	0b 34 30 e1 	lt.u %d14,%d4,%d3
80007064:	82 2f       	mov %d15,2
80007066:	ab 1f 80 ee 	sel %d14,%d14,%d15,1
8000706a:	8f 4e 00 50 	sh %d5,%d14,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
8000706e:	7b c0 be 60 	movh %d6,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80007072:	91 40 0f 60 	movh.a %a6,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80007076:	7b 80 82 ce 	movh %d12,59432
8000707a:	91 80 7d 51 	movh.a %a5,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
8000707e:	19 4a 10 10 	ld.w %d10,[%a4]80
80007082:	60 53       	mov.a %a3,%d5
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80007084:	1b 06 20 6c 	addi %d6,%d6,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80007088:	d2 00       	mov %e0,0
8000708a:	82 07       	mov %d7,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
8000708c:	3b 00 01 90 	mov %d9,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80007090:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80007094:	82 fd       	mov %d13,-1
80007096:	1b 0c c0 c7 	addi %d12,%d12,31744
8000709a:	d9 55 41 08 	lea %a5,[%a5]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
8000709e:	a0 f2       	mov.a %a2,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
800070a0:	4b 9a 11 22 	div.u %e2,%d10,%d9

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
800070a4:	7b 60 f8 5f 	movh %d5,65414
800070a8:	1b 05 e0 5e 	addi %d5,%d5,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
800070ac:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
800070ae:	0b 52 40 50 	addx %d5,%d2,%d5
800070b2:	8b f3 bf 20 	addc %d2,%d3,-1
800070b6:	80 63       	mov.d %d3,%a6
800070b8:	ba 02       	eq %d15,%d2,0
800070ba:	0b 35 50 f2 	and.ge.u %d15,%d5,%d3
800070be:	8b 02 00 f5 	or.ne %d15,%d2,0
800070c2:	ee 24       	jnz %d15,8000710a <IfxScuCcu_calculateSysPllDividers+0xb2>
800070c4:	02 9b       	mov %d11,%d9
800070c6:	82 18       	mov %d8,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
800070c8:	03 48 68 2c 	madd.u %e2,%e12,%d8,%d4
800070cc:	80 55       	mov.d %d5,%a5
800070ce:	ba 03       	eq %d15,%d3,0
800070d0:	0b 52 50 f2 	and.ge.u %d15,%d2,%d5
800070d4:	8b 03 00 f5 	or.ne %d15,%d3,0
800070d8:	ee 13       	jnz %d15,800070fe <IfxScuCcu_calculateSysPllDividers+0xa6>
800070da:	82 15       	mov %d5,1
800070dc:	c5 0f 3f 10 	lea %a15,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
800070e0:	4b b5 11 22 	div.u %e2,%d5,%d11
800070e4:	e2 a2       	mul %d2,%d10
800070e6:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
800070e8:	df 02 1b 00 	jeq %d2,0,8000711e <IfxScuCcu_calculateSysPllDividers+0xc6>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
800070ec:	82 1f       	mov %d15,1
800070ee:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
800070f2:	6a 50       	cmovn %d0,%d15,%d5
800070f4:	6a 26       	cmovn %d6,%d15,%d2
800070f6:	6a 91       	cmovn %d1,%d15,%d9
800070f8:	6a 87       	cmovn %d7,%d15,%d8
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
800070fa:	c2 15       	add %d5,1
800070fc:	fc f2       	loop %a15,800070e0 <IfxScuCcu_calculateSysPllDividers+0x88>
800070fe:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80007100:	42 e8       	add %d8,%d14
80007102:	42 fb       	add %d11,%d15
80007104:	8b 18 68 f2 	lt.u %d15,%d8,129
80007108:	ee e0       	jnz %d15,800070c8 <IfxScuCcu_calculateSysPllDividers+0x70>
8000710a:	60 ef       	mov.a %a15,%d14
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
8000710c:	c2 f9       	add %d9,-1
8000710e:	01 f3 20 30 	sub.a %a3,%a3,%a15
80007112:	fd 20 c7 7f 	loop %a2,800070a0 <IfxScuCcu_calculateSysPllDividers+0x48>
80007116:	02 19       	mov %d9,%d1
80007118:	02 05       	mov %d5,%d0
8000711a:	02 78       	mov %d8,%d7
8000711c:	3c 02       	j 80007120 <IfxScuCcu_calculateSysPllDividers+0xc8>
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
8000711e:	82 06       	mov %d6,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80007120:	7b c0 1e 25 	movh %d2,20972
80007124:	06 14       	sh %d4,1
80007126:	1b f2 51 28 	addi %d2,%d2,-31457
8000712a:	73 24 68 20 	mul.u %e2,%d4,%d2
8000712e:	82 1f       	mov %d15,1
80007130:	8f b3 1f 20 	sh %d2,%d3,-5
80007134:	0b 26 50 f2 	and.ge.u %d15,%d6,%d2
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80007138:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
8000713a:	ee 0f       	jnz %d15,80007158 <IfxScuCcu_calculateSysPllDividers+0x100>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
8000713c:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
8000713e:	c2 f5       	add %d5,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80007140:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80007142:	c2 f8       	add %d8,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80007144:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80007148:	e9 45 09 00 	st.b [%a4]9,%d5
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
8000714c:	e9 49 08 00 	st.b [%a4]8,%d9
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80007150:	e9 48 0a 00 	st.b [%a4]10,%d8
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80007154:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80007156:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80007158:	00 90       	ret 

8000715a <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000715a:	91 30 00 ff 	movh.a %a15,61443
8000715e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007162:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
80007164:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80007166:	8f ff 00 31 	and %d3,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
8000716a:	f6 32       	jnz %d3,8000716e <IfxScuCcu_getBaud1Frequency+0x14>
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
    }

    return frequency;
}
8000716c:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000716e:	48 04       	ld.w %d4,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007170:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007174:	37 04 62 4e 	extr.u %d4,%d4,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007178:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000717c:	df 04 2c 00 	jeq %d4,0,800071d4 <IfxScuCcu_getBaud1Frequency+0x7a>
80007180:	df 14 46 80 	jne %d4,1,8000720c <IfxScuCcu_getBaud1Frequency+0xb2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007184:	91 30 00 ff 	movh.a %a15,61443
80007188:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000718c:	48 04       	ld.w %d4,[%a15]0
8000718e:	37 04 62 4e 	extr.u %d4,%d4,28,2
80007192:	df 04 79 80 	jne %d4,0,80007284 <IfxScuCcu_getBaud1Frequency+0x12a>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007196:	91 30 00 ff 	movh.a %a15,61443
8000719a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000719e:	48 52       	ld.w %d2,[%a15]20
800071a0:	6f 02 80 80 	jnz.t %d2,0,800072a0 <IfxScuCcu_getBaud1Frequency+0x146>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800071a4:	48 52       	ld.w %d2,[%a15]20
800071a6:	6f 32 86 80 	jnz.t %d2,3,800072b2 <IfxScuCcu_getBaud1Frequency+0x158>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800071aa:	48 65       	ld.w %d5,[%a15]24
800071ac:	48 72       	ld.w %d2,[%a15]28
800071ae:	37 05 e7 54 	extr.u %d5,%d5,9,7
800071b2:	8f f2 07 41 	and %d4,%d2,127
800071b6:	48 62       	ld.w %d2,[%a15]24
800071b8:	c2 15       	add %d5,1
800071ba:	37 02 64 2c 	extr.u %d2,%d2,24,4
800071be:	4b 05 41 51 	itof %d5,%d5
800071c2:	c2 12       	add %d2,1
800071c4:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
800071c8:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
800071cc:	4b 02 41 21 	itof %d2,%d2
800071d0:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800071d4:	91 30 00 ff 	movh.a %a15,61443
800071d8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800071dc:	48 02       	ld.w %d2,[%a15]0
800071de:	37 02 64 26 	extr.u %d2,%d2,12,4
800071e2:	bf 52 04 80 	jlt.u %d2,5,800071ea <IfxScuCcu_getBaud1Frequency+0x90>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
        break;
    default:
        maxFrequency = 0.0f;
800071e6:	82 0f       	mov %d15,0
800071e8:	3c 23       	j 8000722e <IfxScuCcu_getBaud1Frequency+0xd4>
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800071ea:	91 00 00 f8 	movh.a %a15,32768
800071ee:	d9 ff 38 77 	lea %a15,[%a15]29176 <800071f8 <IfxScuCcu_getBaud1Frequency+0x9e>>
800071f2:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
800071f6:	dc 0f       	ji %a15
800071f8:	1d 00 2e 00 	j 80007254 <IfxScuCcu_getBaud1Frequency+0xfa>
800071fc:	1d 00 25 00 	j 80007246 <IfxScuCcu_getBaud1Frequency+0xec>
80007200:	1d 00 1c 00 	j 80007238 <IfxScuCcu_getBaud1Frequency+0xde>
80007204:	1d 00 0f 00 	j 80007222 <IfxScuCcu_getBaud1Frequency+0xc8>
80007208:	1d 00 37 00 	j 80007276 <IfxScuCcu_getBaud1Frequency+0x11c>
8000720c:	91 30 00 ff 	movh.a %a15,61443
80007210:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007214:	48 02       	ld.w %d2,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007216:	82 0f       	mov %d15,0
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007218:	37 02 64 26 	extr.u %d2,%d2,12,4
8000721c:	ff 52 e5 ff 	jge.u %d2,5,800071e6 <IfxScuCcu_getBaud1Frequency+0x8c>
80007220:	3c e5       	j 800071ea <IfxScuCcu_getBaud1Frequency+0x90>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80007222:	7b 90 c8 23 	movh %d2,15497
80007226:	1b 92 88 28 	addi %d2,%d2,-30583
8000722a:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
8000722e:	4b 03 41 21 	itof %d2,%d3
80007232:	4b 2f 51 20 	div.f %d2,%d15,%d2
    }

    return frequency;
}
80007236:	00 90       	ret 
        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
80007238:	7b 90 d0 23 	movh %d2,15625
8000723c:	1b 92 88 28 	addi %d2,%d2,-30583
80007240:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80007244:	3c f5       	j 8000722e <IfxScuCcu_getBaud1Frequency+0xd4>
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80007246:	7b 90 d8 23 	movh %d2,15753
8000724a:	1b 92 88 28 	addi %d2,%d2,-30583
8000724e:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80007252:	3c ee       	j 8000722e <IfxScuCcu_getBaud1Frequency+0xd4>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
80007254:	91 30 00 ff 	movh.a %a15,61443
80007258:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
8000725c:	48 02       	ld.w %d2,[%a15]0
8000725e:	8f f2 00 21 	and %d2,%d2,15
80007262:	df 02 e6 7f 	jeq %d2,0,8000722e <IfxScuCcu_getBaud1Frequency+0xd4>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
80007266:	48 02       	ld.w %d2,[%a15]0
80007268:	8f f2 00 21 	and %d2,%d2,15
8000726c:	4b 02 41 21 	itof %d2,%d2
80007270:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80007274:	3c dd       	j 8000722e <IfxScuCcu_getBaud1Frequency+0xd4>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
80007276:	7b 90 c0 23 	movh %d2,15369
8000727a:	1b 92 88 28 	addi %d2,%d2,-30583
8000727e:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80007282:	3c d6       	j 8000722e <IfxScuCcu_getBaud1Frequency+0xd4>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007284:	48 04       	ld.w %d4,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007286:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007288:	37 04 62 4e 	extr.u %d4,%d4,28,2
8000728c:	df 14 85 ff 	jne %d4,1,80007196 <IfxScuCcu_getBaud1Frequency+0x3c>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007290:	91 00 00 f7 	movh.a %a15,28672
80007294:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007298:	4b 0f 61 f1 	utof %d15,%d15
8000729c:	1d ff 7d ff 	j 80007196 <IfxScuCcu_getBaud1Frequency+0x3c>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800072a0:	48 72       	ld.w %d2,[%a15]28
800072a2:	37 02 67 28 	extr.u %d2,%d2,16,7
800072a6:	c2 12       	add %d2,1
800072a8:	4b 02 41 21 	itof %d2,%d2
800072ac:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800072b0:	3c 92       	j 800071d4 <IfxScuCcu_getBaud1Frequency+0x7a>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800072b2:	4c f7       	ld.w %d15,[%a15]28
800072b4:	7b f0 cb 24 	movh %d2,19647
800072b8:	16 7f       	and %d15,127
800072ba:	c2 1f       	add %d15,1
800072bc:	4b 0f 41 f1 	itof %d15,%d15
800072c0:	1b 02 c2 2b 	addi %d2,%d2,-17376
800072c4:	4b f2 51 f0 	div.f %d15,%d2,%d15
800072c8:	3c 86       	j 800071d4 <IfxScuCcu_getBaud1Frequency+0x7a>

800072ca <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800072ca:	91 30 00 ff 	movh.a %a15,61443
800072ce:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800072d2:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
800072d4:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800072d6:	37 0f 64 32 	extr.u %d3,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
800072da:	16 f0       	and %d15,240
800072dc:	ee 02       	jnz %d15,800072e0 <IfxScuCcu_getBaud2Frequency+0x16>
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
    }

    return frequency;
}
800072de:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800072e0:	48 04       	ld.w %d4,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800072e2:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800072e6:	37 04 62 4e 	extr.u %d4,%d4,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800072ea:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800072ee:	df 04 2c 00 	jeq %d4,0,80007346 <IfxScuCcu_getBaud2Frequency+0x7c>
800072f2:	df 14 47 80 	jne %d4,1,80007380 <IfxScuCcu_getBaud2Frequency+0xb6>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
800072f6:	91 30 00 ff 	movh.a %a15,61443
800072fa:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800072fe:	48 04       	ld.w %d4,[%a15]0
80007300:	37 04 62 4e 	extr.u %d4,%d4,28,2
80007304:	df 04 7a 80 	jne %d4,0,800073f8 <IfxScuCcu_getBaud2Frequency+0x12e>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007308:	91 30 00 ff 	movh.a %a15,61443
8000730c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007310:	48 52       	ld.w %d2,[%a15]20
80007312:	6f 02 81 80 	jnz.t %d2,0,80007414 <IfxScuCcu_getBaud2Frequency+0x14a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007316:	48 52       	ld.w %d2,[%a15]20
80007318:	6f 32 87 80 	jnz.t %d2,3,80007426 <IfxScuCcu_getBaud2Frequency+0x15c>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000731c:	48 65       	ld.w %d5,[%a15]24
8000731e:	48 72       	ld.w %d2,[%a15]28
80007320:	37 05 e7 54 	extr.u %d5,%d5,9,7
80007324:	8f f2 07 41 	and %d4,%d2,127
80007328:	48 62       	ld.w %d2,[%a15]24
8000732a:	c2 15       	add %d5,1
8000732c:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007330:	4b 05 41 51 	itof %d5,%d5
80007334:	c2 12       	add %d2,1
80007336:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
8000733a:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
8000733e:	4b 02 41 21 	itof %d2,%d2
80007342:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007346:	91 30 00 ff 	movh.a %a15,61443
8000734a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000734e:	48 02       	ld.w %d2,[%a15]0
80007350:	37 02 64 26 	extr.u %d2,%d2,12,4
80007354:	bf 52 04 80 	jlt.u %d2,5,8000735c <IfxScuCcu_getBaud2Frequency+0x92>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
        break;
    default:
        maxFrequency = 0.0f;
80007358:	82 0f       	mov %d15,0
8000735a:	3c 24       	j 800073a2 <IfxScuCcu_getBaud2Frequency+0xd8>
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000735c:	91 00 00 f8 	movh.a %a15,32768
80007360:	d9 ff 2c d7 	lea %a15,[%a15]29548 <8000736c <IfxScuCcu_getBaud2Frequency+0xa2>>
80007364:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
80007368:	dc 0f       	ji %a15
8000736a:	00 00       	nop 
8000736c:	1d 00 2e 00 	j 800073c8 <IfxScuCcu_getBaud2Frequency+0xfe>
80007370:	1d 00 25 00 	j 800073ba <IfxScuCcu_getBaud2Frequency+0xf0>
80007374:	1d 00 1c 00 	j 800073ac <IfxScuCcu_getBaud2Frequency+0xe2>
80007378:	1d 00 0f 00 	j 80007396 <IfxScuCcu_getBaud2Frequency+0xcc>
8000737c:	1d 00 37 00 	j 800073ea <IfxScuCcu_getBaud2Frequency+0x120>
80007380:	91 30 00 ff 	movh.a %a15,61443
80007384:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007388:	48 02       	ld.w %d2,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
8000738a:	82 0f       	mov %d15,0
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000738c:	37 02 64 26 	extr.u %d2,%d2,12,4
80007390:	ff 52 e4 ff 	jge.u %d2,5,80007358 <IfxScuCcu_getBaud2Frequency+0x8e>
80007394:	3c e4       	j 8000735c <IfxScuCcu_getBaud2Frequency+0x92>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80007396:	7b 90 c8 23 	movh %d2,15497
8000739a:	1b 92 88 28 	addi %d2,%d2,-30583
8000739e:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
800073a2:	4b 03 41 21 	itof %d2,%d3
800073a6:	4b 2f 51 20 	div.f %d2,%d15,%d2
    }

    return frequency;
}
800073aa:	00 90       	ret 
        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
800073ac:	7b 90 d0 23 	movh %d2,15625
800073b0:	1b 92 88 28 	addi %d2,%d2,-30583
800073b4:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
800073b8:	3c f5       	j 800073a2 <IfxScuCcu_getBaud2Frequency+0xd8>
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
800073ba:	7b 90 d8 23 	movh %d2,15753
800073be:	1b 92 88 28 	addi %d2,%d2,-30583
800073c2:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
800073c6:	3c ee       	j 800073a2 <IfxScuCcu_getBaud2Frequency+0xd8>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
800073c8:	91 30 00 ff 	movh.a %a15,61443
800073cc:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
800073d0:	48 02       	ld.w %d2,[%a15]0
800073d2:	8f f2 00 21 	and %d2,%d2,15
800073d6:	df 02 e6 7f 	jeq %d2,0,800073a2 <IfxScuCcu_getBaud2Frequency+0xd8>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
800073da:	48 02       	ld.w %d2,[%a15]0
800073dc:	8f f2 00 21 	and %d2,%d2,15
800073e0:	4b 02 41 21 	itof %d2,%d2
800073e4:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800073e8:	3c dd       	j 800073a2 <IfxScuCcu_getBaud2Frequency+0xd8>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
800073ea:	7b 90 c0 23 	movh %d2,15369
800073ee:	1b 92 88 28 	addi %d2,%d2,-30583
800073f2:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
800073f6:	3c d6       	j 800073a2 <IfxScuCcu_getBaud2Frequency+0xd8>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800073f8:	48 04       	ld.w %d4,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800073fa:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800073fc:	37 04 62 4e 	extr.u %d4,%d4,28,2
80007400:	df 14 84 ff 	jne %d4,1,80007308 <IfxScuCcu_getBaud2Frequency+0x3e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007404:	91 00 00 f7 	movh.a %a15,28672
80007408:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
8000740c:	4b 0f 61 f1 	utof %d15,%d15
80007410:	1d ff 7c ff 	j 80007308 <IfxScuCcu_getBaud2Frequency+0x3e>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007414:	48 72       	ld.w %d2,[%a15]28
80007416:	37 02 67 28 	extr.u %d2,%d2,16,7
8000741a:	c2 12       	add %d2,1
8000741c:	4b 02 41 21 	itof %d2,%d2
80007420:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80007424:	3c 91       	j 80007346 <IfxScuCcu_getBaud2Frequency+0x7c>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007426:	4c f7       	ld.w %d15,[%a15]28
80007428:	7b f0 cb 24 	movh %d2,19647
8000742c:	16 7f       	and %d15,127
8000742e:	c2 1f       	add %d15,1
80007430:	4b 0f 41 f1 	itof %d15,%d15
80007434:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007438:	4b f2 51 f0 	div.f %d15,%d2,%d15
8000743c:	3c 85       	j 80007346 <IfxScuCcu_getBaud2Frequency+0x7c>

8000743e <IfxScuCcu_getBbbFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000743e:	91 30 00 ff 	movh.a %a15,61443
80007442:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007446:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007448:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000744c:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007450:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007454:	df 02 2c 00 	jeq %d2,0,800074ac <IfxScuCcu_getBbbFrequency+0x6e>
80007458:	df 12 4d 80 	jne %d2,1,800074f2 <IfxScuCcu_getBbbFrequency+0xb4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000745c:	91 30 00 ff 	movh.a %a15,61443
80007460:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007464:	48 02       	ld.w %d2,[%a15]0
80007466:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000746a:	df 02 6d 80 	jne %d2,0,80007544 <IfxScuCcu_getBbbFrequency+0x106>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000746e:	91 30 00 ff 	movh.a %a15,61443
80007472:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007476:	48 52       	ld.w %d2,[%a15]20
80007478:	6f 02 73 80 	jnz.t %d2,0,8000755e <IfxScuCcu_getBbbFrequency+0x120>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000747c:	48 52       	ld.w %d2,[%a15]20
8000747e:	6f 32 79 80 	jnz.t %d2,3,80007570 <IfxScuCcu_getBbbFrequency+0x132>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007482:	48 64       	ld.w %d4,[%a15]24
80007484:	48 72       	ld.w %d2,[%a15]28
80007486:	37 04 e7 44 	extr.u %d4,%d4,9,7
8000748a:	8f f2 07 31 	and %d3,%d2,127
8000748e:	48 62       	ld.w %d2,[%a15]24
80007490:	c2 14       	add %d4,1
80007492:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007496:	4b 04 41 41 	itof %d4,%d4
8000749a:	c2 12       	add %d2,1
8000749c:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
800074a0:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
800074a4:	4b 02 41 21 	itof %d2,%d2
800074a8:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800074ac:	91 30 00 ff 	movh.a %a15,61443
800074b0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800074b4:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0f;
800074b6:	82 02       	mov %d2,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800074b8:	37 03 64 36 	extr.u %d3,%d3,12,4
800074bc:	ff 53 1a 80 	jge.u %d3,5,800074f0 <IfxScuCcu_getBbbFrequency+0xb2>
800074c0:	91 00 00 f8 	movh.a %a15,32768
800074c4:	d9 ff 50 37 	lea %a15,[%a15]29904 <800074d0 <IfxScuCcu_getBbbFrequency+0x92>>
800074c8:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800074cc:	dc 0f       	ji %a15
800074ce:	00 00       	nop 
800074d0:	1d 00 1a 00 	j 80007504 <IfxScuCcu_getBbbFrequency+0xc6>
800074d4:	1d 00 2a 00 	j 80007528 <IfxScuCcu_getBbbFrequency+0xea>
800074d8:	1d 00 2f 00 	j 80007536 <IfxScuCcu_getBbbFrequency+0xf8>
800074dc:	1d 00 0d 00 	j 800074f6 <IfxScuCcu_getBbbFrequency+0xb8>
800074e0:	1d 00 02 00 	j 800074e4 <IfxScuCcu_getBbbFrequency+0xa6>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
800074e4:	7b 90 b8 23 	movh %d2,15241
800074e8:	1b 92 88 28 	addi %d2,%d2,-30583
800074ec:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        bbbFrequency = 0.0f;
        break;
    }

    return bbbFrequency;
}
800074f0:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800074f2:	82 0f       	mov %d15,0
800074f4:	3c dc       	j 800074ac <IfxScuCcu_getBbbFrequency+0x6e>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
800074f6:	7b 90 c0 23 	movh %d2,15369
800074fa:	1b 92 88 28 	addi %d2,%d2,-30583
800074fe:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80007502:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80007504:	91 30 00 ff 	movh.a %a15,61443
80007508:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
8000750c:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0f;
8000750e:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80007510:	8f f3 00 31 	and %d3,%d3,15
80007514:	df 03 ee 7f 	jeq %d3,0,800074f0 <IfxScuCcu_getBbbFrequency+0xb2>
        {
            bbbFrequency = 0.0f;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
80007518:	48 02       	ld.w %d2,[%a15]0
8000751a:	8f f2 00 21 	and %d2,%d2,15
8000751e:	4b 02 41 21 	itof %d2,%d2
80007522:	4b 2f 51 20 	div.f %d2,%d15,%d2
80007526:	00 90       	ret 
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
80007528:	7b 90 d0 23 	movh %d2,15625
8000752c:	1b 92 88 28 	addi %d2,%d2,-30583
80007530:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80007534:	00 90       	ret 
    case 2:
        bbbFrequency = sourceFrequency / 60;
80007536:	7b 90 c8 23 	movh %d2,15497
8000753a:	1b 92 88 28 	addi %d2,%d2,-30583
8000753e:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80007542:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007544:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007546:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007548:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000754c:	df 12 91 ff 	jne %d2,1,8000746e <IfxScuCcu_getBbbFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007550:	91 00 00 f7 	movh.a %a15,28672
80007554:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007558:	4b 0f 61 f1 	utof %d15,%d15
8000755c:	3c 89       	j 8000746e <IfxScuCcu_getBbbFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
8000755e:	48 72       	ld.w %d2,[%a15]28
80007560:	37 02 67 28 	extr.u %d2,%d2,16,7
80007564:	c2 12       	add %d2,1
80007566:	4b 02 41 21 	itof %d2,%d2
8000756a:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000756e:	3c 9f       	j 800074ac <IfxScuCcu_getBbbFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007570:	4c f7       	ld.w %d15,[%a15]28
80007572:	7b f0 cb 24 	movh %d2,19647
80007576:	16 7f       	and %d15,127
80007578:	c2 1f       	add %d15,1
8000757a:	4b 0f 41 f1 	itof %d15,%d15
8000757e:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007582:	4b f2 51 f0 	div.f %d15,%d2,%d15
80007586:	3c 93       	j 800074ac <IfxScuCcu_getBbbFrequency+0x6e>

80007588 <IfxScuCcu_getCpuFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007588:	91 30 00 ff 	movh.a %a15,61443
8000758c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007590:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007592:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007596:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000759a:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000759e:	df 02 2c 00 	jeq %d2,0,800075f6 <IfxScuCcu_getCpuFrequency+0x6e>
800075a2:	df 12 6a 80 	jne %d2,1,80007676 <IfxScuCcu_getCpuFrequency+0xee>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
800075a6:	91 30 00 ff 	movh.a %a15,61443
800075aa:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800075ae:	48 02       	ld.w %d2,[%a15]0
800075b0:	37 02 62 2e 	extr.u %d2,%d2,28,2
800075b4:	df 02 8d 80 	jne %d2,0,800076ce <IfxScuCcu_getCpuFrequency+0x146>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800075b8:	91 30 00 ff 	movh.a %a15,61443
800075bc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800075c0:	48 52       	ld.w %d2,[%a15]20
800075c2:	6f 02 94 80 	jnz.t %d2,0,800076ea <IfxScuCcu_getCpuFrequency+0x162>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800075c6:	48 52       	ld.w %d2,[%a15]20
800075c8:	6f 32 9b 80 	jnz.t %d2,3,800076fe <IfxScuCcu_getCpuFrequency+0x176>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800075cc:	48 65       	ld.w %d5,[%a15]24
800075ce:	48 72       	ld.w %d2,[%a15]28
800075d0:	37 05 e7 54 	extr.u %d5,%d5,9,7
800075d4:	8f f2 07 31 	and %d3,%d2,127
800075d8:	48 62       	ld.w %d2,[%a15]24
800075da:	c2 15       	add %d5,1
800075dc:	37 02 64 2c 	extr.u %d2,%d2,24,4
800075e0:	4b 05 41 51 	itof %d5,%d5
800075e4:	c2 12       	add %d2,1
800075e6:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
800075ea:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
800075ee:	4b 02 41 21 	itof %d2,%d2
800075f2:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800075f6:	91 30 00 ff 	movh.a %a15,61443
800075fa:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800075fe:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
80007600:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007602:	37 03 64 36 	extr.u %d3,%d3,12,4
80007606:	ff 53 23 80 	jge.u %d3,5,8000764c <IfxScuCcu_getCpuFrequency+0xc4>
8000760a:	91 00 00 f8 	movh.a %a15,32768
8000760e:	d9 ff 58 87 	lea %a15,[%a15]30232 <80007618 <IfxScuCcu_getCpuFrequency+0x90>>
80007612:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80007616:	dc 0f       	ji %a15
80007618:	1d 00 0a 00 	j 8000762c <IfxScuCcu_getCpuFrequency+0xa4>
8000761c:	1d 00 4b 00 	j 800076b2 <IfxScuCcu_getCpuFrequency+0x12a>
80007620:	1d 00 50 00 	j 800076c0 <IfxScuCcu_getCpuFrequency+0x138>
80007624:	1d 00 39 00 	j 80007696 <IfxScuCcu_getCpuFrequency+0x10e>
80007628:	1d 00 3e 00 	j 800076a4 <IfxScuCcu_getCpuFrequency+0x11c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
8000762c:	91 30 00 ff 	movh.a %a15,61443
80007630:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007634:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0f;
80007636:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80007638:	37 03 64 34 	extr.u %d3,%d3,8,4
8000763c:	76 38       	jz %d3,8000764c <IfxScuCcu_getCpuFrequency+0xc4>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
8000763e:	48 02       	ld.w %d2,[%a15]0
80007640:	37 02 64 24 	extr.u %d2,%d2,8,4
80007644:	4b 02 41 21 	itof %d2,%d2
80007648:	4b 2f 51 20 	div.f %d2,%d15,%d2
float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
    float32 frequency = IfxScuCcu_getSriFrequency();
    uint32  cpuDiv    = 0;

    switch (cpu)
8000764c:	df 14 1f 00 	jeq %d4,1,8000768a <IfxScuCcu_getCpuFrequency+0x102>
80007650:	df 04 17 00 	jeq %d4,0,8000767e <IfxScuCcu_getCpuFrequency+0xf6>
80007654:	df 24 13 80 	jne %d4,2,8000767a <IfxScuCcu_getCpuFrequency+0xf2>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
80007658:	91 30 00 ff 	movh.a %a15,61443
8000765c:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80007660:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0f;
        break;
    }

    if (cpuDiv != 0)
80007662:	6e 0d       	jz %d15,8000767c <IfxScuCcu_getCpuFrequency+0xf4>
80007664:	7b 00 c8 33 	movh %d3,15488
80007668:	4b 32 41 20 	mul.f %d2,%d2,%d3
    {
        frequency = frequency * (cpuDiv / 64.0f);
8000766c:	4b 0f 61 f1 	utof %d15,%d15
80007670:	4b f2 41 20 	mul.f %d2,%d2,%d15
80007674:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007676:	82 0f       	mov %d15,0
80007678:	3c bf       	j 800075f6 <IfxScuCcu_getCpuFrequency+0x6e>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0f;
8000767a:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
8000767c:	00 90       	ret 
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
8000767e:	91 30 00 ff 	movh.a %a15,61443
80007682:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80007686:	4c f0       	ld.w %d15,[%a15]0
        break;
80007688:	3c ed       	j 80007662 <IfxScuCcu_getCpuFrequency+0xda>
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
8000768a:	91 30 00 ff 	movh.a %a15,61443
8000768e:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
80007692:	4c f0       	ld.w %d15,[%a15]0
        break;
80007694:	3c e7       	j 80007662 <IfxScuCcu_getCpuFrequency+0xda>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80007696:	7b 90 c0 23 	movh %d2,15369
8000769a:	1b 92 88 28 	addi %d2,%d2,-30583
8000769e:	4b 2f 41 20 	mul.f %d2,%d15,%d2
800076a2:	3c d5       	j 8000764c <IfxScuCcu_getCpuFrequency+0xc4>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
800076a4:	7b 90 b8 23 	movh %d2,15241
800076a8:	1b 92 88 28 	addi %d2,%d2,-30583
800076ac:	4b 2f 41 20 	mul.f %d2,%d15,%d2
800076b0:	3c ce       	j 8000764c <IfxScuCcu_getCpuFrequency+0xc4>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
800076b2:	7b 90 d0 23 	movh %d2,15625
800076b6:	1b 92 88 28 	addi %d2,%d2,-30583
800076ba:	4b 2f 41 20 	mul.f %d2,%d15,%d2
800076be:	3c c7       	j 8000764c <IfxScuCcu_getCpuFrequency+0xc4>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
800076c0:	7b 90 c8 23 	movh %d2,15497
800076c4:	1b 92 88 28 	addi %d2,%d2,-30583
800076c8:	4b 2f 41 20 	mul.f %d2,%d15,%d2
800076cc:	3c c0       	j 8000764c <IfxScuCcu_getCpuFrequency+0xc4>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800076ce:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800076d0:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800076d2:	37 02 62 2e 	extr.u %d2,%d2,28,2
800076d6:	df 12 71 ff 	jne %d2,1,800075b8 <IfxScuCcu_getCpuFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800076da:	91 00 00 f7 	movh.a %a15,28672
800076de:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
800076e2:	4b 0f 61 f1 	utof %d15,%d15
800076e6:	1d ff 69 ff 	j 800075b8 <IfxScuCcu_getCpuFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800076ea:	48 72       	ld.w %d2,[%a15]28
800076ec:	37 02 67 28 	extr.u %d2,%d2,16,7
800076f0:	c2 12       	add %d2,1
800076f2:	4b 02 41 21 	itof %d2,%d2
800076f6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800076fa:	1d ff 7e ff 	j 800075f6 <IfxScuCcu_getCpuFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800076fe:	4c f7       	ld.w %d15,[%a15]28
80007700:	7b f0 cb 24 	movh %d2,19647
80007704:	16 7f       	and %d15,127
80007706:	c2 1f       	add %d15,1
80007708:	4b 0f 41 f1 	itof %d15,%d15
8000770c:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007710:	4b f2 51 f0 	div.f %d15,%d2,%d15
80007714:	1d ff 71 ff 	j 800075f6 <IfxScuCcu_getCpuFrequency+0x6e>

80007718 <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80007718:	91 30 00 ff 	movh.a %a15,61443
8000771c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007720:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
80007722:	7b 00 03 30 	movh %d3,48
80007726:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80007728:	37 0f 62 4a 	extr.u %d4,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
8000772c:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
8000772e:	f6 32       	jnz %d3,80007732 <IfxScuCcu_getFsi2Frequency+0x1a>
            frequency = frequency / ccucon0.B.FSI2DIV;
        }
    }

    return frequency;
}
80007730:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007732:	48 05       	ld.w %d5,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007734:	7b f0 cb 34 	movh %d3,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007738:	37 05 62 5e 	extr.u %d5,%d5,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000773c:	1b 03 c2 3b 	addi %d3,%d3,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007740:	df 05 2c 00 	jeq %d5,0,80007798 <IfxScuCcu_getFsi2Frequency+0x80>
80007744:	df 15 52 80 	jne %d5,1,800077e8 <IfxScuCcu_getFsi2Frequency+0xd0>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007748:	91 30 00 ff 	movh.a %a15,61443
8000774c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007750:	48 05       	ld.w %d5,[%a15]0
80007752:	37 05 62 5e 	extr.u %d5,%d5,28,2
80007756:	df 05 83 80 	jne %d5,0,8000785c <IfxScuCcu_getFsi2Frequency+0x144>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000775a:	91 30 00 ff 	movh.a %a15,61443
8000775e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007762:	48 52       	ld.w %d2,[%a15]20
80007764:	6f 02 8a 80 	jnz.t %d2,0,80007878 <IfxScuCcu_getFsi2Frequency+0x160>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007768:	48 52       	ld.w %d2,[%a15]20
8000776a:	6f 32 90 80 	jnz.t %d2,3,8000788a <IfxScuCcu_getFsi2Frequency+0x172>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000776e:	48 66       	ld.w %d6,[%a15]24
80007770:	48 72       	ld.w %d2,[%a15]28
80007772:	37 06 e7 64 	extr.u %d6,%d6,9,7
80007776:	8f f2 07 51 	and %d5,%d2,127
8000777a:	48 62       	ld.w %d2,[%a15]24
8000777c:	c2 16       	add %d6,1
8000777e:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007782:	4b 06 41 61 	itof %d6,%d6
80007786:	c2 12       	add %d2,1
80007788:	03 25 0a 22 	madd %d2,%d2,%d5,%d2
8000778c:	4b 63 41 30 	mul.f %d3,%d3,%d6
80007790:	4b 02 41 21 	itof %d2,%d2
80007794:	4b 23 51 30 	div.f %d3,%d3,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007798:	91 30 00 ff 	movh.a %a15,61443
8000779c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800077a0:	48 05       	ld.w %d5,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800077a2:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800077a4:	37 05 64 56 	extr.u %d5,%d5,12,4
800077a8:	bf 55 0f 80 	jlt.u %d5,5,800077c6 <IfxScuCcu_getFsi2Frequency+0xae>
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800077ac:	3b 00 f0 30 	mov %d3,3840
800077b0:	26 3f       	and %d15,%d3
800077b2:	1b 0f f0 ff 	addi %d15,%d15,-256
800077b6:	8f 0f d0 f1 	andn %d15,%d15,256
800077ba:	ee bb       	jnz %d15,80007730 <IfxScuCcu_getFsi2Frequency+0x18>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
800077bc:	4b 04 41 41 	itof %d4,%d4
800077c0:	4b 42 51 20 	div.f %d2,%d2,%d4
        }
    }

    return frequency;
}
800077c4:	00 90       	ret 
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800077c6:	91 00 00 f8 	movh.a %a15,32768
800077ca:	d9 ff 54 f7 	lea %a15,[%a15]30676 <800077d4 <IfxScuCcu_getFsi2Frequency+0xbc>>
800077ce:	01 f5 02 f6 	addsc.a %a15,%a15,%d5,2
800077d2:	dc 0f       	ji %a15
800077d4:	1d 00 2b 00 	j 8000782a <IfxScuCcu_getFsi2Frequency+0x112>
800077d8:	1d 00 22 00 	j 8000781c <IfxScuCcu_getFsi2Frequency+0x104>
800077dc:	1d 00 19 00 	j 8000780e <IfxScuCcu_getFsi2Frequency+0xf6>
800077e0:	1d 00 10 00 	j 80007800 <IfxScuCcu_getFsi2Frequency+0xe8>
800077e4:	1d 00 35 00 	j 8000784e <IfxScuCcu_getFsi2Frequency+0x136>
800077e8:	91 30 00 ff 	movh.a %a15,61443
800077ec:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800077f0:	48 05       	ld.w %d5,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800077f2:	82 03       	mov %d3,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800077f4:	37 05 64 56 	extr.u %d5,%d5,12,4
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800077f8:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800077fa:	ff 55 d9 ff 	jge.u %d5,5,800077ac <IfxScuCcu_getFsi2Frequency+0x94>
800077fe:	3c e4       	j 800077c6 <IfxScuCcu_getFsi2Frequency+0xae>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80007800:	7b 90 c0 23 	movh %d2,15369
80007804:	1b 92 88 28 	addi %d2,%d2,-30583
80007808:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000780c:	3c d0       	j 800077ac <IfxScuCcu_getFsi2Frequency+0x94>
        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
8000780e:	7b 90 c8 23 	movh %d2,15497
80007812:	1b 92 88 28 	addi %d2,%d2,-30583
80007816:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000781a:	3c c9       	j 800077ac <IfxScuCcu_getFsi2Frequency+0x94>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
8000781c:	7b 90 d0 23 	movh %d2,15625
80007820:	1b 92 88 28 	addi %d2,%d2,-30583
80007824:	4b 23 41 20 	mul.f %d2,%d3,%d2
80007828:	3c c2       	j 800077ac <IfxScuCcu_getFsi2Frequency+0x94>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
8000782a:	91 30 00 ff 	movh.a %a15,61443
8000782e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007832:	48 05       	ld.w %d5,[%a15]0
        {
            sriFrequency = 0.0f;
80007834:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80007836:	37 05 64 54 	extr.u %d5,%d5,8,4
8000783a:	df 05 b9 7f 	jeq %d5,0,800077ac <IfxScuCcu_getFsi2Frequency+0x94>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
8000783e:	48 02       	ld.w %d2,[%a15]0
80007840:	37 02 64 24 	extr.u %d2,%d2,8,4
80007844:	4b 02 41 21 	itof %d2,%d2
80007848:	4b 23 51 20 	div.f %d2,%d3,%d2
8000784c:	3c b0       	j 800077ac <IfxScuCcu_getFsi2Frequency+0x94>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
8000784e:	7b 90 b8 23 	movh %d2,15241
80007852:	1b 92 88 28 	addi %d2,%d2,-30583
80007856:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000785a:	3c a9       	j 800077ac <IfxScuCcu_getFsi2Frequency+0x94>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000785c:	48 05       	ld.w %d5,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
8000785e:	82 03       	mov %d3,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007860:	37 05 62 5e 	extr.u %d5,%d5,28,2
80007864:	df 15 7b ff 	jne %d5,1,8000775a <IfxScuCcu_getFsi2Frequency+0x42>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007868:	91 00 00 f7 	movh.a %a15,28672
8000786c:	19 f3 f8 c0 	ld.w %d3,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007870:	4b 03 61 31 	utof %d3,%d3
80007874:	1d ff 73 ff 	j 8000775a <IfxScuCcu_getFsi2Frequency+0x42>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007878:	48 72       	ld.w %d2,[%a15]28
8000787a:	37 02 67 28 	extr.u %d2,%d2,16,7
8000787e:	c2 12       	add %d2,1
80007880:	4b 02 41 21 	itof %d2,%d2
80007884:	4b 23 51 30 	div.f %d3,%d3,%d2
80007888:	3c 88       	j 80007798 <IfxScuCcu_getFsi2Frequency+0x80>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000788a:	48 73       	ld.w %d3,[%a15]28
8000788c:	8f f3 07 31 	and %d3,%d3,127
80007890:	c2 13       	add %d3,1
80007892:	4b 03 41 21 	itof %d2,%d3
80007896:	7b f0 cb 34 	movh %d3,19647
8000789a:	1b 03 c2 3b 	addi %d3,%d3,-17376
8000789e:	4b 23 51 30 	div.f %d3,%d3,%d2
800078a2:	1d ff 7b ff 	j 80007798 <IfxScuCcu_getFsi2Frequency+0x80>

800078a6 <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800078a6:	91 30 00 ff 	movh.a %a15,61443
800078aa:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800078ae:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
800078b0:	7b 00 30 30 	movh %d3,768
800078b4:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800078b6:	37 0f 62 4c 	extr.u %d4,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
800078ba:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
800078bc:	f6 32       	jnz %d3,800078c0 <IfxScuCcu_getFsiFrequency+0x1a>
            frequency = frequency / ccucon0.B.FSIDIV;
        }
    }

    return frequency;
}
800078be:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800078c0:	48 05       	ld.w %d5,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800078c2:	7b f0 cb 34 	movh %d3,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800078c6:	37 05 62 5e 	extr.u %d5,%d5,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800078ca:	1b 03 c2 3b 	addi %d3,%d3,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800078ce:	df 05 2c 00 	jeq %d5,0,80007926 <IfxScuCcu_getFsiFrequency+0x80>
800078d2:	df 15 53 80 	jne %d5,1,80007978 <IfxScuCcu_getFsiFrequency+0xd2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
800078d6:	91 30 00 ff 	movh.a %a15,61443
800078da:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800078de:	48 05       	ld.w %d5,[%a15]0
800078e0:	37 05 62 5e 	extr.u %d5,%d5,28,2
800078e4:	df 05 84 80 	jne %d5,0,800079ec <IfxScuCcu_getFsiFrequency+0x146>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800078e8:	91 30 00 ff 	movh.a %a15,61443
800078ec:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800078f0:	48 52       	ld.w %d2,[%a15]20
800078f2:	6f 02 8b 80 	jnz.t %d2,0,80007a08 <IfxScuCcu_getFsiFrequency+0x162>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800078f6:	48 52       	ld.w %d2,[%a15]20
800078f8:	6f 32 91 80 	jnz.t %d2,3,80007a1a <IfxScuCcu_getFsiFrequency+0x174>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800078fc:	48 66       	ld.w %d6,[%a15]24
800078fe:	48 72       	ld.w %d2,[%a15]28
80007900:	37 06 e7 64 	extr.u %d6,%d6,9,7
80007904:	8f f2 07 51 	and %d5,%d2,127
80007908:	48 62       	ld.w %d2,[%a15]24
8000790a:	c2 16       	add %d6,1
8000790c:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007910:	4b 06 41 61 	itof %d6,%d6
80007914:	c2 12       	add %d2,1
80007916:	03 25 0a 22 	madd %d2,%d2,%d5,%d2
8000791a:	4b 63 41 30 	mul.f %d3,%d3,%d6
8000791e:	4b 02 41 21 	itof %d2,%d2
80007922:	4b 23 51 30 	div.f %d3,%d3,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007926:	91 30 00 ff 	movh.a %a15,61443
8000792a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000792e:	48 05       	ld.w %d5,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
80007930:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007932:	37 05 64 56 	extr.u %d5,%d5,12,4
80007936:	bf 55 0f 80 	jlt.u %d5,5,80007954 <IfxScuCcu_getFsiFrequency+0xae>
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
8000793a:	3b 00 f0 30 	mov %d3,3840
8000793e:	26 3f       	and %d15,%d3
80007940:	1b 0f f0 ff 	addi %d15,%d15,-256
80007944:	8f 0f d0 f1 	andn %d15,%d15,256
80007948:	ee bb       	jnz %d15,800078be <IfxScuCcu_getFsiFrequency+0x18>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
8000794a:	4b 04 41 41 	itof %d4,%d4
8000794e:	4b 42 51 20 	div.f %d2,%d2,%d4
        }
    }

    return frequency;
}
80007952:	00 90       	ret 
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007954:	91 00 00 f8 	movh.a %a15,32768
80007958:	d9 ff a4 57 	lea %a15,[%a15]31076 <80007964 <IfxScuCcu_getFsiFrequency+0xbe>>
8000795c:	01 f5 02 f6 	addsc.a %a15,%a15,%d5,2
80007960:	dc 0f       	ji %a15
80007962:	00 00       	nop 
80007964:	1d 00 2b 00 	j 800079ba <IfxScuCcu_getFsiFrequency+0x114>
80007968:	1d 00 22 00 	j 800079ac <IfxScuCcu_getFsiFrequency+0x106>
8000796c:	1d 00 19 00 	j 8000799e <IfxScuCcu_getFsiFrequency+0xf8>
80007970:	1d 00 10 00 	j 80007990 <IfxScuCcu_getFsiFrequency+0xea>
80007974:	1d 00 35 00 	j 800079de <IfxScuCcu_getFsiFrequency+0x138>
80007978:	91 30 00 ff 	movh.a %a15,61443
8000797c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007980:	48 05       	ld.w %d5,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007982:	82 03       	mov %d3,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007984:	37 05 64 56 	extr.u %d5,%d5,12,4
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
80007988:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000798a:	ff 55 d8 ff 	jge.u %d5,5,8000793a <IfxScuCcu_getFsiFrequency+0x94>
8000798e:	3c e3       	j 80007954 <IfxScuCcu_getFsiFrequency+0xae>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80007990:	7b 90 c0 23 	movh %d2,15369
80007994:	1b 92 88 28 	addi %d2,%d2,-30583
80007998:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000799c:	3c cf       	j 8000793a <IfxScuCcu_getFsiFrequency+0x94>
        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
8000799e:	7b 90 c8 23 	movh %d2,15497
800079a2:	1b 92 88 28 	addi %d2,%d2,-30583
800079a6:	4b 23 41 20 	mul.f %d2,%d3,%d2
800079aa:	3c c8       	j 8000793a <IfxScuCcu_getFsiFrequency+0x94>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
800079ac:	7b 90 d0 23 	movh %d2,15625
800079b0:	1b 92 88 28 	addi %d2,%d2,-30583
800079b4:	4b 23 41 20 	mul.f %d2,%d3,%d2
800079b8:	3c c1       	j 8000793a <IfxScuCcu_getFsiFrequency+0x94>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800079ba:	91 30 00 ff 	movh.a %a15,61443
800079be:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800079c2:	48 05       	ld.w %d5,[%a15]0
        {
            sriFrequency = 0.0f;
800079c4:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800079c6:	37 05 64 54 	extr.u %d5,%d5,8,4
800079ca:	df 05 b8 7f 	jeq %d5,0,8000793a <IfxScuCcu_getFsiFrequency+0x94>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
800079ce:	48 02       	ld.w %d2,[%a15]0
800079d0:	37 02 64 24 	extr.u %d2,%d2,8,4
800079d4:	4b 02 41 21 	itof %d2,%d2
800079d8:	4b 23 51 20 	div.f %d2,%d3,%d2
800079dc:	3c af       	j 8000793a <IfxScuCcu_getFsiFrequency+0x94>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
800079de:	7b 90 b8 23 	movh %d2,15241
800079e2:	1b 92 88 28 	addi %d2,%d2,-30583
800079e6:	4b 23 41 20 	mul.f %d2,%d3,%d2
800079ea:	3c a8       	j 8000793a <IfxScuCcu_getFsiFrequency+0x94>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800079ec:	48 05       	ld.w %d5,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800079ee:	82 03       	mov %d3,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800079f0:	37 05 62 5e 	extr.u %d5,%d5,28,2
800079f4:	df 15 7a ff 	jne %d5,1,800078e8 <IfxScuCcu_getFsiFrequency+0x42>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800079f8:	91 00 00 f7 	movh.a %a15,28672
800079fc:	19 f3 f8 c0 	ld.w %d3,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007a00:	4b 03 61 31 	utof %d3,%d3
80007a04:	1d ff 72 ff 	j 800078e8 <IfxScuCcu_getFsiFrequency+0x42>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007a08:	48 72       	ld.w %d2,[%a15]28
80007a0a:	37 02 67 28 	extr.u %d2,%d2,16,7
80007a0e:	c2 12       	add %d2,1
80007a10:	4b 02 41 21 	itof %d2,%d2
80007a14:	4b 23 51 30 	div.f %d3,%d3,%d2
80007a18:	3c 87       	j 80007926 <IfxScuCcu_getFsiFrequency+0x80>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007a1a:	48 73       	ld.w %d3,[%a15]28
80007a1c:	8f f3 07 31 	and %d3,%d3,127
80007a20:	c2 13       	add %d3,1
80007a22:	4b 03 41 21 	itof %d2,%d3
80007a26:	7b f0 cb 34 	movh %d3,19647
80007a2a:	1b 03 c2 3b 	addi %d3,%d3,-17376
80007a2e:	4b 23 51 30 	div.f %d3,%d3,%d2
80007a32:	1d ff 7a ff 	j 80007926 <IfxScuCcu_getFsiFrequency+0x80>

80007a36 <IfxScuCcu_getMaxFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007a36:	91 30 00 ff 	movh.a %a15,61443
80007a3a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007a3e:	4c f0       	ld.w %d15,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007a40:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007a44:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007a48:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007a4c:	6e 2a       	jz %d15,80007aa0 <IfxScuCcu_getMaxFrequency+0x6a>
80007a4e:	df 1f 45 80 	jne %d15,1,80007ad8 <IfxScuCcu_getMaxFrequency+0xa2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007a52:	91 30 00 ff 	movh.a %a15,61443
80007a56:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007a5a:	4c f0       	ld.w %d15,[%a15]0
80007a5c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007a60:	ee 68       	jnz %d15,80007b30 <IfxScuCcu_getMaxFrequency+0xfa>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007a62:	91 30 00 ff 	movh.a %a15,61443
80007a66:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007a6a:	4c f5       	ld.w %d15,[%a15]20
80007a6c:	6f 0f 6f 80 	jnz.t %d15,0,80007b4a <IfxScuCcu_getMaxFrequency+0x114>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007a70:	4c f5       	ld.w %d15,[%a15]20
80007a72:	6f 3f 75 80 	jnz.t %d15,3,80007b5c <IfxScuCcu_getMaxFrequency+0x126>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007a76:	48 64       	ld.w %d4,[%a15]24
80007a78:	4c f7       	ld.w %d15,[%a15]28
80007a7a:	37 04 e7 44 	extr.u %d4,%d4,9,7
80007a7e:	8f ff 07 31 	and %d3,%d15,127
80007a82:	4c f6       	ld.w %d15,[%a15]24
80007a84:	c2 14       	add %d4,1
80007a86:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80007a8a:	4b 04 41 41 	itof %d4,%d4
80007a8e:	c2 1f       	add %d15,1
80007a90:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80007a94:	4b 42 41 20 	mul.f %d2,%d2,%d4
80007a98:	4b 0f 41 f1 	itof %d15,%d15
80007a9c:	4b f2 51 20 	div.f %d2,%d2,%d15
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007aa0:	91 30 00 ff 	movh.a %a15,61443
80007aa4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007aa8:	4c f0       	ld.w %d15,[%a15]0
80007aaa:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80007aae:	bf 5f 04 80 	jlt.u %d15,5,80007ab6 <IfxScuCcu_getMaxFrequency+0x80>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
        break;
    default:
        maxFrequency = 0.0f;
80007ab2:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
80007ab4:	00 90       	ret 
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007ab6:	91 00 00 f8 	movh.a %a15,32768
80007aba:	d9 ff 84 b7 	lea %a15,[%a15]31428 <80007ac4 <IfxScuCcu_getMaxFrequency+0x8e>>
80007abe:	90 ff       	addsc.a %a15,%a15,%d15,2
80007ac0:	dc 0f       	ji %a15
80007ac2:	00 00       	nop 
80007ac4:	1d 00 1a 00 	j 80007af8 <IfxScuCcu_getMaxFrequency+0xc2>
80007ac8:	1d 00 26 00 	j 80007b14 <IfxScuCcu_getMaxFrequency+0xde>
80007acc:	1d 00 2b 00 	j 80007b22 <IfxScuCcu_getMaxFrequency+0xec>
80007ad0:	1d 00 06 00 	j 80007adc <IfxScuCcu_getMaxFrequency+0xa6>
80007ad4:	1d 00 0b 00 	j 80007aea <IfxScuCcu_getMaxFrequency+0xb4>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007ad8:	82 02       	mov %d2,0
80007ada:	3c e3       	j 80007aa0 <IfxScuCcu_getMaxFrequency+0x6a>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80007adc:	7b 90 c8 f3 	movh %d15,15497
80007ae0:	1b 9f 88 f8 	addi %d15,%d15,-30583
80007ae4:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
80007ae8:	00 90       	ret 
    case 4:
        maxFrequency = sourceFrequency / 120;
80007aea:	7b 90 c0 f3 	movh %d15,15369
80007aee:	1b 9f 88 f8 	addi %d15,%d15,-30583
80007af2:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
80007af6:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
80007af8:	91 30 00 ff 	movh.a %a15,61443
80007afc:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80007b00:	4c f0       	ld.w %d15,[%a15]0
80007b02:	16 0f       	and %d15,15
80007b04:	6e d8       	jz %d15,80007ab4 <IfxScuCcu_getMaxFrequency+0x7e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
80007b06:	4c f0       	ld.w %d15,[%a15]0
80007b08:	16 0f       	and %d15,15
80007b0a:	4b 0f 41 f1 	itof %d15,%d15
80007b0e:	4b f2 51 20 	div.f %d2,%d2,%d15
80007b12:	00 90       	ret 
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80007b14:	7b 90 d8 f3 	movh %d15,15753
80007b18:	1b 9f 88 f8 	addi %d15,%d15,-30583
80007b1c:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
80007b20:	00 90       	ret 
    case 2:
        maxFrequency = sourceFrequency / 30;
80007b22:	7b 90 d0 f3 	movh %d15,15625
80007b26:	1b 9f 88 f8 	addi %d15,%d15,-30583
80007b2a:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
80007b2e:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007b30:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007b32:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007b34:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007b38:	df 1f 95 ff 	jne %d15,1,80007a62 <IfxScuCcu_getMaxFrequency+0x2c>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007b3c:	91 00 00 f7 	movh.a %a15,28672
80007b40:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007b44:	4b 02 61 21 	utof %d2,%d2
80007b48:	3c 8d       	j 80007a62 <IfxScuCcu_getMaxFrequency+0x2c>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007b4a:	4c f7       	ld.w %d15,[%a15]28
80007b4c:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80007b50:	c2 1f       	add %d15,1
80007b52:	4b 0f 41 f1 	itof %d15,%d15
80007b56:	4b f2 51 20 	div.f %d2,%d2,%d15
80007b5a:	3c a3       	j 80007aa0 <IfxScuCcu_getMaxFrequency+0x6a>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007b5c:	48 72       	ld.w %d2,[%a15]28
80007b5e:	8f f2 07 21 	and %d2,%d2,127
80007b62:	c2 12       	add %d2,1
80007b64:	4b 02 41 f1 	itof %d15,%d2
80007b68:	7b f0 cb 24 	movh %d2,19647
80007b6c:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007b70:	4b f2 51 20 	div.f %d2,%d2,%d15
80007b74:	3c 96       	j 80007aa0 <IfxScuCcu_getMaxFrequency+0x6a>

80007b76 <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
80007b76:	91 30 00 ff 	movh.a %a15,61443
80007b7a:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
80007b7e:	48 05       	ld.w %d5,[%a15]0

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007b80:	91 30 00 ff 	movh.a %a15,61443
80007b84:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007b88:	48 03       	ld.w %d3,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007b8a:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007b8e:	37 03 62 3e 	extr.u %d3,%d3,28,2
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
80007b92:	b7 05 16 65 	insert %d6,%d5,0,10,22
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007b96:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007b9a:	df 03 2c 00 	jeq %d3,0,80007bf2 <IfxScuCcu_getModuleFrequency+0x7c>
80007b9e:	df 13 60 80 	jne %d3,1,80007c5e <IfxScuCcu_getModuleFrequency+0xe8>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007ba2:	91 30 00 ff 	movh.a %a15,61443
80007ba6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007baa:	48 02       	ld.w %d2,[%a15]0
80007bac:	37 02 62 2e 	extr.u %d2,%d2,28,2
80007bb0:	df 02 8c 80 	jne %d2,0,80007cc8 <IfxScuCcu_getModuleFrequency+0x152>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007bb4:	91 30 00 ff 	movh.a %a15,61443
80007bb8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007bbc:	48 52       	ld.w %d2,[%a15]20
80007bbe:	6f 02 93 80 	jnz.t %d2,0,80007ce4 <IfxScuCcu_getModuleFrequency+0x16e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007bc2:	48 52       	ld.w %d2,[%a15]20
80007bc4:	6f 32 9a 80 	jnz.t %d2,3,80007cf8 <IfxScuCcu_getModuleFrequency+0x182>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007bc8:	48 64       	ld.w %d4,[%a15]24
80007bca:	48 72       	ld.w %d2,[%a15]28
80007bcc:	37 04 e7 44 	extr.u %d4,%d4,9,7
80007bd0:	8f f2 07 31 	and %d3,%d2,127
80007bd4:	48 62       	ld.w %d2,[%a15]24
80007bd6:	c2 14       	add %d4,1
80007bd8:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007bdc:	4b 04 41 41 	itof %d4,%d4
80007be0:	c2 12       	add %d2,1
80007be2:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80007be6:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
80007bea:	4b 02 41 21 	itof %d2,%d2
80007bee:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007bf2:	91 30 00 ff 	movh.a %a15,61443
80007bf6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007bfa:	48 04       	ld.w %d4,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0f;
80007bfc:	82 03       	mov %d3,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007bfe:	37 04 64 46 	extr.u %d4,%d4,12,4
80007c02:	ff 54 23 80 	jge.u %d4,5,80007c48 <IfxScuCcu_getModuleFrequency+0xd2>
80007c06:	91 00 00 f8 	movh.a %a15,32768
80007c0a:	d9 ff d4 07 	lea %a15,[%a15]31764 <80007c14 <IfxScuCcu_getModuleFrequency+0x9e>>
80007c0e:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80007c12:	dc 0f       	ji %a15
80007c14:	1d 00 0a 00 	j 80007c28 <IfxScuCcu_getModuleFrequency+0xb2>
80007c18:	1d 00 4a 00 	j 80007cac <IfxScuCcu_getModuleFrequency+0x136>
80007c1c:	1d 00 4f 00 	j 80007cba <IfxScuCcu_getModuleFrequency+0x144>
80007c20:	1d 00 2a 00 	j 80007c74 <IfxScuCcu_getModuleFrequency+0xfe>
80007c24:	1d 00 3d 00 	j 80007c9e <IfxScuCcu_getModuleFrequency+0x128>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80007c28:	91 30 00 ff 	movh.a %a15,61443
80007c2c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007c30:	48 02       	ld.w %d2,[%a15]0
        {
            spbFrequency = 0.0f;
80007c32:	82 03       	mov %d3,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80007c34:	37 02 64 28 	extr.u %d2,%d2,16,4
80007c38:	76 28       	jz %d2,80007c48 <IfxScuCcu_getModuleFrequency+0xd2>
        {
            spbFrequency = 0.0f;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80007c3a:	48 03       	ld.w %d3,[%a15]0
80007c3c:	37 03 64 38 	extr.u %d3,%d3,16,4
80007c40:	4b 03 41 31 	itof %d3,%d3
80007c44:	4b 3f 51 30 	div.f %d3,%d15,%d3
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
80007c48:	bb 00 00 fc 	mov.u %d15,49152
80007c4c:	26 5f       	and %d15,%d5
80007c4e:	3b 00 00 24 	mov %d2,16384
80007c52:	be 2e       	jeq %d15,%d2,80007c8e <IfxScuCcu_getModuleFrequency+0x118>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
80007c54:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
80007c58:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
80007c5a:	3e 44       	jeq %d15,%d4,80007c62 <IfxScuCcu_getModuleFrequency+0xec>
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
80007c5c:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007c5e:	82 0f       	mov %d15,0
80007c60:	3c c9       	j 80007bf2 <IfxScuCcu_getModuleFrequency+0x7c>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
80007c62:	4b 06 41 21 	itof %d2,%d6
80007c66:	7b 00 a8 f3 	movh %d15,14976
80007c6a:	4b f2 41 20 	mul.f %d2,%d2,%d15
80007c6e:	4b 32 41 20 	mul.f %d2,%d2,%d3
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
80007c72:	00 90       	ret 
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
80007c74:	7b 90 c0 33 	movh %d3,15369
80007c78:	1b 93 88 38 	addi %d3,%d3,-30583
80007c7c:	4b 3f 41 30 	mul.f %d3,%d15,%d3
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
80007c80:	bb 00 00 fc 	mov.u %d15,49152
80007c84:	26 5f       	and %d15,%d5
80007c86:	3b 00 00 24 	mov %d2,16384
80007c8a:	5f 2f e5 ff 	jne %d15,%d2,80007c54 <IfxScuCcu_getModuleFrequency+0xde>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
80007c8e:	3b 00 40 20 	mov %d2,1024
80007c92:	a2 62       	sub %d2,%d6
80007c94:	4b 02 41 21 	itof %d2,%d2
80007c98:	4b 23 51 20 	div.f %d2,%d3,%d2
80007c9c:	00 90       	ret 
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
80007c9e:	7b 90 b8 33 	movh %d3,15241
80007ca2:	1b 93 88 38 	addi %d3,%d3,-30583
80007ca6:	4b 3f 41 30 	mul.f %d3,%d15,%d3
80007caa:	3c cf       	j 80007c48 <IfxScuCcu_getModuleFrequency+0xd2>
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80007cac:	7b 90 d0 33 	movh %d3,15625
80007cb0:	1b 93 88 38 	addi %d3,%d3,-30583
80007cb4:	4b 3f 41 30 	mul.f %d3,%d15,%d3
80007cb8:	3c c8       	j 80007c48 <IfxScuCcu_getModuleFrequency+0xd2>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
80007cba:	7b 90 c8 33 	movh %d3,15497
80007cbe:	1b 93 88 38 	addi %d3,%d3,-30583
80007cc2:	4b 3f 41 30 	mul.f %d3,%d15,%d3
80007cc6:	3c c1       	j 80007c48 <IfxScuCcu_getModuleFrequency+0xd2>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007cc8:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007cca:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007ccc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80007cd0:	df 12 72 ff 	jne %d2,1,80007bb4 <IfxScuCcu_getModuleFrequency+0x3e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007cd4:	91 00 00 f7 	movh.a %a15,28672
80007cd8:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007cdc:	4b 0f 61 f1 	utof %d15,%d15
80007ce0:	1d ff 6a ff 	j 80007bb4 <IfxScuCcu_getModuleFrequency+0x3e>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007ce4:	48 72       	ld.w %d2,[%a15]28
80007ce6:	37 02 67 28 	extr.u %d2,%d2,16,7
80007cea:	c2 12       	add %d2,1
80007cec:	4b 02 41 21 	itof %d2,%d2
80007cf0:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80007cf4:	1d ff 7f ff 	j 80007bf2 <IfxScuCcu_getModuleFrequency+0x7c>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007cf8:	4c f7       	ld.w %d15,[%a15]28
80007cfa:	7b f0 cb 24 	movh %d2,19647
80007cfe:	16 7f       	and %d15,127
80007d00:	c2 1f       	add %d15,1
80007d02:	4b 0f 41 f1 	itof %d15,%d15
80007d06:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007d0a:	4b f2 51 f0 	div.f %d15,%d2,%d15
80007d0e:	1d ff 72 ff 	j 80007bf2 <IfxScuCcu_getModuleFrequency+0x7c>

80007d12 <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80007d12:	91 00 00 f7 	movh.a %a15,28672
80007d16:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
}
80007d1a:	4b 02 61 21 	utof %d2,%d2
80007d1e:	00 90       	ret 

80007d20 <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d20:	91 30 00 ff 	movh.a %a15,61443
80007d24:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007d28:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80007d2a:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d2e:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80007d32:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d36:	6e 06       	jz %d15,80007d42 <IfxScuCcu_getOscFrequency+0x22>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007d38:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007d3a:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007d3c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007d40:	1e 12       	jeq %d15,1,80007d44 <IfxScuCcu_getOscFrequency+0x24>
        /* Reserved values, this */
        freq = 0.0f;
    }

    return freq;
}
80007d42:	00 90       	ret 
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007d44:	91 00 00 f7 	movh.a %a15,28672
80007d48:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007d4c:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0f;
    }

    return freq;
}
80007d50:	00 90       	ret 

80007d52 <IfxScuCcu_getPllErayFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d52:	91 30 00 ff 	movh.a %a15,61443
80007d56:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007d5a:	48 02       	ld.w %d2,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80007d5c:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d60:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80007d64:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d68:	df 02 1e 80 	jne %d2,0,80007da4 <IfxScuCcu_getPllErayFrequency+0x52>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80007d6c:	91 30 00 ff 	movh.a %a15,61443
80007d70:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007d74:	48 92       	ld.w %d2,[%a15]36
80007d76:	6f 02 2a 80 	jnz.t %d2,0,80007dca <IfxScuCcu_getPllErayFrequency+0x78>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80007d7a:	48 92       	ld.w %d2,[%a15]36
80007d7c:	6f 32 30 80 	jnz.t %d2,3,80007ddc <IfxScuCcu_getPllErayFrequency+0x8a>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80007d80:	48 a2       	ld.w %d2,[%a15]40
80007d82:	48 b3       	ld.w %d3,[%a15]44
80007d84:	37 02 e5 24 	extr.u %d2,%d2,9,5
80007d88:	8f f3 07 31 	and %d3,%d3,127
80007d8c:	c2 12       	add %d2,1
80007d8e:	4b 02 41 21 	itof %d2,%d2
80007d92:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80007d96:	1b 13 00 20 	addi %d2,%d3,1
80007d9a:	4b 02 41 31 	itof %d3,%d2
80007d9e:	4b 3f 51 20 	div.f %d2,%d15,%d3
    }

    return freq;
}
80007da2:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007da4:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007da6:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007da8:	37 02 62 2e 	extr.u %d2,%d2,28,2
80007dac:	df 12 e0 ff 	jne %d2,1,80007d6c <IfxScuCcu_getPllErayFrequency+0x1a>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007db0:	91 00 00 f7 	movh.a %a15,28672
80007db4:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80007db8:	91 30 00 ff 	movh.a %a15,61443
80007dbc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007dc0:	4b 02 61 f1 	utof %d15,%d2
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80007dc4:	48 92       	ld.w %d2,[%a15]36
80007dc6:	6f 02 da 7f 	jz.t %d2,0,80007d7a <IfxScuCcu_getPllErayFrequency+0x28>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80007dca:	48 b2       	ld.w %d2,[%a15]44
80007dcc:	37 02 67 28 	extr.u %d2,%d2,16,7
80007dd0:	c2 12       	add %d2,1
80007dd2:	4b 02 41 21 	itof %d2,%d2
80007dd6:	4b 2f 51 20 	div.f %d2,%d15,%d2
80007dda:	00 90       	ret 
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80007ddc:	48 b2       	ld.w %d2,[%a15]44
80007dde:	8f f2 07 21 	and %d2,%d2,127
80007de2:	c2 12       	add %d2,1
80007de4:	4b 02 41 f1 	itof %d15,%d2
80007de8:	7b f0 cb 24 	movh %d2,19647
80007dec:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007df0:	4b f2 51 20 	div.f %d2,%d2,%d15
80007df4:	00 90       	ret 

80007df6 <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80007df6:	91 30 00 ff 	movh.a %a15,61443
80007dfa:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80007dfe:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80007e00:	7b f0 cb 24 	movh %d2,19647
80007e04:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80007e08:	6f 3f 1e 80 	jnz.t %d15,3,80007e44 <IfxScuCcu_getPllErayVcoFrequency+0x4e>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007e0c:	91 30 00 ff 	movh.a %a15,61443
80007e10:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007e14:	4c f0       	ld.w %d15,[%a15]0
80007e16:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007e1a:	ee 16       	jnz %d15,80007e46 <IfxScuCcu_getPllErayVcoFrequency+0x50>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80007e1c:	91 30 00 ff 	movh.a %a15,61443
80007e20:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80007e24:	48 03       	ld.w %d3,[%a15]0
80007e26:	4c f0       	ld.w %d15,[%a15]0
80007e28:	37 03 e5 34 	extr.u %d3,%d3,9,5
80007e2c:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80007e30:	c2 13       	add %d3,1
80007e32:	4b 03 41 31 	itof %d3,%d3
80007e36:	c2 1f       	add %d15,1
80007e38:	4b 32 41 20 	mul.f %d2,%d2,%d3
80007e3c:	4b 0f 41 f1 	itof %d15,%d15
80007e40:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80007e44:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007e46:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007e48:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007e4a:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007e4e:	df 1f e7 ff 	jne %d15,1,80007e1c <IfxScuCcu_getPllErayVcoFrequency+0x26>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007e52:	91 00 00 f7 	movh.a %a15,28672
80007e56:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007e5a:	4b 02 61 21 	utof %d2,%d2
80007e5e:	3c df       	j 80007e1c <IfxScuCcu_getPllErayVcoFrequency+0x26>

80007e60 <IfxScuCcu_getPllFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007e60:	91 30 00 ff 	movh.a %a15,61443
80007e64:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007e68:	48 02       	ld.w %d2,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80007e6a:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007e6e:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80007e72:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007e76:	df 02 22 80 	jne %d2,0,80007eba <IfxScuCcu_getPllFrequency+0x5a>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007e7a:	91 30 00 ff 	movh.a %a15,61443
80007e7e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007e82:	48 52       	ld.w %d2,[%a15]20
80007e84:	6f 02 2e 80 	jnz.t %d2,0,80007ee0 <IfxScuCcu_getPllFrequency+0x80>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007e88:	48 52       	ld.w %d2,[%a15]20
80007e8a:	6f 32 34 80 	jnz.t %d2,3,80007ef2 <IfxScuCcu_getPllFrequency+0x92>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007e8e:	48 62       	ld.w %d2,[%a15]24
80007e90:	48 73       	ld.w %d3,[%a15]28
80007e92:	37 02 e7 24 	extr.u %d2,%d2,9,7
80007e96:	8f f3 07 41 	and %d4,%d3,127
80007e9a:	48 63       	ld.w %d3,[%a15]24
80007e9c:	c2 12       	add %d2,1
80007e9e:	37 03 64 3c 	extr.u %d3,%d3,24,4
80007ea2:	4b 02 41 21 	itof %d2,%d2
80007ea6:	c2 13       	add %d3,1
80007ea8:	03 34 0a 33 	madd %d3,%d3,%d4,%d3
80007eac:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80007eb0:	4b 03 41 31 	itof %d3,%d3
80007eb4:	4b 3f 51 20 	div.f %d2,%d15,%d3
    }

    return freq;
}
80007eb8:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007eba:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007ebc:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007ebe:	37 02 62 2e 	extr.u %d2,%d2,28,2
80007ec2:	df 12 dc ff 	jne %d2,1,80007e7a <IfxScuCcu_getPllFrequency+0x1a>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007ec6:	91 00 00 f7 	movh.a %a15,28672
80007eca:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007ece:	91 30 00 ff 	movh.a %a15,61443
80007ed2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007ed6:	4b 02 61 f1 	utof %d15,%d2
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007eda:	48 52       	ld.w %d2,[%a15]20
80007edc:	6f 02 d6 7f 	jz.t %d2,0,80007e88 <IfxScuCcu_getPllFrequency+0x28>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007ee0:	48 72       	ld.w %d2,[%a15]28
80007ee2:	37 02 67 28 	extr.u %d2,%d2,16,7
80007ee6:	c2 12       	add %d2,1
80007ee8:	4b 02 41 21 	itof %d2,%d2
80007eec:	4b 2f 51 20 	div.f %d2,%d15,%d2
80007ef0:	00 90       	ret 
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007ef2:	48 72       	ld.w %d2,[%a15]28
80007ef4:	8f f2 07 21 	and %d2,%d2,127
80007ef8:	c2 12       	add %d2,1
80007efa:	4b 02 41 f1 	itof %d15,%d2
80007efe:	7b f0 cb 24 	movh %d2,19647
80007f02:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007f06:	4b f2 51 20 	div.f %d2,%d2,%d15
80007f0a:	00 90       	ret 

80007f0c <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80007f0c:	91 30 00 ff 	movh.a %a15,61443
80007f10:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80007f14:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80007f16:	7b f0 cb 24 	movh %d2,19647
80007f1a:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80007f1e:	6f 3f 1e 80 	jnz.t %d15,3,80007f5a <IfxScuCcu_getPllVcoFrequency+0x4e>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007f22:	91 30 00 ff 	movh.a %a15,61443
80007f26:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007f2a:	4c f0       	ld.w %d15,[%a15]0
80007f2c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007f30:	ee 16       	jnz %d15,80007f5c <IfxScuCcu_getPllVcoFrequency+0x50>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80007f32:	91 30 00 ff 	movh.a %a15,61443
80007f36:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80007f3a:	48 03       	ld.w %d3,[%a15]0
80007f3c:	4c f0       	ld.w %d15,[%a15]0
80007f3e:	37 03 e7 34 	extr.u %d3,%d3,9,7
80007f42:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80007f46:	c2 13       	add %d3,1
80007f48:	4b 03 41 31 	itof %d3,%d3
80007f4c:	c2 1f       	add %d15,1
80007f4e:	4b 32 41 20 	mul.f %d2,%d2,%d3
80007f52:	4b 0f 41 f1 	itof %d15,%d15
80007f56:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80007f5a:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007f5c:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007f5e:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007f60:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007f64:	df 1f e7 ff 	jne %d15,1,80007f32 <IfxScuCcu_getPllVcoFrequency+0x26>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007f68:	91 00 00 f7 	movh.a %a15,28672
80007f6c:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007f70:	4b 02 61 21 	utof %d2,%d2
80007f74:	3c df       	j 80007f32 <IfxScuCcu_getPllVcoFrequency+0x26>

80007f76 <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007f76:	91 30 00 ff 	movh.a %a15,61443
80007f7a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007f7e:	4c f0       	ld.w %d15,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007f80:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007f84:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007f88:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007f8c:	6e 2a       	jz %d15,80007fe0 <IfxScuCcu_getSourceFrequency+0x6a>
80007f8e:	df 1f 2a 80 	jne %d15,1,80007fe2 <IfxScuCcu_getSourceFrequency+0x6c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007f92:	91 30 00 ff 	movh.a %a15,61443
80007f96:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007f9a:	4c f0       	ld.w %d15,[%a15]0
80007f9c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007fa0:	ee 23       	jnz %d15,80007fe6 <IfxScuCcu_getSourceFrequency+0x70>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007fa2:	91 30 00 ff 	movh.a %a15,61443
80007fa6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007faa:	4c f5       	ld.w %d15,[%a15]20
80007fac:	6f 0f 2a 80 	jnz.t %d15,0,80008000 <_SMALL_DATA2_>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007fb0:	4c f5       	ld.w %d15,[%a15]20
80007fb2:	6f 3f 30 80 	jnz.t %d15,3,80008012 <_SMALL_DATA2_+0x12>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007fb6:	48 64       	ld.w %d4,[%a15]24
80007fb8:	4c f7       	ld.w %d15,[%a15]28
80007fba:	37 04 e7 44 	extr.u %d4,%d4,9,7
80007fbe:	8f ff 07 31 	and %d3,%d15,127
80007fc2:	4c f6       	ld.w %d15,[%a15]24
80007fc4:	c2 14       	add %d4,1
80007fc6:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80007fca:	4b 04 41 41 	itof %d4,%d4
80007fce:	c2 1f       	add %d15,1
80007fd0:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80007fd4:	4b 42 41 20 	mul.f %d2,%d2,%d4
80007fd8:	4b 0f 41 f1 	itof %d15,%d15
80007fdc:	4b f2 51 20 	div.f %d2,%d2,%d15
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
80007fe0:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007fe2:	82 02       	mov %d2,0
80007fe4:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007fe6:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007fe8:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007fea:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80007fee:	df 1f da ff 	jne %d15,1,80007fa2 <IfxScuCcu_getSourceFrequency+0x2c>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007ff2:	91 00 00 f7 	movh.a %a15,28672
80007ff6:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80007ffa:	4b 02 61 21 	utof %d2,%d2
80007ffe:	3c d2       	j 80007fa2 <IfxScuCcu_getSourceFrequency+0x2c>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008000:	4c f7       	ld.w %d15,[%a15]28
80008002:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80008006:	c2 1f       	add %d15,1
80008008:	4b 0f 41 f1 	itof %d15,%d15
8000800c:	4b f2 51 20 	div.f %d2,%d2,%d15
80008010:	00 90       	ret 
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008012:	48 72       	ld.w %d2,[%a15]28
80008014:	8f f2 07 21 	and %d2,%d2,127
80008018:	c2 12       	add %d2,1
8000801a:	4b 02 41 f1 	itof %d15,%d2
8000801e:	7b f0 cb 24 	movh %d2,19647
80008022:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008026:	4b f2 51 20 	div.f %d2,%d2,%d15
8000802a:	00 90       	ret 

8000802c <IfxScuCcu_getSpbFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000802c:	91 30 00 ff 	movh.a %a15,61443
80008030:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008034:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008036:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000803a:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000803e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008042:	df 02 2c 00 	jeq %d2,0,8000809a <IfxScuCcu_getSpbFrequency+0x6e>
80008046:	df 12 4c 80 	jne %d2,1,800080de <IfxScuCcu_getSpbFrequency+0xb2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000804a:	91 30 00 ff 	movh.a %a15,61443
8000804e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008052:	48 02       	ld.w %d2,[%a15]0
80008054:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008058:	df 02 6c 80 	jne %d2,0,80008130 <IfxScuCcu_getSpbFrequency+0x104>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000805c:	91 30 00 ff 	movh.a %a15,61443
80008060:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008064:	48 52       	ld.w %d2,[%a15]20
80008066:	6f 02 72 80 	jnz.t %d2,0,8000814a <IfxScuCcu_getSpbFrequency+0x11e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000806a:	48 52       	ld.w %d2,[%a15]20
8000806c:	6f 32 78 80 	jnz.t %d2,3,8000815c <IfxScuCcu_getSpbFrequency+0x130>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008070:	48 64       	ld.w %d4,[%a15]24
80008072:	48 72       	ld.w %d2,[%a15]28
80008074:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008078:	8f f2 07 31 	and %d3,%d2,127
8000807c:	48 62       	ld.w %d2,[%a15]24
8000807e:	c2 14       	add %d4,1
80008080:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008084:	4b 04 41 41 	itof %d4,%d4
80008088:	c2 12       	add %d2,1
8000808a:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
8000808e:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
80008092:	4b 02 41 21 	itof %d2,%d2
80008096:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000809a:	91 30 00 ff 	movh.a %a15,61443
8000809e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800080a2:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0f;
800080a4:	82 02       	mov %d2,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800080a6:	37 03 64 36 	extr.u %d3,%d3,12,4
800080aa:	ff 53 19 80 	jge.u %d3,5,800080dc <IfxScuCcu_getSpbFrequency+0xb0>
800080ae:	91 10 00 f8 	movh.a %a15,32769
800080b2:	d9 ff 3c 28 	lea %a15,[%a15]-32580 <800080bc <IfxScuCcu_getSpbFrequency+0x90>>
800080b6:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800080ba:	dc 0f       	ji %a15
800080bc:	1d 00 1a 00 	j 800080f0 <IfxScuCcu_getSpbFrequency+0xc4>
800080c0:	1d 00 2a 00 	j 80008114 <IfxScuCcu_getSpbFrequency+0xe8>
800080c4:	1d 00 2f 00 	j 80008122 <IfxScuCcu_getSpbFrequency+0xf6>
800080c8:	1d 00 0d 00 	j 800080e2 <IfxScuCcu_getSpbFrequency+0xb6>
800080cc:	1d 00 02 00 	j 800080d0 <IfxScuCcu_getSpbFrequency+0xa4>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
800080d0:	7b 90 b8 23 	movh %d2,15241
800080d4:	1b 92 88 28 	addi %d2,%d2,-30583
800080d8:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        spbFrequency = 0.0f;
        break;
    }

    return spbFrequency;
}
800080dc:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800080de:	82 0f       	mov %d15,0
800080e0:	3c dd       	j 8000809a <IfxScuCcu_getSpbFrequency+0x6e>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
800080e2:	7b 90 c0 23 	movh %d2,15369
800080e6:	1b 92 88 28 	addi %d2,%d2,-30583
800080ea:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
800080ee:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800080f0:	91 30 00 ff 	movh.a %a15,61443
800080f4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800080f8:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0f;
800080fa:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800080fc:	37 03 64 38 	extr.u %d3,%d3,16,4
80008100:	df 03 ee 7f 	jeq %d3,0,800080dc <IfxScuCcu_getSpbFrequency+0xb0>
        {
            spbFrequency = 0.0f;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80008104:	48 02       	ld.w %d2,[%a15]0
80008106:	37 02 64 28 	extr.u %d2,%d2,16,4
8000810a:	4b 02 41 21 	itof %d2,%d2
8000810e:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008112:	00 90       	ret 
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80008114:	7b 90 d0 23 	movh %d2,15625
80008118:	1b 92 88 28 	addi %d2,%d2,-30583
8000811c:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008120:	00 90       	ret 
    case 2:
        spbFrequency = sourceFrequency / 60;
80008122:	7b 90 c8 23 	movh %d2,15497
80008126:	1b 92 88 28 	addi %d2,%d2,-30583
8000812a:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
8000812e:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008130:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008132:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008134:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008138:	df 12 92 ff 	jne %d2,1,8000805c <IfxScuCcu_getSpbFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
8000813c:	91 00 00 f7 	movh.a %a15,28672
80008140:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008144:	4b 0f 61 f1 	utof %d15,%d15
80008148:	3c 8a       	j 8000805c <IfxScuCcu_getSpbFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
8000814a:	48 72       	ld.w %d2,[%a15]28
8000814c:	37 02 67 28 	extr.u %d2,%d2,16,7
80008150:	c2 12       	add %d2,1
80008152:	4b 02 41 21 	itof %d2,%d2
80008156:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000815a:	3c a0       	j 8000809a <IfxScuCcu_getSpbFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000815c:	4c f7       	ld.w %d15,[%a15]28
8000815e:	7b f0 cb 24 	movh %d2,19647
80008162:	16 7f       	and %d15,127
80008164:	c2 1f       	add %d15,1
80008166:	4b 0f 41 f1 	itof %d15,%d15
8000816a:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000816e:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008172:	3c 94       	j 8000809a <IfxScuCcu_getSpbFrequency+0x6e>

80008174 <IfxScuCcu_getSriFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008174:	91 30 00 ff 	movh.a %a15,61443
80008178:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000817c:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000817e:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008182:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008186:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000818a:	df 02 2c 00 	jeq %d2,0,800081e2 <IfxScuCcu_getSriFrequency+0x6e>
8000818e:	df 12 4c 80 	jne %d2,1,80008226 <IfxScuCcu_getSriFrequency+0xb2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008192:	91 30 00 ff 	movh.a %a15,61443
80008196:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000819a:	48 02       	ld.w %d2,[%a15]0
8000819c:	37 02 62 2e 	extr.u %d2,%d2,28,2
800081a0:	df 02 6c 80 	jne %d2,0,80008278 <IfxScuCcu_getSriFrequency+0x104>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800081a4:	91 30 00 ff 	movh.a %a15,61443
800081a8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800081ac:	48 52       	ld.w %d2,[%a15]20
800081ae:	6f 02 72 80 	jnz.t %d2,0,80008292 <IfxScuCcu_getSriFrequency+0x11e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800081b2:	48 52       	ld.w %d2,[%a15]20
800081b4:	6f 32 78 80 	jnz.t %d2,3,800082a4 <IfxScuCcu_getSriFrequency+0x130>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800081b8:	48 64       	ld.w %d4,[%a15]24
800081ba:	48 72       	ld.w %d2,[%a15]28
800081bc:	37 04 e7 44 	extr.u %d4,%d4,9,7
800081c0:	8f f2 07 31 	and %d3,%d2,127
800081c4:	48 62       	ld.w %d2,[%a15]24
800081c6:	c2 14       	add %d4,1
800081c8:	37 02 64 2c 	extr.u %d2,%d2,24,4
800081cc:	4b 04 41 41 	itof %d4,%d4
800081d0:	c2 12       	add %d2,1
800081d2:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
800081d6:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
800081da:	4b 02 41 21 	itof %d2,%d2
800081de:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800081e2:	91 30 00 ff 	movh.a %a15,61443
800081e6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800081ea:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800081ec:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800081ee:	37 03 64 36 	extr.u %d3,%d3,12,4
800081f2:	ff 53 19 80 	jge.u %d3,5,80008224 <IfxScuCcu_getSriFrequency+0xb0>
800081f6:	91 10 00 f8 	movh.a %a15,32769
800081fa:	d9 ff 04 88 	lea %a15,[%a15]-32252 <80008204 <IfxScuCcu_getSriFrequency+0x90>>
800081fe:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80008202:	dc 0f       	ji %a15
80008204:	1d 00 1a 00 	j 80008238 <IfxScuCcu_getSriFrequency+0xc4>
80008208:	1d 00 2a 00 	j 8000825c <IfxScuCcu_getSriFrequency+0xe8>
8000820c:	1d 00 2f 00 	j 8000826a <IfxScuCcu_getSriFrequency+0xf6>
80008210:	1d 00 0d 00 	j 8000822a <IfxScuCcu_getSriFrequency+0xb6>
80008214:	1d 00 02 00 	j 80008218 <IfxScuCcu_getSriFrequency+0xa4>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
80008218:	7b 90 b8 23 	movh %d2,15241
8000821c:	1b 92 88 28 	addi %d2,%d2,-30583
80008220:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        sriFrequency = 0.0f;
        break;
    }

    return sriFrequency;
}
80008224:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008226:	82 0f       	mov %d15,0
80008228:	3c dd       	j 800081e2 <IfxScuCcu_getSriFrequency+0x6e>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
8000822a:	7b 90 c0 23 	movh %d2,15369
8000822e:	1b 92 88 28 	addi %d2,%d2,-30583
80008232:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008236:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80008238:	91 30 00 ff 	movh.a %a15,61443
8000823c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008240:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0f;
80008242:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80008244:	37 03 64 34 	extr.u %d3,%d3,8,4
80008248:	df 03 ee 7f 	jeq %d3,0,80008224 <IfxScuCcu_getSriFrequency+0xb0>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
8000824c:	48 02       	ld.w %d2,[%a15]0
8000824e:	37 02 64 24 	extr.u %d2,%d2,8,4
80008252:	4b 02 41 21 	itof %d2,%d2
80008256:	4b 2f 51 20 	div.f %d2,%d15,%d2
8000825a:	00 90       	ret 
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
8000825c:	7b 90 d0 23 	movh %d2,15625
80008260:	1b 92 88 28 	addi %d2,%d2,-30583
80008264:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008268:	00 90       	ret 
    case 2:
        sriFrequency = sourceFrequency / 60;
8000826a:	7b 90 c8 23 	movh %d2,15497
8000826e:	1b 92 88 28 	addi %d2,%d2,-30583
80008272:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008276:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008278:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
8000827a:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000827c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008280:	df 12 92 ff 	jne %d2,1,800081a4 <IfxScuCcu_getSriFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008284:	91 00 00 f7 	movh.a %a15,28672
80008288:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
8000828c:	4b 0f 61 f1 	utof %d15,%d15
80008290:	3c 8a       	j 800081a4 <IfxScuCcu_getSriFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008292:	48 72       	ld.w %d2,[%a15]28
80008294:	37 02 67 28 	extr.u %d2,%d2,16,7
80008298:	c2 12       	add %d2,1
8000829a:	4b 02 41 21 	itof %d2,%d2
8000829e:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800082a2:	3c a0       	j 800081e2 <IfxScuCcu_getSriFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800082a4:	4c f7       	ld.w %d15,[%a15]28
800082a6:	7b f0 cb 24 	movh %d2,19647
800082aa:	16 7f       	and %d15,127
800082ac:	c2 1f       	add %d15,1
800082ae:	4b 0f 41 f1 	itof %d15,%d15
800082b2:	1b 02 c2 2b 	addi %d2,%d2,-17376
800082b6:	4b f2 51 f0 	div.f %d15,%d2,%d15
800082ba:	3c 94       	j 800081e2 <IfxScuCcu_getSriFrequency+0x6e>

800082bc <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800082bc:	19 42 10 10 	ld.w %d2,[%a4]80
800082c0:	91 00 00 d7 	movh.a %a13,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
800082c4:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800082c6:	59 d2 f8 c0 	st.w [%a13]3896 <70000f38 <IfxScuCcu_xtalFrequency>>,%d2

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
800082ca:	6d 00 3d 0a 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>
800082ce:	02 2a       	mov %d10,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
800082d0:	6d 00 58 0a 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800082d4:	02 a4       	mov %d4,%d10
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
800082d6:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800082d8:	6d 00 38 09 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800082dc:	91 30 00 ff 	movh.a %a15,61443
800082e0:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800082e4:	48 0c       	ld.w %d12,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
800082e6:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800082e8:	02 a4       	mov %d4,%d10

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800082ea:	96 08       	or %d15,8
800082ec:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
800082ee:	6d 00 71 0b 	call 800099d0 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800082f2:	02 84       	mov %d4,%d8
800082f4:	6d 00 45 09 	call 8000957e <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800082f8:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
800082fc:	91 30 00 2f 	movh.a %a2,61443
80008300:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008304:	4c 20       	ld.w %d15,[%a2]0
80008306:	91 30 00 ff 	movh.a %a15,61443
8000830a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000830e:	bf 0f fb 7f 	jlt %d15,0,80008304 <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80008312:	4c f0       	ld.w %d15,[%a15]0
        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON1.B.LCK != 0U)
80008314:	91 30 00 2f 	movh.a %a2,61443
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80008318:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON1.B.LCK != 0U)
8000831c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80008320:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80008322:	4c f0       	ld.w %d15,[%a15]0
80008324:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80008328:	68 0f       	st.w [%a15]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
8000832a:	91 30 00 ff 	movh.a %a15,61443
8000832e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008332:	4c f0       	ld.w %d15,[%a15]0
80008334:	96 10       	or %d15,16
80008336:	68 0f       	st.w [%a15]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON1.B.LCK != 0U)
80008338:	4c 20       	ld.w %d15,[%a2]0
8000833a:	91 30 00 ff 	movh.a %a15,61443
8000833e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008342:	bf 0f fb 7f 	jlt %d15,0,80008338 <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon1 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80008346:	4c f0       	ld.w %d15,[%a15]0
80008348:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
8000834c:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
8000834e:	4c f0       	ld.w %d15,[%a15]0
80008350:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80008354:	68 0f       	st.w [%a15]0,%d15
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80008356:	91 30 00 ff 	movh.a %a15,61443
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
8000835a:	6d 00 f5 09 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
8000835e:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008362:	4c f0       	ld.w %d15,[%a15]0
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
80008364:	02 29       	mov %d9,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80008366:	8f 0f c6 f1 	andn %d15,%d15,96
8000836a:	68 0f       	st.w [%a15]0,%d15

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
8000836c:	19 d6 f8 c0 	ld.w %d6,[%a13]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008370:	7b 00 b6 f6 	movh %d15,27488
80008374:	1b bf a6 fc 	addi %d15,%d15,-13717
80008378:	73 f6 68 60 	mul.u %e6,%d6,%d15
8000837c:	48 02       	ld.w %d2,[%a15]0

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
8000837e:	40 f2       	mov.aa %a2,%a15

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80008380:	8f c7 1e f0 	sh %d15,%d7,-20
80008384:	c2 ff       	add %d15,-1
80008386:	37 f2 05 f8 	insert %d15,%d2,%d15,16,5
8000838a:	68 0f       	st.w [%a15]0,%d15

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
8000838c:	4c f0       	ld.w %d15,[%a15]0
8000838e:	96 04       	or %d15,4
80008390:	68 0f       	st.w [%a15]0,%d15

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80008392:	c5 0f 3f 90 	lea %a15,27f <_.+0x27e>
80008396:	4c 20       	ld.w %d15,[%a2]0
80008398:	2e 14       	jz.t %d15,1,800083a0 <IfxScuCcu_init+0xe4>
8000839a:	4c 20       	ld.w %d15,[%a2]0
8000839c:	6f 8f 1d 80 	jnz.t %d15,8,800083d6 <IfxScuCcu_init+0x11a>
800083a0:	fc fb       	loop %a15,80008396 <IfxScuCcu_init+0xda>
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083a2:	91 30 00 ff 	movh.a %a15,61443
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800083a6:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083a8:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800083ac:	6d 00 ce 08 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083b0:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
800083b2:	02 94       	mov %d4,%d9
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083b4:	96 08       	or %d15,8
800083b6:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800083b8:	91 30 00 ff 	movh.a %a15,61443
800083bc:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800083c0:	4c f0       	ld.w %d15,[%a15]0
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
800083c2:	82 19       	mov %d9,1

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800083c4:	96 08       	or %d15,8
800083c6:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinitPw);
800083c8:	6d 00 04 0b 	call 800099d0 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800083cc:	02 84       	mov %d4,%d8
800083ce:	6d 00 1c 0b 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
800083d2:	1d 00 46 01 	j 8000865e <IfxScuCcu_init+0x3a2>
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083d6:	91 30 00 ff 	movh.a %a15,61443
800083da:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800083de:	02 94       	mov %d4,%d9
800083e0:	6d 00 b4 08 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083e4:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
800083e6:	02 94       	mov %d4,%d9
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800083e8:	96 08       	or %d15,8
800083ea:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800083ec:	91 30 00 ff 	movh.a %a15,61443
800083f0:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800083f4:	4c f0       	ld.w %d15,[%a15]0
800083f6:	96 08       	or %d15,8
800083f8:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinitPw);
800083fa:	6d 00 eb 0a 	call 800099d0 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800083fe:	02 84       	mov %d4,%d8
80008400:	6d 00 03 0b 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008404:	02 84       	mov %d4,%d8
80008406:	6d 00 bc 08 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000840a:	91 30 00 ff 	movh.a %a15,61443
8000840e:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008412:	4c f0       	ld.w %d15,[%a15]0
80008414:	6f 5f ff 7f 	jz.t %d15,5,80008412 <IfxScuCcu_init+0x156>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80008418:	91 30 00 ff 	movh.a %a15,61443
8000841c:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008420:	48 02       	ld.w %d2,[%a15]0
80008422:	0c ca       	ld.bu %d15,[%a12]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80008424:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80008428:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000842c:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80008430:	68 0f       	st.w [%a15]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80008432:	91 30 00 ff 	movh.a %a15,61443
80008436:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000843a:	48 02       	ld.w %d2,[%a15]0
8000843c:	0c c8       	ld.bu %d15,[%a12]8
8000843e:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80008442:	68 0f       	st.w [%a15]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80008444:	48 02       	ld.w %d2,[%a15]0
80008446:	0c c9       	ld.bu %d15,[%a12]9
80008448:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
8000844c:	68 0f       	st.w [%a15]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
8000844e:	4c f0       	ld.w %d15,[%a15]0
80008450:	96 40       	or %d15,64
80008452:	68 0f       	st.w [%a15]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
80008454:	4c f0       	ld.w %d15,[%a15]0
80008456:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
8000845a:	68 0f       	st.w [%a15]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
8000845c:	4c f0       	ld.w %d15,[%a15]0
8000845e:	96 20       	or %d15,32
80008460:	68 0f       	st.w [%a15]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
80008462:	4c f0       	ld.w %d15,[%a15]0
80008464:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80008468:	68 0f       	st.w [%a15]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
8000846a:	4c f0       	ld.w %d15,[%a15]0
8000846c:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80008470:	68 0f       	st.w [%a15]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80008472:	6d ff 81 f5 	call 80006f74 <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
80008476:	91 30 00 ff 	movh.a %a15,61443
8000847a:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000847e:	4c f0       	ld.w %d15,[%a15]0
80008480:	6f 2f ff 7f 	jz.t %d15,2,8000847e <IfxScuCcu_init+0x1c2>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
80008484:	91 30 00 ff 	movh.a %a15,61443
80008488:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000848c:	4c f0       	ld.w %d15,[%a15]0
8000848e:	8f 1f c0 f1 	andn %d15,%d15,1
80008492:	68 0f       	st.w [%a15]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
80008494:	91 30 00 ff 	movh.a %a15,61443
80008498:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000849c:	4c f0       	ld.w %d15,[%a15]0
8000849e:	91 30 00 2f 	movh.a %a2,61443
800084a2:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800084a6:	bf 0f fb 7f 	jlt %d15,0,8000849c <IfxScuCcu_init+0x1e0>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
800084aa:	4c 20       	ld.w %d15,[%a2]0

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
800084ac:	40 2f       	mov.aa %a15,%a2
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
800084ae:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
800084b2:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
800084b4:	4c f0       	ld.w %d15,[%a15]0
800084b6:	91 30 00 df 	movh.a %a13,61443
800084ba:	d9 dd 30 06 	lea %a13,[%a13]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800084be:	bf 0f fb 7f 	jlt %d15,0,800084b4 <IfxScuCcu_init+0x1f8>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
800084c2:	19 c4 0c 00 	ld.w %d4,[%a12]12
800084c6:	6d ff 57 f5 	call 80006f74 <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800084ca:	4c c5       	ld.w %d15,[%a12]20
800084cc:	54 d2       	ld.w %d2,[%a13]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800084ce:	19 c3 10 00 	ld.w %d3,[%a12]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800084d2:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800084d6:	26 3f       	and %d15,%d3
800084d8:	a6 2f       	or %d15,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
800084da:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
800084de:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800084e2:	91 30 00 ff 	movh.a %a15,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
800084e6:	6c d0       	st.w [%a13]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800084e8:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800084ec:	4c f0       	ld.w %d15,[%a15]0
800084ee:	91 30 00 2f 	movh.a %a2,61443
800084f2:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800084f6:	bf 0f fb 7f 	jlt %d15,0,800084ec <IfxScuCcu_init+0x230>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
800084fa:	4c c7       	ld.w %d15,[%a12]28
800084fc:	54 22       	ld.w %d2,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
800084fe:	19 c3 18 00 	ld.w %d3,[%a12]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80008502:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80008506:	26 3f       	and %d15,%d3
80008508:	a6 2f       	or %d15,%d2
                        ccucon1.B.INSEL = 1;
8000850a:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
8000850e:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80008512:	91 30 00 ff 	movh.a %a15,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
80008516:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80008518:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
8000851c:	4c f0       	ld.w %d15,[%a15]0
8000851e:	91 30 00 2f 	movh.a %a2,61443
80008522:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80008526:	bf 0f fb 7f 	jlt %d15,0,8000851c <IfxScuCcu_init+0x260>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
8000852a:	4c c9       	ld.w %d15,[%a12]36
8000852c:	54 22       	ld.w %d2,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
8000852e:	19 c3 20 00 	ld.w %d3,[%a12]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80008532:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80008536:	26 3f       	and %d15,%d3
80008538:	a6 2f       	or %d15,%d2
                        ccucon2.B.UP = 1;
8000853a:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
8000853e:	91 30 00 ff 	movh.a %a15,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
80008542:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
80008544:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80008548:	4c f0       	ld.w %d15,[%a15]0
8000854a:	91 30 00 2f 	movh.a %a2,61443
8000854e:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80008552:	bf 0f fb 7f 	jlt %d15,0,80008548 <IfxScuCcu_init+0x28c>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80008556:	54 22       	ld.w %d2,[%a2]
80008558:	4c cb       	ld.w %d15,[%a12]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000855a:	19 c3 28 00 	ld.w %d3,[%a12]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
8000855e:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80008562:	26 3f       	and %d15,%d3
80008564:	a6 2f       	or %d15,%d2
                        ccucon5.B.UP = 1;
80008566:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
8000856a:	91 30 00 ff 	movh.a %a15,61443
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
8000856e:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80008570:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80008574:	48 02       	ld.w %d2,[%a15]0
80008576:	4c cd       	ld.w %d15,[%a12]52
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80008578:	19 c3 30 00 	ld.w %d3,[%a12]48 <f0030000 <_SMALL_DATA4_+0x40028000>>
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
8000857c:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80008580:	26 3f       	and %d15,%d3
80008582:	a6 2f       	or %d15,%d2
                        SCU_CCUCON6 = ccucon6;
80008584:	68 0f       	st.w [%a15]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80008586:	91 30 00 ff 	movh.a %a15,61443
8000858a:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
8000858e:	48 02       	ld.w %d2,[%a15]0
80008590:	4c cf       	ld.w %d15,[%a12]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
80008592:	19 c3 38 00 	ld.w %d3,[%a12]56 <f0030000 <_SMALL_DATA4_+0x40028000>>
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80008596:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
8000859a:	26 3f       	and %d15,%d3
8000859c:	a6 2f       	or %d15,%d2
                        SCU_CCUCON7 = ccucon7;
8000859e:	68 0f       	st.w [%a15]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800085a0:	91 30 00 ff 	movh.a %a15,61443
800085a4:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800085a8:	48 02       	ld.w %d2,[%a15]0
800085aa:	19 cf 04 10 	ld.w %d15,[%a12]68 <f0030000 <_SMALL_DATA4_+0x40028000>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800085ae:	19 c3 00 10 	ld.w %d3,[%a12]64 <f0030000 <_SMALL_DATA4_+0x40028000>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800085b2:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800085b6:	26 3f       	and %d15,%d3
800085b8:	a6 2f       	or %d15,%d2
                        SCU_CCUCON8 = ccucon8;
800085ba:	68 0f       	st.w [%a15]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800085bc:	02 84       	mov %d4,%d8
800085be:	6d 00 24 0a 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
800085c2:	91 00 80 ff 	movh.a %a15,63488
800085c6:	d9 ff 14 02 	lea %a15,[%a15]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800085ca:	48 02       	ld.w %d2,[%a15]0
800085cc:	19 cf 0c 10 	ld.w %d15,[%a12]76 <f8000000 <_SMALL_DATA4_+0x47ff8000>>

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800085d0:	19 c3 08 10 	ld.w %d3,[%a12]72 <f8000000 <_SMALL_DATA4_+0x47ff8000>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
800085d4:	0f f2 e0 20 	andn %d2,%d2,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800085d8:	02 a4       	mov %d4,%d10
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800085da:	26 3f       	and %d15,%d3
800085dc:	a6 2f       	or %d15,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800085de:	6d 00 b5 07 	call 80009548 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
800085e2:	68 0f       	st.w [%a15]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
800085e4:	02 a4       	mov %d4,%d10
800085e6:	6d 00 f5 09 	call 800099d0 <IfxScuWdt_setCpuEndinit>
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800085ea:	0c c0       	ld.bu %d15,[%a12]0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800085ec:	91 30 00 ff 	movh.a %a15,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800085f0:	91 30 00 df 	movh.a %a13,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800085f4:	82 09       	mov %d9,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800085f6:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800085fa:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800085fe:	6e 2f       	jz %d15,8000865c <IfxScuCcu_init+0x3a0>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008600:	02 84       	mov %d4,%d8
80008602:	8f f9 0f b1 	and %d11,%d9,255
80008606:	6d 00 bc 07 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000860a:	4c f0       	ld.w %d15,[%a15]0
8000860c:	6f 5f ff 7f 	jz.t %d15,5,8000860a <IfxScuCcu_init+0x34e>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80008610:	8f f9 0f f1 	and %d15,%d9,255
80008614:	99 c3 04 00 	ld.a %a3,[%a12]4
80008618:	53 cf 20 f0 	mul %d15,%d15,12
8000861c:	54 d3       	ld.w %d3,[%a13]
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000861e:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80008620:	10 32       	addsc.a %a2,%a3,%d15,0
80008622:	14 22       	ld.bu %d2,[%a2]
80008624:	37 23 07 20 	insert %d2,%d3,%d2,0,7
80008628:	74 d2       	st.w [%a13],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000862a:	6d 00 ee 09 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
8000862e:	99 c3 04 00 	ld.a %a3,[%a12]4
80008632:	10 32       	addsc.a %a2,%a3,%d15,0
80008634:	99 23 08 00 	ld.a %a3,[%a2]8
80008638:	bc 36       	jz.a %a3,80008644 <IfxScuCcu_init+0x388>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
8000863a:	2d 03 00 00 	calli %a3
8000863e:	99 c3 04 00 	ld.a %a3,[%a12]4
80008642:	10 32       	addsc.a %a2,%a3,%d15,0
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
80008644:	19 24 04 00 	ld.w %d4,[%a2]4
80008648:	6d ff 96 f4 	call 80006f74 <IfxScuCcu_wait>
8000864c:	1b 1b 00 20 	addi %d2,%d11,1
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80008650:	0c c0       	ld.bu %d15,[%a12]0
80008652:	8f f2 0f 21 	and %d2,%d2,255
80008656:	c2 19       	add %d9,1
80008658:	3f f2 d4 ff 	jlt.u %d2,%d15,80008600 <IfxScuCcu_init+0x344>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
8000865c:	82 09       	mov %d9,0
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000865e:	02 84       	mov %d4,%d8
80008660:	6d 00 8f 07 	call 8000957e <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80008664:	91 30 00 ff 	movh.a %a15,61443
80008668:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000866c:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000866e:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80008670:	8f 0f c4 f1 	andn %d15,%d15,64
80008674:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008676:	6d 00 c8 09 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000867a:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000867e:	02 a4       	mov %d4,%d10
        SCU_TRAPCLR.B.SMUT = 1U;
80008680:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80008684:	6d 00 62 07 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80008688:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000868a:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000868c:	96 08       	or %d15,8
8000868e:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80008690:	91 30 00 ff 	movh.a %a15,61443
80008694:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80008698:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000869a:	02 a4       	mov %d4,%d10
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000869c:	8f 8f c0 f1 	andn %d15,%d15,8
800086a0:	a6 fc       	or %d12,%d15
800086a2:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
800086a4:	6d 00 96 09 	call 800099d0 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
800086a8:	02 92       	mov %d2,%d9
800086aa:	00 90       	ret 

800086ac <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
800086ac:	7b 00 00 28 	movh %d2,32768
800086b0:	60 22       	mov.a %a2,%d2
800086b2:	d9 2f 40 20 	lea %a15,[%a2]1152
800086b6:	a0 92       	mov.a %a2,9
800086b8:	09 f2 48 01 	ld.d %e2,[%a15+]8
800086bc:	89 42 48 01 	st.d [%a4+]8,%e2
800086c0:	fc 2c       	loop %a2,800086b8 <IfxScuCcu_initConfig+0xc>
800086c2:	44 f2       	ld.w %d2,[%a15+]
800086c4:	64 42       	st.w [%a4+],%d2
800086c6:	00 90       	ret 

800086c8 <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
800086c8:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
800086ca:	6d 00 3d 08 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>
800086ce:	02 28       	mov %d8,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800086d0:	6d 00 58 08 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800086d4:	02 84       	mov %d4,%d8
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800086d6:	02 29       	mov %d9,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800086d8:	6d 00 38 07 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800086dc:	91 30 00 ff 	movh.a %a15,61443
800086e0:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800086e4:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
800086e6:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800086e8:	02 84       	mov %d4,%d8
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800086ea:	96 08       	or %d15,8
800086ec:	68 0f       	st.w [%a15]0,%d15
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800086ee:	37 02 e1 b1 	extr.u %d11,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
800086f2:	6d 00 6f 09 	call 800099d0 <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800086f6:	91 30 00 ff 	movh.a %a15,61443
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800086fa:	02 94       	mov %d4,%d9

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800086fc:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008700:	6d 00 3f 07 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
80008704:	4c f0       	ld.w %d15,[%a15]0
80008706:	ef 0f 05 00 	jz.t %d15,16,80008710 <IfxScuCcu_initErayPll+0x48>
8000870a:	4c f0       	ld.w %d15,[%a15]0
8000870c:	6f 1f a1 00 	jz.t %d15,1,8000884e <IfxScuCcu_initErayPll+0x186>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
80008710:	91 30 00 ff 	movh.a %a15,61443
80008714:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80008718:	4c f0       	ld.w %d15,[%a15]0
8000871a:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
8000871e:	68 0f       	st.w [%a15]0,%d15
        SCU_PLLERAYCON0.B.VCOPWD = 0;
80008720:	4c f0       	ld.w %d15,[%a15]0
80008722:	8f 2f c0 f1 	andn %d15,%d15,2
80008726:	68 0f       	st.w [%a15]0,%d15

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
80008728:	91 30 00 ff 	movh.a %a15,61443
8000872c:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80008730:	4c f0       	ld.w %d15,[%a15]0
80008732:	6f 1f ff ff 	jnz.t %d15,1,80008730 <IfxScuCcu_initErayPll+0x68>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
80008736:	19 c4 04 00 	ld.w %d4,[%a12]4
8000873a:	6d ff 1d f4 	call 80006f74 <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
8000873e:	91 30 00 ff 	movh.a %a15,61443
80008742:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80008746:	4c f0       	ld.w %d15,[%a15]0
80008748:	6f 0f 38 00 	jz.t %d15,0,800087b8 <IfxScuCcu_initErayPll+0xf0>

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
8000874c:	91 30 00 ff 	movh.a %a15,61443
80008750:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80008754:	4c f0       	ld.w %d15,[%a15]0
80008756:	6f 5f ff 7f 	jz.t %d15,5,80008754 <IfxScuCcu_initErayPll+0x8c>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
8000875a:	91 30 00 ff 	movh.a %a15,61443
8000875e:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80008762:	48 02       	ld.w %d2,[%a15]0
80008764:	0c c2       	ld.bu %d15,[%a12]2
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008766:	02 94       	mov %d4,%d9
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
80008768:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
8000876c:	68 0f       	st.w [%a15]0,%d15
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
8000876e:	91 30 00 ff 	movh.a %a15,61443
80008772:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80008776:	48 02       	ld.w %d2,[%a15]0
80008778:	0c c0       	ld.bu %d15,[%a12]0
8000877a:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
8000877e:	68 0f       	st.w [%a15]0,%d15
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
80008780:	48 02       	ld.w %d2,[%a15]0
80008782:	0c c1       	ld.bu %d15,[%a12]1
80008784:	37 f2 85 f4 	insert %d15,%d2,%d15,9,5
80008788:	68 0f       	st.w [%a15]0,%d15
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
8000878a:	4c f0       	ld.w %d15,[%a15]0
8000878c:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80008790:	68 0f       	st.w [%a15]0,%d15
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
80008792:	4c f0       	ld.w %d15,[%a15]0
80008794:	96 20       	or %d15,32
80008796:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008798:	6d 00 37 09 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
8000879c:	91 10 00 f0 	movh.a %a15,1
800087a0:	91 30 00 2f 	movh.a %a2,61443
800087a4:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800087a8:	d9 ff 0e dc 	lea %a15,[%a15]-15538 <c34e <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4e>>
800087ac:	4c 20       	ld.w %d15,[%a2]0
800087ae:	6f 2f 18 80 	jnz.t %d15,2,800087de <IfxScuCcu_initErayPll+0x116>
800087b2:	fc fd       	loop %a15,800087ac <IfxScuCcu_initErayPll+0xe4>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
800087b4:	82 1a       	mov %d10,1
800087b6:	3c 15       	j 800087e0 <IfxScuCcu_initErayPll+0x118>

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
800087b8:	4c f0       	ld.w %d15,[%a15]0
800087ba:	6f 4f ff 7f 	jz.t %d15,4,800087b8 <IfxScuCcu_initErayPll+0xf0>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
800087be:	91 30 00 ff 	movh.a %a15,61443
800087c2:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800087c6:	4c f0       	ld.w %d15,[%a15]0
800087c8:	b7 3f 07 f8 	insert %d15,%d15,3,16,7
800087cc:	68 0f       	st.w [%a15]0,%d15

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
800087ce:	91 30 00 ff 	movh.a %a15,61443
800087d2:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800087d6:	4c f0       	ld.w %d15,[%a15]0
800087d8:	96 01       	or %d15,1
800087da:	68 0f       	st.w [%a15]0,%d15
800087dc:	3c b8       	j 8000874c <IfxScuCcu_initErayPll+0x84>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
800087de:	82 0a       	mov %d10,0
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
800087e0:	91 30 00 ff 	movh.a %a15,61443
800087e4:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800087e8:	02 94       	mov %d4,%d9
800087ea:	6d 00 ca 06 	call 8000957e <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
800087ee:	4c f0       	ld.w %d15,[%a15]0
800087f0:	8f 1f c0 f1 	andn %d15,%d15,1
800087f4:	68 0f       	st.w [%a15]0,%d15

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
800087f6:	91 30 00 ff 	movh.a %a15,61443
800087fa:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800087fe:	4c f0       	ld.w %d15,[%a15]0
80008800:	6f 0f ff ff 	jnz.t %d15,0,800087fe <IfxScuCcu_initErayPll+0x136>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
80008804:	91 30 00 ff 	movh.a %a15,61443
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008808:	02 94       	mov %d4,%d9

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
8000880a:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000880e:	4c f0       	ld.w %d15,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008810:	6d 00 fb 08 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
80008814:	37 0f 61 f1 	extr.u %d15,%d15,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80008818:	91 30 00 ff 	movh.a %a15,61443
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000881c:	02 84       	mov %d4,%d8
        SCU_TRAPCLR.B.SMUT = 1U;
8000881e:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80008822:	6d 00 93 06 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
80008826:	ea 1a       	cmovn %d10,%d15,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80008828:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000882a:	8f 3b 00 20 	sh %d2,%d11,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000882e:	96 08       	or %d15,8
80008830:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80008832:	91 30 00 ff 	movh.a %a15,61443
80008836:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000883a:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000883c:	02 84       	mov %d4,%d8
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000883e:	8f 8f c0 f1 	andn %d15,%d15,8
80008842:	a6 2f       	or %d15,%d2
80008844:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80008846:	6d 00 c5 08 	call 800099d0 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
8000884a:	02 a2       	mov %d2,%d10
8000884c:	00 90       	ret 
        IfxScuWdt_setCpuEndinit(endinit_pw);
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
8000884e:	91 30 00 ff 	movh.a %a15,61443
80008852:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80008856:	4c f0       	ld.w %d15,[%a15]0
80008858:	6f 1f 73 7f 	jz.t %d15,1,8000873e <IfxScuCcu_initErayPll+0x76>
8000885c:	1d ff 5a ff 	j 80008710 <IfxScuCcu_initErayPll+0x48>

80008860 <IfxScuCcu_initErayPllConfig>:
}


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
80008860:	82 0f       	mov %d15,0
80008862:	2c 40       	st.b [%a4]0,%d15
80008864:	da 17       	mov %d15,23
80008866:	2c 41       	st.b [%a4]1,%d15
80008868:	82 5f       	mov %d15,5
8000886a:	2c 42       	st.b [%a4]2,%d15
8000886c:	82 0f       	mov %d15,0
8000886e:	6c 41       	st.w [%a4]4,%d15
80008870:	00 90       	ret 

80008872 <IfxScuCcu_setCpuFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008872:	91 30 00 ff 	movh.a %a15,61443
80008876:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000887a:	4c f0       	ld.w %d15,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000887c:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008880:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
80008884:	02 49       	mov %d9,%d4
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008886:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000888a:	6e 2b       	jz %d15,800088e0 <IfxScuCcu_setCpuFrequency+0x6e>
8000888c:	df 1f 91 80 	jne %d15,1,800089ae <IfxScuCcu_setCpuFrequency+0x13c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008890:	91 30 00 ff 	movh.a %a15,61443
80008894:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008898:	4c f0       	ld.w %d15,[%a15]0
8000889a:	37 0f 62 fe 	extr.u %d15,%d15,28,2
8000889e:	df 0f b4 80 	jne %d15,0,80008a06 <IfxScuCcu_setCpuFrequency+0x194>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800088a2:	91 30 00 ff 	movh.a %a15,61443
800088a6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800088aa:	4c f5       	ld.w %d15,[%a15]20
800088ac:	6f 0f bb 80 	jnz.t %d15,0,80008a22 <IfxScuCcu_setCpuFrequency+0x1b0>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800088b0:	4c f5       	ld.w %d15,[%a15]20
800088b2:	6f 3f c2 80 	jnz.t %d15,3,80008a36 <IfxScuCcu_setCpuFrequency+0x1c4>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800088b6:	48 64       	ld.w %d4,[%a15]24
800088b8:	4c f7       	ld.w %d15,[%a15]28
800088ba:	37 04 e7 44 	extr.u %d4,%d4,9,7
800088be:	8f ff 07 31 	and %d3,%d15,127
800088c2:	4c f6       	ld.w %d15,[%a15]24
800088c4:	c2 14       	add %d4,1
800088c6:	37 0f 64 fc 	extr.u %d15,%d15,24,4
800088ca:	4b 04 41 41 	itof %d4,%d4
800088ce:	c2 1f       	add %d15,1
800088d0:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
800088d4:	4b 42 41 20 	mul.f %d2,%d2,%d4
800088d8:	4b 0f 41 f1 	itof %d15,%d15
800088dc:	4b f2 51 20 	div.f %d2,%d2,%d15
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800088e0:	91 30 00 ff 	movh.a %a15,61443
800088e4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800088e8:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800088ea:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800088ec:	37 03 64 36 	extr.u %d3,%d3,12,4
800088f0:	ff 53 24 80 	jge.u %d3,5,80008938 <IfxScuCcu_setCpuFrequency+0xc6>
800088f4:	91 10 00 f8 	movh.a %a15,32769
800088f8:	d9 ff 84 48 	lea %a15,[%a15]-30460 <80008904 <IfxScuCcu_setCpuFrequency+0x92>>
800088fc:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80008900:	dc 0f       	ji %a15
80008902:	00 00       	nop 
80008904:	1d 00 0a 00 	j 80008918 <IfxScuCcu_setCpuFrequency+0xa6>
80008908:	1d 00 78 00 	j 800089f8 <IfxScuCcu_setCpuFrequency+0x186>
8000890c:	1d 00 68 00 	j 800089dc <IfxScuCcu_setCpuFrequency+0x16a>
80008910:	1d 00 6d 00 	j 800089ea <IfxScuCcu_setCpuFrequency+0x178>
80008914:	1d 00 5d 00 	j 800089ce <IfxScuCcu_setCpuFrequency+0x15c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80008918:	91 30 00 ff 	movh.a %a15,61443
8000891c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008920:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0f;
80008922:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80008924:	37 03 64 34 	extr.u %d3,%d3,8,4
80008928:	76 38       	jz %d3,80008938 <IfxScuCcu_setCpuFrequency+0xc6>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
8000892a:	4c f0       	ld.w %d15,[%a15]0
8000892c:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80008930:	4b 0f 41 f1 	itof %d15,%d15
80008934:	4b f2 51 f0 	div.f %d15,%d2,%d15
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
80008938:	4b f5 01 20 	cmp.f %d2,%d5,%d15
8000893c:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
80008940:	df 02 24 80 	jne %d2,0,80008988 <IfxScuCcu_setCpuFrequency+0x116>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
80008944:	7b 00 28 84 	movh %d8,17024
80008948:	4b 85 41 80 	mul.f %d8,%d5,%d8
8000894c:	4b f8 51 80 	div.f %d8,%d8,%d15
80008950:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80008954:	6d 00 16 07 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008958:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000895a:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000895c:	6d 00 11 06 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
80008960:	df 19 2a 00 	jeq %d9,1,800089b4 <IfxScuCcu_setCpuFrequency+0x142>
80008964:	df 09 2f 00 	jeq %d9,0,800089c2 <IfxScuCcu_setCpuFrequency+0x150>
80008968:	df 29 1d 00 	jeq %d9,2,800089a2 <IfxScuCcu_setCpuFrequency+0x130>

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000896c:	02 a4       	mov %d4,%d10
8000896e:	6d 00 4c 08 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
80008972:	76 89       	jz %d8,80008984 <IfxScuCcu_setCpuFrequency+0x112>
80008974:	7b 00 c8 23 	movh %d2,15488
80008978:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
8000897c:	4b 08 61 81 	utof %d8,%d8
80008980:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
80008984:	02 f2       	mov %d2,%d15
80008986:	00 90       	ret 
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80008988:	6d 00 fc 06 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000898c:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000898e:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008990:	6d 00 f7 05 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
80008994:	df 19 0f 00 	jeq %d9,1,800089b2 <IfxScuCcu_setCpuFrequency+0x140>
80008998:	df 09 14 00 	jeq %d9,0,800089c0 <IfxScuCcu_setCpuFrequency+0x14e>
8000899c:	df 29 5b 80 	jne %d9,2,80008a52 <IfxScuCcu_setCpuFrequency+0x1e0>

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
    {
        cpuDiv = 0;
800089a0:	82 08       	mov %d8,0
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800089a2:	91 30 00 ff 	movh.a %a15,61443
800089a6:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800089aa:	68 08       	st.w [%a15]0,%d8
            break;
800089ac:	3c e0       	j 8000896c <IfxScuCcu_setCpuFrequency+0xfa>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800089ae:	82 02       	mov %d2,0
800089b0:	3c 98       	j 800088e0 <IfxScuCcu_setCpuFrequency+0x6e>

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
    {
        cpuDiv = 0;
800089b2:	82 08       	mov %d8,0
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
800089b4:	91 30 00 ff 	movh.a %a15,61443
800089b8:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
800089bc:	68 08       	st.w [%a15]0,%d8
            break;
800089be:	3c d7       	j 8000896c <IfxScuCcu_setCpuFrequency+0xfa>

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
    {
        cpuDiv = 0;
800089c0:	82 08       	mov %d8,0
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
800089c2:	91 30 00 ff 	movh.a %a15,61443
800089c6:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800089ca:	68 08       	st.w [%a15]0,%d8
            break;
800089cc:	3c d0       	j 8000896c <IfxScuCcu_setCpuFrequency+0xfa>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
800089ce:	7b 90 b8 f3 	movh %d15,15241
800089d2:	1b 9f 88 f8 	addi %d15,%d15,-30583
800089d6:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800089da:	3c af       	j 80008938 <IfxScuCcu_setCpuFrequency+0xc6>
        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
800089dc:	7b 90 c8 f3 	movh %d15,15497
800089e0:	1b 9f 88 f8 	addi %d15,%d15,-30583
800089e4:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800089e8:	3c a8       	j 80008938 <IfxScuCcu_setCpuFrequency+0xc6>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
800089ea:	7b 90 c0 f3 	movh %d15,15369
800089ee:	1b 9f 88 f8 	addi %d15,%d15,-30583
800089f2:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800089f6:	3c a1       	j 80008938 <IfxScuCcu_setCpuFrequency+0xc6>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
800089f8:	7b 90 d0 f3 	movh %d15,15625
800089fc:	1b 9f 88 f8 	addi %d15,%d15,-30583
80008a00:	4b f2 41 f0 	mul.f %d15,%d2,%d15
80008a04:	3c 9a       	j 80008938 <IfxScuCcu_setCpuFrequency+0xc6>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008a06:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008a08:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008a0a:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008a0e:	df 1f 4a ff 	jne %d15,1,800088a2 <IfxScuCcu_setCpuFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008a12:	91 00 00 f7 	movh.a %a15,28672
80008a16:	19 f2 f8 c0 	ld.w %d2,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008a1a:	4b 02 61 21 	utof %d2,%d2
80008a1e:	1d ff 42 ff 	j 800088a2 <IfxScuCcu_setCpuFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008a22:	4c f7       	ld.w %d15,[%a15]28
80008a24:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80008a28:	c2 1f       	add %d15,1
80008a2a:	4b 0f 41 f1 	itof %d15,%d15
80008a2e:	4b f2 51 20 	div.f %d2,%d2,%d15
80008a32:	1d ff 57 ff 	j 800088e0 <IfxScuCcu_setCpuFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008a36:	48 72       	ld.w %d2,[%a15]28
80008a38:	8f f2 07 21 	and %d2,%d2,127
80008a3c:	c2 12       	add %d2,1
80008a3e:	4b 02 41 f1 	itof %d15,%d2
80008a42:	7b f0 cb 24 	movh %d2,19647
80008a46:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008a4a:	4b f2 51 20 	div.f %d2,%d2,%d15
80008a4e:	1d ff 49 ff 	j 800088e0 <IfxScuCcu_setCpuFrequency+0x6e>

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008a52:	02 a4       	mov %d4,%d10
80008a54:	6d 00 d9 07 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
80008a58:	3c 96       	j 80008984 <IfxScuCcu_setCpuFrequency+0x112>

80008a5a <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80008a5a:	91 30 00 ff 	movh.a %a15,61443

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008a5e:	91 30 00 2f 	movh.a %a2,61443


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80008a62:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008a66:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80008a6a:	48 08       	ld.w %d8,[%a15]0

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008a6c:	54 22       	ld.w %d2,[%a2]
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008a6e:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008a72:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008a76:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008a7a:	df 02 28 00 	jeq %d2,0,80008aca <IfxScuCcu_setGtmFrequency+0x70>
80008a7e:	df 12 a0 80 	jne %d2,1,80008bbe <IfxScuCcu_setGtmFrequency+0x164>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008a82:	48 02       	ld.w %d2,[%a15]0
80008a84:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008a88:	df 02 aa 80 	jne %d2,0,80008bdc <IfxScuCcu_setGtmFrequency+0x182>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008a8c:	91 30 00 ff 	movh.a %a15,61443
80008a90:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008a94:	48 52       	ld.w %d2,[%a15]20
80008a96:	6f 02 b1 80 	jnz.t %d2,0,80008bf8 <IfxScuCcu_setGtmFrequency+0x19e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008a9a:	48 52       	ld.w %d2,[%a15]20
80008a9c:	6f 32 c1 80 	jnz.t %d2,3,80008c1e <IfxScuCcu_setGtmFrequency+0x1c4>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008aa0:	48 65       	ld.w %d5,[%a15]24
80008aa2:	48 72       	ld.w %d2,[%a15]28
80008aa4:	37 05 e7 54 	extr.u %d5,%d5,9,7
80008aa8:	8f f2 07 31 	and %d3,%d2,127
80008aac:	48 62       	ld.w %d2,[%a15]24
80008aae:	c2 15       	add %d5,1
80008ab0:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008ab4:	4b 05 41 51 	itof %d5,%d5
80008ab8:	c2 12       	add %d2,1
80008aba:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80008abe:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80008ac2:	4b 02 41 21 	itof %d2,%d2
80008ac6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
80008aca:	4b 4f 51 f0 	div.f %d15,%d15,%d4
80008ace:	4b 0f 31 21 	ftoiz %d2,%d15
80008ad2:	4b 02 41 31 	itof %d3,%d2
80008ad6:	6b 03 31 ff 	sub.f %d15,%d15,%d3
80008ada:	7b 00 f0 33 	movh %d3,16128
80008ade:	4b 3f 01 f0 	cmp.f %d15,%d15,%d3
80008ae2:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80008ae6:	42 2f       	add %d15,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008ae8:	82 12       	mov %d2,1
80008aea:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
80008aee:	92 92       	add %d2,%d15,-7
80008af0:	ff 72 5e 80 	jge.u %d2,7,80008bac <IfxScuCcu_setGtmFrequency+0x152>
    {
        gtmDiv = gtmDiv - 1;
80008af4:	8f 1f c0 f1 	andn %d15,%d15,1
80008af8:	8f ff 00 a1 	and %d10,%d15,15
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80008afc:	6d 00 42 06 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80008b00:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80008b02:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80008b04:	6d 00 3d 05 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
80008b08:	91 30 00 ff 	movh.a %a15,61443
80008b0c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008b10:	4c f0       	ld.w %d15,[%a15]0
80008b12:	91 30 00 cf 	movh.a %a12,61443
80008b16:	d9 cc 34 06 	lea %a12,[%a12]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008b1a:	bf 0f fb 7f 	jlt %d15,0,80008b10 <IfxScuCcu_setGtmFrequency+0xb6>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
80008b1e:	37 a8 04 86 	insert %d8,%d8,%d10,12,4
    ccucon1.B.UP     = 1U;
80008b22:	b7 18 01 8f 	insert %d8,%d8,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80008b26:	02 94       	mov %d4,%d9
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
80008b28:	74 c8       	st.w [%a12],%d8

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80008b2a:	6d 00 6e 07 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008b2e:	91 30 00 ff 	movh.a %a15,61443
80008b32:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008b36:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008b38:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008b3c:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008b40:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008b44:	df 02 28 00 	jeq %d2,0,80008b94 <IfxScuCcu_setGtmFrequency+0x13a>
80008b48:	df 12 39 80 	jne %d2,1,80008bba <IfxScuCcu_setGtmFrequency+0x160>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008b4c:	54 c2       	ld.w %d2,[%a12]
80008b4e:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008b52:	df 02 38 80 	jne %d2,0,80008bc2 <IfxScuCcu_setGtmFrequency+0x168>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008b56:	91 30 00 ff 	movh.a %a15,61443
80008b5a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008b5e:	48 52       	ld.w %d2,[%a15]20
80008b60:	6f 02 56 80 	jnz.t %d2,0,80008c0c <IfxScuCcu_setGtmFrequency+0x1b2>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008b64:	48 52       	ld.w %d2,[%a15]20
80008b66:	6f 32 69 80 	jnz.t %d2,3,80008c38 <IfxScuCcu_setGtmFrequency+0x1de>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008b6a:	48 64       	ld.w %d4,[%a15]24
80008b6c:	48 72       	ld.w %d2,[%a15]28
80008b6e:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008b72:	8f f2 07 31 	and %d3,%d2,127
80008b76:	48 62       	ld.w %d2,[%a15]24
80008b78:	c2 14       	add %d4,1
80008b7a:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008b7e:	4b 04 41 41 	itof %d4,%d4
80008b82:	c2 12       	add %d2,1
80008b84:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80008b88:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
80008b8c:	4b 02 41 21 	itof %d2,%d2
80008b90:	4b 2f 51 f0 	div.f %d15,%d15,%d2
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
80008b94:	91 30 00 ff 	movh.a %a15,61443
80008b98:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008b9c:	48 02       	ld.w %d2,[%a15]0
80008b9e:	37 02 64 26 	extr.u %d2,%d2,12,4
80008ba2:	4b 02 41 21 	itof %d2,%d2
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    return IfxScuCcu_getGtmFrequency();
}
80008ba6:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008baa:	00 90       	ret 
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
80008bac:	8b ef 00 22 	eq %d2,%d15,14
80008bb0:	3b c0 00 a0 	mov %d10,12
80008bb4:	df 02 a4 ff 	jne %d2,0,80008afc <IfxScuCcu_setGtmFrequency+0xa2>
80008bb8:	3c a0       	j 80008af8 <IfxScuCcu_setGtmFrequency+0x9e>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008bba:	82 0f       	mov %d15,0
80008bbc:	3c ec       	j 80008b94 <IfxScuCcu_setGtmFrequency+0x13a>
80008bbe:	82 0f       	mov %d15,0
80008bc0:	3c 85       	j 80008aca <IfxScuCcu_setGtmFrequency+0x70>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008bc2:	54 c2       	ld.w %d2,[%a12]
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008bc4:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008bc6:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008bca:	df 12 c6 ff 	jne %d2,1,80008b56 <IfxScuCcu_setGtmFrequency+0xfc>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008bce:	91 00 00 f7 	movh.a %a15,28672
80008bd2:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008bd6:	4b 0f 61 f1 	utof %d15,%d15
80008bda:	3c be       	j 80008b56 <IfxScuCcu_setGtmFrequency+0xfc>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008bdc:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008bde:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008be0:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008be4:	df 12 54 ff 	jne %d2,1,80008a8c <IfxScuCcu_setGtmFrequency+0x32>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008be8:	91 00 00 f7 	movh.a %a15,28672
80008bec:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008bf0:	4b 0f 61 f1 	utof %d15,%d15
80008bf4:	1d ff 4c ff 	j 80008a8c <IfxScuCcu_setGtmFrequency+0x32>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008bf8:	48 72       	ld.w %d2,[%a15]28
80008bfa:	37 02 67 28 	extr.u %d2,%d2,16,7
80008bfe:	c2 12       	add %d2,1
80008c00:	4b 02 41 21 	itof %d2,%d2
80008c04:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008c08:	1d ff 61 ff 	j 80008aca <IfxScuCcu_setGtmFrequency+0x70>
80008c0c:	48 72       	ld.w %d2,[%a15]28
80008c0e:	37 02 67 28 	extr.u %d2,%d2,16,7
80008c12:	c2 12       	add %d2,1
80008c14:	4b 02 41 21 	itof %d2,%d2
80008c18:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008c1c:	3c bc       	j 80008b94 <IfxScuCcu_setGtmFrequency+0x13a>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008c1e:	4c f7       	ld.w %d15,[%a15]28
80008c20:	7b f0 cb 24 	movh %d2,19647
80008c24:	16 7f       	and %d15,127
80008c26:	c2 1f       	add %d15,1
80008c28:	4b 0f 41 f1 	itof %d15,%d15
80008c2c:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008c30:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008c34:	1d ff 4b ff 	j 80008aca <IfxScuCcu_setGtmFrequency+0x70>
80008c38:	4c f7       	ld.w %d15,[%a15]28
80008c3a:	7b f0 cb 24 	movh %d2,19647
80008c3e:	16 7f       	and %d15,127
80008c40:	c2 1f       	add %d15,1
80008c42:	4b 0f 41 f1 	itof %d15,%d15
80008c46:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008c4a:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008c4e:	3c a3       	j 80008b94 <IfxScuCcu_setGtmFrequency+0x13a>

80008c50 <IfxScuCcu_setPll2ErayFrequency>:
    return IfxScuCcu_getGtmFrequency();
}


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
80008c50:	02 49       	mov %d9,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80008c52:	6d 00 97 05 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008c56:	91 30 00 ff 	movh.a %a15,61443
80008c5a:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
}


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80008c5e:	02 28       	mov %d8,%d2

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008c60:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80008c62:	7b f0 cb f4 	movh %d15,19647
80008c66:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008c6a:	6f 32 1f 80 	jnz.t %d2,3,80008ca8 <IfxScuCcu_setPll2ErayFrequency+0x58>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008c6e:	91 30 00 ff 	movh.a %a15,61443
80008c72:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008c76:	48 02       	ld.w %d2,[%a15]0
80008c78:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008c7c:	df 02 61 80 	jne %d2,0,80008d3e <IfxScuCcu_setPll2ErayFrequency+0xee>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80008c80:	91 30 00 ff 	movh.a %a15,61443
80008c84:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80008c88:	48 03       	ld.w %d3,[%a15]0
80008c8a:	48 02       	ld.w %d2,[%a15]0
80008c8c:	37 03 e5 34 	extr.u %d3,%d3,9,5
80008c90:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008c94:	c2 13       	add %d3,1
80008c96:	4b 03 41 31 	itof %d3,%d3
80008c9a:	c2 12       	add %d2,1
80008c9c:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80008ca0:	4b 02 41 21 	itof %d2,%d2
80008ca4:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80008ca8:	91 30 00 ff 	movh.a %a15,61443
80008cac:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(password);
80008cb0:	02 84       	mov %d4,%d8
80008cb2:	6d 00 66 04 	call 8000957e <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80008cb6:	4b 9f 51 f0 	div.f %d15,%d15,%d9
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80008cba:	48 09       	ld.w %d9,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80008cbc:	7b 00 f8 23 	movh %d2,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
80008cc0:	02 84       	mov %d4,%d8


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80008cc2:	6b 02 31 ff 	sub.f %d15,%d15,%d2
80008cc6:	4b 0f 71 f1 	ftouz %d15,%d15
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80008cca:	37 f9 04 f4 	insert %d15,%d9,%d15,8,4
80008cce:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(password);
80008cd0:	6d 00 9b 06 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008cd4:	91 30 00 ff 	movh.a %a15,61443
80008cd8:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80008cdc:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80008cde:	7b f0 cb f4 	movh %d15,19647
80008ce2:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008ce6:	6f 32 1f 80 	jnz.t %d2,3,80008d24 <IfxScuCcu_setPll2ErayFrequency+0xd4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008cea:	91 30 00 ff 	movh.a %a15,61443
80008cee:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008cf2:	48 02       	ld.w %d2,[%a15]0
80008cf4:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008cf8:	df 02 30 80 	jne %d2,0,80008d58 <IfxScuCcu_setPll2ErayFrequency+0x108>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80008cfc:	91 30 00 ff 	movh.a %a15,61443
80008d00:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80008d04:	48 03       	ld.w %d3,[%a15]0
80008d06:	48 02       	ld.w %d2,[%a15]0
80008d08:	37 03 e5 34 	extr.u %d3,%d3,9,5
80008d0c:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008d10:	c2 13       	add %d3,1
80008d12:	4b 03 41 31 	itof %d3,%d3
80008d16:	c2 12       	add %d2,1
80008d18:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80008d1c:	4b 02 41 21 	itof %d2,%d2
80008d20:	4b 2f 51 f0 	div.f %d15,%d15,%d2

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
80008d24:	91 30 00 ff 	movh.a %a15,61443
80008d28:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80008d2c:	48 02       	ld.w %d2,[%a15]0
80008d2e:	37 02 64 24 	extr.u %d2,%d2,8,4
80008d32:	c2 12       	add %d2,1
80008d34:	4b 02 41 21 	itof %d2,%d2
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
80008d38:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008d3c:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008d3e:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008d40:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008d42:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008d46:	df 12 9d ff 	jne %d2,1,80008c80 <IfxScuCcu_setPll2ErayFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008d4a:	91 00 00 f7 	movh.a %a15,28672
80008d4e:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008d52:	4b 0f 61 f1 	utof %d15,%d15
80008d56:	3c 95       	j 80008c80 <IfxScuCcu_setPll2ErayFrequency+0x30>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008d58:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008d5a:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008d5c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008d60:	df 12 ce ff 	jne %d2,1,80008cfc <IfxScuCcu_setPll2ErayFrequency+0xac>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008d64:	91 00 00 f7 	movh.a %a15,28672
80008d68:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008d6c:	4b 0f 61 f1 	utof %d15,%d15
80008d70:	3c c6       	j 80008cfc <IfxScuCcu_setPll2ErayFrequency+0xac>

80008d72 <IfxScuCcu_setPll2Frequency>:
    return IfxScuCcu_getPll2ErayFrequency();
}


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
80008d72:	02 49       	mov %d9,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80008d74:	6d 00 06 05 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008d78:	91 30 00 ff 	movh.a %a15,61443
80008d7c:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
}


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80008d80:	02 28       	mov %d8,%d2

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008d82:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80008d84:	7b f0 cb f4 	movh %d15,19647
80008d88:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008d8c:	6f 32 1f 80 	jnz.t %d2,3,80008dca <IfxScuCcu_setPll2Frequency+0x58>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008d90:	91 30 00 ff 	movh.a %a15,61443
80008d94:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008d98:	48 02       	ld.w %d2,[%a15]0
80008d9a:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008d9e:	df 02 61 80 	jne %d2,0,80008e60 <IfxScuCcu_setPll2Frequency+0xee>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80008da2:	91 30 00 ff 	movh.a %a15,61443
80008da6:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008daa:	48 03       	ld.w %d3,[%a15]0
80008dac:	48 02       	ld.w %d2,[%a15]0
80008dae:	37 03 e7 34 	extr.u %d3,%d3,9,7
80008db2:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008db6:	c2 13       	add %d3,1
80008db8:	4b 03 41 31 	itof %d3,%d3
80008dbc:	c2 12       	add %d2,1
80008dbe:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80008dc2:	4b 02 41 21 	itof %d2,%d2
80008dc6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80008dca:	91 30 00 ff 	movh.a %a15,61443
80008dce:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008dd2:	02 84       	mov %d4,%d8
80008dd4:	6d 00 d5 03 	call 8000957e <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80008dd8:	4b 9f 51 f0 	div.f %d15,%d15,%d9
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80008ddc:	48 09       	ld.w %d9,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80008dde:	7b 00 f8 23 	movh %d2,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008de2:	02 84       	mov %d4,%d8


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80008de4:	6b 02 31 ff 	sub.f %d15,%d15,%d2
80008de8:	4b 0f 71 f1 	ftouz %d15,%d15
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80008dec:	37 f9 07 f4 	insert %d15,%d9,%d15,8,7
80008df0:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80008df2:	6d 00 0a 06 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008df6:	91 30 00 ff 	movh.a %a15,61443
80008dfa:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008dfe:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80008e00:	7b f0 cb f4 	movh %d15,19647
80008e04:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008e08:	6f 32 1f 80 	jnz.t %d2,3,80008e46 <IfxScuCcu_setPll2Frequency+0xd4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008e0c:	91 30 00 ff 	movh.a %a15,61443
80008e10:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008e14:	48 02       	ld.w %d2,[%a15]0
80008e16:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008e1a:	df 02 30 80 	jne %d2,0,80008e7a <IfxScuCcu_setPll2Frequency+0x108>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80008e1e:	91 30 00 ff 	movh.a %a15,61443
80008e22:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008e26:	48 03       	ld.w %d3,[%a15]0
80008e28:	48 02       	ld.w %d2,[%a15]0
80008e2a:	37 03 e7 34 	extr.u %d3,%d3,9,7
80008e2e:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008e32:	c2 13       	add %d3,1
80008e34:	4b 03 41 31 	itof %d3,%d3
80008e38:	c2 12       	add %d2,1
80008e3a:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80008e3e:	4b 02 41 21 	itof %d2,%d2
80008e42:	4b 2f 51 f0 	div.f %d15,%d15,%d2


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80008e46:	91 30 00 ff 	movh.a %a15,61443
80008e4a:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008e4e:	48 02       	ld.w %d2,[%a15]0
80008e50:	37 02 67 24 	extr.u %d2,%d2,8,7
80008e54:	c2 12       	add %d2,1
80008e56:	4b 02 41 21 	itof %d2,%d2
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    return IfxScuCcu_getPll2Frequency();
}
80008e5a:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008e5e:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008e60:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008e62:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008e64:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008e68:	df 12 9d ff 	jne %d2,1,80008da2 <IfxScuCcu_setPll2Frequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008e6c:	91 00 00 f7 	movh.a %a15,28672
80008e70:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008e74:	4b 0f 61 f1 	utof %d15,%d15
80008e78:	3c 95       	j 80008da2 <IfxScuCcu_setPll2Frequency+0x30>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008e7a:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008e7c:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008e7e:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008e82:	df 12 ce ff 	jne %d2,1,80008e1e <IfxScuCcu_setPll2Frequency+0xac>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008e86:	91 00 00 f7 	movh.a %a15,28672
80008e8a:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008e8e:	4b 0f 61 f1 	utof %d15,%d15
80008e92:	3c c6       	j 80008e1e <IfxScuCcu_setPll2Frequency+0xac>

80008e94 <IfxScuCcu_setSpbFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008e94:	91 30 00 ff 	movh.a %a15,61443
80008e98:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008e9c:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008e9e:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008ea2:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008ea6:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008eaa:	df 02 2c 00 	jeq %d2,0,80008f02 <IfxScuCcu_setSpbFrequency+0x6e>
80008eae:	df 12 81 80 	jne %d2,1,80008fb0 <IfxScuCcu_setSpbFrequency+0x11c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008eb2:	91 30 00 ff 	movh.a %a15,61443
80008eb6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008eba:	48 02       	ld.w %d2,[%a15]0
80008ebc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008ec0:	df 02 7a 80 	jne %d2,0,80008fb4 <IfxScuCcu_setSpbFrequency+0x120>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008ec4:	91 30 00 ff 	movh.a %a15,61443
80008ec8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008ecc:	48 52       	ld.w %d2,[%a15]20
80008ece:	6f 02 81 80 	jnz.t %d2,0,80008fd0 <IfxScuCcu_setSpbFrequency+0x13c>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008ed2:	48 52       	ld.w %d2,[%a15]20
80008ed4:	6f 32 87 80 	jnz.t %d2,3,80008fe2 <IfxScuCcu_setSpbFrequency+0x14e>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008ed8:	48 65       	ld.w %d5,[%a15]24
80008eda:	48 72       	ld.w %d2,[%a15]28
80008edc:	37 05 e7 54 	extr.u %d5,%d5,9,7
80008ee0:	8f f2 07 31 	and %d3,%d2,127
80008ee4:	48 62       	ld.w %d2,[%a15]24
80008ee6:	c2 15       	add %d5,1
80008ee8:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008eec:	4b 05 41 51 	itof %d5,%d5
80008ef0:	c2 12       	add %d2,1
80008ef2:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80008ef6:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80008efa:	4b 02 41 21 	itof %d2,%d2
80008efe:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80008f02:	4b 4f 51 40 	div.f %d4,%d15,%d4
80008f06:	4b 04 71 f1 	ftouz %d15,%d4
80008f0a:	82 24       	mov %d4,2
80008f0c:	0b 4f b0 41 	max.u %d4,%d15,%d4
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
80008f10:	9a 94       	add %d15,%d4,-7
80008f12:	ff 7f 49 80 	jge.u %d15,7,80008fa4 <IfxScuCcu_setSpbFrequency+0x110>
    {
        spbDiv = spbDiv - 1;
80008f16:	8f 14 c0 41 	andn %d4,%d4,1
80008f1a:	8f f4 00 a1 	and %d10,%d4,15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
80008f1e:	6d 00 13 04 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>
80008f22:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80008f24:	6d 00 2e 04 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80008f28:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80008f2a:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80008f2c:	6d 00 0e 03 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80008f30:	91 30 00 ff 	movh.a %a15,61443
80008f34:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80008f38:	48 02       	ld.w %d2,[%a15]0
80008f3a:	3b 00 3e f0 	mov %d15,992
80008f3e:	a6 2f       	or %d15,%d2
80008f40:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80008f42:	02 84       	mov %d4,%d8
80008f44:	6d 00 46 05 	call 800099d0 <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80008f48:	02 94       	mov %d4,%d9
80008f4a:	6d 00 1a 03 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80008f4e:	91 30 00 ff 	movh.a %a15,61443
80008f52:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008f56:	4c f0       	ld.w %d15,[%a15]0
80008f58:	91 30 00 2f 	movh.a %a2,61443
80008f5c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008f60:	bf 0f fb 7f 	jlt %d15,0,80008f56 <IfxScuCcu_setSpbFrequency+0xc2>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80008f64:	4c 20       	ld.w %d15,[%a2]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80008f66:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
80008f68:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
80008f6c:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80008f70:	91 30 00 ff 	movh.a %a15,61443
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
80008f74:	6c 20       	st.w [%a2]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80008f76:	6d 00 48 05 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80008f7a:	02 84       	mov %d4,%d8
80008f7c:	6d 00 e6 02 	call 80009548 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80008f80:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80008f84:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80008f86:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80008f88:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
80008f8c:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80008f8e:	6d 00 21 05 	call 800099d0 <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80008f92:	91 30 00 ff 	movh.a %a15,61443
80008f96:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008f9a:	4c f0       	ld.w %d15,[%a15]0
80008f9c:	bf 0f ff 7f 	jlt %d15,0,80008f9a <IfxScuCcu_setSpbFrequency+0x106>
    {}

    return IfxScuCcu_getSpbFrequency();
80008fa0:	1d ff 46 f8 	j 8000802c <IfxScuCcu_getSpbFrequency>
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
80008fa4:	8b e4 00 f2 	eq %d15,%d4,14
80008fa8:	3b c0 00 a0 	mov %d10,12
80008fac:	ee b9       	jnz %d15,80008f1e <IfxScuCcu_setSpbFrequency+0x8a>
80008fae:	3c b6       	j 80008f1a <IfxScuCcu_setSpbFrequency+0x86>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008fb0:	82 0f       	mov %d15,0
80008fb2:	3c a8       	j 80008f02 <IfxScuCcu_setSpbFrequency+0x6e>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008fb4:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008fb6:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008fb8:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008fbc:	df 12 84 ff 	jne %d2,1,80008ec4 <IfxScuCcu_setSpbFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008fc0:	91 00 00 f7 	movh.a %a15,28672
80008fc4:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80008fc8:	4b 0f 61 f1 	utof %d15,%d15
80008fcc:	1d ff 7c ff 	j 80008ec4 <IfxScuCcu_setSpbFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008fd0:	48 72       	ld.w %d2,[%a15]28
80008fd2:	37 02 67 28 	extr.u %d2,%d2,16,7
80008fd6:	c2 12       	add %d2,1
80008fd8:	4b 02 41 21 	itof %d2,%d2
80008fdc:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008fe0:	3c 91       	j 80008f02 <IfxScuCcu_setSpbFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008fe2:	4c f7       	ld.w %d15,[%a15]28
80008fe4:	7b f0 cb 24 	movh %d2,19647
80008fe8:	16 7f       	and %d15,127
80008fea:	c2 1f       	add %d15,1
80008fec:	4b 0f 41 f1 	itof %d15,%d15
80008ff0:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008ff4:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008ff8:	3c 85       	j 80008f02 <IfxScuCcu_setSpbFrequency+0x6e>

80008ffa <IfxScuCcu_setSriFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008ffa:	91 30 00 ff 	movh.a %a15,61443
80008ffe:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009002:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009004:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009008:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000900c:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009010:	df 02 2c 00 	jeq %d2,0,80009068 <IfxScuCcu_setSriFrequency+0x6e>
80009014:	df 12 6d 80 	jne %d2,1,800090ee <IfxScuCcu_setSriFrequency+0xf4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009018:	91 30 00 ff 	movh.a %a15,61443
8000901c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009020:	48 02       	ld.w %d2,[%a15]0
80009022:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009026:	df 02 66 80 	jne %d2,0,800090f2 <IfxScuCcu_setSriFrequency+0xf8>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000902a:	91 30 00 ff 	movh.a %a15,61443
8000902e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80009032:	48 52       	ld.w %d2,[%a15]20
80009034:	6f 02 6c 80 	jnz.t %d2,0,8000910c <IfxScuCcu_setSriFrequency+0x112>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80009038:	48 52       	ld.w %d2,[%a15]20
8000903a:	6f 32 72 80 	jnz.t %d2,3,8000911e <IfxScuCcu_setSriFrequency+0x124>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000903e:	48 65       	ld.w %d5,[%a15]24
80009040:	48 72       	ld.w %d2,[%a15]28
80009042:	37 05 e7 54 	extr.u %d5,%d5,9,7
80009046:	8f f2 07 31 	and %d3,%d2,127
8000904a:	48 62       	ld.w %d2,[%a15]24
8000904c:	c2 15       	add %d5,1
8000904e:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009052:	4b 05 41 51 	itof %d5,%d5
80009056:	c2 12       	add %d2,1
80009058:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
8000905c:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80009060:	4b 02 41 21 	itof %d2,%d2
80009064:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
80009068:	4b 4f 51 f0 	div.f %d15,%d15,%d4
8000906c:	4b 0f 31 21 	ftoiz %d2,%d15
80009070:	4b 02 41 31 	itof %d3,%d2
80009074:	6b 03 31 ff 	sub.f %d15,%d15,%d3
80009078:	7b 00 f0 33 	movh %d3,16128
8000907c:	4b 3f 01 f0 	cmp.f %d15,%d15,%d3
80009080:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80009084:	42 2f       	add %d15,%d2
80009086:	82 12       	mov %d2,1
80009088:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
8000908c:	92 92       	add %d2,%d15,-7
8000908e:	ff 72 29 80 	jge.u %d2,7,800090e0 <IfxScuCcu_setSriFrequency+0xe6>
    {
        sriDiv = sriDiv - 1;
80009092:	8f 1f c0 f1 	andn %d15,%d15,1
80009096:	8f ff 00 91 	and %d9,%d15,15
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
8000909a:	6d 00 73 03 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
8000909e:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
800090a0:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
800090a2:	6d 00 6e 02 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
800090a6:	91 30 00 ff 	movh.a %a15,61443
800090aa:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090ae:	4c f0       	ld.w %d15,[%a15]0
800090b0:	91 30 00 2f 	movh.a %a2,61443
800090b4:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090b8:	bf 0f fb 7f 	jlt %d15,0,800090ae <IfxScuCcu_setSriFrequency+0xb4>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
800090bc:	4c 20       	ld.w %d15,[%a2]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800090be:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
800090c0:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
800090c4:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    while (SCU_CCUCON0.B.LCK != 0U)
800090c8:	91 30 00 ff 	movh.a %a15,61443
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
800090cc:	6c 20       	st.w [%a2]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800090ce:	6d 00 9c 04 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
800090d2:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090d6:	4c f0       	ld.w %d15,[%a15]0
800090d8:	bf 0f ff 7f 	jlt %d15,0,800090d6 <IfxScuCcu_setSriFrequency+0xdc>
    {}

    freq = IfxScuCcu_getSriFrequency();
800090dc:	1d ff 4c f8 	j 80008174 <IfxScuCcu_getSriFrequency>
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
800090e0:	8b ef 00 22 	eq %d2,%d15,14
800090e4:	3b c0 00 90 	mov %d9,12
800090e8:	df 02 d9 ff 	jne %d2,0,8000909a <IfxScuCcu_setSriFrequency+0xa0>
800090ec:	3c d5       	j 80009096 <IfxScuCcu_setSriFrequency+0x9c>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800090ee:	82 0f       	mov %d15,0
800090f0:	3c bc       	j 80009068 <IfxScuCcu_setSriFrequency+0x6e>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800090f2:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800090f4:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800090f6:	37 02 62 2e 	extr.u %d2,%d2,28,2
800090fa:	df 12 98 ff 	jne %d2,1,8000902a <IfxScuCcu_setSriFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800090fe:	91 00 00 f7 	movh.a %a15,28672
80009102:	19 ff f8 c0 	ld.w %d15,[%a15]3896 <70000f38 <IfxScuCcu_xtalFrequency>>
80009106:	4b 0f 61 f1 	utof %d15,%d15
8000910a:	3c 90       	j 8000902a <IfxScuCcu_setSriFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
8000910c:	48 72       	ld.w %d2,[%a15]28
8000910e:	37 02 67 28 	extr.u %d2,%d2,16,7
80009112:	c2 12       	add %d2,1
80009114:	4b 02 41 21 	itof %d2,%d2
80009118:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000911c:	3c a6       	j 80009068 <IfxScuCcu_setSriFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000911e:	4c f7       	ld.w %d15,[%a15]28
80009120:	7b f0 cb 24 	movh %d2,19647
80009124:	16 7f       	and %d15,127
80009126:	c2 1f       	add %d15,1
80009128:	4b 0f 41 f1 	itof %d15,%d15
8000912c:	1b 02 c2 2b 	addi %d2,%d2,-17376
80009130:	4b f2 51 f0 	div.f %d15,%d2,%d15
80009134:	3c 9a       	j 80009068 <IfxScuCcu_setSriFrequency+0x6e>

80009136 <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80009136:	91 30 00 ff 	movh.a %a15,61443
8000913a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000913e:	4c f0       	ld.w %d15,[%a15]0
80009140:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80009144:	ee 02       	jnz %d15,80009148 <IfxScuCcu_switchToBackupClock+0x12>
80009146:	00 90       	ret 
80009148:	40 4c       	mov.aa %a12,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000914a:	6d 00 1b 03 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>
8000914e:	02 28       	mov %d8,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80009150:	6d 00 fa 02 	call 80009744 <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80009154:	14 c9       	ld.bu %d9,[%a12]
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80009156:	91 30 00 ff 	movh.a %a15,61443
8000915a:	53 c9 20 f0 	mul %d15,%d9,12
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
8000915e:	91 30 00 ef 	movh.a %a14,61443

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009162:	7b 30 00 af 	movh %d10,61443
80009166:	60 f2       	mov.a %a2,%d15
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009168:	7b f0 cb c4 	movh %d12,19647
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
8000916c:	7b 00 00 d7 	movh %d13,28672
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80009170:	02 2b       	mov %d11,%d2
80009172:	d9 2d f4 ff 	lea %a13,[%a2]-12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80009176:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
8000917a:	d9 ee 1c 06 	lea %a14,[%a14]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000917e:	1b 0a 03 a6 	addi %d10,%d10,24624
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009182:	1b 0c c2 cb 	addi %d12,%d12,-17376
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009186:	1b 8d f3 d0 	addi %d13,%d13,3896

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
8000918a:	df 09 3f 00 	jeq %d9,0,80009208 <IfxScuCcu_switchToBackupClock+0xd2>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000918e:	02 84       	mov %d4,%d8
80009190:	6d 00 f7 01 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80009194:	4c f0       	ld.w %d15,[%a15]0
80009196:	6f 5f ff 7f 	jz.t %d15,5,80009194 <IfxScuCcu_switchToBackupClock+0x5e>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
8000919a:	99 c2 04 00 	ld.a %a2,[%a12]4
8000919e:	54 e3       	ld.w %d3,[%a14]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800091a0:	02 84       	mov %d4,%d8
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
800091a2:	30 d2       	add.a %a2,%a13
800091a4:	0c 20       	ld.bu %d15,[%a2]0
800091a6:	37 f3 07 f0 	insert %d15,%d3,%d15,0,7
800091aa:	6c e0       	st.w [%a14]0,%d15

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800091ac:	6d 00 2d 04 	call 80009a06 <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
800091b0:	99 c2 04 00 	ld.a %a2,[%a12]4
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800091b4:	7b f0 cb f4 	movh %d15,19647
800091b8:	1b 0f c2 fb 	addi %d15,%d15,-17376
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
800091bc:	30 d2       	add.a %a2,%a13
800091be:	19 26 04 00 	ld.w %d6,[%a2]4

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800091c2:	60 a2       	mov.a %a2,%d10
800091c4:	54 25       	ld.w %d5,[%a2]
800091c6:	37 05 62 5e 	extr.u %d5,%d5,28,2
800091ca:	76 54       	jz %d5,800091d2 <IfxScuCcu_switchToBackupClock+0x9c>
800091cc:	df 15 6d 00 	jeq %d5,1,800092a6 <IfxScuCcu_switchToBackupClock+0x170>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800091d0:	82 0f       	mov %d15,0
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
800091d2:	91 30 00 2f 	movh.a %a2,61443
800091d6:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800091da:	54 23       	ld.w %d3,[%a2]


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
800091dc:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
800091e0:	37 03 64 34 	extr.u %d3,%d3,8,4
800091e4:	4b 03 41 31 	itof %d3,%d3
800091e8:	4b 3f 51 30 	div.f %d3,%d15,%d3
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
800091ec:	4b 63 41 30 	mul.f %d3,%d3,%d6
800091f0:	4b 03 71 31 	ftouz %d3,%d3
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
800091f4:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
800091f8:	a2 5f       	sub %d15,%d5
800091fa:	3f 3f fd ff 	jlt.u %d15,%d3,800091f4 <IfxScuCcu_switchToBackupClock+0xbe>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
800091fe:	c2 f9       	add %d9,-1
80009200:	d9 dd f4 ff 	lea %a13,[%a13]-12
80009204:	df 09 c5 ff 	jne %d9,0,8000918e <IfxScuCcu_switchToBackupClock+0x58>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80009208:	02 b4       	mov %d4,%d11
8000920a:	6d 00 9f 01 	call 80009548 <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
8000920e:	91 30 00 ff 	movh.a %a15,61443
80009212:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009216:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80009218:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
8000921a:	02 b4       	mov %d4,%d11
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
8000921c:	96 08       	or %d15,8
8000921e:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80009220:	37 02 e1 91 	extr.u %d9,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80009224:	6d 00 d6 03 	call 800099d0 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009228:	02 84       	mov %d4,%d8
8000922a:	6d 00 aa 01 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
8000922e:	91 30 00 2f 	movh.a %a2,61443
80009232:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009236:	4c 20       	ld.w %d15,[%a2]0
80009238:	91 30 00 ff 	movh.a %a15,61443
8000923c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009240:	bf 0f fb 7f 	jlt %d15,0,80009236 <IfxScuCcu_switchToBackupClock+0x100>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80009244:	4c f0       	ld.w %d15,[%a15]0
80009246:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
8000924a:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
8000924c:	4c f0       	ld.w %d15,[%a15]0
8000924e:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80009252:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
80009254:	4c f0       	ld.w %d15,[%a15]0
80009256:	bf 0f ff 7f 	jlt %d15,0,80009254 <IfxScuCcu_switchToBackupClock+0x11e>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
8000925a:	91 30 00 ff 	movh.a %a15,61443
8000925e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009262:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009264:	02 84       	mov %d4,%d8
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80009266:	96 10       	or %d15,16
80009268:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000926a:	4c f0       	ld.w %d15,[%a15]0
8000926c:	8f 0f c4 f1 	andn %d15,%d15,64
80009270:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009272:	6d 00 ca 03 	call 80009a06 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80009276:	91 30 00 ff 	movh.a %a15,61443
8000927a:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000927e:	02 b4       	mov %d4,%d11
80009280:	6d 00 64 01 	call 80009548 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80009284:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80009286:	8f 39 00 20 	sh %d2,%d9,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000928a:	96 08       	or %d15,8
8000928c:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000928e:	91 30 00 ff 	movh.a %a15,61443
80009292:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009296:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80009298:	02 b4       	mov %d4,%d11
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000929a:	8f 8f c0 f1 	andn %d15,%d15,8
8000929e:	a6 2f       	or %d15,%d2
800092a0:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
800092a2:	1d 00 97 03 	j 800099d0 <IfxScuWdt_setCpuEndinit>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
800092a6:	91 30 00 2f 	movh.a %a2,61443
800092aa:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800092ae:	54 22       	ld.w %d2,[%a2]
800092b0:	37 02 62 2e 	extr.u %d2,%d2,28,2
800092b4:	df 02 28 80 	jne %d2,0,80009304 <IfxScuCcu_switchToBackupClock+0x1ce>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800092b8:	91 30 00 2f 	movh.a %a2,61443
800092bc:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800092c0:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
800092c4:	6f 02 32 80 	jnz.t %d2,0,80009328 <IfxScuCcu_switchToBackupClock+0x1f2>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800092c8:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
800092cc:	6f 32 39 80 	jnz.t %d2,3,8000933e <IfxScuCcu_switchToBackupClock+0x208>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800092d0:	19 24 18 00 	ld.w %d4,[%a2]24 <f0030018 <_SMALL_DATA4_+0x40028018>>
800092d4:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x4002801c>>
800092d8:	37 04 e7 44 	extr.u %d4,%d4,9,7
800092dc:	8f f2 07 31 	and %d3,%d2,127
800092e0:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x40028018>>
800092e4:	c2 14       	add %d4,1
800092e6:	37 02 64 2c 	extr.u %d2,%d2,24,4
800092ea:	4b 04 41 41 	itof %d4,%d4
800092ee:	c2 12       	add %d2,1
800092f0:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
800092f4:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
800092f8:	4b 02 41 21 	itof %d2,%d2
800092fc:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80009300:	1d ff 69 ff 	j 800091d2 <IfxScuCcu_switchToBackupClock+0x9c>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009304:	54 22       	ld.w %d2,[%a2]
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009306:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009308:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000930c:	df 12 d6 ff 	jne %d2,1,800092b8 <IfxScuCcu_switchToBackupClock+0x182>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009310:	60 d2       	mov.a %a2,%d13
80009312:	4c 20       	ld.w %d15,[%a2]0
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80009314:	91 30 00 2f 	movh.a %a2,61443
80009318:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000931c:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009320:	4b 0f 61 f1 	utof %d15,%d15
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80009324:	6f 02 d2 7f 	jz.t %d2,0,800092c8 <IfxScuCcu_switchToBackupClock+0x192>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80009328:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x4002801c>>
8000932c:	37 02 67 28 	extr.u %d2,%d2,16,7
80009330:	c2 12       	add %d2,1
80009332:	4b 02 41 21 	itof %d2,%d2
80009336:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000933a:	1d ff 4c ff 	j 800091d2 <IfxScuCcu_switchToBackupClock+0x9c>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000933e:	4c 27       	ld.w %d15,[%a2]28
80009340:	16 7f       	and %d15,127
80009342:	c2 1f       	add %d15,1
80009344:	4b 0f 41 f1 	itof %d15,%d15
80009348:	4b fc 51 f0 	div.f %d15,%d12,%d15
8000934c:	1d ff 43 ff 	j 800091d2 <IfxScuCcu_switchToBackupClock+0x9c>

80009350 <IfxScuCcu_enableExtClockOut0>:
    }
}


void IfxScuCcu_enableExtClockOut0(IfxScuCcu_ClkSel0 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk0Mode mode)
{
80009350:	0b 45 10 88 	mov %e8,%d5,%d4
80009354:	02 6a       	mov %d10,%d6
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009356:	6d 00 15 02 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000935a:	02 24       	mov %d4,%d2

void IfxScuCcu_enableExtClockOut0(IfxScuCcu_ClkSel0 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk0Mode mode)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000935c:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000935e:	6d 00 10 01 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

    SCU_EXTCON.B.SEL0 = (uint32)Clk_Sel;
80009362:	91 30 00 ff 	movh.a %a15,61443
80009366:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
8000936a:	48 02       	ld.w %d2,[%a15]0
8000936c:	37 82 04 21 	insert %d2,%d2,%d8,2,4
80009370:	68 02       	st.w [%a15]0,%d2

    if (IfxScuCcu_ClkSel0_fOUT == Clk_Sel)
80009372:	df 08 1a 80 	jne %d8,0,800093a6 <IfxScuCcu_enableExtClockOut0+0x56>
    {
        if (mode == IfxScuCcu_Clk0Mode_normal)
        {
            /* normal divider mode */
            SCU_FDR.B.DM = 1U;
80009376:	91 30 00 ff 	movh.a %a15,61443
8000937a:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
8000937e:	48 02       	ld.w %d2,[%a15]0

    SCU_EXTCON.B.SEL0 = (uint32)Clk_Sel;

    if (IfxScuCcu_ClkSel0_fOUT == Clk_Sel)
    {
        if (mode == IfxScuCcu_Clk0Mode_normal)
80009380:	df 1a 1e 00 	jeq %d10,1,800093bc <IfxScuCcu_enableExtClockOut0+0x6c>
            }
        }
        else
        {
            /* fractional divider mode */
            SCU_FDR.B.DM   = 2U;
80009384:	b7 22 02 27 	insert %d2,%d2,2,14,2
            SCU_FDR.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxScuCcu_getSpbFrequency()));
80009388:	8f b9 00 90 	sh %d9,%d9,11
            }
        }
        else
        {
            /* fractional divider mode */
            SCU_FDR.B.DM   = 2U;
8000938c:	68 02       	st.w [%a15]0,%d2
            SCU_FDR.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxScuCcu_getSpbFrequency()));
8000938e:	6d ff 4f f6 	call 8000802c <IfxScuCcu_getSpbFrequency>
80009392:	4b 09 61 91 	utof %d9,%d9
80009396:	4b 29 51 20 	div.f %d2,%d9,%d2
8000939a:	48 09       	ld.w %d9,[%a15]0
8000939c:	4b 02 71 21 	ftouz %d2,%d2
800093a0:	37 29 0a 20 	insert %d2,%d9,%d2,0,10
800093a4:	68 02       	st.w [%a15]0,%d2
        }
    }

    SCU_EXTCON.B.EN0 = 1U;
800093a6:	91 30 00 ff 	movh.a %a15,61443
800093aa:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
800093ae:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800093b0:	02 f4       	mov %d4,%d15
            SCU_FDR.B.DM   = 2U;
            SCU_FDR.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxScuCcu_getSpbFrequency()));
        }
    }

    SCU_EXTCON.B.EN0 = 1U;
800093b2:	8f 12 40 21 	or %d2,%d2,1
800093b6:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800093b8:	1d 00 27 03 	j 80009a06 <IfxScuWdt_setSafetyEndinit>
    if (IfxScuCcu_ClkSel0_fOUT == Clk_Sel)
    {
        if (mode == IfxScuCcu_Clk0Mode_normal)
        {
            /* normal divider mode */
            SCU_FDR.B.DM = 1U;
800093bc:	b7 12 02 27 	insert %d2,%d2,1,14,2
800093c0:	68 02       	st.w [%a15]0,%d2

            if (freqHz == (IfxScuCcu_getSpbFrequency() / 2))
800093c2:	6d ff 35 f6 	call 8000802c <IfxScuCcu_getSpbFrequency>
800093c6:	7b 00 f0 43 	movh %d4,16128
800093ca:	4b 09 61 31 	utof %d3,%d9
800093ce:	4b 42 41 20 	mul.f %d2,%d2,%d4
800093d2:	4b 23 01 20 	cmp.f %d2,%d3,%d2
800093d6:	8f d2 00 21 	and %d2,%d2,13
800093da:	f6 27       	jnz %d2,800093e8 <IfxScuCcu_enableExtClockOut0+0x98>
            {
                SCU_FDR.B.STEP = 0x3FFu;
800093dc:	48 03       	ld.w %d3,[%a15]0
800093de:	3b f0 3f 20 	mov %d2,1023
800093e2:	a6 32       	or %d2,%d3
800093e4:	68 02       	st.w [%a15]0,%d2
800093e6:	3c e0       	j 800093a6 <IfxScuCcu_enableExtClockOut0+0x56>
            }
            else
            {
                SCU_FDR.B.STEP = (uint32)(1024u - (IfxScuCcu_getSpbFrequency() / (2u * freqHz)));
800093e8:	6d ff 22 f6 	call 8000802c <IfxScuCcu_getSpbFrequency>
800093ec:	06 19       	sh %d9,1
800093ee:	4b 09 61 91 	utof %d9,%d9
800093f2:	7b 00 48 34 	movh %d3,17536
800093f6:	4b 92 51 20 	div.f %d2,%d2,%d9
800093fa:	6b 02 31 23 	sub.f %d2,%d3,%d2
800093fe:	48 03       	ld.w %d3,[%a15]0
80009400:	4b 02 71 21 	ftouz %d2,%d2
80009404:	37 23 0a 20 	insert %d2,%d3,%d2,0,10
80009408:	68 02       	st.w [%a15]0,%d2
8000940a:	3c ce       	j 800093a6 <IfxScuCcu_enableExtClockOut0+0x56>

8000940c <IfxScuCcu_enableExtClockOut1>:
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
}


void IfxScuCcu_enableExtClockOut1(IfxScuCcu_ClkSel1 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk1Negation sel)
{
8000940c:	02 48       	mov %d8,%d4
8000940e:	02 5a       	mov %d10,%d5
80009410:	02 69       	mov %d9,%d6
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009412:	6d 00 b7 01 	call 80009780 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009416:	02 24       	mov %d4,%d2

void IfxScuCcu_enableExtClockOut1(IfxScuCcu_ClkSel1 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk1Negation sel)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009418:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000941a:	6d 00 b2 00 	call 8000957e <IfxScuWdt_clearSafetyEndinit>

    SCU_EXTCON.B.SEL1 = (uint32)Clk_Sel;
8000941e:	91 30 00 ff 	movh.a %a15,61443
80009422:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
80009426:	48 03       	ld.w %d3,[%a15]0
80009428:	37 83 04 39 	insert %d3,%d3,%d8,18,4
8000942c:	68 03       	st.w [%a15]0,%d3

    if (IfxScuCcu_ClkSel1_fOUT == Clk_Sel)
8000942e:	df 08 16 80 	jne %d8,0,8000945a <IfxScuCcu_enableExtClockOut1+0x4e>
    {
        SCU_EXTCON.B.DIV1 = (uint32)((IfxScuCcu_getSpbFrequency() / freqHz) - 1U);
80009432:	6d ff fd f5 	call 8000802c <IfxScuCcu_getSpbFrequency>
80009436:	4b 0a 61 a1 	utof %d10,%d10
8000943a:	4b a2 51 20 	div.f %d2,%d2,%d10
8000943e:	7b 00 f8 a3 	movh %d10,16256
80009442:	6b 0a 31 22 	sub.f %d2,%d2,%d10
80009446:	48 0a       	ld.w %d10,[%a15]0
80009448:	4b 02 71 21 	ftouz %d2,%d2
8000944c:	37 2a 08 2c 	insert %d2,%d10,%d2,24,8
80009450:	68 02       	st.w [%a15]0,%d2
        SCU_EXTCON.B.NSEL = sel;
80009452:	48 02       	ld.w %d2,[%a15]0
80009454:	67 92 11 90 	ins.t %d9,%d2,17,%d9,0
80009458:	68 09       	st.w [%a15]0,%d9
    }

    SCU_EXTCON.B.EN1 = 1U;
8000945a:	91 30 00 ff 	movh.a %a15,61443
8000945e:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
80009462:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009464:	02 f4       	mov %d4,%d15
    {
        SCU_EXTCON.B.DIV1 = (uint32)((IfxScuCcu_getSpbFrequency() / freqHz) - 1U);
        SCU_EXTCON.B.NSEL = sel;
    }

    SCU_EXTCON.B.EN1 = 1U;
80009466:	b7 f2 01 28 	insert %d2,%d2,15,16,1
8000946a:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000946c:	1d 00 cd 02 	j 80009a06 <IfxScuWdt_setSafetyEndinit>

80009470 <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80009470:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80009474:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
80009476:	53 cf 20 f0 	mul %d15,%d15,12
8000947a:	60 f2       	mov.a %a2,%d15
8000947c:	d9 2f 00 46 	lea %a15,[%a2]24832
80009480:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80009484:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80009486:	2e 16       	jz.t %d15,1,80009492 <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80009488:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000948c:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80009490:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80009492:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80009496:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
8000949a:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
8000949e:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800094a0:	4c f0       	ld.w %d15,[%a15]0
800094a2:	6f 0f ff 7f 	jz.t %d15,0,800094a0 <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
800094a6:	00 90       	ret 

800094a8 <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800094a8:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800094ac:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
800094ae:	53 cf 20 f0 	mul %d15,%d15,12
800094b2:	60 f2       	mov.a %a2,%d15
800094b4:	d9 2f 00 46 	lea %a15,[%a2]24832
800094b8:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
800094bc:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
800094be:	2e 16       	jz.t %d15,1,800094ca <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800094c0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
800094c4:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800094c8:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
800094ca:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
800094ce:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
800094d2:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
800094d6:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
800094d8:	4c f0       	ld.w %d15,[%a15]0
800094da:	6f 0f ff 7f 	jz.t %d15,0,800094d8 <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
800094de:	00 90       	ret 

800094e0 <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
800094e0:	91 30 00 ff 	movh.a %a15,61443
800094e4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800094e8:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
800094ea:	2e 16       	jz.t %d15,1,800094f6 <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800094ec:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
800094f0:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
800094f4:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
800094f6:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
800094fa:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
800094fe:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80009502:	91 30 00 ff 	movh.a %a15,61443
80009506:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000950a:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000950c:	4c f0       	ld.w %d15,[%a15]0
8000950e:	6f 0f ff 7f 	jz.t %d15,0,8000950c <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
80009512:	00 90       	ret 

80009514 <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
80009514:	91 30 00 ff 	movh.a %a15,61443
80009518:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000951c:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000951e:	2e 16       	jz.t %d15,1,8000952a <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80009520:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80009524:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80009528:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
8000952a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000952e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80009532:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80009536:	91 30 00 ff 	movh.a %a15,61443
8000953a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000953e:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80009540:	4c f0       	ld.w %d15,[%a15]0
80009542:	6f 0f ff 7f 	jz.t %d15,0,80009540 <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
80009546:	00 90       	ret 

80009548 <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80009548:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000954c:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000954e:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009552:	06 24       	sh %d4,2
80009554:	60 f2       	mov.a %a2,%d15
80009556:	d9 2f 00 46 	lea %a15,[%a2]24832
8000955a:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000955e:	4c f0       	ld.w %d15,[%a15]0
80009560:	2e 16       	jz.t %d15,1,8000956c <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80009562:	4c f0       	ld.w %d15,[%a15]0
80009564:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009568:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000956a:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000956c:	4c f0       	ld.w %d15,[%a15]0
8000956e:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009572:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80009574:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80009576:	4c f0       	ld.w %d15,[%a15]0
80009578:	6f 0f ff ff 	jnz.t %d15,0,80009576 <IfxScuWdt_clearCpuEndinit+0x2e>
}
8000957c:	00 90       	ret 

8000957e <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000957e:	91 30 00 ff 	movh.a %a15,61443
80009582:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009586:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009588:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000958a:	2e 16       	jz.t %d15,1,80009596 <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000958c:	4c f0       	ld.w %d15,[%a15]0
8000958e:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009592:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009594:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009596:	91 30 00 ff 	movh.a %a15,61443
8000959a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000959e:	4c f0       	ld.w %d15,[%a15]0
800095a0:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800095a4:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800095a6:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800095a8:	4c f0       	ld.w %d15,[%a15]0
800095aa:	6f 0f ff ff 	jnz.t %d15,0,800095a8 <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
800095ae:	00 90       	ret 

800095b0 <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800095b0:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800095b4:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800095b6:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800095ba:	06 24       	sh %d4,2
800095bc:	60 f2       	mov.a %a2,%d15
800095be:	d9 2f 00 46 	lea %a15,[%a2]24832
800095c2:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800095c6:	4c f0       	ld.w %d15,[%a15]0
800095c8:	2e 16       	jz.t %d15,1,800095d4 <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800095ca:	4c f0       	ld.w %d15,[%a15]0
800095cc:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800095d0:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800095d2:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800095d4:	4c f0       	ld.w %d15,[%a15]0
800095d6:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800095da:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800095dc:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
800095de:	4c f0       	ld.w %d15,[%a15]0
800095e0:	6f 0f ff ff 	jnz.t %d15,0,800095de <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
800095e4:	4c f1       	ld.w %d15,[%a15]4
800095e6:	96 08       	or %d15,8
800095e8:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800095ea:	4c f0       	ld.w %d15,[%a15]0
800095ec:	2e 16       	jz.t %d15,1,800095f8 <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800095ee:	4c f0       	ld.w %d15,[%a15]0
800095f0:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800095f4:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800095f6:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800095f8:	4c f0       	ld.w %d15,[%a15]0
800095fa:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800095fe:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80009600:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80009602:	4c f0       	ld.w %d15,[%a15]0
80009604:	6f 0f ff 7f 	jz.t %d15,0,80009602 <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80009608:	00 90       	ret 

8000960a <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000960a:	91 30 00 ff 	movh.a %a15,61443
8000960e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009612:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009614:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80009616:	2e 16       	jz.t %d15,1,80009622 <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009618:	4c f0       	ld.w %d15,[%a15]0
8000961a:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000961e:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009620:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009622:	91 30 00 ff 	movh.a %a15,61443
80009626:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000962a:	4c f0       	ld.w %d15,[%a15]0
8000962c:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009630:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009632:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80009634:	4c f0       	ld.w %d15,[%a15]0
80009636:	91 30 00 2f 	movh.a %a2,61443
8000963a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000963e:	6f 0f fb ff 	jnz.t %d15,0,80009634 <IfxScuWdt_disableSafetyWatchdog+0x2a>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
80009642:	91 30 00 ff 	movh.a %a15,61443
80009646:	d9 ff 34 36 	lea %a15,[%a15]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
8000964a:	4c f0       	ld.w %d15,[%a15]0
8000964c:	96 08       	or %d15,8
8000964e:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80009650:	4c 20       	ld.w %d15,[%a2]0
80009652:	2e 16       	jz.t %d15,1,8000965e <IfxScuWdt_disableSafetyWatchdog+0x54>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009654:	4c 20       	ld.w %d15,[%a2]0
80009656:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000965a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000965c:	6c 20       	st.w [%a2]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000965e:	91 30 00 ff 	movh.a %a15,61443
80009662:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009666:	4c f0       	ld.w %d15,[%a15]0
80009668:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000966c:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000966e:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80009670:	4c f0       	ld.w %d15,[%a15]0
80009672:	6f 0f ff 7f 	jz.t %d15,0,80009670 <IfxScuWdt_disableSafetyWatchdog+0x66>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80009676:	00 90       	ret 

80009678 <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80009678:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000967c:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000967e:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009682:	06 24       	sh %d4,2
80009684:	60 f2       	mov.a %a2,%d15
80009686:	d9 2f 00 46 	lea %a15,[%a2]24832
8000968a:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000968e:	4c f0       	ld.w %d15,[%a15]0
80009690:	2e 16       	jz.t %d15,1,8000969c <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80009692:	4c f0       	ld.w %d15,[%a15]0
80009694:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009698:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000969a:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000969c:	4c f0       	ld.w %d15,[%a15]0
8000969e:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800096a2:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800096a4:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
800096a6:	4c f0       	ld.w %d15,[%a15]0
800096a8:	6f 0f ff ff 	jnz.t %d15,0,800096a6 <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
800096ac:	4c f1       	ld.w %d15,[%a15]4
800096ae:	8f 8f c0 f1 	andn %d15,%d15,8
800096b2:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800096b4:	4c f0       	ld.w %d15,[%a15]0
800096b6:	2e 16       	jz.t %d15,1,800096c2 <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800096b8:	4c f0       	ld.w %d15,[%a15]0
800096ba:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800096be:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800096c0:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800096c2:	4c f0       	ld.w %d15,[%a15]0
800096c4:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800096c8:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800096ca:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800096cc:	4c f0       	ld.w %d15,[%a15]0
800096ce:	6f 0f ff 7f 	jz.t %d15,0,800096cc <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
800096d2:	00 90       	ret 

800096d4 <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800096d4:	91 30 00 ff 	movh.a %a15,61443
800096d8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800096dc:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800096de:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800096e0:	2e 16       	jz.t %d15,1,800096ec <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800096e2:	4c f0       	ld.w %d15,[%a15]0
800096e4:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800096e8:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800096ea:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800096ec:	91 30 00 ff 	movh.a %a15,61443
800096f0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800096f4:	4c f0       	ld.w %d15,[%a15]0
800096f6:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800096fa:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800096fc:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
800096fe:	4c f0       	ld.w %d15,[%a15]0
80009700:	91 30 00 2f 	movh.a %a2,61443
80009704:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009708:	6f 0f fb ff 	jnz.t %d15,0,800096fe <IfxScuWdt_enableSafetyWatchdog+0x2a>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
8000970c:	91 30 00 ff 	movh.a %a15,61443
80009710:	d9 ff 34 36 	lea %a15,[%a15]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
80009714:	4c f0       	ld.w %d15,[%a15]0
80009716:	8f 8f c0 f1 	andn %d15,%d15,8
8000971a:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000971c:	4c 20       	ld.w %d15,[%a2]0
8000971e:	2e 16       	jz.t %d15,1,8000972a <IfxScuWdt_enableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009720:	4c 20       	ld.w %d15,[%a2]0
80009722:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009726:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009728:	6c 20       	st.w [%a2]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000972a:	91 30 00 ff 	movh.a %a15,61443
8000972e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009732:	4c f0       	ld.w %d15,[%a15]0
80009734:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009738:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000973a:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000973c:	4c f0       	ld.w %d15,[%a15]0
8000973e:	6f 0f ff 7f 	jz.t %d15,0,8000973c <IfxScuWdt_enableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80009742:	00 90       	ret 

80009744 <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80009744:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80009748:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
8000974a:	53 cf 20 f0 	mul %d15,%d15,12
8000974e:	60 f2       	mov.a %a2,%d15
80009750:	d9 2f 00 46 	lea %a15,[%a2]24832
80009754:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80009758:	48 02       	ld.w %d2,[%a15]0
8000975a:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
8000975e:	8f f2 83 21 	xor %d2,%d2,63
80009762:	00 90       	ret 

80009764 <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80009764:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80009768:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
8000976a:	53 cf 20 f0 	mul %d15,%d15,12
8000976e:	60 f2       	mov.a %a2,%d15
80009770:	d9 2f 00 46 	lea %a15,[%a2]24832
80009774:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
80009778:	48 02       	ld.w %d2,[%a15]0
}
8000977a:	8f 12 00 21 	and %d2,%d2,1
8000977e:	00 90       	ret 

80009780 <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80009780:	91 30 00 ff 	movh.a %a15,61443
80009784:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009788:	48 02       	ld.w %d2,[%a15]0
8000978a:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
8000978e:	8f f2 83 21 	xor %d2,%d2,63
80009792:	00 90       	ret 

80009794 <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
80009794:	da 3c       	mov %d15,60
80009796:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
80009798:	82 cf       	mov %d15,-4
8000979a:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
8000979c:	82 0f       	mov %d15,0
8000979e:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
800097a0:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
800097a2:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
800097a4:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
800097a6:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
800097a8:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
800097aa:	2c 4a       	st.b [%a4]10,%d15
800097ac:	00 90       	ret 

800097ae <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
800097ae:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
800097b0:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
800097b2:	6f 12 0b 00 	jz.t %d2,1,800097c8 <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
800097b6:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
800097ba:	37 02 6e 31 	extr.u %d3,%d2,2,14
800097be:	8f f3 83 31 	xor %d3,%d3,63
800097c2:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800097c6:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
800097c8:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
800097ca:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
800097ce:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
800097d2:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
800097d6:	b9 53 02 00 	ld.hu %d3,[%a5]2
800097da:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
800097de:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
800097e0:	54 42       	ld.w %d2,[%a4]
800097e2:	6f 02 ff ff 	jnz.t %d2,0,800097e0 <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
800097e6:	39 52 04 00 	ld.bu %d2,[%a5]4
800097ea:	df 12 48 00 	jeq %d2,1,8000987a <IfxScuWdt_initCpuWatchdog+0xcc>
800097ee:	df 02 4b 00 	jeq %d2,0,80009884 <IfxScuWdt_initCpuWatchdog+0xd6>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
800097f2:	8b 22 20 22 	ne %d2,%d2,2
800097f6:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
800097fa:	39 52 05 00 	ld.bu %d2,[%a5]5
800097fe:	8b 02 20 22 	ne %d2,%d2,0
80009802:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
80009806:	39 52 06 00 	ld.bu %d2,[%a5]6
8000980a:	8b 02 20 22 	ne %d2,%d2,0
8000980e:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
80009812:	39 52 07 00 	ld.bu %d2,[%a5]7
80009816:	8b 02 20 22 	ne %d2,%d2,0
8000981a:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
8000981e:	39 52 08 00 	ld.bu %d2,[%a5]8
80009822:	8b 02 20 22 	ne %d2,%d2,0
80009826:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
8000982a:	39 52 09 00 	ld.bu %d2,[%a5]9
8000982e:	8b 02 20 22 	ne %d2,%d2,0
80009832:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
80009836:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
80009838:	b9 5f 00 00 	ld.hu %d15,[%a5]0


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000983c:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80009840:	8f 72 00 21 	and %d2,%d2,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80009844:	53 c2 20 20 	mul %d2,%d2,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009848:	06 2f       	sh %d15,2
8000984a:	60 22       	mov.a %a2,%d2
8000984c:	d9 2f 00 46 	lea %a15,[%a2]24832
80009850:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80009854:	48 02       	ld.w %d2,[%a15]0
80009856:	6f 12 09 00 	jz.t %d2,1,80009868 <IfxScuWdt_initCpuWatchdog+0xba>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000985a:	48 02       	ld.w %d2,[%a15]0
8000985c:	b7 02 10 20 	insert %d2,%d2,0,0,16
80009860:	a6 f2       	or %d2,%d15
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009862:	8f 12 40 21 	or %d2,%d2,1
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80009866:	68 02       	st.w [%a15]0,%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80009868:	48 02       	ld.w %d2,[%a15]0
8000986a:	b7 32 10 20 	insert %d2,%d2,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000986e:	a6 2f       	or %d15,%d2
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80009870:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80009872:	4c f0       	ld.w %d15,[%a15]0
80009874:	6f 0f ff 7f 	jz.t %d15,0,80009872 <IfxScuWdt_initCpuWatchdog+0xc4>
    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
}
80009878:	00 90       	ret 
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000987a:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000987e:	8f 0f c2 f1 	andn %d15,%d15,32
        break;
80009882:	3c bc       	j 800097fa <IfxScuWdt_initCpuWatchdog+0x4c>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
80009884:	82 0f       	mov %d15,0
        break;
80009886:	3c ba       	j 800097fa <IfxScuWdt_initCpuWatchdog+0x4c>

80009888 <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
80009888:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
8000988a:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000988c:	6f 12 0b 00 	jz.t %d2,1,800098a2 <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80009890:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
80009894:	37 02 6e 31 	extr.u %d3,%d2,2,14
80009898:	8f f3 83 31 	xor %d3,%d3,63
8000989c:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
800098a0:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
800098a2:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
800098a4:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
800098a8:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
800098ac:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
800098b0:	b9 53 02 00 	ld.hu %d3,[%a5]2
800098b4:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
800098b8:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
800098ba:	54 42       	ld.w %d2,[%a4]
800098bc:	6f 02 ff ff 	jnz.t %d2,0,800098ba <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
800098c0:	39 52 04 00 	ld.bu %d2,[%a5]4
800098c4:	df 12 4b 00 	jeq %d2,1,8000995a <IfxScuWdt_initSafetyWatchdog+0xd2>
800098c8:	df 02 4e 00 	jeq %d2,0,80009964 <IfxScuWdt_initSafetyWatchdog+0xdc>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
800098cc:	8b 22 20 22 	ne %d2,%d2,2
800098d0:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
800098d4:	39 52 05 00 	ld.bu %d2,[%a5]5
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800098d8:	91 30 00 ff 	movh.a %a15,61443
800098dc:	8b 02 20 22 	ne %d2,%d2,0
800098e0:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
800098e4:	39 52 06 00 	ld.bu %d2,[%a5]6
800098e8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800098ec:	8b 02 20 22 	ne %d2,%d2,0
800098f0:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
800098f4:	39 52 07 00 	ld.bu %d2,[%a5]7
800098f8:	8b 02 20 22 	ne %d2,%d2,0
800098fc:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
80009900:	39 52 08 00 	ld.bu %d2,[%a5]8
80009904:	8b 02 20 22 	ne %d2,%d2,0
80009908:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
8000990c:	39 52 09 00 	ld.bu %d2,[%a5]9
80009910:	8b 02 20 22 	ne %d2,%d2,0
80009914:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 1 : 0;
80009918:	39 52 0a 00 	ld.bu %d2,[%a5]10
8000991c:	8b 02 20 22 	ne %d2,%d2,0
80009920:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
80009924:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
80009926:	b9 5f 00 00 	ld.hu %d15,[%a5]0
8000992a:	48 02       	ld.w %d2,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000992c:	06 2f       	sh %d15,2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000992e:	6f 12 09 00 	jz.t %d2,1,80009940 <IfxScuWdt_initSafetyWatchdog+0xb8>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009932:	48 02       	ld.w %d2,[%a15]0
80009934:	b7 02 10 20 	insert %d2,%d2,0,0,16
80009938:	a6 f2       	or %d2,%d15
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000993a:	8f 12 40 21 	or %d2,%d2,1
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000993e:	68 02       	st.w [%a15]0,%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009940:	91 30 00 ff 	movh.a %a15,61443
80009944:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009948:	48 02       	ld.w %d2,[%a15]0
8000994a:	b7 32 10 20 	insert %d2,%d2,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000994e:	a6 2f       	or %d15,%d2
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009950:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80009952:	4c f0       	ld.w %d15,[%a15]0
80009954:	6f 0f ff 7f 	jz.t %d15,0,80009952 <IfxScuWdt_initSafetyWatchdog+0xca>
}
80009958:	00 90       	ret 
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000995a:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000995e:	8f 0f c2 f1 	andn %d15,%d15,32
        break;
80009962:	3c b9       	j 800098d4 <IfxScuWdt_initSafetyWatchdog+0x4c>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
80009964:	82 0f       	mov %d15,0
        break;
80009966:	3c b7       	j 800098d4 <IfxScuWdt_initSafetyWatchdog+0x4c>

80009968 <IfxScuWdt_serviceCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80009968:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000996c:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000996e:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009972:	06 24       	sh %d4,2
80009974:	60 f2       	mov.a %a2,%d15
80009976:	d9 2f 00 46 	lea %a15,[%a2]24832
8000997a:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000997e:	4c f0       	ld.w %d15,[%a15]0
80009980:	2e 16       	jz.t %d15,1,8000998c <IfxScuWdt_serviceCpuWatchdog+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80009982:	4c f0       	ld.w %d15,[%a15]0
80009984:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009988:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000998a:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000998c:	4c f0       	ld.w %d15,[%a15]0
8000998e:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80009992:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80009994:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80009996:	4c f0       	ld.w %d15,[%a15]0
80009998:	6f 0f ff 7f 	jz.t %d15,0,80009996 <IfxScuWdt_serviceCpuWatchdog+0x2e>


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
}
8000999c:	00 90       	ret 

8000999e <IfxScuWdt_serviceSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000999e:	91 30 00 ff 	movh.a %a15,61443
800099a2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800099a6:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800099a8:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800099aa:	2e 16       	jz.t %d15,1,800099b6 <IfxScuWdt_serviceSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800099ac:	4c f0       	ld.w %d15,[%a15]0
800099ae:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800099b2:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800099b4:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800099b6:	91 30 00 ff 	movh.a %a15,61443
800099ba:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800099be:	4c f0       	ld.w %d15,[%a15]0
800099c0:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800099c4:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800099c6:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800099c8:	4c f0       	ld.w %d15,[%a15]0
800099ca:	6f 0f ff 7f 	jz.t %d15,0,800099c8 <IfxScuWdt_serviceSafetyWatchdog+0x2a>


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
}
800099ce:	00 90       	ret 

800099d0 <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800099d0:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800099d4:	16 07       	and %d15,7


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800099d6:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800099da:	06 24       	sh %d4,2
800099dc:	60 f2       	mov.a %a2,%d15
800099de:	d9 2f 00 46 	lea %a15,[%a2]24832
800099e2:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800099e6:	4c f0       	ld.w %d15,[%a15]0
800099e8:	2e 16       	jz.t %d15,1,800099f4 <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800099ea:	4c f0       	ld.w %d15,[%a15]0
800099ec:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800099f0:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800099f2:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800099f4:	4c f0       	ld.w %d15,[%a15]0
800099f6:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800099fa:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800099fc:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800099fe:	4c f0       	ld.w %d15,[%a15]0
80009a00:	6f 0f ff 7f 	jz.t %d15,0,800099fe <IfxScuWdt_setCpuEndinit+0x2e>
}
80009a04:	00 90       	ret 

80009a06 <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80009a06:	91 30 00 ff 	movh.a %a15,61443
80009a0a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009a0e:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009a10:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80009a12:	2e 16       	jz.t %d15,1,80009a1e <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009a14:	4c f0       	ld.w %d15,[%a15]0
80009a16:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009a1a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009a1c:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80009a1e:	91 30 00 ff 	movh.a %a15,61443
80009a22:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009a26:	4c f0       	ld.w %d15,[%a15]0
80009a28:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80009a2c:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80009a2e:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80009a30:	4c f0       	ld.w %d15,[%a15]0
80009a32:	6f 0f ff 7f 	jz.t %d15,0,80009a30 <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
80009a36:	00 90       	ret 

80009a38 <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
80009a38:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
80009a3c:	2e 0c       	jz.t %d15,0,80009a54 <IfxScuWdt_enableWatchdogWithDebugger+0x1c>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
80009a3e:	3b 00 00 f3 	mov %d15,12288
80009a42:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
80009a46:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
80009a4a:	82 02       	mov %d2,0

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
80009a4c:	37 0f e1 f3 	extr.u %d15,%d15,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
80009a50:	ea 12       	cmovn %d2,%d15,1
80009a52:	00 90       	ret 

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
80009a54:	3b 10 0a 20 	mov %d2,161
80009a58:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
80009a5c:	da 5e       	mov %d15,94
80009a5e:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
80009a62:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
80009a66:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
80009a6a:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
80009a6e:	6f 0f e8 ff 	jnz.t %d15,0,80009a3e <IfxScuWdt_enableWatchdogWithDebugger+0x6>
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
80009a72:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
80009a76:	82 12       	mov %d2,1

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
80009a78:	37 0f e1 f3 	extr.u %d15,%d15,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
80009a7c:	ea 12       	cmovn %d2,%d15,1
80009a7e:	00 90       	ret 

80009a80 <CAN_RX_HND>:
}


IFX_INLINE void IfxCpu_enableInterrupts(void)
{
    __enable();
80009a80:	0d 00 00 03 	enable 
	    static uint32_t u32nuTemp3=0u;
	   // static uint32_t u32nuTemp4=0u;
	    IfxCpu_enableInterrupts();

	    //frmIsInternal  0x100
	    readStatusfromsensor=IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[0], &stRxMsgData[0]);
80009a84:	91 00 00 f7 	movh.a %a15,28672
80009a88:	d9 ff a4 61 	lea %a15,[%a15]6564 <700019a4 <stRxMsgData>>
80009a8c:	91 00 00 47 	movh.a %a4,28672
80009a90:	d9 44 a0 c1 	lea %a4,[%a4]6944 <70001b20 <stEcu1Can+0xb0>>
80009a94:	40 f5       	mov.aa %a5,%a15
80009a96:	6d ff f2 e2 	call 8000607a <IfxMultican_Can_MsgObj_readMessage>

	    if(readStatusfromsensor==IfxMultican_Status_newData){
80009a9a:	3b 00 10 f0 	mov %d15,256
80009a9e:	5f f2 24 00 	jeq %d2,%d15,80009ae6 <CAN_RX_HND+0x66>
	        }
	        //ActivateTask(LCD_IsIntunnel);
	    }

	    //frmBodyStatus  0x300
	    readStatusfrombody=IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[1], &stRxMsgData[1]);
80009aa2:	91 00 00 47 	movh.a %a4,28672
80009aa6:	91 00 00 57 	movh.a %a5,28672
80009aaa:	d9 44 b0 c1 	lea %a4,[%a4]6960 <70001b30 <stEcu1Can+0xc0>>
80009aae:	d9 55 b8 61 	lea %a5,[%a5]6584 <700019b8 <stRxMsgData+0x14>>
80009ab2:	6d ff e4 e2 	call 8000607a <IfxMultican_Can_MsgObj_readMessage>

	    if(readStatusfrombody==IfxMultican_Status_newData){
80009ab6:	3b 00 10 f0 	mov %d15,256
80009aba:	5f f2 03 00 	jeq %d2,%d15,80009ac0 <CAN_RX_HND+0x40>
80009abe:	00 90       	ret 
	            u32nuTemp3=stRxMsgData[1].data[0]; //dataLow  -  0x1 0x1 0x1
80009ac0:	4c f7       	ld.w %d15,[%a15]28
	           // u32nuTemp4=stRxMsgData[1].data[1]; //dataHigh - 
	         if(u32nuTemp3==0x00010101){
80009ac2:	7b 10 00 20 	movh %d2,1

	    //frmBodyStatus  0x300
	    readStatusfrombody=IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[1], &stRxMsgData[1]);

	    if(readStatusfrombody==IfxMultican_Status_newData){
	            u32nuTemp3=stRxMsgData[1].data[0]; //dataLow  -  0x1 0x1 0x1
80009ac6:	91 00 00 f7 	movh.a %a15,28672
80009aca:	59 ff 98 61 	st.w [%a15]6552 <70001998 <u32nuTemp3.10893>>,%d15
	           // u32nuTemp4=stRxMsgData[1].data[1]; //dataHigh - 
	         if(u32nuTemp3==0x00010101){
80009ace:	1b 12 10 20 	addi %d2,%d2,257
80009ad2:	be 2a       	jeq %d15,%d2,80009b06 <CAN_RX_HND+0x86>

	        	 led_king=1;
	        	 ActivateTask(Display_BodyStatus);
	         	 }
	         else if(u32nuTemp3==0x00000000){
80009ad4:	ee f5       	jnz %d15,80009abe <CAN_RX_HND+0x3e>

	        	 led_king=0;
80009ad6:	91 00 00 f7 	movh.a %a15,28672
	        	 ActivateTask(Display_BodyStatus);
80009ada:	3b e0 00 40 	mov %d4,14
	        	 led_king=1;
	        	 ActivateTask(Display_BodyStatus);
	         	 }
	         else if(u32nuTemp3==0x00000000){

	        	 led_king=0;
80009ade:	e9 ff a1 61 	st.b [%a15]6561 <700019a1 <led_king>>,%d15
	        	 ActivateTask(Display_BodyStatus);
80009ae2:	1d 00 2f 1b 	j 8000d140 <ActivateTask>

	    //frmIsInternal  0x100
	    readStatusfromsensor=IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[0], &stRxMsgData[0]);

	    if(readStatusfromsensor==IfxMultican_Status_newData){
	        u32nuTemp1=stRxMsgData[0].data[0]; //dataLow  -  0x1
80009ae6:	4c f2       	ld.w %d15,[%a15]8
80009ae8:	91 00 00 27 	movh.a %a2,28672
80009aec:	59 2f 9c 61 	st.w [%a2]6556 <7000199c <u32nuTemp1.10892>>,%d15
	       // u32nuTemp2=stRxMsgData[0].data[1]; //dataHigh - 


	        if(u32nuTemp1==0x00000001){ //   
80009af0:	1e 12       	jeq %d15,1,80009af4 <CAN_RX_HND+0x74>

	        	tunnel_ok=1;
	        	ActivateTask(LCD_IsIntunnel);
	        }
	        else if(u32nuTemp1==0x0){ //  
80009af2:	ee d8       	jnz %d15,80009aa2 <CAN_RX_HND+0x22>

	        	tunnel_ok=0;
80009af4:	91 00 00 27 	movh.a %a2,28672
	        	ActivateTask(LCD_IsIntunnel);
80009af8:	3b d0 00 40 	mov %d4,13
	        	tunnel_ok=1;
	        	ActivateTask(LCD_IsIntunnel);
	        }
	        else if(u32nuTemp1==0x0){ //  

	        	tunnel_ok=0;
80009afc:	e9 2f a0 61 	st.b [%a2]6560 <700019a0 <tunnel_ok>>,%d15
	        	ActivateTask(LCD_IsIntunnel);
80009b00:	6d 00 20 1b 	call 8000d140 <ActivateTask>
80009b04:	3c cf       	j 80009aa2 <CAN_RX_HND+0x22>
	    if(readStatusfrombody==IfxMultican_Status_newData){
	            u32nuTemp3=stRxMsgData[1].data[0]; //dataLow  -  0x1 0x1 0x1
	           // u32nuTemp4=stRxMsgData[1].data[1]; //dataHigh - 
	         if(u32nuTemp3==0x00010101){

	        	 led_king=1;
80009b06:	82 1f       	mov %d15,1
80009b08:	91 00 00 f7 	movh.a %a15,28672
	        	 ActivateTask(Display_BodyStatus);
80009b0c:	3b e0 00 40 	mov %d4,14
	    if(readStatusfrombody==IfxMultican_Status_newData){
	            u32nuTemp3=stRxMsgData[1].data[0]; //dataLow  -  0x1 0x1 0x1
	           // u32nuTemp4=stRxMsgData[1].data[1]; //dataHigh - 
	         if(u32nuTemp3==0x00010101){

	        	 led_king=1;
80009b10:	e9 ff a1 61 	st.b [%a15]6561 <700019a1 <led_king>>,%d15
	        	 ActivateTask(Display_BodyStatus);
80009b14:	1d 00 16 1b 	j 8000d140 <ActivateTask>

80009b18 <getLEDKing>:
}


char getLEDKing(void){
	return led_king;
}
80009b18:	91 00 00 f7 	movh.a %a15,28672
80009b1c:	79 f2 a1 61 	ld.b %d2,[%a15]6561 <700019a1 <led_king>>
80009b20:	00 90       	ret 

80009b22 <getTunnelStatus>:
char getTunnelStatus(void){
	return tunnel_ok;
}
80009b22:	91 00 00 f7 	movh.a %a15,28672
80009b26:	79 f2 a0 61 	ld.b %d2,[%a15]6560 <700019a0 <tunnel_ok>>
80009b2a:	00 90       	ret 

80009b2c <Driver_Can_Init>:

void Driver_Can_Init(void)
{
	InterruptInstall(SRC_ID_CANINT0, CAN_RX_HND,3,0);
80009b2c:	91 10 00 48 	movh.a %a4,32769
char getTunnelStatus(void){
	return tunnel_ok;
}

void Driver_Can_Init(void)
{
80009b30:	20 d0       	sub.a %sp,208
	InterruptInstall(SRC_ID_CANINT0, CAN_RX_HND,3,0);
80009b32:	3b 00 24 40 	mov %d4,576
80009b36:	82 35       	mov %d5,3
80009b38:	82 06       	mov %d6,0
80009b3a:	d9 44 80 a9 	lea %a4,[%a4]-25984
80009b3e:	6d 00 7e 0e 	call 8000b83a <InterruptInstall>
    /* create module config */
    IfxMultican_Can_Config canConfig;
    IfxMultican_Can_initModuleConfig(&canConfig, &MODULE_CAN);
80009b42:	91 20 00 5f 	movh.a %a5,61442
80009b46:	d9 a4 04 20 	lea %a4,[%sp]132
80009b4a:	d9 55 00 08 	lea %a5,[%a5]-32768 <f0018000 <_SMALL_DATA4_+0x40010000>>
80009b4e:	6d ff c9 e6 	call 800068e0 <IfxMultican_Can_initModuleConfig>

    /* initialize module */
    IfxMultican_Can_initModule(&stEcu1Can.CanEcu1, &canConfig);
80009b52:	91 00 00 c7 	movh.a %a12,28672
80009b56:	d9 cc b0 91 	lea %a12,[%a12]6768 <70001a70 <stEcu1Can>>
80009b5a:	40 c4       	mov.aa %a4,%a12
80009b5c:	d9 a5 04 20 	lea %a5,[%sp]132
80009b60:	6d ff e7 e5 	call 8000672e <IfxMultican_Can_initModule>

    /* create CAN node config */
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
80009b64:	7b 80 00 f0 	movh %d15,8
    /* initialize module */
    IfxMultican_Can_initModule(&stEcu1Can.CanEcu1, &canConfig);

    /* create CAN node config */
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);
80009b68:	d9 a4 00 10 	lea %a4,[%sp]64
80009b6c:	40 c5       	mov.aa %a5,%a12

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
80009b6e:	1b 0f 12 fa 	addi %d15,%d15,-24288
    /* initialize module */
    IfxMultican_Can_initModule(&stEcu1Can.CanEcu1, &canConfig);

    /* create CAN node config */
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);
80009b72:	6d ff a2 e4 	call 800064b6 <IfxMultican_Can_Node_initConfig>

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
80009b76:	78 12       	st.w [%sp]72,%d15
    {
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
80009b78:	82 0f       	mov %d15,0
80009b7a:	e9 af 04 10 	st.b [%sp]68,%d15
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
80009b7e:	7b 00 00 f8 	movh %d15,32768
80009b82:	1b 8f 34 f0 	addi %d15,%d15,840
80009b86:	78 1a       	st.w [%sp]104,%d15
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
80009b88:	da 10       	mov %d15,16
80009b8a:	e9 af 2c 10 	st.b [%sp]108,%d15
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
80009b8e:	7b 00 00 f8 	movh %d15,32768
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
80009b92:	d9 cf 04 00 	lea %a15,[%a12]4 <70000004 <__DSPR0_START+0x4>>
    {
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
80009b96:	1b cf 17 f0 	addi %d15,%d15,380
80009b9a:	78 1c       	st.w [%sp]112,%d15
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
80009b9c:	40 f4       	mov.aa %a4,%a15
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;
80009b9e:	3b 00 f8 ff 	mov %d15,-128

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
80009ba2:	d9 a5 00 10 	lea %a5,[%sp]64
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;
80009ba6:	e9 af 34 10 	st.b [%sp]116,%d15

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
80009baa:	6d ff 28 e3 	call 800061fa <IfxMultican_Can_Node_init>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80009bae:	d9 a4 04 00 	lea %a4,[%sp]4
80009bb2:	40 f5       	mov.aa %a5,%a15
80009bb4:	6d ff dc e1 	call 80005f6c <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80009bb8:	39 a2 12 00 	ld.bu %d2,[%sp]18
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80009bbc:	82 f8       	mov %d8,-1
    canMsgObjConfig.control.matchingId    = TRUE;
80009bbe:	8f e2 0f 21 	and %d2,%d2,254
80009bc2:	b7 12 81 20 	insert %d2,%d2,1,1,1
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80009bc6:	82 0f       	mov %d15,0
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
80009bc8:	82 19       	mov %d9,1
    canMsgObjConfig.control.messageLen    = msgDlc;
80009bca:	3b 80 00 a0 	mov %d10,8
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80009bce:	06 f8       	sh %d8,-1
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80009bd0:	3b 00 30 b0 	mov %d11,768
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009bd4:	d9 c4 10 00 	lea %a4,[%a12]16 <70000010 <__DSPR0_START+0x10>>
80009bd8:	d9 a5 04 00 	lea %a5,[%sp]4 <70000010 <__DSPR0_START+0x10>>
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80009bdc:	78 02       	st.w [%sp]8,%d15
    canMsgObjConfig.messageId             = msgId;
80009bde:	59 ab 28 00 	st.w [%sp]40 <70000010 <__DSPR0_START+0x10>>,%d11
    canMsgObjConfig.frame                 = frameType;
80009be2:	e9 a9 20 00 	st.b [%sp]32 <70000010 <__DSPR0_START+0x10>>,%d9
    canMsgObjConfig.control.messageLen    = msgDlc;
80009be6:	e9 aa 11 00 	st.b [%sp]17 <70000010 <__DSPR0_START+0x10>>,%d10
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80009bea:	59 a8 24 00 	st.w [%sp]36 <70000010 <__DSPR0_START+0x10>>,%d8
    canMsgObjConfig.control.matchingId    = TRUE;
80009bee:	e9 a2 12 00 	st.b [%sp]18 <70000010 <__DSPR0_START+0x10>>,%d2
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009bf2:	6d ff 8b dc 	call 80005508 <IfxMultican_Can_MsgObj_init>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80009bf6:	d9 a4 04 00 	lea %a4,[%sp]4
80009bfa:	40 f5       	mov.aa %a5,%a15
80009bfc:	6d ff b8 e1 	call 80005f6c <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
80009c00:	3b a0 00 20 	mov %d2,10
80009c04:	59 a2 08 00 	st.w [%sp]8,%d2
    canMsgObjConfig.messageId             = msgId;
80009c08:	3b 00 10 20 	mov %d2,256
80009c0c:	59 a2 28 00 	st.w [%sp]40,%d2
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80009c10:	39 a2 12 00 	ld.bu %d2,[%sp]18
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009c14:	d9 c4 30 20 	lea %a4,[%a12]176 <700000b0 <__DSPR0_START+0xb0>>
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80009c18:	8f e2 0f 21 	and %d2,%d2,254
80009c1c:	b7 12 81 20 	insert %d2,%d2,1,1,1
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009c20:	d9 a5 04 00 	lea %a5,[%sp]4
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
80009c24:	e9 af 20 00 	st.b [%sp]32,%d15
    canMsgObjConfig.control.messageLen    = msgDlc;
80009c28:	e9 aa 11 00 	st.b [%sp]17,%d10
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80009c2c:	59 a8 24 00 	st.w [%sp]36,%d8
    canMsgObjConfig.control.matchingId    = TRUE;
80009c30:	e9 a2 12 00 	st.b [%sp]18,%d2

    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80009c34:	e9 a9 2e 00 	st.b [%sp]46,%d9
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0
80009c38:	e9 af 2f 00 	st.b [%sp]47,%d15

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009c3c:	6d ff 66 dc 	call 80005508 <IfxMultican_Can_MsgObj_init>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80009c40:	d9 a4 04 00 	lea %a4,[%sp]4
80009c44:	40 f5       	mov.aa %a5,%a15
80009c46:	6d ff 93 e1 	call 80005f6c <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
80009c4a:	3b b0 00 20 	mov %d2,11
80009c4e:	59 a2 08 00 	st.w [%sp]8,%d2
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80009c52:	39 a2 12 00 	ld.bu %d2,[%sp]18
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009c56:	d9 c4 00 30 	lea %a4,[%a12]192 <700000c0 <__DSPR0_START+0xc0>>
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80009c5a:	8f e2 0f 21 	and %d2,%d2,254
80009c5e:	b7 12 81 20 	insert %d2,%d2,1,1,1
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009c62:	d9 a5 04 00 	lea %a5,[%sp]4
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80009c66:	59 ab 28 00 	st.w [%sp]40,%d11
    canMsgObjConfig.frame                 = frameType;
80009c6a:	e9 af 20 00 	st.b [%sp]32,%d15
    canMsgObjConfig.control.messageLen    = msgDlc;
80009c6e:	e9 aa 11 00 	st.b [%sp]17,%d10
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80009c72:	59 a8 24 00 	st.w [%sp]36,%d8
    canMsgObjConfig.control.matchingId    = TRUE;
80009c76:	e9 a2 12 00 	st.b [%sp]18,%d2

    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80009c7a:	e9 a9 2e 00 	st.b [%sp]46,%d9
        canMsgObjConfig.rxInterrupt.srcId=0u; //source can nodeid 0
80009c7e:	e9 af 2f 00 	st.b [%sp]47,%d15

    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80009c82:	1d ff 43 dc 	j 80005508 <IfxMultican_Can_MsgObj_init>

80009c86 <Driver_Can_TxTest>:
}

void Driver_Can_TxTest(void)
{
80009c86:	20 18       	sub.a %sp,24
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxMultican_Message_init(IfxMultican_Message *msg, uint32 id, uint32 dataLow, uint32 dataHigh, IfxMultican_DataLengthCode lengthCode)
{
    msg->id          = id;
80009c88:	3b 00 30 f0 	mov %d15,768
80009c8c:	78 01       	st.w [%sp]4,%d15
    msg->data[0]     = dataLow;
80009c8e:	82 1f       	mov %d15,1
80009c90:	78 03       	st.w [%sp]12,%d15
    msg->data[1]     = dataHigh;
    msg->lengthCode  = lengthCode;
80009c92:	3b 80 00 20 	mov %d2,8

IFX_INLINE void IfxMultican_Message_init(IfxMultican_Message *msg, uint32 id, uint32 dataLow, uint32 dataHigh, IfxMultican_DataLengthCode lengthCode)
{
    msg->id          = id;
    msg->data[0]     = dataLow;
    msg->data[1]     = dataHigh;
80009c96:	82 0f       	mov %d15,0
80009c98:	91 00 00 f7 	movh.a %a15,28672
80009c9c:	78 04       	st.w [%sp]16,%d15
    msg->lengthCode  = lengthCode;
80009c9e:	e9 a2 08 00 	st.b [%sp]8 <70000004 <__DSPR0_START+0x4>>,%d2

    msg->fastBitRate = FALSE;
80009ca2:	e9 af 14 00 	st.b [%sp]20 <70000004 <__DSPR0_START+0x4>>,%d15
80009ca6:	d9 ff 80 a1 	lea %a15,[%a15]6784 <70001a80 <stEcu1Can+0x10>>

        IfxMultican_Message msg;
        IfxMultican_Message_init(&msg, 0x300, dataLow, dataHigh, IfxMultican_DataLengthCode_8);

        //send message
        while (IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[0], &msg) == IfxMultican_Status_notSentBusy)
80009caa:	40 f4       	mov.aa %a4,%a15
80009cac:	d9 a5 04 00 	lea %a5,[%sp]4
80009cb0:	6d ff 11 e2 	call 800060d2 <IfxMultican_Can_MsgObj_sendMessage>
80009cb4:	8b 02 02 22 	eq %d2,%d2,32
80009cb8:	df 02 f9 ff 	jne %d2,0,80009caa <Driver_Can_TxTest+0x24>
        {

        }

    }
}
80009cbc:	00 90       	ret 
	...

80009cc0 <_init_uart3>:
	unsigned int denominator = 3125;
	unsigned int pisel = 3; /* select ARXnD */

	/* ARX3D/P32.2 (RXD), ATX3/P15.7 (TXD) */
	/* Set TXD/P15.7 to "output" and "high" */
	MODULE_P15.IOCR4.B.PC7 = 0x12;
80009cc0:	91 40 00 ff 	movh.a %a15,61444
80009cc4:	d9 ff 40 4b 	lea %a15,[%a15]-19200 <f003b500 <_SMALL_DATA4_+0x40033500>>
80009cc8:	4c f5       	ld.w %d15,[%a15]20
80009cca:	7b 00 00 29 	movh %d2,36864
80009cce:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
80009cd2:	a6 2f       	or %d15,%d2
80009cd4:	68 5f       	st.w [%a15]20,%d15
	MODULE_P15.OUT.B.P7 = 1;
80009cd6:	4c f0       	ld.w %d15,[%a15]0
80009cd8:	96 80       	or %d15,128
80009cda:	68 0f       	st.w [%a15]0,%d15

	/* Enable ASCn */
	unlock_wdtcon();
	MODULE_ASCLIN3.CLC.U = 0;
80009cdc:	c5 ff 80 40 	lea %a15,f0000900 <_SMALL_DATA4_+0x3fff8900>
80009ce0:	82 0f       	mov %d15,0
	/* Set TXD/P15.7 to "output" and "high" */
	MODULE_P15.IOCR4.B.PC7 = 0x12;
	MODULE_P15.OUT.B.P7 = 1;

	/* Enable ASCn */
	unlock_wdtcon();
80009ce2:	6d 00 eb 3d 	call 800118b8 <unlock_wdtcon>
	MODULE_ASCLIN3.CLC.U = 0;
80009ce6:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
80009ce8:	6d 00 fe 3d 	call 800118e4 <lock_wdtcon>
	/* read back for activating module */
	(void)MODULE_ASCLIN3.CLC.U;
80009cec:	48 02       	ld.w %d2,[%a15]0

	/* select RXD as input pin */
	MODULE_ASCLIN3.IOCR.B.ALTI = pisel;
80009cee:	48 12       	ld.w %d2,[%a15]4
	MODULE_ASCLIN3.CSR.U = 1;				/* select CLC as clock source */

	/* ASCLIN3RX Interrupt */
	MODULE_ASCLIN3.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
	/* set SRC register  */
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.TOS = 0;	// execute core
80009cf0:	91 40 00 2f 	movh.a %a2,61444
	lock_wdtcon();
	/* read back for activating module */
	(void)MODULE_ASCLIN3.CLC.U;

	/* select RXD as input pin */
	MODULE_ASCLIN3.IOCR.B.ALTI = pisel;
80009cf4:	b7 32 03 20 	insert %d2,%d2,3,0,3
	MODULE_ASCLIN3.CSR.U = 1;				/* select CLC as clock source */

	/* ASCLIN3RX Interrupt */
	MODULE_ASCLIN3.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
	/* set SRC register  */
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.TOS = 0;	// execute core
80009cf8:	d9 22 00 08 	lea %a2,[%a2]-32768 <f0038000 <_SMALL_DATA4_+0x40030000>>
	lock_wdtcon();
	/* read back for activating module */
	(void)MODULE_ASCLIN3.CLC.U;

	/* select RXD as input pin */
	MODULE_ASCLIN3.IOCR.B.ALTI = pisel;
80009cfc:	68 12       	st.w [%a15]4,%d2

	/* Program ASC0 */
	MODULE_ASCLIN3.CSR.U = 0;
80009cfe:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* configure TX and RX FIFOs */
	MODULE_ASCLIN3.TXFIFOCON.U = (1 << 6)	/* INW: (1 == 1 byte) */
80009d02:	da 43       	mov %d15,67
80009d04:	68 3f       	st.w [%a15]12,%d15
						  | (1 << 1)	/* ENO */
						  | (1 << 0);	/* FLUSH */
	MODULE_ASCLIN3.RXFIFOCON.U = (1 << 31)  /* BUF: (1 == Single Stage RX Buffer) */
80009d06:	9b 0f 00 f8 	addih %d15,%d15,32768
80009d0a:	68 4f       	st.w [%a15]16,%d15
						  | (1 << 6)	/* OUTW: (1 == 1 byte) */
						  | (1 << 1)	/* ENI */
						  | (1 << 0);	/* FLUSH */

	/* 38400 */
	MODULE_ASCLIN3.BITCON.U = ( 9 << 0)		/* PRESCALER: 10 */
80009d0c:	7b f0 90 f8 	movh %d15,35087
80009d10:	1b 9f 00 f0 	addi %d15,%d15,9
80009d14:	68 5f       	st.w [%a15]20,%d15
					   | (15 << 16)		/* OVERSAMPLING: 16 */
					   | ( 9 << 24)		/* SAMPLEPOINT: position 7,8,9 */
					   | (1u << 31);	/* SM: 3 samples per bit */
	/* data format: 8N1 */
	MODULE_ASCLIN3.FRAMECON.U = (1 << 9)		/* STOP: 1 bit */
80009d16:	3b 00 20 f0 	mov %d15,512
80009d1a:	68 6f       	st.w [%a15]24,%d15
						 | (0 << 16)	/* MODE: Init */
						 | (0 << 30);	/* PEN: no parity */
	MODULE_ASCLIN3.DATCON.U = (7 << 0);		/* DATLEN: 8 bit */
80009d1c:	82 7f       	mov %d15,7
80009d1e:	68 7f       	st.w [%a15]28,%d15

	/* set baudrate value */
	MODULE_ASCLIN3.BRG.U = (denominator << 0)	/* DENOMINATOR */
80009d20:	7b 00 0c f0 	movh %d15,192
80009d24:	1b 5f c3 f0 	addi %d15,%d15,3125
80009d28:	68 8f       	st.w [%a15]32,%d15
					| (numerator << 16);	/* NUMERATOR */

	MODULE_ASCLIN3.FRAMECON.B.MODE = 1;		/* ASC mode */
80009d2a:	4c f6       	ld.w %d15,[%a15]24
80009d2c:	b7 1f 02 f8 	insert %d15,%d15,1,16,2
80009d30:	68 6f       	st.w [%a15]24,%d15
	MODULE_ASCLIN3.CSR.U = 1;				/* select CLC as clock source */
80009d32:	82 1f       	mov %d15,1
80009d34:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* ASCLIN3RX Interrupt */
	MODULE_ASCLIN3.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
80009d38:	7b 00 00 f1 	movh %d15,4096
80009d3c:	59 ff 00 10 	st.w [%a15]64 <f0040040 <_SMALL_DATA4_+0x40038040>>,%d15
	/* set SRC register  */
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.TOS = 0;	// execute core
80009d40:	19 2f 28 20 	ld.w %d15,[%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>
80009d44:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
80009d48:	59 2f 28 20 	st.w [%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>,%d15
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.SRPN = 1;	// priority
80009d4c:	19 2f 28 20 	ld.w %d15,[%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>
80009d50:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
80009d54:	59 2f 28 20 	st.w [%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>,%d15
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.SRE = 1;	// enable
80009d58:	19 2f 28 20 	ld.w %d15,[%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>
80009d5c:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80009d60:	59 2f 28 20 	st.w [%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>,%d15

	TX_START(MODULE_ASCLIN3);
80009d64:	7b 00 00 f8 	movh %d15,32768
80009d68:	68 ef       	st.w [%a15]56,%d15
80009d6a:	00 90       	ret 

80009d6c <_out_uart3>:

/* Send character CHR via the serial line */
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));
80009d6c:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
80009d70:	ff 0f fe 7f 	jge %d15,0,80009d6c <_out_uart3>

	TX_CLEAR(MODULE_ASCLIN3);
80009d74:	7b 00 00 f8 	movh %d15,32768
80009d78:	a5 ff bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d15

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN3, chr);
80009d7c:	a5 f4 84 50 	st.w f0000944 <_SMALL_DATA4_+0x3fff8944>,%d4
80009d80:	00 90       	ret 

80009d82 <_in_uart3>:

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
80009d82:	7b 00 00 41 	movh %d4,4096
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
80009d86:	7b 50 40 30 	movh %d3,1029
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
80009d8a:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
80009d8e:	ef cf fe 7f 	jz.t %d15,28,80009d8a <_in_uart3+0x8>
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
80009d92:	85 f2 88 50 	ld.w %d2,f0000948 <_SMALL_DATA4_+0x3fff8948>
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
80009d96:	a5 f4 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d4
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
80009d9a:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
80009d9e:	26 3f       	and %d15,%d3
80009da0:	ee 04       	jnz %d15,80009da8 <_in_uart3+0x26>

	/* wait for a new character */
	while (_poll_uart3(&ch) == 0);

	return ch;
}
80009da2:	8f f2 0f 21 	and %d2,%d2,255
80009da6:	00 90       	ret 
		RX_CLEAR(MODULE_ASCLIN3);
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
		{
			/* reset error flags */
			RESET_ERROR(MODULE_ASCLIN3);
80009da8:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3
80009dac:	3c ef       	j 80009d8a <_in_uart3+0x8>

80009dae <_poll_uart3>:
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
80009dae:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
   else 0
 */
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
80009db2:	82 02       	mov %d2,0

	if (RX_READY(MODULE_ASCLIN3))
80009db4:	ef cf 10 00 	jz.t %d15,28,80009dd4 <_poll_uart3+0x26>
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
80009db8:	7b 00 00 f1 	movh %d15,4096
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
80009dbc:	85 f4 88 50 	ld.w %d4,f0000948 <_SMALL_DATA4_+0x3fff8948>
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
80009dc0:	a5 ff bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d15
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
80009dc4:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
80009dc8:	7b 50 40 30 	movh %d3,1029
80009dcc:	26 3f       	and %d15,%d3
80009dce:	ee 04       	jnz %d15,80009dd6 <_poll_uart3+0x28>
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
80009dd0:	34 44       	st.b [%a4],%d4
		}
		else
		{
			/* this is a valid character */
			*chr = ret;
			res = 1;
80009dd2:	82 12       	mov %d2,1
		}
	}

	return res;
}
80009dd4:	00 90       	ret 
		RX_CLEAR(MODULE_ASCLIN3);
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
		{
			/* reset error flags */
			RESET_ERROR(MODULE_ASCLIN3);
80009dd6:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3
80009dda:	00 90       	ret 

80009ddc <usr_vsprintf>:
	*buf = '\0';
	return length;
}

int usr_vsprintf(char *dest, const char *fmt, va_list ap)
{
80009ddc:	20 70       	sub.a %sp,112
			/* handle type modifier */
			if (c == 'l' || c == 'h')
			{
				c = *fmt++;
			}
			switch (c)
80009dde:	7b 10 00 e8 	movh %d14,32769
	*buf = '\0';
	return length;
}

int usr_vsprintf(char *dest, const char *fmt, va_list ap)
{
80009de2:	80 4d       	mov.d %d13,%a4
80009de4:	40 5c       	mov.aa %a12,%a5
	char c, sign, *cp, *dp = dest;
80009de6:	40 4f       	mov.aa %a15,%a4
		}
		else
		{
			if (c == '\n')
			{
				*dp++= '\r';
80009de8:	3b d0 00 b0 	mov %d11,13
			/* handle type modifier */
			if (c == 'l' || c == 'h')
			{
				c = *fmt++;
			}
			switch (c)
80009dec:	1b 0e f0 e9 	addi %d14,%d14,-24832
			}
			if (pad_on_right)
			{
				while (pad-- > 0)
				{
					*dp++= ' ';
80009df0:	3b 00 02 90 	mov %d9,32
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
80009df4:	d9 ae 20 00 	lea %a14,[%sp]32
	int left_prec, right_prec, zero_fill, length, pad, pad_on_right;
	unsigned int p;
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
80009df8:	79 cf 00 00 	ld.b %d15,[%a12]0
80009dfc:	6e 0e       	jz %d15,80009e18 <usr_vsprintf+0x3c>
	{
		cp = buf;
		length = 0;
		if (c == '%')
80009dfe:	8b 5f 22 32 	ne %d3,%d15,37
80009e02:	76 3f       	jz %d3,80009e20 <usr_vsprintf+0x44>
				}
			}
		}
		else
		{
			if (c == '\n')
80009e04:	8b af 20 32 	ne %d3,%d15,10
80009e08:	df 03 24 01 	jeq %d3,0,8000a050 <usr_vsprintf+0x274>
			{
				*dp++= '\r';
			}
			*dp++ = c;
80009e0c:	28 0f       	st.b [%a15]0,%d15
	int left_prec, right_prec, zero_fill, length, pad, pad_on_right;
	unsigned int p;
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
80009e0e:	b0 1c       	add.a %a12,1
80009e10:	79 cf 00 00 	ld.b %d15,[%a12]0
		{
			if (c == '\n')
			{
				*dp++= '\r';
			}
			*dp++ = c;
80009e14:	b0 1f       	add.a %a15,1
	int left_prec, right_prec, zero_fill, length, pad, pad_on_right;
	unsigned int p;
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
80009e16:	ee f4       	jnz %d15,80009dfe <usr_vsprintf+0x22>
		}
	}

	*dp = '\0';

	return ((int)dp - (int)dest);
80009e18:	80 f2       	mov.d %d2,%a15
			}
			*dp++ = c;
		}
	}

	*dp = '\0';
80009e1a:	28 0f       	st.b [%a15]0,%d15

	return ((int)dp - (int)dest);
80009e1c:	a2 d2       	sub %d2,%d13
80009e1e:	00 90       	ret 
	{
		cp = buf;
		length = 0;
		if (c == '%')
		{
			c = *fmt++;
80009e20:	79 cf 01 00 	ld.b %d15,[%a12]1
80009e24:	d9 c2 02 00 	lea %a2,[%a12]2
			left_prec = right_prec = pad_on_right = 0;
			if (c == '-')
80009e28:	8b df 02 32 	eq %d3,%d15,45
		cp = buf;
		length = 0;
		if (c == '%')
		{
			c = *fmt++;
			left_prec = right_prec = pad_on_right = 0;
80009e2c:	82 0a       	mov %d10,0
			if (c == '-')
80009e2e:	df 03 15 81 	jne %d3,0,8000a058 <usr_vsprintf+0x27c>
			{
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
80009e32:	8b 0f 23 32 	ne %d3,%d15,48
				zero_fill = TRUE;
				c = *fmt++;
			}
			else
			{
				zero_fill = FALSE;
80009e36:	82 0c       	mov %d12,0
			if (c == '-')
			{
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
80009e38:	df 03 1a 01 	jeq %d3,0,8000a06c <usr_vsprintf+0x290>
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
80009e3c:	1b 0f fd 3f 	addi %d3,%d15,-48
80009e40:	8f f3 0f 41 	and %d4,%d3,255
80009e44:	40 2c       	mov.aa %a12,%a2
80009e46:	82 08       	mov %d8,0
80009e48:	ff a4 0f 80 	jge.u %d4,10,80009e66 <usr_vsprintf+0x8a>
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
80009e4c:	79 2f 00 00 	ld.b %d15,[%a2]0
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
			{
				left_prec = (left_prec * 10) + (c - '0');
80009e50:	13 a8 20 83 	madd %d8,%d3,%d8,10
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
80009e54:	1b 0f fd 3f 	addi %d3,%d15,-48
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
80009e58:	d9 2c 01 00 	lea %a12,[%a2]1
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
80009e5c:	8f f3 0f 41 	and %d4,%d3,255
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
80009e60:	40 c2       	mov.aa %a2,%a12
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
80009e62:	bf a4 f5 ff 	jlt.u %d4,10,80009e4c <usr_vsprintf+0x70>
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
			}
			if (c == '.')
80009e66:	8b ef 22 32 	ne %d3,%d15,46
80009e6a:	df 03 07 01 	jeq %d3,0,8000a078 <usr_vsprintf+0x29c>
			{
				right_prec = left_prec;
			}
			sign = '\0';
			/* handle type modifier */
			if (c == 'l' || c == 'h')
80009e6e:	8f 4f c0 31 	andn %d3,%d15,4
80009e72:	8b 83 26 32 	ne %d3,%d3,104
80009e76:	f6 34       	jnz %d3,80009e7e <usr_vsprintf+0xa2>
			{
				c = *fmt++;
80009e78:	79 cf 00 00 	ld.b %d15,[%a12]0
80009e7c:	b0 1c       	add.a %a12,1
			}
			switch (c)
80009e7e:	1b bf fd 4f 	addi %d4,%d15,-37
80009e82:	8b 44 a5 32 	ge.u %d3,%d4,84
80009e86:	df 03 38 00 	jeq %d3,0,80009ef6 <usr_vsprintf+0x11a>
				case 'P' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
				default:
					*dp++ = '?';
80009e8a:	da 3f       	mov %d15,63
80009e8c:	28 0f       	st.b [%a15]0,%d15
80009e8e:	82 f4       	mov %d4,-1
80009e90:	b0 1f       	add.a %a15,1
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
		length = 0;
80009e92:	82 02       	mov %d2,0
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
80009e94:	40 ad       	mov.aa %a13,%sp
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
				default:
					*dp++ = '?';
			}
			pad = left_prec - length;
80009e96:	a2 28       	sub %d8,%d2
80009e98:	82 03       	mov %d3,0
			if (sign != '\0')
			{
				pad--;
			}
			if (zero_fill)
80009e9a:	df 0c 08 01 	jeq %d12,0,8000a0aa <usr_vsprintf+0x2ce>
			}
			else
			{
				c = ' ';
			}
			if (!pad_on_right)
80009e9e:	df 0a 91 01 	jeq %d10,0,8000a1c0 <usr_vsprintf+0x3e4>
			}
			if (sign != '\0')
			{
				*dp++ = sign;
			}
			while (length-- > 0)
80009ea2:	bf 12 1f 00 	jlt %d2,1,80009ee0 <usr_vsprintf+0x104>
			{
				c = *cp++;
				if (c == '\n')
				{
					*dp++ = '\r';
80009ea6:	80 d2       	mov.d %d2,%a13
80009ea8:	80 df       	mov.d %d15,%a13
80009eaa:	46 02       	not %d2
80009eac:	1b 14 00 30 	addi %d3,%d4,1
80009eb0:	42 2f       	add %d15,%d2
80009eb2:	42 3f       	add %d15,%d3
80009eb4:	8b 04 80 42 	ge %d4,%d4,0
80009eb8:	ab 0f 80 44 	sel %d4,%d4,%d15,0
80009ebc:	60 42       	mov.a %a2,%d4
					*dp++ = c;
				}
			}
			if (sign != '\0')
			{
				*dp++ = sign;
80009ebe:	40 d3       	mov.aa %a3,%a13
			}
			while (length-- > 0)
			{
				c = *cp++;
80009ec0:	79 3f 00 00 	ld.b %d15,[%a3]0
80009ec4:	d9 37 01 00 	lea %a7,[%a3]1
				if (c == '\n')
80009ec8:	8b af 20 32 	ne %d3,%d15,10
80009ecc:	40 f3       	mov.aa %a3,%a15
80009ece:	df 03 75 01 	jeq %d3,0,8000a1b8 <usr_vsprintf+0x3dc>
				{
					*dp++ = '\r';
				}
				*dp++ = c;
80009ed2:	2c 30       	st.b [%a3]0,%d15
80009ed4:	d9 3f 01 00 	lea %a15,[%a3]1
			{
				*dp++ = sign;
			}
			while (length-- > 0)
			{
				c = *cp++;
80009ed8:	40 73       	mov.aa %a3,%a7
80009eda:	fc 23       	loop %a2,80009ec0 <usr_vsprintf+0xe4>
				{
					*dp++ = '\r';
				}
				*dp++ = c;
			}
			if (pad_on_right)
80009edc:	df 0a 8e 7f 	jeq %d10,0,80009df8 <usr_vsprintf+0x1c>
			{
				while (pad-- > 0)
80009ee0:	bf 18 8c 7f 	jlt %d8,1,80009df8 <usr_vsprintf+0x1c>
				{
					*dp++= ' ';
80009ee4:	80 ff       	mov.d %d15,%a15
80009ee6:	01 f8 00 26 	addsc.a %a2,%a15,%d8,0
80009eea:	46 0f       	not %d15
80009eec:	10 22       	addsc.a %a2,%a2,%d15,0
80009eee:	28 09       	st.b [%a15]0,%d9
80009ef0:	b0 1f       	add.a %a15,1
80009ef2:	fc 2e       	loop %a2,80009eee <usr_vsprintf+0x112>
80009ef4:	3c 82       	j 80009df8 <usr_vsprintf+0x1c>
			/* handle type modifier */
			if (c == 'l' || c == 'h')
			{
				c = *fmt++;
			}
			switch (c)
80009ef6:	60 e3       	mov.a %a3,%d14
80009ef8:	01 34 02 26 	addsc.a %a2,%a3,%d4,2
80009efc:	dc 02       	ji %a2
80009efe:	00 00       	nop 
80009f00:	1d 00 59 01 	j 8000a1b2 <usr_vsprintf+0x3d6>
80009f04:	1d ff c3 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f08:	1d ff c1 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f0c:	1d ff bf ff 	j 80009e8a <usr_vsprintf+0xae>
80009f10:	1d ff bd ff 	j 80009e8a <usr_vsprintf+0xae>
80009f14:	1d ff bb ff 	j 80009e8a <usr_vsprintf+0xae>
80009f18:	1d ff b9 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f1c:	1d ff b7 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f20:	1d ff b5 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f24:	1d ff b3 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f28:	1d ff b1 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f2c:	1d ff af ff 	j 80009e8a <usr_vsprintf+0xae>
80009f30:	1d ff ad ff 	j 80009e8a <usr_vsprintf+0xae>
80009f34:	1d ff ab ff 	j 80009e8a <usr_vsprintf+0xae>
80009f38:	1d ff a9 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f3c:	1d ff a7 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f40:	1d ff a5 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f44:	1d ff a3 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f48:	1d ff a1 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f4c:	1d ff 9f ff 	j 80009e8a <usr_vsprintf+0xae>
80009f50:	1d ff 9d ff 	j 80009e8a <usr_vsprintf+0xae>
80009f54:	1d ff 9b ff 	j 80009e8a <usr_vsprintf+0xae>
80009f58:	1d ff 99 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f5c:	1d ff 97 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f60:	1d ff 95 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f64:	1d ff 93 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f68:	1d ff 91 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f6c:	1d ff 8f ff 	j 80009e8a <usr_vsprintf+0xae>
80009f70:	1d ff 8d ff 	j 80009e8a <usr_vsprintf+0xae>
80009f74:	1d ff 8b ff 	j 80009e8a <usr_vsprintf+0xae>
80009f78:	1d ff 89 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f7c:	1d ff 87 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f80:	1d ff 85 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f84:	1d ff 83 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f88:	1d ff 81 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f8c:	1d ff 7f ff 	j 80009e8a <usr_vsprintf+0xae>
80009f90:	1d ff 7d ff 	j 80009e8a <usr_vsprintf+0xae>
80009f94:	1d ff 7b ff 	j 80009e8a <usr_vsprintf+0xae>
80009f98:	1d ff 79 ff 	j 80009e8a <usr_vsprintf+0xae>
80009f9c:	1d ff 77 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fa0:	1d ff 75 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fa4:	1d ff 73 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fa8:	1d ff 71 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fac:	1d 00 de 00 	j 8000a168 <usr_vsprintf+0x38c>
80009fb0:	1d ff 6d ff 	j 80009e8a <usr_vsprintf+0xae>
80009fb4:	1d ff 6b ff 	j 80009e8a <usr_vsprintf+0xae>
80009fb8:	1d ff 69 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fbc:	1d ff 67 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fc0:	1d ff 65 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fc4:	1d ff 63 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fc8:	1d ff 61 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fcc:	1d 00 bf 00 	j 8000a14a <usr_vsprintf+0x36e>
80009fd0:	1d ff 5d ff 	j 80009e8a <usr_vsprintf+0xae>
80009fd4:	1d ff 5b ff 	j 80009e8a <usr_vsprintf+0xae>
80009fd8:	1d ff 59 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fdc:	1d ff 57 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fe0:	1d ff 55 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fe4:	1d ff 53 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fe8:	1d ff 51 ff 	j 80009e8a <usr_vsprintf+0xae>
80009fec:	1d ff 4f ff 	j 80009e8a <usr_vsprintf+0xae>
80009ff0:	1d ff 4d ff 	j 80009e8a <usr_vsprintf+0xae>
80009ff4:	1d ff 4b ff 	j 80009e8a <usr_vsprintf+0xae>
80009ff8:	1d 00 a3 00 	j 8000a13e <usr_vsprintf+0x362>
80009ffc:	1d 00 a7 00 	j 8000a14a <usr_vsprintf+0x36e>
8000a000:	1d ff 45 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a004:	1d ff 43 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a008:	1d ff 41 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a00c:	1d ff 3f ff 	j 80009e8a <usr_vsprintf+0xae>
8000a010:	1d ff 3d ff 	j 80009e8a <usr_vsprintf+0xae>
8000a014:	1d ff 3b ff 	j 80009e8a <usr_vsprintf+0xae>
8000a018:	1d ff 39 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a01c:	1d ff 37 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a020:	1d ff 35 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a024:	1d ff 33 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a028:	1d ff 31 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a02c:	1d 00 63 00 	j 8000a0f2 <usr_vsprintf+0x316>
8000a030:	1d ff 2d ff 	j 80009e8a <usr_vsprintf+0xae>
8000a034:	1d ff 2b ff 	j 80009e8a <usr_vsprintf+0xae>
8000a038:	1d 00 52 00 	j 8000a0dc <usr_vsprintf+0x300>
8000a03c:	1d ff 27 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a040:	1d 00 85 00 	j 8000a14a <usr_vsprintf+0x36e>
8000a044:	1d ff 23 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a048:	1d ff 21 ff 	j 80009e8a <usr_vsprintf+0xae>
8000a04c:	1d 00 7f 00 	j 8000a14a <usr_vsprintf+0x36e>
		}
		else
		{
			if (c == '\n')
			{
				*dp++= '\r';
8000a050:	28 0b       	st.b [%a15]0,%d11
8000a052:	b0 1f       	add.a %a15,1
8000a054:	1d ff dc fe 	j 80009e0c <usr_vsprintf+0x30>
		{
			c = *fmt++;
			left_prec = right_prec = pad_on_right = 0;
			if (c == '-')
			{
				c = *fmt++;
8000a058:	79 cf 02 00 	ld.b %d15,[%a12]2
8000a05c:	d9 c2 03 00 	lea %a2,[%a12]3
				pad_on_right++;
			}
			if (c == '0')
8000a060:	8b 0f 23 32 	ne %d3,%d15,48
			c = *fmt++;
			left_prec = right_prec = pad_on_right = 0;
			if (c == '-')
			{
				c = *fmt++;
				pad_on_right++;
8000a064:	82 1a       	mov %d10,1
				zero_fill = TRUE;
				c = *fmt++;
			}
			else
			{
				zero_fill = FALSE;
8000a066:	82 0c       	mov %d12,0
			if (c == '-')
			{
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
8000a068:	df 03 ea fe 	jne %d3,0,80009e3c <usr_vsprintf+0x60>
			{
				zero_fill = TRUE;
				c = *fmt++;
8000a06c:	79 2f 00 00 	ld.b %d15,[%a2]0
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
			{
				zero_fill = TRUE;
8000a070:	82 1c       	mov %d12,1
				c = *fmt++;
8000a072:	b0 12       	add.a %a2,1
8000a074:	1d ff e4 fe 	j 80009e3c <usr_vsprintf+0x60>
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
			}
			if (c == '.')
			{
				c = *fmt++;
8000a078:	79 cf 00 00 	ld.b %d15,[%a12]0
8000a07c:	d9 c2 01 00 	lea %a2,[%a12]1
				zero_fill++;
				while (is_digit(c))
8000a080:	1b 0f fd 2f 	addi %d2,%d15,-48
8000a084:	8f f2 0f 21 	and %d2,%d2,255
				c = *fmt++;
			}
			if (c == '.')
			{
				c = *fmt++;
				zero_fill++;
8000a088:	c2 1c       	add %d12,1
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
			}
			if (c == '.')
			{
				c = *fmt++;
8000a08a:	40 2c       	mov.aa %a12,%a2
				zero_fill++;
				while (is_digit(c))
8000a08c:	ff a2 f1 fe 	jge.u %d2,10,80009e6e <usr_vsprintf+0x92>
				{
					right_prec = (right_prec * 10) + (c - '0');
					c = *fmt++;
8000a090:	79 2f 00 00 	ld.b %d15,[%a2]0
8000a094:	d9 2c 01 00 	lea %a12,[%a2]1
			}
			if (c == '.')
			{
				c = *fmt++;
				zero_fill++;
				while (is_digit(c))
8000a098:	1b 0f fd 3f 	addi %d3,%d15,-48
8000a09c:	8f f3 0f 31 	and %d3,%d3,255
				{
					right_prec = (right_prec * 10) + (c - '0');
					c = *fmt++;
8000a0a0:	40 c2       	mov.aa %a2,%a12
			}
			if (c == '.')
			{
				c = *fmt++;
				zero_fill++;
				while (is_digit(c))
8000a0a2:	bf a3 f7 ff 	jlt.u %d3,10,8000a090 <usr_vsprintf+0x2b4>
8000a0a6:	1d ff e4 fe 	j 80009e6e <usr_vsprintf+0x92>
8000a0aa:	da 20       	mov %d15,32
			}
			else
			{
				c = ' ';
			}
			if (!pad_on_right)
8000a0ac:	f6 af       	jnz %d10,8000a0ca <usr_vsprintf+0x2ee>
			{
				while (pad-- > 0)
8000a0ae:	1b f8 ff 5f 	addi %d5,%d8,-1
8000a0b2:	bf 18 8d 00 	jlt %d8,1,8000a1cc <usr_vsprintf+0x3f0>
8000a0b6:	80 f5       	mov.d %d5,%a15
8000a0b8:	01 f8 00 56 	addsc.a %a5,%a15,%d8,0
8000a0bc:	46 05       	not %d5
8000a0be:	01 55 00 56 	addsc.a %a5,%a5,%d5,0
				{
					*dp++ = c;
8000a0c2:	28 0f       	st.b [%a15]0,%d15
8000a0c4:	b0 1f       	add.a %a15,1
8000a0c6:	fc 5e       	loop %a5,8000a0c2 <usr_vsprintf+0x2e6>
8000a0c8:	82 f8       	mov %d8,-1
				}
			}
			if (sign != '\0')
8000a0ca:	76 33       	jz %d3,8000a0d0 <usr_vsprintf+0x2f4>
			{
				*dp++ = sign;
8000a0cc:	28 03       	st.b [%a15]0,%d3
8000a0ce:	b0 1f       	add.a %a15,1
			}
			while (length-- > 0)
8000a0d0:	ff 12 eb 7e 	jge %d2,1,80009ea6 <usr_vsprintf+0xca>
				{
					*dp++ = '\r';
				}
				*dp++ = c;
			}
			if (pad_on_right)
8000a0d4:	df 0a 92 7e 	jeq %d10,0,80009df8 <usr_vsprintf+0x1c>
8000a0d8:	1d ff 04 ff 	j 80009ee0 <usr_vsprintf+0x104>
							length = _cvt(val, buf, 16, "0123456789ABCDEF");
							break;
					}
					break;
				case 's' :
					cp = va_arg(ap, char *);
8000a0dc:	d4 6d       	ld.a %a13,[%a6]
8000a0de:	80 6f       	mov.d %d15,%a6
					length = strlen(cp);
8000a0e0:	40 d4       	mov.aa %a4,%a13
8000a0e2:	6d 00 55 21 	call 8000e38c <strlen>
							length = _cvt(val, buf, 16, "0123456789ABCDEF");
							break;
					}
					break;
				case 's' :
					cp = va_arg(ap, char *);
8000a0e6:	c2 4f       	add %d15,4
8000a0e8:	1b f2 ff 4f 	addi %d4,%d2,-1
8000a0ec:	60 f6       	mov.a %a6,%d15
					length = strlen(cp);
					break;
8000a0ee:	1d ff d4 fe 	j 80009e96 <usr_vsprintf+0xba>
					continue;
				case '%' : /* '%%' ==> output '%' */
					*dp++ = c;
					break;
				case 'p' :
					p = va_arg(ap, unsigned int);
8000a0f2:	4c 60       	ld.w %d15,[%a6]0
8000a0f4:	d9 67 04 00 	lea %a7,[%a6]4
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a0f8:	df 0f cc 80 	jne %d15,0,8000a290 <usr_vsprintf+0x4b4>
	{
		/* Special case */
		*cp++ = '0';
8000a0fc:	da 30       	mov %d15,48
8000a0fe:	e9 af 20 00 	st.b [%sp]32,%d15
8000a102:	d9 a4 21 00 	lea %a4,[%sp]33
8000a106:	01 4e 20 20 	sub.a %a2,%a14,%a4
8000a10a:	80 2f       	mov.d %d15,%a2
8000a10c:	40 43       	mov.aa %a3,%a4
8000a10e:	46 0f       	not %d15
8000a110:	60 f2       	mov.a %a2,%d15
8000a112:	40 a5       	mov.aa %a5,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000a114:	09 3f 7f f4 	ld.bu %d15,[+%a3]-1
8000a118:	2c 50       	st.b [%a5]0,%d15
8000a11a:	b0 15       	add.a %a5,1
8000a11c:	fc 2c       	loop %a2,8000a114 <usr_vsprintf+0x338>
8000a11e:	d9 42 ff ff 	lea %a2,[%a4]-1
8000a122:	01 32 20 20 	sub.a %a2,%a2,%a3
8000a126:	80 24       	mov.d %d4,%a2
8000a128:	01 34 20 40 	sub.a %a4,%a4,%a3
8000a12c:	30 a4       	add.a %a4,%sp
8000a12e:	1b 14 00 20 	addi %d2,%d4,1
		length++;
	}
	*buf = '\0';
8000a132:	82 0f       	mov %d15,0
8000a134:	2c 40       	st.b [%a4]0,%d15
					continue;
				case '%' : /* '%%' ==> output '%' */
					*dp++ = c;
					break;
				case 'p' :
					p = va_arg(ap, unsigned int);
8000a136:	40 76       	mov.aa %a6,%a7
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000a138:	40 ad       	mov.aa %a13,%sp
					*dp++ = c;
					break;
				case 'p' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789abcdef");
					break;
8000a13a:	1d ff ae fe 	j 80009e96 <usr_vsprintf+0xba>
				case 's' :
					cp = va_arg(ap, char *);
					length = strlen(cp);
					break;
				case 'c' :
					c = (char)va_arg(ap, long);
8000a13e:	4c 60       	ld.w %d15,[%a6]0
8000a140:	b0 46       	add.a %a6,4
8000a142:	28 0f       	st.b [%a15]0,%d15
					*dp++ = c;
8000a144:	b0 1f       	add.a %a15,1
					continue;
8000a146:	1d ff 59 fe 	j 80009df8 <usr_vsprintf+0x1c>
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
					switch (c)
8000a14a:	1b 8f fa ff 	addi %d15,%d15,-88
8000a14e:	8b 1f a2 32 	ge.u %d3,%d15,33
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000a152:	d9 64 04 00 	lea %a4,[%a6]4
8000a156:	54 62       	ld.w %d2,[%a6]
					switch (c)
8000a158:	df 03 3d 00 	jeq %d3,0,8000a1d2 <usr_vsprintf+0x3f6>
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000a15c:	40 46       	mov.aa %a6,%a4
					switch (c)
8000a15e:	82 f4       	mov %d4,-1
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
		length = 0;
8000a160:	82 02       	mov %d2,0
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000a162:	40 ad       	mov.aa %a13,%sp
8000a164:	1d ff 99 fe 	j 80009e96 <usr_vsprintf+0xba>
				case 'p' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789abcdef");
					break;
				case 'P' :
					p = va_arg(ap, unsigned int);
8000a168:	4c 60       	ld.w %d15,[%a6]0
8000a16a:	d9 64 04 00 	lea %a4,[%a6]4
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a16e:	ee 7b       	jnz %d15,8000a264 <usr_vsprintf+0x488>
	{
		/* Special case */
		*cp++ = '0';
8000a170:	da 30       	mov %d15,48
8000a172:	e9 af 20 00 	st.b [%sp]32,%d15
8000a176:	d9 a6 21 00 	lea %a6,[%sp]33
8000a17a:	01 6e 20 20 	sub.a %a2,%a14,%a6
8000a17e:	80 2f       	mov.d %d15,%a2
8000a180:	40 63       	mov.aa %a3,%a6
8000a182:	46 0f       	not %d15
8000a184:	60 f2       	mov.a %a2,%d15
8000a186:	40 a5       	mov.aa %a5,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000a188:	09 3f 7f f4 	ld.bu %d15,[+%a3]-1
8000a18c:	2c 50       	st.b [%a5]0,%d15
8000a18e:	b0 15       	add.a %a5,1
8000a190:	fc 2c       	loop %a2,8000a188 <usr_vsprintf+0x3ac>
8000a192:	d9 62 ff ff 	lea %a2,[%a6]-1
8000a196:	01 36 20 60 	sub.a %a6,%a6,%a3
8000a19a:	01 32 20 30 	sub.a %a3,%a2,%a3
8000a19e:	80 34       	mov.d %d4,%a3
8000a1a0:	30 a6       	add.a %a6,%sp
8000a1a2:	1b 14 00 20 	addi %d2,%d4,1
		length++;
	}
	*buf = '\0';
8000a1a6:	82 0f       	mov %d15,0
8000a1a8:	2c 60       	st.b [%a6]0,%d15
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000a1aa:	40 ad       	mov.aa %a13,%sp
				case 'p' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789abcdef");
					break;
				case 'P' :
					p = va_arg(ap, unsigned int);
8000a1ac:	40 46       	mov.aa %a6,%a4
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
8000a1ae:	1d ff 74 fe 	j 80009e96 <usr_vsprintf+0xba>
				case 'c' :
					c = (char)va_arg(ap, long);
					*dp++ = c;
					continue;
				case '%' : /* '%%' ==> output '%' */
					*dp++ = c;
8000a1b2:	da 25       	mov %d15,37
8000a1b4:	1d ff 6c fe 	j 80009e8c <usr_vsprintf+0xb0>
			while (length-- > 0)
			{
				c = *cp++;
				if (c == '\n')
				{
					*dp++ = '\r';
8000a1b8:	b0 13       	add.a %a3,1
8000a1ba:	28 0b       	st.b [%a15]0,%d11
8000a1bc:	1d ff 8b fe 	j 80009ed2 <usr_vsprintf+0xf6>
			}
			else
			{
				c = ' ';
			}
			if (!pad_on_right)
8000a1c0:	82 03       	mov %d3,0
8000a1c2:	da 30       	mov %d15,48
			{
				while (pad-- > 0)
8000a1c4:	1b f8 ff 5f 	addi %d5,%d8,-1
8000a1c8:	ff 18 77 7f 	jge %d8,1,8000a0b6 <usr_vsprintf+0x2da>
8000a1cc:	02 58       	mov %d8,%d5
8000a1ce:	1d ff 7e ff 	j 8000a0ca <usr_vsprintf+0x2ee>
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
					switch (c)
8000a1d2:	91 10 00 58 	movh.a %a5,32769
8000a1d6:	d9 55 20 7a 	lea %a5,[%a5]-24096 <8000a1e0 <usr_vsprintf+0x404>>
8000a1da:	90 52       	addsc.a %a2,%a5,%d15,2
8000a1dc:	dc 02       	ji %a2
8000a1de:	00 00       	nop 
8000a1e0:	1d 00 a6 00 	j 8000a32c <usr_vsprintf+0x550>
8000a1e4:	1d ff bc ff 	j 8000a15c <usr_vsprintf+0x380>
8000a1e8:	1d ff ba ff 	j 8000a15c <usr_vsprintf+0x380>
8000a1ec:	1d ff b8 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a1f0:	1d ff b6 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a1f4:	1d ff b4 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a1f8:	1d ff b2 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a1fc:	1d ff b0 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a200:	1d ff ae ff 	j 8000a15c <usr_vsprintf+0x380>
8000a204:	1d ff ac ff 	j 8000a15c <usr_vsprintf+0x380>
8000a208:	1d ff aa ff 	j 8000a15c <usr_vsprintf+0x380>
8000a20c:	1d ff a8 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a210:	1d 00 87 00 	j 8000a31e <usr_vsprintf+0x542>
8000a214:	1d ff a4 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a218:	1d ff a2 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a21c:	1d ff a0 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a220:	1d ff 9e ff 	j 8000a15c <usr_vsprintf+0x380>
8000a224:	1d ff 9c ff 	j 8000a15c <usr_vsprintf+0x380>
8000a228:	1d ff 9a ff 	j 8000a15c <usr_vsprintf+0x380>
8000a22c:	1d ff 98 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a230:	1d ff 96 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a234:	1d ff 94 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a238:	1d ff 92 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a23c:	1d ff 90 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a240:	1d ff 8e ff 	j 8000a15c <usr_vsprintf+0x380>
8000a244:	1d ff 8c ff 	j 8000a15c <usr_vsprintf+0x380>
8000a248:	1d ff 8a ff 	j 8000a15c <usr_vsprintf+0x380>
8000a24c:	1d ff 88 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a250:	1d ff 86 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a254:	1d 00 34 00 	j 8000a2bc <usr_vsprintf+0x4e0>
8000a258:	1d ff 82 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a25c:	1d ff 80 ff 	j 8000a15c <usr_vsprintf+0x380>
8000a260:	1d 00 92 00 	j 8000a384 <usr_vsprintf+0x5a8>
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a264:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a266:	91 00 00 58 	movh.a %a5,32768
8000a26a:	8f ff 00 21 	and %d2,%d15,15
8000a26e:	d9 55 54 40 	lea %a5,[%a5]1300 <80000514 <IfxScuCcu_aDefaultPllConfigSteps+0x40>>
8000a272:	01 52 00 36 	addsc.a %a3,%a5,%d2,0
8000a276:	d9 26 01 00 	lea %a6,[%a2]1
8000a27a:	14 32       	ld.bu %d2,[%a3]
			val /= radix;
8000a27c:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a27e:	34 22       	st.b [%a2],%d2
8000a280:	40 62       	mov.aa %a2,%a6
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000a282:	ee f2       	jnz %d15,8000a266 <usr_vsprintf+0x48a>
		{
			*cp++ = digits[val % radix];
			val /= radix;
		}
	}
	while (cp != temp)
8000a284:	7d e6 7b ff 	jne.a %a6,%a14,8000a17a <usr_vsprintf+0x39e>
8000a288:	82 f4       	mov %d4,-1
8000a28a:	82 02       	mov %d2,0
8000a28c:	40 a6       	mov.aa %a6,%sp
8000a28e:	3c 8c       	j 8000a1a6 <usr_vsprintf+0x3ca>
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a290:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a292:	91 00 00 48 	movh.a %a4,32768
8000a296:	8f ff 00 21 	and %d2,%d15,15
8000a29a:	d9 44 43 40 	lea %a4,[%a4]1283 <80000503 <IfxScuCcu_aDefaultPllConfigSteps+0x2f>>
8000a29e:	01 42 00 36 	addsc.a %a3,%a4,%d2,0
			val /= radix;
8000a2a2:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a2a4:	14 32       	ld.bu %d2,[%a3]
8000a2a6:	34 22       	st.b [%a2],%d2
8000a2a8:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000a2aa:	ee f4       	jnz %d15,8000a292 <usr_vsprintf+0x4b6>
		{
			*cp++ = digits[val % radix];
8000a2ac:	40 24       	mov.aa %a4,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000a2ae:	7d e2 2c ff 	jne.a %a2,%a14,8000a106 <usr_vsprintf+0x32a>
8000a2b2:	82 f4       	mov %d4,-1
8000a2b4:	82 02       	mov %d2,0
8000a2b6:	40 a4       	mov.aa %a4,%sp
8000a2b8:	1d ff 3d ff 	j 8000a132 <usr_vsprintf+0x356>
			}
			else
			{
				right_prec = left_prec;
			}
			sign = '\0';
8000a2bc:	82 03       	mov %d3,0
								sign = '-';
								val = -val;
							} // @suppress("No break at end of case")
							/* fall through */
						case 'u' :
							length = _cvt(val, buf, 10, "0123456789");
8000a2be:	02 2f       	mov %d15,%d2
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a2c0:	df 02 8e 80 	jne %d2,0,8000a3dc <usr_vsprintf+0x600>
	{
		/* Special case */
		*cp++ = '0';
8000a2c4:	da 30       	mov %d15,48
8000a2c6:	e9 af 20 00 	st.b [%sp]32,%d15
8000a2ca:	d9 a6 21 00 	lea %a6,[%sp]33
8000a2ce:	01 6e 20 20 	sub.a %a2,%a14,%a6
8000a2d2:	80 2f       	mov.d %d15,%a2
8000a2d4:	40 63       	mov.aa %a3,%a6
8000a2d6:	46 0f       	not %d15
8000a2d8:	60 f2       	mov.a %a2,%d15
8000a2da:	40 a5       	mov.aa %a5,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000a2dc:	09 3f 7f f4 	ld.bu %d15,[+%a3]-1
8000a2e0:	2c 50       	st.b [%a5]0,%d15
8000a2e2:	b0 15       	add.a %a5,1
8000a2e4:	fc 2c       	loop %a2,8000a2dc <usr_vsprintf+0x500>
8000a2e6:	d9 62 ff ff 	lea %a2,[%a6]-1
8000a2ea:	01 36 20 60 	sub.a %a6,%a6,%a3
8000a2ee:	01 32 20 30 	sub.a %a3,%a2,%a3
8000a2f2:	80 34       	mov.d %d4,%a3
8000a2f4:	30 a6       	add.a %a6,%sp
8000a2f6:	1b 14 00 20 	addi %d2,%d4,1
		length++;
	}
	*buf = '\0';
8000a2fa:	82 0f       	mov %d15,0
8000a2fc:	2c 60       	st.b [%a6]0,%d15
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
				default:
					*dp++ = '?';
			}
			pad = left_prec - length;
8000a2fe:	a2 28       	sub %d8,%d2
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000a300:	40 46       	mov.aa %a6,%a4
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000a302:	40 ad       	mov.aa %a13,%sp
					break;
				default:
					*dp++ = '?';
			}
			pad = left_prec - length;
			if (sign != '\0')
8000a304:	df 03 ca 7d 	jeq %d3,0,80009e98 <usr_vsprintf+0xbc>
			{
				pad--;
8000a308:	c2 f8       	add %d8,-1
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000a30a:	40 46       	mov.aa %a6,%a4
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000a30c:	40 ad       	mov.aa %a13,%sp
			pad = left_prec - length;
			if (sign != '\0')
			{
				pad--;
			}
			if (zero_fill)
8000a30e:	df 0c ce 7e 	jeq %d12,0,8000a0aa <usr_vsprintf+0x2ce>
			{
				c = '0';
				if (sign != '\0')
				{
					*dp++ = sign;
8000a312:	28 03       	st.b [%a15]0,%d3
8000a314:	40 46       	mov.aa %a6,%a4
8000a316:	b0 1f       	add.a %a15,1
8000a318:	40 ad       	mov.aa %a13,%sp
8000a31a:	1d ff c2 fd 	j 80009e9e <usr_vsprintf+0xc2>
			}
			else
			{
				right_prec = left_prec;
			}
			sign = '\0';
8000a31e:	82 03       	mov %d3,0
				case 'X' :
					val = va_arg(ap, long);
					switch (c)
					{
						case 'd' :
							if (val < 0)
8000a320:	ff 02 cf 7f 	jge %d2,0,8000a2be <usr_vsprintf+0x4e2>
							{
								sign = '-';
								val = -val;
8000a324:	32 52       	rsub %d2
					switch (c)
					{
						case 'd' :
							if (val < 0)
							{
								sign = '-';
8000a326:	3b d0 02 30 	mov %d3,45
8000a32a:	3c ca       	j 8000a2be <usr_vsprintf+0x4e2>
							break;
						case 'x' :
							length = _cvt(val, buf, 16, "0123456789abcdef");
							break;
						case 'X' :
							length = _cvt(val, buf, 16, "0123456789ABCDEF");
8000a32c:	02 2f       	mov %d15,%d2
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a32e:	df 02 7c 00 	jeq %d2,0,8000a426 <usr_vsprintf+0x64a>
8000a332:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a334:	91 00 00 58 	movh.a %a5,32768
8000a338:	8f ff 00 21 	and %d2,%d15,15
8000a33c:	d9 55 54 40 	lea %a5,[%a5]1300 <80000514 <IfxScuCcu_aDefaultPllConfigSteps+0x40>>
8000a340:	01 52 00 36 	addsc.a %a3,%a5,%d2,0
			val /= radix;
8000a344:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a346:	14 32       	ld.bu %d2,[%a3]
8000a348:	34 22       	st.b [%a2],%d2
8000a34a:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000a34c:	ee f4       	jnz %d15,8000a334 <usr_vsprintf+0x558>
		{
			*cp++ = digits[val % radix];
8000a34e:	40 26       	mov.aa %a6,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000a350:	7d e2 9c 7f 	jeq.a %a2,%a14,8000a288 <usr_vsprintf+0x4ac>
	int length = 0;

	if (val == 0)
	{
		/* Special case */
		*cp++ = '0';
8000a354:	01 6e 20 50 	sub.a %a5,%a14,%a6
8000a358:	80 5f       	mov.d %d15,%a5
8000a35a:	40 62       	mov.aa %a2,%a6
8000a35c:	46 0f       	not %d15
8000a35e:	60 f5       	mov.a %a5,%d15
8000a360:	40 a3       	mov.aa %a3,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000a362:	09 2f 7f f4 	ld.bu %d15,[+%a2]-1
8000a366:	2c 30       	st.b [%a3]0,%d15
8000a368:	b0 13       	add.a %a3,1
8000a36a:	fc 5c       	loop %a5,8000a362 <usr_vsprintf+0x586>
8000a36c:	d9 63 ff ff 	lea %a3,[%a6]-1
8000a370:	01 23 20 30 	sub.a %a3,%a3,%a2
8000a374:	80 34       	mov.d %d4,%a3
8000a376:	01 26 20 60 	sub.a %a6,%a6,%a2
8000a37a:	30 a6       	add.a %a6,%sp
8000a37c:	1b 14 00 20 	addi %d2,%d4,1
8000a380:	1d ff 13 ff 	j 8000a1a6 <usr_vsprintf+0x3ca>
							/* fall through */
						case 'u' :
							length = _cvt(val, buf, 10, "0123456789");
							break;
						case 'x' :
							length = _cvt(val, buf, 16, "0123456789abcdef");
8000a384:	02 2f       	mov %d15,%d2
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a386:	df 02 4a 00 	jeq %d2,0,8000a41a <usr_vsprintf+0x63e>
8000a38a:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a38c:	91 00 00 58 	movh.a %a5,32768
8000a390:	8f ff 00 21 	and %d2,%d15,15
8000a394:	d9 55 43 40 	lea %a5,[%a5]1283 <80000503 <IfxScuCcu_aDefaultPllConfigSteps+0x2f>>
8000a398:	01 52 00 36 	addsc.a %a3,%a5,%d2,0
			val /= radix;
8000a39c:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a39e:	14 32       	ld.bu %d2,[%a3]
8000a3a0:	34 22       	st.b [%a2],%d2
8000a3a2:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000a3a4:	ee f4       	jnz %d15,8000a38c <usr_vsprintf+0x5b0>
		{
			*cp++ = digits[val % radix];
8000a3a6:	40 26       	mov.aa %a6,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000a3a8:	7d e2 70 7f 	jeq.a %a2,%a14,8000a288 <usr_vsprintf+0x4ac>
	int length = 0;

	if (val == 0)
	{
		/* Special case */
		*cp++ = '0';
8000a3ac:	01 6e 20 50 	sub.a %a5,%a14,%a6
8000a3b0:	80 5f       	mov.d %d15,%a5
8000a3b2:	40 62       	mov.aa %a2,%a6
8000a3b4:	46 0f       	not %d15
8000a3b6:	60 f5       	mov.a %a5,%d15
8000a3b8:	40 a3       	mov.aa %a3,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000a3ba:	09 2f 7f f4 	ld.bu %d15,[+%a2]-1
8000a3be:	2c 30       	st.b [%a3]0,%d15
8000a3c0:	b0 13       	add.a %a3,1
8000a3c2:	fc 5c       	loop %a5,8000a3ba <usr_vsprintf+0x5de>
8000a3c4:	d9 63 ff ff 	lea %a3,[%a6]-1
8000a3c8:	01 26 20 60 	sub.a %a6,%a6,%a2
8000a3cc:	01 23 20 20 	sub.a %a2,%a3,%a2
8000a3d0:	80 24       	mov.d %d4,%a2
8000a3d2:	30 a6       	add.a %a6,%sp
8000a3d4:	1b 14 00 20 	addi %d2,%d4,1
8000a3d8:	1d ff e7 fe 	j 8000a1a6 <usr_vsprintf+0x3ca>
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a3dc:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a3de:	7b d0 cc 4c 	movh %d4,52429
8000a3e2:	1b d4 cc 4c 	addi %d4,%d4,-13107
8000a3e6:	73 4f 68 40 	mul.u %e4,%d15,%d4
8000a3ea:	91 00 00 58 	movh.a %a5,32768
8000a3ee:	d9 55 78 30 	lea %a5,[%a5]1272 <800004f8 <IfxScuCcu_aDefaultPllConfigSteps+0x24>>
8000a3f2:	8f d5 1f 20 	sh %d2,%d5,-3
8000a3f6:	53 a2 20 40 	mul %d4,%d2,10
8000a3fa:	a2 4f       	sub %d15,%d4
8000a3fc:	10 53       	addsc.a %a3,%a5,%d15,0
8000a3fe:	0c 30       	ld.bu %d15,[%a3]0
8000a400:	2c 20       	st.b [%a2]0,%d15
			val /= radix;
8000a402:	02 2f       	mov %d15,%d2
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000a404:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000a406:	df 02 ec ff 	jne %d2,0,8000a3de <usr_vsprintf+0x602>
		{
			*cp++ = digits[val % radix];
8000a40a:	40 26       	mov.aa %a6,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000a40c:	7d e2 61 ff 	jne.a %a2,%a14,8000a2ce <usr_vsprintf+0x4f2>
8000a410:	82 f4       	mov %d4,-1
8000a412:	82 02       	mov %d2,0
8000a414:	40 a6       	mov.aa %a6,%sp
8000a416:	1d ff 72 ff 	j 8000a2fa <usr_vsprintf+0x51e>
	int length = 0;

	if (val == 0)
	{
		/* Special case */
		*cp++ = '0';
8000a41a:	da 30       	mov %d15,48
8000a41c:	e9 af 20 00 	st.b [%sp]32,%d15
8000a420:	d9 a6 21 00 	lea %a6,[%sp]33
8000a424:	3c c4       	j 8000a3ac <usr_vsprintf+0x5d0>
8000a426:	da 30       	mov %d15,48
8000a428:	e9 af 20 00 	st.b [%sp]32,%d15
8000a42c:	d9 a6 21 00 	lea %a6,[%sp]33
8000a430:	3c 92       	j 8000a354 <usr_vsprintf+0x578>

8000a432 <usr_sprintf>:
{
	int ret;
	va_list ap;

	va_start(ap, fmt);
	ret = usr_vsprintf(buf, fmt, ap);
8000a432:	40 a6       	mov.aa %a6,%sp
	va_end(ap);

	return ret;
}
8000a434:	1d ff d4 fc 	j 80009ddc <usr_vsprintf>

8000a438 <my_puts>:
#define BUFSIZE		128
#define KB_BS '\x7F'
#define KB_CR '\r'

void my_puts(const char *str)
{
8000a438:	20 88       	sub.a %sp,136
	char buffer[BUFSIZE];
	char *ptr;

	usr_sprintf(buffer, "%s\r\n", str);
8000a43a:	91 00 00 58 	movh.a %a5,32768
8000a43e:	f4 a4       	st.a [%sp],%a4
8000a440:	d9 55 65 40 	lea %a5,[%a5]1317 <80000525 <IfxScuCcu_aDefaultPllConfigSteps+0x51>>
8000a444:	d9 a4 08 00 	lea %a4,[%sp]8 <80000525 <IfxScuCcu_aDefaultPllConfigSteps+0x51>>
8000a448:	6d ff f5 ff 	call 8000a432 <usr_sprintf>

	for (ptr = buffer; *ptr; ++ptr)
8000a44c:	79 af 08 00 	ld.b %d15,[%sp]8
8000a450:	d9 af 08 00 	lea %a15,[%sp]8
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));

	TX_CLEAR(MODULE_ASCLIN3);
8000a454:	7b 00 00 38 	movh %d3,32768
	char buffer[BUFSIZE];
	char *ptr;

	usr_sprintf(buffer, "%s\r\n", str);

	for (ptr = buffer; *ptr; ++ptr)
8000a458:	6e 0e       	jz %d15,8000a474 <my_puts+0x3c>
		_out_uart3((const unsigned char) *ptr);
8000a45a:	8f ff 0f 21 	and %d2,%d15,255

/* Send character CHR via the serial line */
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));
8000a45e:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a462:	ff 0f fe 7f 	jge %d15,0,8000a45e <my_puts+0x26>

	TX_CLEAR(MODULE_ASCLIN3);
8000a466:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN3, chr);
8000a46a:	a5 f2 84 50 	st.w f0000944 <_SMALL_DATA4_+0x3fff8944>,%d2
	char buffer[BUFSIZE];
	char *ptr;

	usr_sprintf(buffer, "%s\r\n", str);

	for (ptr = buffer; *ptr; ++ptr)
8000a46e:	09 ff 01 04 	ld.b %d15,[+%a15]1
8000a472:	ee f4       	jnz %d15,8000a45a <my_puts+0x22>
8000a474:	00 90       	ret 

8000a476 <my_printf>:
		_out_uart3((const unsigned char) *ptr);
}

void my_printf(const char *fmt, ...)
{
8000a476:	d9 aa c0 cf 	lea %sp,[%sp]-256
8000a47a:	40 45       	mov.aa %a5,%a4
	char buffer2[BUFSIZE]; // add \r before \n
	char *ptr;
	va_list ap;

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
8000a47c:	d9 a6 00 40 	lea %a6,[%sp]256
8000a480:	40 a4       	mov.aa %a4,%sp
8000a482:	6d 00 2f 20 	call 8000e4e0 <vsprintf>
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000a486:	79 af 00 00 	ld.b %d15,[%sp]0
	va_list ap;

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
8000a48a:	a0 0f       	mov.a %a15,0
	for (int i = 0; buffer[i]; i++) {
8000a48c:	6e 28       	jz %d15,8000a4dc <my_printf+0x66>
8000a48e:	a0 02       	mov.a %a2,0
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
8000a490:	3b d0 00 30 	mov %d3,13
8000a494:	3c 0c       	j 8000a4ac <my_printf+0x36>
			buffer2[j++] = buffer[i];
		} else {
			buffer2[j++] = buffer[i];
8000a496:	d9 a3 00 20 	lea %a3,[%sp]128
8000a49a:	30 f3       	add.a %a3,%a15
8000a49c:	2c 30       	st.b [%a3]0,%d15

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000a49e:	b0 12       	add.a %a2,1
8000a4a0:	40 a3       	mov.aa %a3,%sp
8000a4a2:	30 23       	add.a %a3,%a2
8000a4a4:	79 3f 00 00 	ld.b %d15,[%a3]0
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
			buffer2[j++] = buffer[i];
		} else {
			buffer2[j++] = buffer[i];
8000a4a8:	b0 1f       	add.a %a15,1

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000a4aa:	6e 19       	jz %d15,8000a4dc <my_printf+0x66>
		if (buffer[i] == '\n') {
8000a4ac:	8b af 20 22 	ne %d2,%d15,10
8000a4b0:	df 02 f3 ff 	jne %d2,0,8000a496 <my_printf+0x20>
			buffer2[j++] = '\r';
8000a4b4:	d9 a3 00 20 	lea %a3,[%sp]128
8000a4b8:	30 f3       	add.a %a3,%a15
8000a4ba:	34 33       	st.b [%a3],%d3
8000a4bc:	d9 f4 01 00 	lea %a4,[%a15]1
			buffer2[j++] = buffer[i];
8000a4c0:	d9 a3 00 20 	lea %a3,[%sp]128
8000a4c4:	30 34       	add.a %a4,%a3
8000a4c6:	40 a3       	mov.aa %a3,%sp
8000a4c8:	30 23       	add.a %a3,%a2
8000a4ca:	0c 30       	ld.bu %d15,[%a3]0

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000a4cc:	b0 12       	add.a %a2,1
8000a4ce:	40 a3       	mov.aa %a3,%sp
8000a4d0:	30 23       	add.a %a3,%a2
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
			buffer2[j++] = buffer[i];
8000a4d2:	2c 40       	st.b [%a4]0,%d15

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000a4d4:	79 3f 00 00 	ld.b %d15,[%a3]0
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
			buffer2[j++] = buffer[i];
8000a4d8:	b0 2f       	add.a %a15,2

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000a4da:	ee e9       	jnz %d15,8000a4ac <my_printf+0x36>
			buffer2[j++] = buffer[i];
		} else {
			buffer2[j++] = buffer[i];
		}
	}
	buffer2[j] = '\0';
8000a4dc:	d9 a2 00 20 	lea %a2,[%sp]128
8000a4e0:	30 2f       	add.a %a15,%a2
8000a4e2:	82 0f       	mov %d15,0
8000a4e4:	28 0f       	st.b [%a15]0,%d15

	for (ptr = buffer2; *ptr; ++ptr)
8000a4e6:	79 af 00 20 	ld.b %d15,[%sp]128
8000a4ea:	40 2f       	mov.aa %a15,%a2
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));

	TX_CLEAR(MODULE_ASCLIN3);
8000a4ec:	7b 00 00 38 	movh %d3,32768
			buffer2[j++] = buffer[i];
		}
	}
	buffer2[j] = '\0';

	for (ptr = buffer2; *ptr; ++ptr)
8000a4f0:	6e 0e       	jz %d15,8000a50c <my_printf+0x96>
		_out_uart3((const unsigned char) *ptr);
8000a4f2:	8f ff 0f 21 	and %d2,%d15,255

/* Send character CHR via the serial line */
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));
8000a4f6:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a4fa:	ff 0f fe 7f 	jge %d15,0,8000a4f6 <my_printf+0x80>

	TX_CLEAR(MODULE_ASCLIN3);
8000a4fe:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN3, chr);
8000a502:	a5 f2 84 50 	st.w f0000944 <_SMALL_DATA4_+0x3fff8944>,%d2
			buffer2[j++] = buffer[i];
		}
	}
	buffer2[j] = '\0';

	for (ptr = buffer2; *ptr; ++ptr)
8000a506:	09 ff 01 04 	ld.b %d15,[+%a15]1
8000a50a:	ee f4       	jnz %d15,8000a4f2 <my_printf+0x7c>
8000a50c:	00 90       	ret 

8000a50e <my_scanf>:
		_out_uart3((const unsigned char) *ptr);
}

void my_scanf(const char *fmt, ...)
{
8000a50e:	d9 aa b8 ff 	lea %sp,[%sp]-1032
	char *pstr, *pidx;
	va_list ap;
	va_start(ap, fmt);

	idx = 0;
	memset(buf, 0, 512);
8000a512:	d9 ac 08 00 	lea %a12,[%sp]8
8000a516:	40 c2       	mov.aa %a2,%a12
8000a518:	91 00 00 d8 	movh.a %a13,32768
	for (ptr = buffer2; *ptr; ++ptr)
		_out_uart3((const unsigned char) *ptr);
}

void my_scanf(const char *fmt, ...)
{
8000a51c:	40 4f       	mov.aa %a15,%a4
	char c = 0, buf[512];
	int idx, i;
	char *pstr, *pidx;
	va_list ap;
	va_start(ap, fmt);
8000a51e:	d9 ae 48 00 	lea %a14,[%sp]1032

	idx = 0;
	memset(buf, 0, 512);
8000a522:	d2 02       	mov %e2,0
8000a524:	c5 03 3f 00 	lea %a3,3f <_.+0x3e>
8000a528:	89 22 48 01 	st.d [%a2+]8,%e2
8000a52c:	fc 3e       	loop %a3,8000a528 <my_scanf+0x1a>
	int idx, i;
	char *pstr, *pidx;
	va_list ap;
	va_start(ap, fmt);

	idx = 0;
8000a52e:	82 0a       	mov %d10,0
8000a530:	d9 dd 6a 40 	lea %a13,[%a13]1322 <8000052a <IfxScuCcu_aDefaultPllConfigSteps+0x56>>

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000a534:	7b 00 00 91 	movh %d9,4096
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000a538:	7b 50 40 80 	movh %d8,1029
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
8000a53c:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a540:	ef cf fe 7f 	jz.t %d15,28,8000a53c <my_scanf+0x2e>
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
8000a544:	85 f2 88 50 	ld.w %d2,f0000948 <_SMALL_DATA4_+0x3fff8948>
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000a548:	a5 f9 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d9
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000a54c:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a550:	26 8f       	and %d15,%d8
8000a552:	ee 14       	jnz %d15,8000a57a <my_scanf+0x6c>

	idx = 0;
	memset(buf, 0, 512);
	while (c != '\r')
	{
		c = _in_uart3();
8000a554:	37 02 48 20 	extr %d2,%d2,0,8
		if (c == KB_BS)
8000a558:	8b f2 07 32 	eq %d3,%d2,127
8000a55c:	df 03 12 80 	jne %d3,0,8000a580 <my_scanf+0x72>
			if (idx != 0) { buf[idx--] = 0; }
			else { continue; }
		}
		else
		{
			if (c == KB_CR) { buf[idx++] = '\0'; }
8000a560:	8b d2 20 32 	ne %d3,%d2,13
8000a564:	01 ca 00 26 	addsc.a %a2,%a12,%d10,0
8000a568:	df 03 13 00 	jeq %d3,0,8000a58e <my_scanf+0x80>
			else { buf[idx++] = c; }
8000a56c:	34 22       	st.b [%a2],%d2
8000a56e:	c2 1a       	add %d10,1
		}
		my_printf("%c", c);
8000a570:	74 a2       	st.w [%sp],%d2
8000a572:	40 d4       	mov.aa %a4,%a13
8000a574:	6d ff 81 ff 	call 8000a476 <my_printf>
8000a578:	3c e2       	j 8000a53c <my_scanf+0x2e>
		RX_CLEAR(MODULE_ASCLIN3);
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
		{
			/* reset error flags */
			RESET_ERROR(MODULE_ASCLIN3);
8000a57a:	a5 f8 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d8
8000a57e:	3c df       	j 8000a53c <my_scanf+0x2e>
	while (c != '\r')
	{
		c = _in_uart3();
		if (c == KB_BS)
		{
			if (idx != 0) { buf[idx--] = 0; }
8000a580:	df 0a de 7f 	jeq %d10,0,8000a53c <my_scanf+0x2e>
8000a584:	01 ca 00 26 	addsc.a %a2,%a12,%d10,0
8000a588:	c2 fa       	add %d10,-1
8000a58a:	2c 20       	st.b [%a2]0,%d15
8000a58c:	3c f2       	j 8000a570 <my_scanf+0x62>
			else { continue; }
		}
		else
		{
			if (c == KB_CR) { buf[idx++] = '\0'; }
8000a58e:	2c 20       	st.b [%a2]0,%d15
			else { buf[idx++] = c; }
		}
		my_printf("%c", c);
8000a590:	40 d4       	mov.aa %a4,%a13
8000a592:	74 a2       	st.w [%sp],%d2
8000a594:	6d ff 71 ff 	call 8000a476 <my_printf>
	}
	my_printf("\r\n");
8000a598:	91 00 00 48 	movh.a %a4,32768
8000a59c:	d9 44 6d 40 	lea %a4,[%a4]1325 <8000052d <IfxScuCcu_aDefaultPllConfigSteps+0x59>>
8000a5a0:	6d ff 6b ff 	call 8000a476 <my_printf>
					pidx = strchr(buf, ' ');
					if (pidx != NULL) { *pidx = '\0'; }
					for (i = 0; ; i++)
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
8000a5a4:	82 08       	mov %d8,0
	int i, start_idx;
	char buf[512];

	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
8000a5a6:	d9 ad 08 80 	lea %a13,[%sp]520
		}
		my_printf("%c", c);
	}
	my_printf("\r\n");

	while ((c = *fmt++) != 0)
8000a5aa:	3c 05       	j 8000a5b4 <my_scanf+0xa6>
	{
		if (c == '%')
8000a5ac:	8b 5f 22 f2 	ne %d15,%d15,37
8000a5b0:	6e 08       	jz %d15,8000a5c0 <my_scanf+0xb2>
		}
		my_printf("%c", c);
	}
	my_printf("\r\n");

	while ((c = *fmt++) != 0)
8000a5b2:	40 2f       	mov.aa %a15,%a2
8000a5b4:	79 ff 00 00 	ld.b %d15,[%a15]0
8000a5b8:	d9 f2 01 00 	lea %a2,[%a15]1
8000a5bc:	ee f8       	jnz %d15,8000a5ac <my_scanf+0x9e>
8000a5be:	00 90       	ret 
	{
		if (c == '%')
		{
			c = *fmt++;
			switch (c)
8000a5c0:	79 ff 01 00 	ld.b %d15,[%a15]1

	while ((c = *fmt++) != 0)
	{
		if (c == '%')
		{
			c = *fmt++;
8000a5c4:	80 f9       	mov.d %d9,%a15
			switch (c)
8000a5c6:	8b 4f 06 22 	eq %d2,%d15,100

	while ((c = *fmt++) != 0)
	{
		if (c == '%')
		{
			c = *fmt++;
8000a5ca:	c2 29       	add %d9,2
			switch (c)
8000a5cc:	df 02 57 80 	jne %d2,0,8000a67a <my_scanf+0x16c>
8000a5d0:	8b 3f 07 22 	eq %d2,%d15,115
8000a5d4:	df 02 34 80 	jne %d2,0,8000a63c <my_scanf+0x12e>
8000a5d8:	8b 3f 06 f2 	eq %d15,%d15,99
8000a5dc:	ee 48       	jnz %d15,8000a66c <my_scanf+0x15e>
void remove_null(char *s)
{
	int i, start_idx;
	char buf[512];

	start_idx = 0;
8000a5de:	a0 0f       	mov.a %a15,0
	while (*(s + start_idx++) == '\0');
8000a5e0:	b0 1f       	add.a %a15,1
8000a5e2:	d9 a2 07 00 	lea %a2,[%sp]7
8000a5e6:	30 f2       	add.a %a2,%a15
8000a5e8:	79 2f 00 00 	ld.b %d15,[%a2]0
8000a5ec:	6e fa       	jz %d15,8000a5e0 <my_scanf+0xd2>
	memset(buf, 0, 512);
8000a5ee:	40 d2       	mov.aa %a2,%a13
8000a5f0:	d2 02       	mov %e2,0
8000a5f2:	c5 03 3f 00 	lea %a3,3f <_.+0x3e>
8000a5f6:	89 22 48 01 	st.d [%a2+]8,%e2
8000a5fa:	fc 3e       	loop %a3,8000a5f6 <my_scanf+0xe8>
	strcpy(buf, (s + (start_idx - 1)));
8000a5fc:	b0 ff       	add.a %a15,-1
8000a5fe:	40 d2       	mov.aa %a2,%a13
8000a600:	30 cf       	add.a %a15,%a12
8000a602:	04 ff       	ld.bu %d15,[%a15+]
8000a604:	24 2f       	st.b [%a2+],%d15
8000a606:	ee fe       	jnz %d15,8000a602 <my_scanf+0xf4>

	memset(s, 0, 512);
8000a608:	40 c2       	mov.aa %a2,%a12
	i = 0;
	while (buf[i] != '\0')
8000a60a:	79 af 08 80 	ld.b %d15,[%sp]520
	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
8000a60e:	d2 02       	mov %e2,0
8000a610:	c5 03 3f 00 	lea %a3,3f <_.+0x3e>
8000a614:	89 22 48 01 	st.d [%a2+]8,%e2
8000a618:	fc 3e       	loop %a3,8000a614 <my_scanf+0x106>
	i = 0;
	while (buf[i] != '\0')
8000a61a:	40 cf       	mov.aa %a15,%a12
8000a61c:	6e 0d       	jz %d15,8000a636 <my_scanf+0x128>
8000a61e:	82 02       	mov %d2,0
	{
		*(s + i) = buf[i];
8000a620:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
		++i;
8000a624:	c2 12       	add %d2,1

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
	{
		*(s + i) = buf[i];
8000a626:	28 0f       	st.b [%a15]0,%d15
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
8000a628:	01 d2 00 f6 	addsc.a %a15,%a13,%d2,0
8000a62c:	79 ff 00 00 	ld.b %d15,[%a15]0
8000a630:	ee f8       	jnz %d15,8000a620 <my_scanf+0x112>
8000a632:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
	{
		*(s + i) = buf[i];
		++i;
	}
	*(s + i) = '\0';
8000a636:	28 08       	st.b [%a15]0,%d8

	while ((c = *fmt++) != 0)
	{
		if (c == '%')
		{
			c = *fmt++;
8000a638:	60 9f       	mov.a %a15,%d9
8000a63a:	3c bd       	j 8000a5b4 <my_scanf+0xa6>
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
8000a63c:	cc e0       	ld.a %a15,[%a14]0
					for (i = 0; buf[i] != '\0'; i++)
8000a63e:	79 cf 00 00 	ld.b %d15,[%a12]0
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
8000a642:	d9 e3 04 00 	lea %a3,[%a14]4
8000a646:	40 f2       	mov.aa %a2,%a15
					for (i = 0; buf[i] != '\0'; i++)
8000a648:	6e 0f       	jz %d15,8000a666 <my_scanf+0x158>
8000a64a:	82 02       	mov %d2,0
					{
						*pstr++ = buf[i];
8000a64c:	28 0f       	st.b [%a15]0,%d15
8000a64e:	d9 f2 01 00 	lea %a2,[%a15]1
						buf[i] = '\0';
8000a652:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
					for (i = 0; buf[i] != '\0'; i++)
8000a656:	c2 12       	add %d2,1
					{
						*pstr++ = buf[i];
						buf[i] = '\0';
8000a658:	28 08       	st.b [%a15]0,%d8
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
					for (i = 0; buf[i] != '\0'; i++)
8000a65a:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
8000a65e:	79 ff 00 00 	ld.b %d15,[%a15]0
					{
						*pstr++ = buf[i];
8000a662:	40 2f       	mov.aa %a15,%a2
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
					for (i = 0; buf[i] != '\0'; i++)
8000a664:	ee f4       	jnz %d15,8000a64c <my_scanf+0x13e>
					{
						*pstr++ = buf[i];
						buf[i] = '\0';
					}
					*pstr = '\0';
8000a666:	34 28       	st.b [%a2],%d8
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
8000a668:	40 3e       	mov.aa %a14,%a3
					{
						*pstr++ = buf[i];
						buf[i] = '\0';
					}
					*pstr = '\0';
					break;
8000a66a:	3c ba       	j 8000a5de <my_scanf+0xd0>
		{
			c = *fmt++;
			switch (c)
			{
				case 'c':
					*va_arg(ap, char *) = buf[0];
8000a66c:	cc e0       	ld.a %a15,[%a14]0
8000a66e:	79 cf 00 00 	ld.b %d15,[%a12]0
8000a672:	b0 4e       	add.a %a14,4
8000a674:	28 0f       	st.b [%a15]0,%d15
					buf[0] = '\0';
8000a676:	34 c8       	st.b [%a12],%d8
					break;
8000a678:	3c b3       	j 8000a5de <my_scanf+0xd0>
				case 'd':
					*va_arg(ap, int *) = atoi(buf);
8000a67a:	cc e0       	ld.a %a15,[%a14]0
8000a67c:	40 c4       	mov.aa %a4,%a12
8000a67e:	b0 4e       	add.a %a14,4
8000a680:	6d 00 73 1e 	call 8000e366 <atoi>
					pidx = strchr(buf, ' ');
8000a684:	40 c4       	mov.aa %a4,%a12
				case 'c':
					*va_arg(ap, char *) = buf[0];
					buf[0] = '\0';
					break;
				case 'd':
					*va_arg(ap, int *) = atoi(buf);
8000a686:	68 02       	st.w [%a15]0,%d2
					pidx = strchr(buf, ' ');
8000a688:	3b 00 02 40 	mov %d4,32
8000a68c:	6d 00 72 1e 	call 8000e370 <strchr>
					if (pidx != NULL) { *pidx = '\0'; }
8000a690:	bc 22       	jz.a %a2,8000a694 <my_scanf+0x186>
8000a692:	34 28       	st.b [%a2],%d8
					for (i = 0; ; i++)
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
8000a694:	79 cf 00 00 	ld.b %d15,[%a12]0
8000a698:	82 02       	mov %d2,0
8000a69a:	8f 0f c2 f1 	andn %d15,%d15,32
8000a69e:	6e 0c       	jz %d15,8000a6b6 <my_scanf+0x1a8>
						buf[i] = '\0';
8000a6a0:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
					break;
				case 'd':
					*va_arg(ap, int *) = atoi(buf);
					pidx = strchr(buf, ' ');
					if (pidx != NULL) { *pidx = '\0'; }
					for (i = 0; ; i++)
8000a6a4:	c2 12       	add %d2,1
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
8000a6a6:	28 08       	st.b [%a15]0,%d8
					*va_arg(ap, int *) = atoi(buf);
					pidx = strchr(buf, ' ');
					if (pidx != NULL) { *pidx = '\0'; }
					for (i = 0; ; i++)
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
8000a6a8:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
8000a6ac:	79 ff 00 00 	ld.b %d15,[%a15]0
8000a6b0:	8f 0f c2 f1 	andn %d15,%d15,32
8000a6b4:	ee f6       	jnz %d15,8000a6a0 <my_scanf+0x192>
8000a6b6:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
8000a6ba:	28 08       	st.b [%a15]0,%d8
						buf[i] = '\0';
					}
					break;
8000a6bc:	3c 91       	j 8000a5de <my_scanf+0xd0>

8000a6be <remove_null>:
	}
	va_end(ap);
}

void remove_null(char *s)
{
8000a6be:	d9 aa c0 8f 	lea %sp,[%sp]-512
	int i, start_idx;
	char buf[512];

	start_idx = 0;
8000a6c2:	82 02       	mov %d2,0
	while (*(s + start_idx++) == '\0');
8000a6c4:	c2 12       	add %d2,1
8000a6c6:	01 42 00 f6 	addsc.a %a15,%a4,%d2,0
8000a6ca:	79 ff ff ff 	ld.b %d15,[%a15]-1
8000a6ce:	6e fb       	jz %d15,8000a6c4 <remove_null+0x6>
	memset(buf, 0, 512);
8000a6d0:	40 a3       	mov.aa %a3,%sp
8000a6d2:	d2 04       	mov %e4,0
8000a6d4:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
8000a6d8:	89 34 48 01 	st.d [%a3+]8,%e4
8000a6dc:	fc fe       	loop %a15,8000a6d8 <remove_null+0x1a>
	strcpy(buf, (s + (start_idx - 1)));
8000a6de:	c2 f2       	add %d2,-1
8000a6e0:	01 42 00 36 	addsc.a %a3,%a4,%d2,0
	int i, start_idx;
	char buf[512];

	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
8000a6e4:	40 a2       	mov.aa %a2,%sp
	strcpy(buf, (s + (start_idx - 1)));
8000a6e6:	40 af       	mov.aa %a15,%sp
8000a6e8:	04 3f       	ld.bu %d15,[%a3+]
8000a6ea:	24 ff       	st.b [%a15+],%d15
8000a6ec:	ee fe       	jnz %d15,8000a6e8 <remove_null+0x2a>

	memset(s, 0, 512);
8000a6ee:	40 43       	mov.aa %a3,%a4
	i = 0;
	while (buf[i] != '\0')
8000a6f0:	79 af 00 00 	ld.b %d15,[%sp]0
	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
8000a6f4:	82 04       	mov %d4,0
8000a6f6:	c5 0f 3f 70 	lea %a15,1ff <_.+0x1fe>
8000a6fa:	24 34       	st.b [%a3+],%d4
8000a6fc:	fc ff       	loop %a15,8000a6fa <remove_null+0x3c>
	i = 0;
	while (buf[i] != '\0')
8000a6fe:	82 02       	mov %d2,0
8000a700:	6e 0a       	jz %d15,8000a714 <remove_null+0x56>
	{
		*(s + i) = buf[i];
8000a702:	01 42 00 f6 	addsc.a %a15,%a4,%d2,0
		++i;
8000a706:	c2 12       	add %d2,1

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
	{
		*(s + i) = buf[i];
8000a708:	28 0f       	st.b [%a15]0,%d15
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
8000a70a:	01 22 00 f6 	addsc.a %a15,%a2,%d2,0
8000a70e:	79 ff 00 00 	ld.b %d15,[%a15]0
8000a712:	ee f8       	jnz %d15,8000a702 <remove_null+0x44>
	{
		*(s + i) = buf[i];
		++i;
	}
	*(s + i) = '\0';
8000a714:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8000a718:	82 0f       	mov %d15,0
8000a71a:	2c 40       	st.b [%a4]0,%d15
8000a71c:	00 90       	ret 

8000a71e <_init_uart1>:
void _init_uart1(void)
{
	unsigned int numerator = 2304;
	unsigned int denominator = 3125;
	/* Set TXD/P15.0 to "output" and "high" */
	MODULE_P15.IOCR0.B.PC0 = 0b10010;
8000a71e:	91 40 00 ff 	movh.a %a15,61444
8000a722:	d9 ff 40 4b 	lea %a15,[%a15]-19200 <f003b500 <_SMALL_DATA4_+0x40033500>>
8000a726:	4c f4       	ld.w %d15,[%a15]16
8000a728:	8f 8f cf f1 	andn %d15,%d15,248
8000a72c:	96 90       	or %d15,144
8000a72e:	68 4f       	st.w [%a15]16,%d15
	P15_OMR.B.PS0 = 1;
8000a730:	91 40 00 ff 	movh.a %a15,61444
8000a734:	d9 ff 44 4b 	lea %a15,[%a15]-19196 <f003b504 <_SMALL_DATA4_+0x40033504>>
8000a738:	4c f0       	ld.w %d15,[%a15]0
8000a73a:	96 01       	or %d15,1
8000a73c:	68 0f       	st.w [%a15]0,%d15

	/* Enable ASCn */
	unlock_wdtcon();
	MODULE_ASCLIN1.CLC.U = 0;
8000a73e:	c5 ff 40 c0 	lea %a15,f0000700 <_SMALL_DATA4_+0x3fff8700>
8000a742:	82 0f       	mov %d15,0
	/* Set TXD/P15.0 to "output" and "high" */
	MODULE_P15.IOCR0.B.PC0 = 0b10010;
	P15_OMR.B.PS0 = 1;

	/* Enable ASCn */
	unlock_wdtcon();
8000a744:	6d 00 ba 38 	call 800118b8 <unlock_wdtcon>
	MODULE_ASCLIN1.CLC.U = 0;
8000a748:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000a74a:	6d 00 cd 38 	call 800118e4 <lock_wdtcon>
	/* read back for activating module */
	(void) MODULE_ASCLIN1.CLC.U;
8000a74e:	48 02       	ld.w %d2,[%a15]0

	/* select RXD as input pin */
	MODULE_ASCLIN1.IOCR.B.ALTI = 0;
8000a750:	48 12       	ld.w %d2,[%a15]4
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000a752:	91 10 00 48 	movh.a %a4,32769
	lock_wdtcon();
	/* read back for activating module */
	(void) MODULE_ASCLIN1.CLC.U;

	/* select RXD as input pin */
	MODULE_ASCLIN1.IOCR.B.ALTI = 0;
8000a756:	8f 72 c0 21 	andn %d2,%d2,7
8000a75a:	68 12       	st.w [%a15]4,%d2

	/* Program ASC0 */
	MODULE_ASCLIN1.CSR.U = 0;
8000a75c:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* configure TX and RX FIFOs */
	MODULE_ASCLIN1.TXFIFOCON.U = (1 << 6)  /* INW: 1byte */
8000a760:	da 43       	mov %d15,67
8000a762:	68 3f       	st.w [%a15]12,%d15
							   | (1 << 1)  /* ENO*/
							   | (1 << 0); /* FLUSH */
	MODULE_ASCLIN1.RXFIFOCON.U = (1 << 6)  /* OUTW: 1byte */
8000a764:	68 4f       	st.w [%a15]16,%d15
							   | (1 << 1)  /* ENI */
							   | (1 << 0); /* FLUSH */

	MODULE_ASCLIN1.BITCON.U = (4 << 0)	   /* PRESCALER: 5 */
8000a766:	7b f0 90 f8 	movh %d15,35087
8000a76a:	c2 4f       	add %d15,4
8000a76c:	68 5f       	st.w [%a15]20,%d15
							| (15 << 16)   /* OVERSAMPLING: 16 */
							| (9 << 24)    /* SAMPLEPOINT: position 7,8,9 */
							| (1u << 31);  /* SM: 3 samples per bit */

	/* data format: 8N1 */
	MODULE_ASCLIN1.FRAMECON.U = (1 << 9)   /* STOP: 1 bit */
8000a76e:	3b 00 20 f0 	mov %d15,512
8000a772:	68 6f       	st.w [%a15]24,%d15
							  | (0 << 16)  /* MODE: Init */
							  | (0 << 30); /* PEN: no parity */
	MODULE_ASCLIN1.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */
8000a774:	82 7f       	mov %d15,7
8000a776:	68 7f       	st.w [%a15]28,%d15

	/* set baudrate value: 921600 */
	MODULE_ASCLIN1.BRG.U = (denominator << 0) | (numerator << 16);
8000a778:	7b 00 90 f0 	movh %d15,2304
8000a77c:	1b 5f c3 f0 	addi %d15,%d15,3125
8000a780:	68 8f       	st.w [%a15]32,%d15

	MODULE_ASCLIN1.FRAMECON.B.MODE = 1; /* ASC Mode */
8000a782:	4c f6       	ld.w %d15,[%a15]24
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000a784:	3b 40 02 40 	mov %d4,36
	MODULE_ASCLIN1.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */

	/* set baudrate value: 921600 */
	MODULE_ASCLIN1.BRG.U = (denominator << 0) | (numerator << 16);

	MODULE_ASCLIN1.FRAMECON.B.MODE = 1; /* ASC Mode */
8000a788:	b7 1f 02 f8 	insert %d15,%d15,1,16,2
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000a78c:	d9 44 42 6b 	lea %a4,[%a4]-19070 <8000b582 <IsrUart1RxHandler_tof>>
	MODULE_ASCLIN1.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */

	/* set baudrate value: 921600 */
	MODULE_ASCLIN1.BRG.U = (denominator << 0) | (numerator << 16);

	MODULE_ASCLIN1.FRAMECON.B.MODE = 1; /* ASC Mode */
8000a790:	68 6f       	st.w [%a15]24,%d15

	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
8000a792:	82 1f       	mov %d15,1
8000a794:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);
8000a798:	7b 00 00 f8 	movh %d15,32768
8000a79c:	68 ef       	st.w [%a15]56,%d15

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000a79e:	82 15       	mov %d5,1
8000a7a0:	82 06       	mov %d6,0
	MODULE_ASCLIN1.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
8000a7a2:	7b 00 00 f1 	movh %d15,4096
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000a7a6:	6d 00 4a 08 	call 8000b83a <InterruptInstall>
	MODULE_ASCLIN1.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
8000a7aa:	59 ff 00 10 	st.w [%a15]64 <f0040040 <_SMALL_DATA4_+0x40038040>>,%d15
8000a7ae:	00 90       	ret 

8000a7b0 <_in_uart1>:
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a7b0:	7b 00 00 41 	movh %d4,4096
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
8000a7b4:	7b 50 40 30 	movh %d3,1029
			/* reset error flags */
			MODULE_ASCLIN1.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
8000a7b8:	3b 30 0c 50 	mov %d5,195

int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
8000a7bc:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
8000a7c0:	ef cf fe 7f 	jz.t %d15,28,8000a7bc <_in_uart1+0xc>
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
8000a7c4:	85 f2 48 d0 	ld.w %d2,f0000748 <_SMALL_DATA4_+0x3fff8748>
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a7c8:	a5 f4 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d4
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
8000a7cc:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
8000a7d0:	26 3f       	and %d15,%d3
8000a7d2:	ee 04       	jnz %d15,8000a7da <_in_uart1+0x2a>
{
	unsigned char ch;
	/* wait for a new character */
	while (_poll_uart1(&ch) == 0);
	return ch;
}
8000a7d4:	8f f2 0f 21 	and %d2,%d2,255
8000a7d8:	00 90       	ret 
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN1.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000a7da:	a5 f3 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d3
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
8000a7de:	a5 f5 50 c0 	st.w f0000710 <_SMALL_DATA4_+0x3fff8710>,%d5
8000a7e2:	3c ed       	j 8000a7bc <_in_uart1+0xc>

8000a7e4 <_poll_uart1>:

int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
8000a7e4:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
}

int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
8000a7e8:	82 02       	mov %d2,0
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
8000a7ea:	ef cf 10 00 	jz.t %d15,28,8000a80a <_poll_uart1+0x26>
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a7ee:	7b 00 00 f1 	movh %d15,4096
int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
8000a7f2:	85 f4 48 d0 	ld.w %d4,f0000748 <_SMALL_DATA4_+0x3fff8748>
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a7f6:	a5 ff 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d15
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
8000a7fa:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
8000a7fe:	7b 50 40 30 	movh %d3,1029
8000a802:	26 3f       	and %d15,%d3
8000a804:	ee 04       	jnz %d15,8000a80c <_poll_uart1+0x28>
int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
8000a806:	34 44       	st.b [%a4],%d4
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
			/* ignore this character */
		} else {
			/* this is a valid character */
			*chr = ret;
			res = 1;
8000a808:	82 12       	mov %d2,1
		}
	}
	return res;
}
8000a80a:	00 90       	ret 
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN1.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000a80c:	a5 f3 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d3
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
8000a810:	da c3       	mov %d15,195
8000a812:	a5 ff 50 c0 	st.w f0000710 <_SMALL_DATA4_+0x3fff8710>,%d15
8000a816:	00 90       	ret 

8000a818 <_init_uart0>:
void _init_uart0(void)
{
	unsigned int numerator = 48;
	unsigned int denominator = 3125;
	/* Set TXD/P14.0 to "output" and "high" */
	MODULE_P14.IOCR0.B.PC0 = 0b10010;
8000a818:	91 40 00 ff 	movh.a %a15,61444
8000a81c:	d9 ff 40 0b 	lea %a15,[%a15]-19456 <f003b400 <_SMALL_DATA4_+0x40033400>>
8000a820:	4c f4       	ld.w %d15,[%a15]16
8000a822:	8f 8f cf f1 	andn %d15,%d15,248
8000a826:	96 90       	or %d15,144
8000a828:	68 4f       	st.w [%a15]16,%d15
	P14_OMR.B.PS0 = 1;
8000a82a:	91 40 00 ff 	movh.a %a15,61444
8000a82e:	d9 ff 44 0b 	lea %a15,[%a15]-19452 <f003b404 <_SMALL_DATA4_+0x40033404>>
8000a832:	4c f0       	ld.w %d15,[%a15]0
8000a834:	96 01       	or %d15,1
8000a836:	68 0f       	st.w [%a15]0,%d15

	/* Enable ASCn */
	unlock_wdtcon();
	MODULE_ASCLIN0.CLC.U = 0;
8000a838:	c5 ff 40 80 	lea %a15,f0000600 <_SMALL_DATA4_+0x3fff8600>
8000a83c:	82 0f       	mov %d15,0
	/* Set TXD/P14.0 to "output" and "high" */
	MODULE_P14.IOCR0.B.PC0 = 0b10010;
	P14_OMR.B.PS0 = 1;

	/* Enable ASCn */
	unlock_wdtcon();
8000a83e:	6d 00 3d 38 	call 800118b8 <unlock_wdtcon>
	MODULE_ASCLIN0.CLC.U = 0;
8000a842:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000a844:	6d 00 50 38 	call 800118e4 <lock_wdtcon>
	/* read back for activating module */
	(void) MODULE_ASCLIN0.CLC.U;
8000a848:	48 02       	ld.w %d2,[%a15]0

	/* select RXD as input pin */
	MODULE_ASCLIN0.IOCR.B.ALTI = 0;
8000a84a:	48 12       	ld.w %d2,[%a15]4
8000a84c:	8f 72 c0 21 	andn %d2,%d2,7
8000a850:	68 12       	st.w [%a15]4,%d2

	/* Program ASC0 */
	MODULE_ASCLIN0.CSR.U = 0;
8000a852:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* configure TX and RX FIFOs */
	MODULE_ASCLIN0.TXFIFOCON.U = (1 << 6)  /* INW: 1byte */
8000a856:	da 43       	mov %d15,67
8000a858:	68 3f       	st.w [%a15]12,%d15
							   | (1 << 1)  /* ENO*/
							   | (1 << 0); /* FLUSH */
//	MODULE_ASCLIN0.RXFIFOCON.U = (1 << 6)  /* OUTW: 1byte */
//							   | (1 << 1)  /* ENI */
//							   | (1 << 0); /* FLUSH */
	MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000a85a:	9b 0f 00 f8 	addih %d15,%d15,32768
8000a85e:	68 4f       	st.w [%a15]16,%d15

	MODULE_ASCLIN0.BITCON.U = (9 << 0)	   /* PRESCALER: 10 */
8000a860:	7b f0 90 f8 	movh %d15,35087
8000a864:	1b 9f 00 f0 	addi %d15,%d15,9
8000a868:	68 5f       	st.w [%a15]20,%d15
							| (15 << 16)   /* OVERSAMPLING: 16 */
							| (9 << 24)    /* SAMPLEPOINT: position 7,8,9 */
							| (1u << 31);  /* SM: 3 samples per bit */

	/* data format: 8N1 */
	MODULE_ASCLIN0.FRAMECON.U = (1 << 9)   /* STOP: 1 bit */
8000a86a:	3b 00 20 f0 	mov %d15,512
8000a86e:	68 6f       	st.w [%a15]24,%d15
							  | (0 << 16)  /* MODE: Init */
							  | (0 << 30); /* PEN: no parity */
	MODULE_ASCLIN0.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */
8000a870:	82 7f       	mov %d15,7
8000a872:	68 7f       	st.w [%a15]28,%d15

	/* set baudrate value: 921600 */
	MODULE_ASCLIN0.BRG.U = (denominator << 0) | (numerator << 16);
8000a874:	7b 00 03 f0 	movh %d15,48
8000a878:	1b 5f c3 f0 	addi %d15,%d15,3125
8000a87c:	68 8f       	st.w [%a15]32,%d15

	MODULE_ASCLIN0.FRAMECON.B.MODE = 1; /* ASC Mode */
8000a87e:	4c f6       	ld.w %d15,[%a15]24
8000a880:	b7 1f 02 f8 	insert %d15,%d15,1,16,2
8000a884:	68 6f       	st.w [%a15]24,%d15

	MODULE_ASCLIN0.CSR.U = 1; /* select CLC as clock source */
8000a886:	82 1f       	mov %d15,1
8000a888:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15
	/* Module Start */
	MODULE_ASCLIN0.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);
8000a88c:	7b 00 00 f8 	movh %d15,32768
8000a890:	68 ef       	st.w [%a15]56,%d15
8000a892:	00 90       	ret 

8000a894 <_in_uart0>:
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000a894:	7b 00 00 58 	movh %d5,32768
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a898:	7b 00 00 41 	movh %d4,4096
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
8000a89c:	7b 50 40 30 	movh %d3,1029
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000a8a0:	1b 35 04 50 	addi %d5,%d5,67

int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
8000a8a4:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000a8a8:	ef cf fe 7f 	jz.t %d15,28,8000a8a4 <_in_uart0+0x10>
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
8000a8ac:	85 f2 48 90 	ld.w %d2,f0000648 <_SMALL_DATA4_+0x3fff8648>
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a8b0:	a5 f4 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d4
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
8000a8b4:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000a8b8:	26 3f       	and %d15,%d3
8000a8ba:	ee 04       	jnz %d15,8000a8c2 <_in_uart0+0x2e>
{
	unsigned char ch;
	/* wait for a new character */
	while (_poll_uart0(&ch) == 0);
	return ch;
}
8000a8bc:	8f f2 0f 21 	and %d2,%d2,255
8000a8c0:	00 90       	ret 
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000a8c2:	a5 f3 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d3
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000a8c6:	a5 f5 50 80 	st.w f0000610 <_SMALL_DATA4_+0x3fff8610>,%d5
8000a8ca:	3c ed       	j 8000a8a4 <_in_uart0+0x10>

8000a8cc <_poll_uart0>:

int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
8000a8cc:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
}

int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
8000a8d0:	82 02       	mov %d2,0
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
8000a8d2:	ef cf 10 00 	jz.t %d15,28,8000a8f2 <_poll_uart0+0x26>
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a8d6:	7b 00 00 f1 	movh %d15,4096
int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
8000a8da:	85 f4 48 90 	ld.w %d4,f0000648 <_SMALL_DATA4_+0x3fff8648>
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000a8de:	a5 ff 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d15
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
8000a8e2:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000a8e6:	7b 50 40 30 	movh %d3,1029
8000a8ea:	26 3f       	and %d15,%d3
8000a8ec:	ee 04       	jnz %d15,8000a8f4 <_poll_uart0+0x28>
int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
8000a8ee:	34 44       	st.b [%a4],%d4
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
			/* ignore this character */
		} else {
			/* this is a valid character */
			*chr = ret;
			res = 1;
8000a8f0:	82 12       	mov %d2,1
		}
	}
	return res;
}
8000a8f2:	00 90       	ret 
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000a8f4:	7b 00 00 f8 	movh %d15,32768
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000a8f8:	a5 f3 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d3
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000a8fc:	1b 3f 04 f0 	addi %d15,%d15,67
8000a900:	a5 ff 50 80 	st.w f0000610 <_SMALL_DATA4_+0x3fff8610>,%d15
8000a904:	00 90       	ret 

8000a906 <_out_uart0>:

/* Send character CHR via the serial line */
void _out_uart0(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN0));
8000a906:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000a90a:	ff 0f fe 7f 	jge %d15,0,8000a906 <_out_uart0>

	TX_CLEAR(MODULE_ASCLIN0);
8000a90e:	7b 00 00 f8 	movh %d15,32768
8000a912:	a5 ff 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d15

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN0, chr);
8000a916:	a5 f4 44 90 	st.w f0000644 <_SMALL_DATA4_+0x3fff8644>,%d4
8000a91a:	00 90       	ret 

8000a91c <IsrGpt2T6Handler>:
//	cntDelay++;
//}

void IsrGpt2T6Handler(void)
{
	if (cnt_10us  < lMotorDuty) {
8000a91c:	91 00 00 27 	movh.a %a2,28672
8000a920:	91 00 00 f7 	movh.a %a15,28672
8000a924:	19 f2 84 f1 	ld.w %d2,[%a15]7108 <70001bc4 <cnt_10us>>
8000a928:	19 2f c4 d0 	ld.w %d15,[%a2]3908 <70000f44 <lMotorDuty>>
		MODULE_P02.OUT.B.P1 = 1; /* Left Motor (CH-A) */
8000a92c:	91 40 00 2f 	movh.a %a2,61444
8000a930:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
//	cntDelay++;
//}

void IsrGpt2T6Handler(void)
{
	if (cnt_10us  < lMotorDuty) {
8000a934:	7f f2 2d 80 	jge.u %d2,%d15,8000a98e <IsrGpt2T6Handler+0x72>
		MODULE_P02.OUT.B.P1 = 1; /* Left Motor (CH-A) */
8000a938:	4c 20       	ld.w %d15,[%a2]0
8000a93a:	96 02       	or %d15,2
8000a93c:	6c 20       	st.w [%a2]0,%d15
	} else {
		MODULE_P02.OUT.B.P1 = 0; /* Left Motor (CH-A) */
	}

	if (cnt_10us < rMotorDuty) {
8000a93e:	91 00 00 27 	movh.a %a2,28672
8000a942:	19 f2 84 f1 	ld.w %d2,[%a15]7108 <70001bc4 <cnt_10us>>
8000a946:	19 2f c0 d0 	ld.w %d15,[%a2]3904 <70000f40 <rMotorDuty>>
		MODULE_P10.OUT.B.P3 = 1; /* Right Motor (CH-B) */
8000a94a:	91 40 00 2f 	movh.a %a2,61444
8000a94e:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
		MODULE_P02.OUT.B.P1 = 1; /* Left Motor (CH-A) */
	} else {
		MODULE_P02.OUT.B.P1 = 0; /* Left Motor (CH-A) */
	}

	if (cnt_10us < rMotorDuty) {
8000a952:	7f f2 19 80 	jge.u %d2,%d15,8000a984 <IsrGpt2T6Handler+0x68>
		MODULE_P10.OUT.B.P3 = 1; /* Right Motor (CH-B) */
8000a956:	4c 20       	ld.w %d15,[%a2]0
8000a958:	96 08       	or %d15,8
8000a95a:	6c 20       	st.w [%a2]0,%d15
	} else {
		MODULE_P10.OUT.B.P3 = 0; /* Right Motor (CH-B) */
	}

	if (cnt_10us == 100) {
8000a95c:	19 ff 84 f1 	ld.w %d15,[%a15]7108 <70001bc4 <cnt_10us>>
8000a960:	91 00 00 27 	movh.a %a2,28672
8000a964:	8b 4f 26 f2 	ne %d15,%d15,100
8000a968:	6e 04       	jz %d15,8000a970 <IsrGpt2T6Handler+0x54>
		cnt_10us = 0;
	} else {
		cnt_10us++;
8000a96a:	19 2f 84 f1 	ld.w %d15,[%a2]7108 <70001bc4 <cnt_10us>>
8000a96e:	c2 1f       	add %d15,1
8000a970:	59 2f 84 f1 	st.w [%a2]7108 <70001bc4 <cnt_10us>>,%d15
	}
	cntDelay++;
8000a974:	91 00 00 f7 	movh.a %a15,28672
8000a978:	19 ff 80 f1 	ld.w %d15,[%a15]7104 <70001bc0 <cntDelay>>
8000a97c:	c2 1f       	add %d15,1
8000a97e:	59 ff 80 f1 	st.w [%a15]7104 <70001bc0 <cntDelay>>,%d15
8000a982:	00 90       	ret 
	}

	if (cnt_10us < rMotorDuty) {
		MODULE_P10.OUT.B.P3 = 1; /* Right Motor (CH-B) */
	} else {
		MODULE_P10.OUT.B.P3 = 0; /* Right Motor (CH-B) */
8000a984:	4c 20       	ld.w %d15,[%a2]0
8000a986:	8f 8f c0 f1 	andn %d15,%d15,8
8000a98a:	6c 20       	st.w [%a2]0,%d15
8000a98c:	3c e8       	j 8000a95c <IsrGpt2T6Handler+0x40>
void IsrGpt2T6Handler(void)
{
	if (cnt_10us  < lMotorDuty) {
		MODULE_P02.OUT.B.P1 = 1; /* Left Motor (CH-A) */
	} else {
		MODULE_P02.OUT.B.P1 = 0; /* Left Motor (CH-A) */
8000a98e:	4c 20       	ld.w %d15,[%a2]0
8000a990:	8f 2f c0 f1 	andn %d15,%d15,2
8000a994:	6c 20       	st.w [%a2]0,%d15
8000a996:	3c d4       	j 8000a93e <IsrGpt2T6Handler+0x22>

8000a998 <getLeftMotorDuty>:

extern void IsrGpt120T3Handler_Beep(void);

unsigned int getLeftMotorDuty(void)
{
	return lMotorDuty;
8000a998:	91 00 00 f7 	movh.a %a15,28672
8000a99c:	19 f2 c4 d0 	ld.w %d2,[%a15]3908 <70000f44 <lMotorDuty>>
}
8000a9a0:	00 90       	ret 

8000a9a2 <getRightMotorDuty>:

unsigned int getRightMotorDuty(void)
{
	return rMotorDuty;
8000a9a2:	91 00 00 f7 	movh.a %a15,28672
8000a9a6:	19 f2 c0 d0 	ld.w %d2,[%a15]3904 <70000f40 <rMotorDuty>>
}
8000a9aa:	00 90       	ret 

8000a9ac <setLeftMotorDuty>:

void setLeftMotorDuty(unsigned int duty)
{
//	cnt_10us = 0; /* Disabled - PWM may not work properly when movChx_PWM() is called frequently */
	lMotorDuty = duty;
8000a9ac:	91 00 00 f7 	movh.a %a15,28672
8000a9b0:	59 f4 c4 d0 	st.w [%a15]3908 <70000f44 <lMotorDuty>>,%d4
8000a9b4:	00 90       	ret 

8000a9b6 <setRightMotorDuty>:
}

void setRightMotorDuty(unsigned int duty)
{
//	cnt_10us = 0; /* Disabled - PWM may not work properly when movChx_PWM() is called frequently */
	rMotorDuty = duty;
8000a9b6:	91 00 00 f7 	movh.a %a15,28672
8000a9ba:	59 f4 c0 d0 	st.w [%a15]3904 <70000f40 <rMotorDuty>>,%d4
8000a9be:	00 90       	ret 

8000a9c0 <getcntDelay>:
}

unsigned int getcntDelay(void)
{
	return cntDelay;
8000a9c0:	91 00 00 f7 	movh.a %a15,28672
8000a9c4:	19 f2 80 f1 	ld.w %d2,[%a15]7104 <70001bc0 <cntDelay>>
}
8000a9c8:	00 90       	ret 

8000a9ca <setcntDelay>:

void setcntDelay(unsigned int n)
{
	cntDelay = n;
8000a9ca:	91 00 00 f7 	movh.a %a15,28672
8000a9ce:	59 f4 80 f1 	st.w [%a15]7104 <70001bc0 <cntDelay>>,%d4
8000a9d2:	00 90       	ret 

8000a9d4 <init_gpt1>:

void init_gpt1(void)
{
    /* Initialize the GPT12 module */
	unlock_wdtcon();
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
8000a9d4:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
}

void init_gpt1(void)
{
    /* Initialize the GPT12 module */
	unlock_wdtcon();
8000a9d8:	6d 00 70 37 	call 800118b8 <unlock_wdtcon>
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
8000a9dc:	4c f0       	ld.w %d15,[%a15]0
8000a9de:	8f 1f c0 f1 	andn %d15,%d15,1
8000a9e2:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000a9e4:	6d 00 80 37 	call 800118e4 <lock_wdtcon>

	/* Initialize the Timer T3 (PWM) */
	MODULE_GPT120.T3CON.B.BPS1 = 0x2; /* Set GPT1 block prescaler: 32 */
8000a9e8:	4c f5       	ld.w %d15,[%a15]20
	MODULE_GPT120.T3.U = 100; /* Set timer T3 value */
    /* Timer T2: reloads the value DutyDownTime in timer T3 */
    MODULE_GPT120.T2CON.B.T2M = 0x4; /* Set the timer T2 in reload mode */
    MODULE_GPT120.T2CON.B.T2I = 0x7; /* Reload Input Mode : Rising/Falling Edge T3OTL */
    MODULE_GPT120.T2.U = 100;
    InterruptInstall(SRC_ID_GPT120T3, (void(*)(int))IsrGpt120T3Handler_Beep, 3, 0);
8000a9ea:	91 10 00 48 	movh.a %a4,32769
	unlock_wdtcon();
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
	lock_wdtcon();

	/* Initialize the Timer T3 (PWM) */
	MODULE_GPT120.T3CON.B.BPS1 = 0x2; /* Set GPT1 block prescaler: 32 */
8000a9ee:	b7 2f 82 f5 	insert %d15,%d15,2,11,2
	MODULE_GPT120.T3.U = 100; /* Set timer T3 value */
    /* Timer T2: reloads the value DutyDownTime in timer T3 */
    MODULE_GPT120.T2CON.B.T2M = 0x4; /* Set the timer T2 in reload mode */
    MODULE_GPT120.T2CON.B.T2I = 0x7; /* Reload Input Mode : Rising/Falling Edge T3OTL */
    MODULE_GPT120.T2.U = 100;
    InterruptInstall(SRC_ID_GPT120T3, (void(*)(int))IsrGpt120T3Handler_Beep, 3, 0);
8000a9f2:	3b a0 11 40 	mov %d4,282
	unlock_wdtcon();
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
	lock_wdtcon();

	/* Initialize the Timer T3 (PWM) */
	MODULE_GPT120.T3CON.B.BPS1 = 0x2; /* Set GPT1 block prescaler: 32 */
8000a9f6:	68 5f       	st.w [%a15]20,%d15
	MODULE_GPT120.T3CON.B.T3M = 0x0; /* Set T3 to timer mode */
8000a9f8:	4c f5       	ld.w %d15,[%a15]20
	MODULE_GPT120.T3.U = 100; /* Set timer T3 value */
    /* Timer T2: reloads the value DutyDownTime in timer T3 */
    MODULE_GPT120.T2CON.B.T2M = 0x4; /* Set the timer T2 in reload mode */
    MODULE_GPT120.T2CON.B.T2I = 0x7; /* Reload Input Mode : Rising/Falling Edge T3OTL */
    MODULE_GPT120.T2.U = 100;
    InterruptInstall(SRC_ID_GPT120T3, (void(*)(int))IsrGpt120T3Handler_Beep, 3, 0);
8000a9fa:	d9 44 dc 3a 	lea %a4,[%a4]-21284 <8000acdc <IsrGpt120T3Handler_Beep>>
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
	lock_wdtcon();

	/* Initialize the Timer T3 (PWM) */
	MODULE_GPT120.T3CON.B.BPS1 = 0x2; /* Set GPT1 block prescaler: 32 */
	MODULE_GPT120.T3CON.B.T3M = 0x0; /* Set T3 to timer mode */
8000a9fe:	8f 8f c3 f1 	andn %d15,%d15,56
8000aa02:	68 5f       	st.w [%a15]20,%d15
	MODULE_GPT120.T3CON.B.T3UD = 0x1; /* Set T3 count direction(down) */
8000aa04:	4c f5       	ld.w %d15,[%a15]20
	MODULE_GPT120.T3.U = 100; /* Set timer T3 value */
    /* Timer T2: reloads the value DutyDownTime in timer T3 */
    MODULE_GPT120.T2CON.B.T2M = 0x4; /* Set the timer T2 in reload mode */
    MODULE_GPT120.T2CON.B.T2I = 0x7; /* Reload Input Mode : Rising/Falling Edge T3OTL */
    MODULE_GPT120.T2.U = 100;
    InterruptInstall(SRC_ID_GPT120T3, (void(*)(int))IsrGpt120T3Handler_Beep, 3, 0);
8000aa06:	82 35       	mov %d5,3
	lock_wdtcon();

	/* Initialize the Timer T3 (PWM) */
	MODULE_GPT120.T3CON.B.BPS1 = 0x2; /* Set GPT1 block prescaler: 32 */
	MODULE_GPT120.T3CON.B.T3M = 0x0; /* Set T3 to timer mode */
	MODULE_GPT120.T3CON.B.T3UD = 0x1; /* Set T3 count direction(down) */
8000aa08:	96 80       	or %d15,128
8000aa0a:	68 5f       	st.w [%a15]20,%d15
	MODULE_GPT120.T3CON.B.T3I = 0x5; /* Set T3 input prescaler(2^5=32) */
8000aa0c:	4c f5       	ld.w %d15,[%a15]20
	MODULE_GPT120.T3.U = 100; /* Set timer T3 value */
    /* Timer T2: reloads the value DutyDownTime in timer T3 */
    MODULE_GPT120.T2CON.B.T2M = 0x4; /* Set the timer T2 in reload mode */
    MODULE_GPT120.T2CON.B.T2I = 0x7; /* Reload Input Mode : Rising/Falling Edge T3OTL */
    MODULE_GPT120.T2.U = 100;
    InterruptInstall(SRC_ID_GPT120T3, (void(*)(int))IsrGpt120T3Handler_Beep, 3, 0);
8000aa0e:	82 06       	mov %d6,0

	/* Initialize the Timer T3 (PWM) */
	MODULE_GPT120.T3CON.B.BPS1 = 0x2; /* Set GPT1 block prescaler: 32 */
	MODULE_GPT120.T3CON.B.T3M = 0x0; /* Set T3 to timer mode */
	MODULE_GPT120.T3CON.B.T3UD = 0x1; /* Set T3 count direction(down) */
	MODULE_GPT120.T3CON.B.T3I = 0x5; /* Set T3 input prescaler(2^5=32) */
8000aa10:	b7 5f 03 f0 	insert %d15,%d15,5,0,3
8000aa14:	68 5f       	st.w [%a15]20,%d15
	/* Calculate dutyUpTime and dutyDownTime for reloading timer T3 */
	MODULE_GPT120.T3.U = 100; /* Set timer T3 value */
8000aa16:	da 64       	mov %d15,100
8000aa18:	68 ef       	st.w [%a15]56,%d15
    /* Timer T2: reloads the value DutyDownTime in timer T3 */
    MODULE_GPT120.T2CON.B.T2M = 0x4; /* Set the timer T2 in reload mode */
8000aa1a:	48 42       	ld.w %d2,[%a15]16
8000aa1c:	b7 42 83 21 	insert %d2,%d2,4,3,3
8000aa20:	68 42       	st.w [%a15]16,%d2
    MODULE_GPT120.T2CON.B.T2I = 0x7; /* Reload Input Mode : Rising/Falling Edge T3OTL */
8000aa22:	48 42       	ld.w %d2,[%a15]16
8000aa24:	8f 72 40 21 	or %d2,%d2,7
8000aa28:	68 42       	st.w [%a15]16,%d2
    MODULE_GPT120.T2.U = 100;
8000aa2a:	68 df       	st.w [%a15]52,%d15
    InterruptInstall(SRC_ID_GPT120T3, (void(*)(int))IsrGpt120T3Handler_Beep, 3, 0);
8000aa2c:	6d 00 07 07 	call 8000b83a <InterruptInstall>

    /* Initialize the Timer T4 for Ultrasonic */
    MODULE_GPT120.T4CON.B.T4M = 0x0; /* Set T4 to timer mode */
8000aa30:	4c f6       	ld.w %d15,[%a15]24
8000aa32:	8f 8f c3 f1 	andn %d15,%d15,56
8000aa36:	68 6f       	st.w [%a15]24,%d15
    MODULE_GPT120.T4CON.B.T4UD = 0x0; /* Set T4 count direction(up) */
8000aa38:	4c f6       	ld.w %d15,[%a15]24
8000aa3a:	8f 0f c8 f1 	andn %d15,%d15,128
8000aa3e:	68 6f       	st.w [%a15]24,%d15
    MODULE_GPT120.T4CON.B.T4I = 0x5; /* Set T4 input prescaler(2^5=32) */
8000aa40:	4c f6       	ld.w %d15,[%a15]24
8000aa42:	b7 5f 03 f0 	insert %d15,%d15,5,0,3
8000aa46:	68 6f       	st.w [%a15]24,%d15
    MODULE_GPT120.T4.U = 0u;
8000aa48:	82 0f       	mov %d15,0
8000aa4a:	68 ff       	st.w [%a15]60,%d15
8000aa4c:	00 90       	ret 

8000aa4e <init_gpt2>:

void init_gpt2(void)
{
    /* Initialize the GPT12 module */
	unlock_wdtcon();
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
8000aa4e:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>


void init_gpt2(void)
{
    /* Initialize the GPT12 module */
	unlock_wdtcon();
8000aa52:	6d 00 33 37 	call 800118b8 <unlock_wdtcon>
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
8000aa56:	4c f0       	ld.w %d15,[%a15]0
8000aa58:	8f 1f c0 f1 	andn %d15,%d15,1
8000aa5c:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000aa5e:	6d 00 43 37 	call 800118e4 <lock_wdtcon>

    /* Initialize the Timer T6 for delay_ms */
    MODULE_GPT120.T6CON.B.BPS2 = 0x0; /* Set GPT2 block prescaler: 4 */
8000aa62:	4c f8       	ld.w %d15,[%a15]32
    MODULE_GPT120.T6CON.B.T6OE = 0x1; /* Overflow/Underflow Output Enable */
    MODULE_GPT120.T6CON.B.T6SR = 0x1; /* Reload from register CAPREL Enabled */
    MODULE_GPT120.T6.U = 250u; /* Set T6 start value (10us) */

    MODULE_GPT120.CAPREL.U = 250u; /* Set CAPREL reload value */
	InterruptInstall(SRC_ID_GPT120T6, (void(*)(int))IsrGpt2T6Handler, 2, 0);
8000aa64:	91 10 00 48 	movh.a %a4,32769
	unlock_wdtcon();
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
	lock_wdtcon();

    /* Initialize the Timer T6 for delay_ms */
    MODULE_GPT120.T6CON.B.BPS2 = 0x0; /* Set GPT2 block prescaler: 4 */
8000aa68:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
    MODULE_GPT120.T6CON.B.T6OE = 0x1; /* Overflow/Underflow Output Enable */
    MODULE_GPT120.T6CON.B.T6SR = 0x1; /* Reload from register CAPREL Enabled */
    MODULE_GPT120.T6.U = 250u; /* Set T6 start value (10us) */

    MODULE_GPT120.CAPREL.U = 250u; /* Set CAPREL reload value */
	InterruptInstall(SRC_ID_GPT120T6, (void(*)(int))IsrGpt2T6Handler, 2, 0);
8000aa6c:	3b d0 11 40 	mov %d4,285
	unlock_wdtcon();
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
	lock_wdtcon();

    /* Initialize the Timer T6 for delay_ms */
    MODULE_GPT120.T6CON.B.BPS2 = 0x0; /* Set GPT2 block prescaler: 4 */
8000aa70:	68 8f       	st.w [%a15]32,%d15
    MODULE_GPT120.T6CON.B.T6M = 0x0; /* Set T6 to timer mode */
8000aa72:	4c f8       	ld.w %d15,[%a15]32
    MODULE_GPT120.T6CON.B.T6OE = 0x1; /* Overflow/Underflow Output Enable */
    MODULE_GPT120.T6CON.B.T6SR = 0x1; /* Reload from register CAPREL Enabled */
    MODULE_GPT120.T6.U = 250u; /* Set T6 start value (10us) */

    MODULE_GPT120.CAPREL.U = 250u; /* Set CAPREL reload value */
	InterruptInstall(SRC_ID_GPT120T6, (void(*)(int))IsrGpt2T6Handler, 2, 0);
8000aa74:	d9 44 9c 4a 	lea %a4,[%a4]-22244 <8000a91c <IsrGpt2T6Handler>>
	MODULE_GPT120.CLC.B.DISR = 0; /* Enable the GPT12 module */
	lock_wdtcon();

    /* Initialize the Timer T6 for delay_ms */
    MODULE_GPT120.T6CON.B.BPS2 = 0x0; /* Set GPT2 block prescaler: 4 */
    MODULE_GPT120.T6CON.B.T6M = 0x0; /* Set T6 to timer mode */
8000aa78:	8f 8f c3 f1 	andn %d15,%d15,56
8000aa7c:	68 8f       	st.w [%a15]32,%d15
    MODULE_GPT120.T6CON.B.T6UD = 0x1; /* Set T6 count direction(down) */
8000aa7e:	4c f8       	ld.w %d15,[%a15]32
    MODULE_GPT120.T6CON.B.T6OE = 0x1; /* Overflow/Underflow Output Enable */
    MODULE_GPT120.T6CON.B.T6SR = 0x1; /* Reload from register CAPREL Enabled */
    MODULE_GPT120.T6.U = 250u; /* Set T6 start value (10us) */

    MODULE_GPT120.CAPREL.U = 250u; /* Set CAPREL reload value */
	InterruptInstall(SRC_ID_GPT120T6, (void(*)(int))IsrGpt2T6Handler, 2, 0);
8000aa80:	82 25       	mov %d5,2
	lock_wdtcon();

    /* Initialize the Timer T6 for delay_ms */
    MODULE_GPT120.T6CON.B.BPS2 = 0x0; /* Set GPT2 block prescaler: 4 */
    MODULE_GPT120.T6CON.B.T6M = 0x0; /* Set T6 to timer mode */
    MODULE_GPT120.T6CON.B.T6UD = 0x1; /* Set T6 count direction(down) */
8000aa82:	96 80       	or %d15,128
8000aa84:	68 8f       	st.w [%a15]32,%d15
    MODULE_GPT120.T6CON.B.T6I = 0x0; /* Set T6 input prescaler(2^0=1) */
8000aa86:	4c f8       	ld.w %d15,[%a15]32
    MODULE_GPT120.T6CON.B.T6OE = 0x1; /* Overflow/Underflow Output Enable */
    MODULE_GPT120.T6CON.B.T6SR = 0x1; /* Reload from register CAPREL Enabled */
    MODULE_GPT120.T6.U = 250u; /* Set T6 start value (10us) */

    MODULE_GPT120.CAPREL.U = 250u; /* Set CAPREL reload value */
	InterruptInstall(SRC_ID_GPT120T6, (void(*)(int))IsrGpt2T6Handler, 2, 0);
8000aa88:	82 06       	mov %d6,0

    /* Initialize the Timer T6 for delay_ms */
    MODULE_GPT120.T6CON.B.BPS2 = 0x0; /* Set GPT2 block prescaler: 4 */
    MODULE_GPT120.T6CON.B.T6M = 0x0; /* Set T6 to timer mode */
    MODULE_GPT120.T6CON.B.T6UD = 0x1; /* Set T6 count direction(down) */
    MODULE_GPT120.T6CON.B.T6I = 0x0; /* Set T6 input prescaler(2^0=1) */
8000aa8a:	8f 7f c0 f1 	andn %d15,%d15,7
8000aa8e:	68 8f       	st.w [%a15]32,%d15
    MODULE_GPT120.T6CON.B.T6OE = 0x1; /* Overflow/Underflow Output Enable */
8000aa90:	4c f8       	ld.w %d15,[%a15]32
8000aa92:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000aa96:	68 8f       	st.w [%a15]32,%d15
    MODULE_GPT120.T6CON.B.T6SR = 0x1; /* Reload from register CAPREL Enabled */
8000aa98:	4c f8       	ld.w %d15,[%a15]32
8000aa9a:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000aa9e:	68 8f       	st.w [%a15]32,%d15
    MODULE_GPT120.T6.U = 250u; /* Set T6 start value (10us) */
8000aaa0:	da fa       	mov %d15,250
8000aaa2:	59 ff 04 10 	st.w [%a15]68,%d15

    MODULE_GPT120.CAPREL.U = 250u; /* Set CAPREL reload value */
8000aaa6:	68 cf       	st.w [%a15]48,%d15
	InterruptInstall(SRC_ID_GPT120T6, (void(*)(int))IsrGpt2T6Handler, 2, 0);
8000aaa8:	1d 00 c9 06 	j 8000b83a <InterruptInstall>

8000aaac <runGpt12_T3>:
}


void runGpt12_T3(void)
{
	MODULE_GPT120.T3CON.B.T3R = 1;
8000aaac:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
8000aab0:	4c f5       	ld.w %d15,[%a15]20
8000aab2:	96 40       	or %d15,64
8000aab4:	68 5f       	st.w [%a15]20,%d15
8000aab6:	00 90       	ret 

8000aab8 <stopGpt12_T3>:
}

void stopGpt12_T3(void)
{
	MODULE_GPT120.T3CON.B.T3R = 0;
8000aab8:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
8000aabc:	4c f5       	ld.w %d15,[%a15]20
8000aabe:	8f 0f c4 f1 	andn %d15,%d15,64
8000aac2:	68 5f       	st.w [%a15]20,%d15
8000aac4:	00 90       	ret 

8000aac6 <runGpt12_T6>:
}

void runGpt12_T6(void)
{
	MODULE_GPT120.T6CON.B.T6R = 1;
8000aac6:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
8000aaca:	4c f8       	ld.w %d15,[%a15]32
8000aacc:	96 40       	or %d15,64
8000aace:	68 8f       	st.w [%a15]32,%d15
8000aad0:	00 90       	ret 

8000aad2 <stopGpt12_T6>:
}

void stopGpt12_T6(void)
{
	MODULE_GPT120.T6CON.B.T6R = 0;
8000aad2:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
8000aad6:	4c f8       	ld.w %d15,[%a15]32
8000aad8:	8f 0f c4 f1 	andn %d15,%d15,64
8000aadc:	68 8f       	st.w [%a15]32,%d15
8000aade:	00 90       	ret 

8000aae0 <runGpt12_T4>:
}

void runGpt12_T4(void)
{
	MODULE_GPT120.T4CON.B.T4R = 1;
8000aae0:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
8000aae4:	4c f6       	ld.w %d15,[%a15]24
8000aae6:	96 40       	or %d15,64
8000aae8:	68 6f       	st.w [%a15]24,%d15
8000aaea:	00 90       	ret 

8000aaec <stopGpt12_T4>:
}

void stopGpt12_T4()
{
	MODULE_GPT120.T4CON.B.T4R = 0;
8000aaec:	c5 ff c0 82 	lea %a15,f0002e00 <_SMALL_DATA4_+0x3fffae00>
8000aaf0:	4c f6       	ld.w %d15,[%a15]24
8000aaf2:	8f 0f c4 f1 	andn %d15,%d15,64
8000aaf6:	68 6f       	st.w [%a15]24,%d15
8000aaf8:	00 90       	ret 

8000aafa <setGpt12_T4>:
}

void setGpt12_T4(unsigned short value)
{
	MODULE_GPT120.T4.U = value;
8000aafa:	a5 f4 fc 82 	st.w f0002e3c <_SMALL_DATA4_+0x3fffae3c>,%d4
8000aafe:	00 90       	ret 

8000ab00 <getGpt12_T4>:
}

unsigned int getGpt12_T4(void)
{
	return MODULE_GPT120.T4.U;
8000ab00:	85 f2 fc 82 	ld.w %d2,f0002e3c <_SMALL_DATA4_+0x3fffae3c>
}
8000ab04:	00 90       	ret 

8000ab06 <init_VADC>:

void init_VADC(void)
{
    /* VADC Module Enable */
	unlock_wdtcon();
    MODULE_VADC.CLC.B.DISR = 0x0;                 // Enable VADC Module (clock)
8000ab06:	91 20 00 ff 	movh.a %a15,61442
#include <machine/intrinsics.h>

void init_VADC(void)
{
    /* VADC Module Enable */
	unlock_wdtcon();
8000ab0a:	6d 00 d7 36 	call 800118b8 <unlock_wdtcon>
    MODULE_VADC.CLC.B.DISR = 0x0;                 // Enable VADC Module (clock)
8000ab0e:	4c f0       	ld.w %d15,[%a15]0
8000ab10:	8f 1f c0 f1 	andn %d15,%d15,1
8000ab14:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000ab16:	6d 00 e7 36 	call 800118e4 <lock_wdtcon>
    while(MODULE_VADC.CLC.B.DISS != 0);     	    // Wait until module is enabled
8000ab1a:	40 f2       	mov.aa %a2,%a15
8000ab1c:	4c 20       	ld.w %d15,[%a2]0
8000ab1e:	91 20 00 ff 	movh.a %a15,61442
8000ab22:	6f 1f fd ff 	jnz.t %d15,1,8000ab1c <init_VADC+0x16>

    /* VADC Group Configuration */
    MODULE_VADC.G[4].ARBPR.B.PRIO0 = 0x3;		    // Highest Priority for Request Source 0
8000ab26:	19 ff 44 21 	ld.w %d15,[%a15]5252 <f0021484 <_SMALL_DATA4_+0x40019484>>
8000ab2a:	96 03       	or %d15,3
8000ab2c:	59 ff 44 21 	st.w [%a15]5252 <f0021484 <_SMALL_DATA4_+0x40019484>>,%d15
    MODULE_VADC.G[4].ARBPR.B.CSM0 = 0x0;          // Conversion Start Mode : Wait-for-start mode
8000ab30:	19 ff 44 21 	ld.w %d15,[%a15]5252 <f0021484 <_SMALL_DATA4_+0x40019484>>
8000ab34:	8f 8f c0 f1 	andn %d15,%d15,8
8000ab38:	59 ff 44 21 	st.w [%a15]5252 <f0021484 <_SMALL_DATA4_+0x40019484>>,%d15
    MODULE_VADC.G[4].ARBPR.B.ASEN0 = 0x1;		    // Arbitration Source Input 0 Enable
8000ab3c:	19 ff 44 21 	ld.w %d15,[%a15]5252 <f0021484 <_SMALL_DATA4_+0x40019484>>
8000ab40:	b7 ff 01 fc 	insert %d15,%d15,15,24,1
8000ab44:	59 ff 44 21 	st.w [%a15]5252 <f0021484 <_SMALL_DATA4_+0x40019484>>,%d15

    MODULE_VADC.G[4].QMR0.B.ENGT  = 0x1;		    // Enable Conversion Requests
8000ab48:	19 ff 44 41 	ld.w %d15,[%a15]5380 <f0021504 <_SMALL_DATA4_+0x40019504>>
8000ab4c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
8000ab50:	59 ff 44 41 	st.w [%a15]5380 <f0021504 <_SMALL_DATA4_+0x40019504>>,%d15
    MODULE_VADC.G[4].QMR0.B.FLUSH = 0x1;          // Clear all Queue Entries
8000ab54:	19 ff 44 41 	ld.w %d15,[%a15]5380 <f0021504 <_SMALL_DATA4_+0x40019504>>
8000ab58:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000ab5c:	59 ff 44 41 	st.w [%a15]5380 <f0021504 <_SMALL_DATA4_+0x40019504>>,%d15

    MODULE_VADC.G[4].ARBCFG.B.ANONC = 0x3;        // Analog Converter : Normal Operation
8000ab60:	19 ff 40 21 	ld.w %d15,[%a15]5248 <f0021480 <_SMALL_DATA4_+0x40019480>>
8000ab64:	96 03       	or %d15,3
8000ab66:	59 ff 40 21 	st.w [%a15]5248 <f0021480 <_SMALL_DATA4_+0x40019480>>,%d15

    MODULE_VADC.G[4].ICLASS[0].B.CMS = 0x0;       // Group-specific Class 0
8000ab6a:	19 ff 60 21 	ld.w %d15,[%a15]5280 <f00214a0 <_SMALL_DATA4_+0x400194a0>>
8000ab6e:	b7 0f 03 f4 	insert %d15,%d15,0,8,3
8000ab72:	59 ff 60 21 	st.w [%a15]5280 <f00214a0 <_SMALL_DATA4_+0x400194a0>>,%d15
                                            // Conversion Mode : Standard Conversion (12-bit)

    /* VADC Group 4 Channel 7 Setting */
    MODULE_VADC.G[4].CHCTR[7].B.RESPOS = 0x1;     // Read Results Right-aligned
8000ab76:	19 ff 5c 81 	ld.w %d15,[%a15]5660 <f002161c <_SMALL_DATA4_+0x4001961c>>
8000ab7a:	b7 ff 81 fa 	insert %d15,%d15,15,21,1
8000ab7e:	59 ff 5c 81 	st.w [%a15]5660 <f002161c <_SMALL_DATA4_+0x4001961c>>,%d15
    MODULE_VADC.G[4].CHCTR[7].B.RESREG = 0x1;     // Store Result in Group Result Register G0RES1
8000ab82:	19 ff 5c 81 	ld.w %d15,[%a15]5660 <f002161c <_SMALL_DATA4_+0x4001961c>>
8000ab86:	b7 1f 04 f8 	insert %d15,%d15,1,16,4
8000ab8a:	59 ff 5c 81 	st.w [%a15]5660 <f002161c <_SMALL_DATA4_+0x4001961c>>,%d15
    MODULE_VADC.G[4].CHCTR[7].B.ICLSEL = 0x0;     // Use Group-specific Class 0
8000ab8e:	19 ff 5c 81 	ld.w %d15,[%a15]5660 <f002161c <_SMALL_DATA4_+0x4001961c>>
8000ab92:	8f 3f c0 f1 	andn %d15,%d15,3
8000ab96:	59 ff 5c 81 	st.w [%a15]5660 <f002161c <_SMALL_DATA4_+0x4001961c>>,%d15
8000ab9a:	00 90       	ret 

8000ab9c <VADC_startConversion>:
}

void VADC_startConversion(void)
{
    /* No fill and Start Queue */
	MODULE_VADC.G[4].QINR0.B.REQCHNR = 0x07;				// Request Channel Number : 7
8000ab9c:	91 20 00 ff 	movh.a %a15,61442
8000aba0:	19 ff 50 41 	ld.w %d15,[%a15]5392 <f0021510 <_SMALL_DATA4_+0x40019510>>
8000aba4:	b7 7f 05 f0 	insert %d15,%d15,7,0,5
8000aba8:	59 ff 50 41 	st.w [%a15]5392 <f0021510 <_SMALL_DATA4_+0x40019510>>,%d15
	MODULE_VADC.G[4].QINR0.B.RF = 0x0; 				    // No fill : it is converted once
8000abac:	19 ff 50 41 	ld.w %d15,[%a15]5392 <f0021510 <_SMALL_DATA4_+0x40019510>>
8000abb0:	8f 0f c2 f1 	andn %d15,%d15,32
8000abb4:	59 ff 50 41 	st.w [%a15]5392 <f0021510 <_SMALL_DATA4_+0x40019510>>,%d15

	MODULE_VADC.G[4].QMR0.B.TREV = 0x1;  					// Generate a Trigger Event
8000abb8:	19 ff 44 41 	ld.w %d15,[%a15]5380 <f0021504 <_SMALL_DATA4_+0x40019504>>
8000abbc:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000abc0:	59 ff 44 41 	st.w [%a15]5380 <f0021504 <_SMALL_DATA4_+0x40019504>>,%d15
8000abc4:	00 90       	ret 

8000abc6 <VADC_readResult>:
}

unsigned int VADC_readResult(void)
{
	unsigned int result;
	while(MODULE_VADC.G[4].RES[1].B.VF == 0);			    // Valid Flag, Wait until New Result Available
8000abc6:	91 20 00 ff 	movh.a %a15,61442
8000abca:	19 ff 44 c1 	ld.w %d15,[%a15]5892 <f0021704 <_SMALL_DATA4_+0x40019704>>
8000abce:	ff 0f fe 7f 	jge %d15,0,8000abca <VADC_readResult+0x4>

	result = (MODULE_VADC.G[4].RES[1].B.RESULT);  		// Read Result
8000abd2:	91 20 00 ff 	movh.a %a15,61442
8000abd6:	19 f2 44 c1 	ld.w %d2,[%a15]5892 <f0021704 <_SMALL_DATA4_+0x40019704>>

	return result;
}
8000abda:	37 02 70 20 	extr.u %d2,%d2,0,16
8000abde:	00 90       	ret 

8000abe0 <delay_ms>:
#include "etc.h"

void delay_ms(unsigned int delay_time)
{
8000abe0:	20 08       	sub.a %sp,8
	volatile unsigned int i, j;
	for (i = 0; i < delay_time; i++)
8000abe2:	82 0f       	mov %d15,0
8000abe4:	78 00       	st.w [%sp]0,%d15
8000abe6:	54 a2       	ld.w %d2,[%sp]
		for (j = 0; j < 18200; j++)
8000abe8:	82 03       	mov %d3,0
8000abea:	3b 80 71 f4 	mov %d15,18200
#include "etc.h"

void delay_ms(unsigned int delay_time)
{
	volatile unsigned int i, j;
	for (i = 0; i < delay_time; i++)
8000abee:	3f 42 09 80 	jlt.u %d2,%d4,8000ac00 <delay_ms+0x20>
8000abf2:	3c 20       	j 8000ac32 <delay_ms+0x52>
8000abf4:	54 a2       	ld.w %d2,[%sp]
8000abf6:	c2 12       	add %d2,1
8000abf8:	74 a2       	st.w [%sp],%d2
8000abfa:	54 a2       	ld.w %d2,[%sp]
8000abfc:	7f 42 1c 80 	jge.u %d2,%d4,8000ac34 <delay_ms+0x54>
		for (j = 0; j < 18200; j++)
8000ac00:	59 a3 04 00 	st.w [%sp]4,%d3
8000ac04:	19 a2 04 00 	ld.w %d2,[%sp]4
8000ac08:	7f f2 f6 ff 	jge.u %d2,%d15,8000abf4 <delay_ms+0x14>
8000ac0c:	19 a2 04 00 	ld.w %d2,[%sp]4
8000ac10:	c2 12       	add %d2,1
8000ac12:	59 a2 04 00 	st.w [%sp]4,%d2
8000ac16:	19 a2 04 00 	ld.w %d2,[%sp]4
8000ac1a:	7f f2 ed ff 	jge.u %d2,%d15,8000abf4 <delay_ms+0x14>
8000ac1e:	19 a2 04 00 	ld.w %d2,[%sp]4
8000ac22:	c2 12       	add %d2,1
8000ac24:	59 a2 04 00 	st.w [%sp]4,%d2
8000ac28:	19 a2 04 00 	ld.w %d2,[%sp]4
8000ac2c:	3f f2 f0 ff 	jlt.u %d2,%d15,8000ac0c <delay_ms+0x2c>
8000ac30:	3c e2       	j 8000abf4 <delay_ms+0x14>
8000ac32:	00 90       	ret 
8000ac34:	00 90       	ret 

8000ac36 <Init_Buzzer>:
/* Function prototype */
void IsrGpt120T3Handler_Beep(void);

void Init_Buzzer(void)
{
	MODULE_P02.IOCR0.B.PC3 = 0b10000;
8000ac36:	91 40 00 ff 	movh.a %a15,61444
8000ac3a:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000ac3e:	4c f4       	ld.w %d15,[%a15]16
8000ac40:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000ac44:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000ac48:	68 4f       	st.w [%a15]16,%d15
8000ac4a:	00 90       	ret 

8000ac4c <Init_Buzzer_PWM>:
8000ac4c:	91 40 00 ff 	movh.a %a15,61444
8000ac50:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000ac54:	4c f4       	ld.w %d15,[%a15]16
8000ac56:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000ac5a:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000ac5e:	68 4f       	st.w [%a15]16,%d15

void Init_Buzzer_PWM(void)
{
	Init_Buzzer();

	init_gpt1(); /* Init Timer */
8000ac60:	6d ff ba fe 	call 8000a9d4 <init_gpt1>
	runGpt12_T3(); /* Start Timer */
}

void setBeepCycle(int cycle)
{
	beepOnOff = cycle;
8000ac64:	82 0f       	mov %d15,0
8000ac66:	91 00 00 f7 	movh.a %a15,28672
8000ac6a:	59 ff 88 f1 	st.w [%a15]7112 <70001bc8 <beepOnOff>>,%d15
{
	Init_Buzzer();

	init_gpt1(); /* Init Timer */
	setBeepCycle(0); /* Initial buzzer beep off */
	runGpt12_T3(); /* Start Timer */
8000ac6e:	1d ff 1f ff 	j 8000aaac <runGpt12_T3>

8000ac72 <setBeepCycle>:
}

void setBeepCycle(int cycle)
{
	beepOnOff = cycle;
8000ac72:	91 00 00 f7 	movh.a %a15,28672
8000ac76:	59 f4 88 f1 	st.w [%a15]7112 <70001bc8 <beepOnOff>>,%d4
8000ac7a:	00 90       	ret 

8000ac7c <Beep>:
}

void Beep(unsigned int hz)
{
	volatile int loop = 1000000 / hz / 2; /*   us  */
8000ac7c:	7b 80 00 f0 	movh %d15,8
8000ac80:	1b 0f 12 fa 	addi %d15,%d15,-24288
8000ac84:	4b 4f 11 42 	div.u %e4,%d15,%d4
{
	beepOnOff = cycle;
}

void Beep(unsigned int hz)
{
8000ac88:	20 10       	sub.a %sp,16
	volatile int loop = 1000000 / hz / 2; /*   us  */
	for (volatile int i = 0; i < loop; i++) /* loop * 1us  delay */
8000ac8a:	82 0f       	mov %d15,0
	beepOnOff = cycle;
}

void Beep(unsigned int hz)
{
	volatile int loop = 1000000 / hz / 2; /*   us  */
8000ac8c:	74 a4       	st.w [%sp],%d4
	for (volatile int i = 0; i < loop; i++) /* loop * 1us  delay */
8000ac8e:	78 01       	st.w [%sp]4,%d15
8000ac90:	19 a3 04 00 	ld.w %d3,[%sp]4
8000ac94:	58 00       	ld.w %d15,[%sp]0
		for (volatile int j = 0; j < 1; j++)
8000ac96:	82 02       	mov %d2,0
}

void Beep(unsigned int hz)
{
	volatile int loop = 1000000 / hz / 2; /*   us  */
	for (volatile int i = 0; i < loop; i++) /* loop * 1us  delay */
8000ac98:	7f f3 21 00 	jge %d3,%d15,8000acda <Beep+0x5e>
		for (volatile int j = 0; j < 1; j++)
8000ac9c:	59 a2 08 00 	st.w [%sp]8,%d2
8000aca0:	58 02       	ld.w %d15,[%sp]8
8000aca2:	ff 1f 13 00 	jge %d15,1,8000acc8 <Beep+0x4c>
			for (volatile int k = 0; k < 1; k++)
8000aca6:	59 a2 0c 00 	st.w [%sp]12,%d2
8000acaa:	58 03       	ld.w %d15,[%sp]12
8000acac:	4e f8       	jgtz %d15,8000acbc <Beep+0x40>
}

static __inline__ __attribute__((__always_inline__))
void _nop (void)
{
  __asm__ volatile ("nop" ::: "memory");
8000acae:	00 00       	nop 
8000acb0:	58 03       	ld.w %d15,[%sp]12
8000acb2:	c2 1f       	add %d15,1
8000acb4:	78 03       	st.w [%sp]12,%d15
8000acb6:	58 03       	ld.w %d15,[%sp]12
8000acb8:	bf 1f fb 7f 	jlt %d15,1,8000acae <Beep+0x32>

void Beep(unsigned int hz)
{
	volatile int loop = 1000000 / hz / 2; /*   us  */
	for (volatile int i = 0; i < loop; i++) /* loop * 1us  delay */
		for (volatile int j = 0; j < 1; j++)
8000acbc:	58 02       	ld.w %d15,[%sp]8
8000acbe:	c2 1f       	add %d15,1
8000acc0:	78 02       	st.w [%sp]8,%d15
8000acc2:	58 02       	ld.w %d15,[%sp]8
8000acc4:	bf 1f f1 7f 	jlt %d15,1,8000aca6 <Beep+0x2a>
}

void Beep(unsigned int hz)
{
	volatile int loop = 1000000 / hz / 2; /*   us  */
	for (volatile int i = 0; i < loop; i++) /* loop * 1us  delay */
8000acc8:	58 01       	ld.w %d15,[%sp]4
8000acca:	c2 1f       	add %d15,1
8000accc:	78 01       	st.w [%sp]4,%d15
8000acce:	19 a3 04 00 	ld.w %d3,[%sp]4
8000acd2:	58 00       	ld.w %d15,[%sp]0
8000acd4:	3f f3 e4 7f 	jlt %d3,%d15,8000ac9c <Beep+0x20>
8000acd8:	00 90       	ret 
8000acda:	00 90       	ret 

8000acdc <IsrGpt120T3Handler_Beep>:
				_nop();
}

void IsrGpt120T3Handler_Beep(void)
{
	MODULE_P02.OUT.B.P3 ^= 1;
8000acdc:	91 40 00 ff 	movh.a %a15,61444
8000ace0:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000ace4:	4c f0       	ld.w %d15,[%a15]0
8000ace6:	07 ff 83 f1 	nand.t %d15,%d15,3,%d15,3
8000acea:	8f 3f 00 20 	sh %d2,%d15,3
8000acee:	4c f0       	ld.w %d15,[%a15]0
8000acf0:	8f 8f c0 f1 	andn %d15,%d15,8
8000acf4:	a6 2f       	or %d15,%d2
8000acf6:	68 0f       	st.w [%a15]0,%d15
8000acf8:	00 90       	ret 

8000acfa <Init_GPIO>:
#include "tc27xd/IfxPort_PinMap.h"
#include "bsw/etc/etc.h"
void Init_GPIO(void)
{
	/* Set P10.2(LED1) as push-pull output */
	MODULE_P10.IOCR0.B.PC2 = 0b10000;
8000acfa:	91 40 00 ff 	movh.a %a15,61444
8000acfe:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000ad02:	4c f4       	ld.w %d15,[%a15]16

	/* Set P10.1(LED2) as push-pull output */
	MODULE_P10.IOCR0.B.PC1 = 0b10000;

	/* Set P2.0(SW1) as input pull-up */
	MODULE_P02.IOCR0.B.PC0 = 0b00010;
8000ad04:	91 40 00 cf 	movh.a %a12,61444
#include "tc27xd/IfxPort_PinMap.h"
#include "bsw/etc/etc.h"
void Init_GPIO(void)
{
	/* Set P10.2(LED1) as push-pull output */
	MODULE_P10.IOCR0.B.PC2 = 0b10000;
8000ad08:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000ad0c:	b7 ff 81 fb 	insert %d15,%d15,15,23,1

	/* Set P10.1(LED2) as push-pull output */
	MODULE_P10.IOCR0.B.PC1 = 0b10000;

	/* Set P2.0(SW1) as input pull-up */
	MODULE_P02.IOCR0.B.PC0 = 0b00010;
8000ad10:	d9 cc 00 8a 	lea %a12,[%a12]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
#include "tc27xd/IfxPort_PinMap.h"
#include "bsw/etc/etc.h"
void Init_GPIO(void)
{
	/* Set P10.2(LED1) as push-pull output */
	MODULE_P10.IOCR0.B.PC2 = 0b10000;
8000ad14:	68 4f       	st.w [%a15]16,%d15

	/* Set P10.1(LED2) as push-pull output */
	MODULE_P10.IOCR0.B.PC1 = 0b10000;
8000ad16:	4c f4       	ld.w %d15,[%a15]16
8000ad18:	3b 00 08 50 	mov %d5,128
8000ad1c:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000ad20:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000ad24:	68 4f       	st.w [%a15]16,%d15

	/* Set P2.0(SW1) as input pull-up */
	MODULE_P02.IOCR0.B.PC0 = 0b00010;
8000ad26:	4c c4       	ld.w %d15,[%a12]16

	/* Set P2.1(SW2) as input pull-up */
	MODULE_P02.IOCR0.B.PC1 = 0b00010;

	/*P20_6    Digital Output (can )*/
	IfxPort_setPinModeOutput(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
8000ad28:	91 00 00 f7 	movh.a %a15,28672

	/* Set P10.1(LED2) as push-pull output */
	MODULE_P10.IOCR0.B.PC1 = 0b10000;

	/* Set P2.0(SW1) as input pull-up */
	MODULE_P02.IOCR0.B.PC0 = 0b00010;
8000ad2c:	b7 2f 85 f1 	insert %d15,%d15,2,3,5

	/* Set P2.1(SW2) as input pull-up */
	MODULE_P02.IOCR0.B.PC1 = 0b00010;

	/*P20_6    Digital Output (can )*/
	IfxPort_setPinModeOutput(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
8000ad30:	d9 fd e8 10 	lea %a13,[%a15]3176 <70000c68 <IfxPort_P20_6>>

	/* Set P10.1(LED2) as push-pull output */
	MODULE_P10.IOCR0.B.PC1 = 0b10000;

	/* Set P2.0(SW1) as input pull-up */
	MODULE_P02.IOCR0.B.PC0 = 0b00010;
8000ad34:	6c c4       	st.w [%a12]16,%d15

	/* Set P2.1(SW2) as input pull-up */
	MODULE_P02.IOCR0.B.PC1 = 0b00010;
8000ad36:	4c c4       	ld.w %d15,[%a12]16
8000ad38:	b7 2f 85 f5 	insert %d15,%d15,2,11,5
8000ad3c:	6c c4       	st.w [%a12]16,%d15
8000ad3e:	99 f4 e8 10 	ld.a %a4,[%a15]3176 <70000c68 <IfxPort_P20_6>>
8000ad42:	39 d4 04 00 	ld.bu %d4,[%a13]4 <70000c68 <IfxPort_P20_6>>
8000ad46:	6d ff 72 e0 	call 80006e2a <IfxPort_setPinMode>

	/*P20_6    Digital Output (can )*/
	IfxPort_setPinModeOutput(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
	IfxPort_setPinLow(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex);
8000ad4a:	99 ff e8 10 	ld.a %a15,[%a15]3176 <70000c68 <IfxPort_P20_6>>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000ad4e:	0c d4       	ld.bu %d15,[%a13]4
8000ad50:	7b 10 00 20 	movh %d2,1
8000ad54:	0f f2 00 f0 	sh %d15,%d2,%d15
8000ad58:	68 1f       	st.w [%a15]4,%d15

	/*P00_0~7 , P11_2,9,11      LCD Output*/
	MODULE_P00.IOCR0.B.PC0=0x10;
8000ad5a:	91 40 00 ff 	movh.a %a15,61444
8000ad5e:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000ad62:	4c f4       	ld.w %d15,[%a15]16
8000ad64:	8f 8f cf f1 	andn %d15,%d15,248
8000ad68:	96 80       	or %d15,128
8000ad6a:	68 4f       	st.w [%a15]16,%d15
	MODULE_P00.IOCR0.B.PC1=0x10;
8000ad6c:	4c f4       	ld.w %d15,[%a15]16
8000ad6e:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000ad72:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000ad76:	68 4f       	st.w [%a15]16,%d15
	MODULE_P00.IOCR0.B.PC2=0x10;
8000ad78:	4c f4       	ld.w %d15,[%a15]16
8000ad7a:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000ad7e:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000ad82:	68 4f       	st.w [%a15]16,%d15
	MODULE_P00.IOCR0.B.PC3=0x10;
8000ad84:	4c f4       	ld.w %d15,[%a15]16
8000ad86:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000ad8a:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000ad8e:	68 4f       	st.w [%a15]16,%d15
	MODULE_P00.IOCR4.B.PC4=0x10;
8000ad90:	4c f5       	ld.w %d15,[%a15]20
8000ad92:	8f 8f cf f1 	andn %d15,%d15,248
8000ad96:	96 80       	or %d15,128
8000ad98:	68 5f       	st.w [%a15]20,%d15
	MODULE_P00.IOCR4.B.PC5=0x10;
8000ad9a:	4c f5       	ld.w %d15,[%a15]20
8000ad9c:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000ada0:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000ada4:	68 5f       	st.w [%a15]20,%d15
	MODULE_P00.IOCR4.B.PC6=0x10;
8000ada6:	4c f5       	ld.w %d15,[%a15]20
8000ada8:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000adac:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000adb0:	68 5f       	st.w [%a15]20,%d15
	MODULE_P00.IOCR4.B.PC7=0x10;
8000adb2:	4c f5       	ld.w %d15,[%a15]20
8000adb4:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000adb8:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000adbc:	68 5f       	st.w [%a15]20,%d15
	MODULE_P11.IOCR0.B.PC2=0x10;
8000adbe:	91 40 00 ff 	movh.a %a15,61444
8000adc2:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
8000adc6:	4c f4       	ld.w %d15,[%a15]16
8000adc8:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000adcc:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000add0:	68 4f       	st.w [%a15]16,%d15
	MODULE_P11.IOCR8.B.PC11=0x10;
8000add2:	4c f6       	ld.w %d15,[%a15]24
8000add4:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000add8:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000addc:	68 6f       	st.w [%a15]24,%d15
	MODULE_P11.IOCR8.B.PC9=0x10;
8000adde:	4c f6       	ld.w %d15,[%a15]24
8000ade0:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000ade4:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000ade8:	68 6f       	st.w [%a15]24,%d15

	/*P02_3,4,5   LED Output*/
	MODULE_P02.IOCR0.B.PC3=0x10;
8000adea:	4c c4       	ld.w %d15,[%a12]16
8000adec:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000adf0:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000adf4:	6c c4       	st.w [%a12]16,%d15
	MODULE_P02.IOCR4.B.PC4=0x10;
8000adf6:	4c c5       	ld.w %d15,[%a12]20
8000adf8:	8f 8f cf f1 	andn %d15,%d15,248
8000adfc:	96 80       	or %d15,128
8000adfe:	6c c5       	st.w [%a12]20,%d15
	MODULE_P02.IOCR4.B.PC5=0x10;
8000ae00:	4c c5       	ld.w %d15,[%a12]20
8000ae02:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000ae06:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000ae0a:	6c c5       	st.w [%a12]20,%d15
8000ae0c:	00 90       	ret 

8000ae0e <setHeadlampLED>:

}
void setHeadlampLED(int onoff){
	if(onoff){
		MODULE_P02.OUT.B.P4=1;
8000ae0e:	91 40 00 ff 	movh.a %a15,61444
8000ae12:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000ae16:	4c f0       	ld.w %d15,[%a15]0
	MODULE_P02.IOCR4.B.PC4=0x10;
	MODULE_P02.IOCR4.B.PC5=0x10;

}
void setHeadlampLED(int onoff){
	if(onoff){
8000ae18:	f6 45       	jnz %d4,8000ae22 <setHeadlampLED+0x14>
		MODULE_P02.OUT.B.P4=1;
	}
	else{
		MODULE_P02.OUT.B.P4=0;
8000ae1a:	8f 0f c1 f1 	andn %d15,%d15,16
8000ae1e:	68 0f       	st.w [%a15]0,%d15
8000ae20:	00 90       	ret 
	MODULE_P02.IOCR4.B.PC5=0x10;

}
void setHeadlampLED(int onoff){
	if(onoff){
		MODULE_P02.OUT.B.P4=1;
8000ae22:	96 10       	or %d15,16
8000ae24:	68 0f       	st.w [%a15]0,%d15
8000ae26:	00 90       	ret 

8000ae28 <setLED1>:
}
void setLED1(int onoff)	// on if true, off if false
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P2 = 1;
8000ae28:	91 40 00 ff 	movh.a %a15,61444
8000ae2c:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000ae30:	4c f0       	ld.w %d15,[%a15]0
		MODULE_P02.OUT.B.P4=0;
	}
}
void setLED1(int onoff)	// on if true, off if false
{
	if(onoff)
8000ae32:	f6 45       	jnz %d4,8000ae3c <setLED1+0x14>
	{
		MODULE_P10.OUT.B.P2 = 1;
	}
	else
	{
		MODULE_P10.OUT.B.P2 = 0;
8000ae34:	8f 4f c0 f1 	andn %d15,%d15,4
8000ae38:	68 0f       	st.w [%a15]0,%d15
8000ae3a:	00 90       	ret 
}
void setLED1(int onoff)	// on if true, off if false
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P2 = 1;
8000ae3c:	96 04       	or %d15,4
8000ae3e:	68 0f       	st.w [%a15]0,%d15
8000ae40:	00 90       	ret 

8000ae42 <setLED2>:

void setLED2(int onoff)
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P1 = 1;
8000ae42:	91 40 00 ff 	movh.a %a15,61444
8000ae46:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000ae4a:	4c f0       	ld.w %d15,[%a15]0
	}
}

void setLED2(int onoff)
{
	if(onoff)
8000ae4c:	f6 45       	jnz %d4,8000ae56 <setLED2+0x14>
	{
		MODULE_P10.OUT.B.P1 = 1;
	}
	else
	{
		MODULE_P10.OUT.B.P1 = 0;
8000ae4e:	8f 2f c0 f1 	andn %d15,%d15,2
8000ae52:	68 0f       	st.w [%a15]0,%d15
8000ae54:	00 90       	ret 

void setLED2(int onoff)
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P1 = 1;
8000ae56:	96 02       	or %d15,2
8000ae58:	68 0f       	st.w [%a15]0,%d15
8000ae5a:	00 90       	ret 

8000ae5c <toggleLED1>:
	}
}

void toggleLED1(void)
{
	MODULE_P10.OUT.B.P2 ^= 1;
8000ae5c:	91 40 00 ff 	movh.a %a15,61444
8000ae60:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000ae64:	4c f0       	ld.w %d15,[%a15]0
8000ae66:	07 ff 02 f1 	nand.t %d15,%d15,2,%d15,2
8000ae6a:	8f 2f 00 20 	sh %d2,%d15,2
8000ae6e:	4c f0       	ld.w %d15,[%a15]0
8000ae70:	8f 4f c0 f1 	andn %d15,%d15,4
8000ae74:	a6 2f       	or %d15,%d2
8000ae76:	68 0f       	st.w [%a15]0,%d15
8000ae78:	00 90       	ret 

8000ae7a <toggleLED2>:
}

void toggleLED2(void)
{
	MODULE_P10.OUT.B.P1 ^= 1;
8000ae7a:	91 40 00 ff 	movh.a %a15,61444
8000ae7e:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000ae82:	4c f0       	ld.w %d15,[%a15]0
8000ae84:	07 ff 81 f0 	nand.t %d15,%d15,1,%d15,1
8000ae88:	8f 1f 00 20 	sh %d2,%d15,1
8000ae8c:	4c f0       	ld.w %d15,[%a15]0
8000ae8e:	8f 2f c0 f1 	andn %d15,%d15,2
8000ae92:	a6 2f       	or %d15,%d2
8000ae94:	68 0f       	st.w [%a15]0,%d15
8000ae96:	00 90       	ret 

8000ae98 <getSW1>:
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000ae98:	91 40 00 ff 	movh.a %a15,61444
8000ae9c:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000aea0:	48 92       	ld.w %d2,[%a15]36
}
8000aea2:	8f 12 00 21 	and %d2,%d2,1
8000aea6:	00 90       	ret 

8000aea8 <getSW2>:

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000aea8:	91 40 00 ff 	movh.a %a15,61444
8000aeac:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000aeb0:	48 92       	ld.w %d2,[%a15]36
}
8000aeb2:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000aeb6:	00 90       	ret 

8000aeb8 <getSW1_Debounce>:

int getSW1_Debounce(void)
{
8000aeb8:	20 18       	sub.a %sp,24
	volatile int SW1, i, cnt = 0;
8000aeba:	82 0f       	mov %d15,0
	volatile char buf[10] = { 0, };
8000aebc:	d9 a2 0e 00 	lea %a2,[%sp]14
	return MODULE_P02.IN.B.P1;
}

int getSW1_Debounce(void)
{
	volatile int SW1, i, cnt = 0;
8000aec0:	78 02       	st.w [%sp]8,%d15
	volatile char buf[10] = { 0, };
8000aec2:	40 23       	mov.aa %a3,%a2
8000aec4:	82 0f       	mov %d15,0
8000aec6:	a0 4f       	mov.a %a15,4
8000aec8:	a4 3f       	st.h [%a3+],%d15
8000aeca:	fc ff       	loop %a15,8000aec8 <getSW1_Debounce+0x10>

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
8000aecc:	19 a2 08 00 	ld.w %d2,[%sp]8
8000aed0:	3b 00 71 f2 	mov %d15,10000
	MODULE_P10.OUT.B.P1 ^= 1;
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000aed4:	91 40 00 3f 	movh.a %a3,61444
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000aed8:	82 03       	mov %d3,0
	MODULE_P10.OUT.B.P1 ^= 1;
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000aeda:	d9 33 00 8a 	lea %a3,[%a3]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
{
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
8000aede:	02 f4       	mov %d4,%d15
8000aee0:	7f f2 31 00 	jge %d2,%d15,8000af42 <getSW1_Debounce+0x8a>
		for (i = 0; i < 10; i++) {
8000aee4:	59 a3 04 00 	st.w [%sp]4,%d3
8000aee8:	58 01       	ld.w %d15,[%sp]4
8000aeea:	8b af 40 f2 	lt %d15,%d15,10
8000aeee:	6e 0d       	jz %d15,8000af08 <getSW1_Debounce+0x50>
			buf[i] = getSW1();
8000aef0:	d8 01       	ld.a %a15,[%sp]4
	MODULE_P10.OUT.B.P1 ^= 1;
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000aef2:	4c 39       	ld.w %d15,[%a3]36
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW1();
8000aef4:	30 2f       	add.a %a15,%a2
8000aef6:	16 01       	and %d15,1
8000aef8:	28 0f       	st.b [%a15]0,%d15
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000aefa:	58 01       	ld.w %d15,[%sp]4
8000aefc:	c2 1f       	add %d15,1
8000aefe:	78 01       	st.w [%sp]4,%d15
8000af00:	58 01       	ld.w %d15,[%sp]4
8000af02:	8b af 40 f2 	lt %d15,%d15,10
8000af06:	ee f5       	jnz %d15,8000aef0 <getSW1_Debounce+0x38>
			buf[i] = getSW1();
		}
		for (i = 0; i < 10; i++) {
8000af08:	59 a3 04 00 	st.w [%sp]4,%d3
8000af0c:	58 01       	ld.w %d15,[%sp]4
8000af0e:	8b af 40 f2 	lt %d15,%d15,10
8000af12:	6e 12       	jz %d15,8000af36 <getSW1_Debounce+0x7e>
			if (buf[0] != buf[i]) {
8000af14:	79 a2 0e 00 	ld.b %d2,[%sp]14
8000af18:	d8 01       	ld.a %a15,[%sp]4
8000af1a:	30 2f       	add.a %a15,%a2
8000af1c:	79 ff 00 00 	ld.b %d15,[%a15]0
8000af20:	5f f2 04 00 	jeq %d2,%d15,8000af28 <getSW1_Debounce+0x70>
				cnt = 0;
8000af24:	59 a3 08 00 	st.w [%sp]8,%d3
	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW1();
		}
		for (i = 0; i < 10; i++) {
8000af28:	58 01       	ld.w %d15,[%sp]4
8000af2a:	c2 1f       	add %d15,1
8000af2c:	78 01       	st.w [%sp]4,%d15
8000af2e:	58 01       	ld.w %d15,[%sp]4
8000af30:	8b af 40 f2 	lt %d15,%d15,10
8000af34:	ee f0       	jnz %d15,8000af14 <getSW1_Debounce+0x5c>
			if (buf[0] != buf[i]) {
				cnt = 0;
			}
		}
		cnt += 1;
8000af36:	58 02       	ld.w %d15,[%sp]8
8000af38:	c2 1f       	add %d15,1
8000af3a:	78 02       	st.w [%sp]8,%d15
{
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
8000af3c:	58 02       	ld.w %d15,[%sp]8
8000af3e:	3f 4f d3 7f 	jlt %d15,%d4,8000aee4 <getSW1_Debounce+0x2c>
				cnt = 0;
			}
		}
		cnt += 1;
	}
	SW1 = buf[0];
8000af42:	79 af 0e 00 	ld.b %d15,[%sp]14
8000af46:	78 00       	st.w [%sp]0,%d15
	return SW1;
8000af48:	54 a2       	ld.w %d2,[%sp]
8000af4a:	00 90       	ret 

8000af4c <getSW2_Debounce>:
}

int getSW2_Debounce(void)
{
8000af4c:	20 18       	sub.a %sp,24
	volatile int SW2, i, cnt = 0;
8000af4e:	82 0f       	mov %d15,0
	volatile char buf[10] = { 0, };
8000af50:	d9 a2 0e 00 	lea %a2,[%sp]14
	return SW1;
}

int getSW2_Debounce(void)
{
	volatile int SW2, i, cnt = 0;
8000af54:	78 02       	st.w [%sp]8,%d15
	volatile char buf[10] = { 0, };
8000af56:	40 23       	mov.aa %a3,%a2
8000af58:	82 0f       	mov %d15,0
8000af5a:	a0 4f       	mov.a %a15,4
8000af5c:	a4 3f       	st.h [%a3+],%d15
8000af5e:	fc ff       	loop %a15,8000af5c <getSW2_Debounce+0x10>

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
8000af60:	19 a2 08 00 	ld.w %d2,[%sp]8
8000af64:	3b 00 71 f2 	mov %d15,10000
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
}

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000af68:	91 40 00 3f 	movh.a %a3,61444
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000af6c:	82 03       	mov %d3,0
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
}

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000af6e:	d9 33 00 8a 	lea %a3,[%a3]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
{
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
8000af72:	02 f4       	mov %d4,%d15
8000af74:	7f f2 32 00 	jge %d2,%d15,8000afd8 <getSW2_Debounce+0x8c>
		for (i = 0; i < 10; i++) {
8000af78:	59 a3 04 00 	st.w [%sp]4,%d3
8000af7c:	58 01       	ld.w %d15,[%sp]4
8000af7e:	8b af 40 f2 	lt %d15,%d15,10
8000af82:	6e 0e       	jz %d15,8000af9e <getSW2_Debounce+0x52>
			buf[i] = getSW2();
8000af84:	d8 01       	ld.a %a15,[%sp]4
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
}

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000af86:	4c 39       	ld.w %d15,[%a3]36
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW2();
8000af88:	37 0f e1 f0 	extr.u %d15,%d15,1,1
8000af8c:	30 2f       	add.a %a15,%a2
8000af8e:	28 0f       	st.b [%a15]0,%d15
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000af90:	58 01       	ld.w %d15,[%sp]4
8000af92:	c2 1f       	add %d15,1
8000af94:	78 01       	st.w [%sp]4,%d15
8000af96:	58 01       	ld.w %d15,[%sp]4
8000af98:	8b af 40 f2 	lt %d15,%d15,10
8000af9c:	ee f4       	jnz %d15,8000af84 <getSW2_Debounce+0x38>
			buf[i] = getSW2();
		}
		for (i = 0; i < 10; i++) {
8000af9e:	59 a3 04 00 	st.w [%sp]4,%d3
8000afa2:	58 01       	ld.w %d15,[%sp]4
8000afa4:	8b af 40 f2 	lt %d15,%d15,10
8000afa8:	6e 12       	jz %d15,8000afcc <getSW2_Debounce+0x80>
			if (buf[0] != buf[i]) {
8000afaa:	79 a2 0e 00 	ld.b %d2,[%sp]14
8000afae:	d8 01       	ld.a %a15,[%sp]4
8000afb0:	30 2f       	add.a %a15,%a2
8000afb2:	79 ff 00 00 	ld.b %d15,[%a15]0
8000afb6:	5f f2 04 00 	jeq %d2,%d15,8000afbe <getSW2_Debounce+0x72>
				cnt = 0;
8000afba:	59 a3 08 00 	st.w [%sp]8,%d3
	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW2();
		}
		for (i = 0; i < 10; i++) {
8000afbe:	58 01       	ld.w %d15,[%sp]4
8000afc0:	c2 1f       	add %d15,1
8000afc2:	78 01       	st.w [%sp]4,%d15
8000afc4:	58 01       	ld.w %d15,[%sp]4
8000afc6:	8b af 40 f2 	lt %d15,%d15,10
8000afca:	ee f0       	jnz %d15,8000afaa <getSW2_Debounce+0x5e>
			if (buf[0] != buf[i]) {
				cnt = 0;
			}
		}
		cnt += 1;
8000afcc:	58 02       	ld.w %d15,[%sp]8
8000afce:	c2 1f       	add %d15,1
8000afd0:	78 02       	st.w [%sp]8,%d15
{
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
8000afd2:	58 02       	ld.w %d15,[%sp]8
8000afd4:	3f 4f d2 7f 	jlt %d15,%d4,8000af78 <getSW2_Debounce+0x2c>
				cnt = 0;
			}
		}
		cnt += 1;
	}
	SW2 = buf[0];
8000afd8:	79 af 0e 00 	ld.b %d15,[%sp]14
8000afdc:	78 00       	st.w [%sp]0,%d15
	return SW2;
8000afde:	54 a2       	ld.w %d2,[%sp]
8000afe0:	00 90       	ret 

8000afe2 <init_lcd>:
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000afe2:	91 40 00 ff 	movh.a %a15,61444
8000afe6:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
#include "bsw/etc/etc.h"
#include "LCD.h"
//lcd   
void init_lcd(void){

	delay_ms(300);
8000afea:	3b c0 12 40 	mov %d4,300
8000afee:	6d ff f9 fd 	call 8000abe0 <delay_ms>
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000aff2:	4c f0       	ld.w %d15,[%a15]0
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000aff4:	91 40 00 cf 	movh.a %a12,61444
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000aff8:	96 04       	or %d15,4
8000affa:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000affc:	4c f0       	ld.w %d15,[%a15]0
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000affe:	d9 cc 00 0a 	lea %a12,[%a12]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b002:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
//lcd   
void init_lcd(void){

	delay_ms(300);
	write_instruction(0x01); //display clear
	delay_ms(100);
8000b006:	3b 40 06 40 	mov %d4,100

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b00a:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b00c:	4c f0       	ld.w %d15,[%a15]0
8000b00e:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b012:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b014:	82 1f       	mov %d15,1
8000b016:	6c c0       	st.w [%a12]0,%d15
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b018:	4c f0       	ld.w %d15,[%a15]0
8000b01a:	8f 4f c0 f1 	andn %d15,%d15,4
8000b01e:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b020:	4c f0       	ld.w %d15,[%a15]0
8000b022:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b026:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b028:	4c f0       	ld.w %d15,[%a15]0
8000b02a:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b02e:	68 0f       	st.w [%a15]0,%d15
//lcd   
void init_lcd(void){

	delay_ms(300);
	write_instruction(0x01); //display clear
	delay_ms(100);
8000b030:	6d ff d8 fd 	call 8000abe0 <delay_ms>
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b034:	4c f0       	ld.w %d15,[%a15]0
	delay_ms(300);
	write_instruction(0x01); //display clear
	delay_ms(100);

	write_instruction(0x38); //function set
	delay_ms(100);
8000b036:	3b 40 06 40 	mov %d4,100
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b03a:	96 04       	or %d15,4
8000b03c:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b03e:	4c f0       	ld.w %d15,[%a15]0
8000b040:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b044:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b046:	4c f0       	ld.w %d15,[%a15]0
8000b048:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b04c:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b04e:	da 38       	mov %d15,56
8000b050:	6c c0       	st.w [%a12]0,%d15
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b052:	4c f0       	ld.w %d15,[%a15]0
8000b054:	8f 4f c0 f1 	andn %d15,%d15,4
8000b058:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b05a:	4c f0       	ld.w %d15,[%a15]0
8000b05c:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b060:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b062:	4c f0       	ld.w %d15,[%a15]0
8000b064:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b068:	68 0f       	st.w [%a15]0,%d15
	delay_ms(300);
	write_instruction(0x01); //display clear
	delay_ms(100);

	write_instruction(0x38); //function set
	delay_ms(100);
8000b06a:	6d ff bb fd 	call 8000abe0 <delay_ms>
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b06e:	4c f0       	ld.w %d15,[%a15]0
	delay_ms(100);
	//write_instruction(0x3c);
	//delay_ms1(1000);
    //write_instruction(0x08);
	write_instruction(0x0e); //display on/off
	delay_ms(100);
8000b070:	3b 40 06 40 	mov %d4,100
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b074:	96 04       	or %d15,4
8000b076:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b078:	4c f0       	ld.w %d15,[%a15]0
8000b07a:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b07e:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b080:	4c f0       	ld.w %d15,[%a15]0
8000b082:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b086:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b088:	da 0e       	mov %d15,14
8000b08a:	6c c0       	st.w [%a12]0,%d15
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b08c:	4c f0       	ld.w %d15,[%a15]0
8000b08e:	8f 4f c0 f1 	andn %d15,%d15,4
8000b092:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b094:	4c f0       	ld.w %d15,[%a15]0
8000b096:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b09a:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b09c:	4c f0       	ld.w %d15,[%a15]0
8000b09e:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b0a2:	68 0f       	st.w [%a15]0,%d15
	delay_ms(100);
	//write_instruction(0x3c);
	//delay_ms1(1000);
    //write_instruction(0x08);
	write_instruction(0x0e); //display on/off
	delay_ms(100);
8000b0a4:	6d ff 9e fd 	call 8000abe0 <delay_ms>
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b0a8:	4c f0       	ld.w %d15,[%a15]0
	write_instruction(0x0e); //display on/off
	delay_ms(100);


	write_instruction(0x06); //entry mode set
	delay_ms(100);
8000b0aa:	3b 40 06 40 	mov %d4,100
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b0ae:	96 04       	or %d15,4
8000b0b0:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b0b2:	4c f0       	ld.w %d15,[%a15]0
8000b0b4:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b0b8:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b0ba:	4c f0       	ld.w %d15,[%a15]0
8000b0bc:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b0c0:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b0c2:	82 6f       	mov %d15,6
8000b0c4:	6c c0       	st.w [%a12]0,%d15
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b0c6:	4c f0       	ld.w %d15,[%a15]0
8000b0c8:	8f 4f c0 f1 	andn %d15,%d15,4
8000b0cc:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b0ce:	4c f0       	ld.w %d15,[%a15]0
8000b0d0:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b0d4:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b0d6:	4c f0       	ld.w %d15,[%a15]0
8000b0d8:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b0dc:	68 0f       	st.w [%a15]0,%d15
	write_instruction(0x0e); //display on/off
	delay_ms(100);


	write_instruction(0x06); //entry mode set
	delay_ms(100);
8000b0de:	1d ff 81 fd 	j 8000abe0 <delay_ms>

8000b0e2 <write_instruction>:
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b0e2:	91 40 00 ff 	movh.a %a15,61444
8000b0e6:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
8000b0ea:	4c f0       	ld.w %d15,[%a15]0
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b0ec:	91 40 00 2f 	movh.a %a2,61444
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b0f0:	96 04       	or %d15,4
8000b0f2:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b0f4:	4c f0       	ld.w %d15,[%a15]0
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b0f6:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b0fa:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b0fe:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b100:	4c f0       	ld.w %d15,[%a15]0
8000b102:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b106:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b108:	74 24       	st.w [%a2],%d4
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b10a:	4c f0       	ld.w %d15,[%a15]0
8000b10c:	8f 4f c0 f1 	andn %d15,%d15,4
8000b110:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b112:	4c f0       	ld.w %d15,[%a15]0
8000b114:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b118:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b11a:	4c f0       	ld.w %d15,[%a15]0
8000b11c:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b120:	68 0f       	st.w [%a15]0,%d15
8000b122:	00 90       	ret 

8000b124 <write_data>:
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b124:	91 40 00 ff 	movh.a %a15,61444
8000b128:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
8000b12c:	4c f0       	ld.w %d15,[%a15]0
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b12e:	91 40 00 2f 	movh.a %a2,61444
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b132:	96 04       	or %d15,4
8000b134:	68 0f       	st.w [%a15]0,%d15
   MODULE_P11.OUT.B.P11 = 0;
8000b136:	4c f0       	ld.w %d15,[%a15]0
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b138:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
8000b13c:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b140:	68 0f       	st.w [%a15]0,%d15
   MODULE_P11.OUT.B.P9 = 1;
8000b142:	4c f0       	ld.w %d15,[%a15]0
8000b144:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000b148:	68 0f       	st.w [%a15]0,%d15

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b14a:	74 24       	st.w [%a2],%d4
   delay_us(10);

   //MODULE_P11.OUT.U=0x00000200;
   MODULE_P11.OUT.B.P2 = 0;
8000b14c:	4c f0       	ld.w %d15,[%a15]0
8000b14e:	8f 4f c0 f1 	andn %d15,%d15,4
8000b152:	68 0f       	st.w [%a15]0,%d15
   MODULE_P11.OUT.B.P11 = 0;
8000b154:	4c f0       	ld.w %d15,[%a15]0
8000b156:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b15a:	68 0f       	st.w [%a15]0,%d15
   MODULE_P11.OUT.B.P9 = 1;
8000b15c:	4c f0       	ld.w %d15,[%a15]0
8000b15e:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000b162:	68 0f       	st.w [%a15]0,%d15
8000b164:	00 90       	ret 

8000b166 <lcdprint_data>:
void lcdprint_data(char *str){// 

	unsigned char i=0;
	//unsigned char check=0;

	while(str[i]!='\0'){
8000b166:	79 4f 00 00 	ld.b %d15,[%a4]0
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b16a:	91 40 00 ff 	movh.a %a15,61444
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b16e:	91 40 00 cf 	movh.a %a12,61444
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;
   delay_us(100);
}

void lcdprint_data(char *str){// 
8000b172:	40 4d       	mov.aa %a13,%a4

	unsigned char i=0;
	//unsigned char check=0;

	while(str[i]!='\0'){
8000b174:	82 08       	mov %d8,0
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b176:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b17a:	d9 cc 00 0a 	lea %a12,[%a12]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
void lcdprint_data(char *str){// 

	unsigned char i=0;
	//unsigned char check=0;

	while(str[i]!='\0'){
8000b17e:	6e 27       	jz %d15,8000b1cc <lcdprint_data+0x66>
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b180:	48 02       	ld.w %d2,[%a15]0
	unsigned char i=0;
	//unsigned char check=0;

	while(str[i]!='\0'){
		write_data(str[i++]);
		delay_ms(10);
8000b182:	3b a0 00 40 	mov %d4,10
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b186:	8f 42 40 21 	or %d2,%d2,4
8000b18a:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b18c:	48 02       	ld.w %d2,[%a15]0
8000b18e:	b7 02 81 25 	insert %d2,%d2,0,11,1
8000b192:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b194:	48 02       	ld.w %d2,[%a15]0
8000b196:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b19a:	68 02       	st.w [%a15]0,%d2

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b19c:	6c c0       	st.w [%a12]0,%d15
   delay_us(10);

   //MODULE_P11.OUT.U=0x00000200;
   MODULE_P11.OUT.B.P2 = 0;
8000b19e:	4c f0       	ld.w %d15,[%a15]0
8000b1a0:	8f 4f c0 f1 	andn %d15,%d15,4
8000b1a4:	68 0f       	st.w [%a15]0,%d15
   MODULE_P11.OUT.B.P11 = 0;
8000b1a6:	4c f0       	ld.w %d15,[%a15]0
8000b1a8:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b1ac:	68 0f       	st.w [%a15]0,%d15
   MODULE_P11.OUT.B.P9 = 1;
8000b1ae:	4c f0       	ld.w %d15,[%a15]0
8000b1b0:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
8000b1b4:	68 0f       	st.w [%a15]0,%d15
	unsigned char i=0;
	//unsigned char check=0;

	while(str[i]!='\0'){
		write_data(str[i++]);
		delay_ms(10);
8000b1b6:	6d ff 15 fd 	call 8000abe0 <delay_ms>
8000b1ba:	1b 18 00 20 	addi %d2,%d8,1
void lcdprint_data(char *str){// 

	unsigned char i=0;
	//unsigned char check=0;

	while(str[i]!='\0'){
8000b1be:	8f f2 0f f1 	and %d15,%d2,255
8000b1c2:	10 d2       	addsc.a %a2,%a13,%d15,0
8000b1c4:	02 28       	mov %d8,%d2
8000b1c6:	79 2f 00 00 	ld.b %d15,[%a2]0
8000b1ca:	ee db       	jnz %d15,8000b180 <lcdprint_data+0x1a>
8000b1cc:	00 90       	ret 

8000b1ce <clear_lcdprint>:
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b1ce:	91 40 00 ff 	movh.a %a15,61444
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b1d2:	91 40 00 cf 	movh.a %a12,61444
		write_data(str[i++]);
		delay_ms(10);
	}
}

void clear_lcdprint(void){
8000b1d6:	82 0f       	mov %d15,0
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b1d8:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b1dc:	d9 cc 00 0a 	lea %a12,[%a12]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b1e0:	3b 00 02 80 	mov %d8,32
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b1e4:	48 02       	ld.w %d2,[%a15]0

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
		write_data(' ');
		delay_ms(10);
8000b1e6:	3b a0 00 40 	mov %d4,10
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b1ea:	8f 42 40 21 	or %d2,%d2,4
8000b1ee:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b1f0:	48 02       	ld.w %d2,[%a15]0
8000b1f2:	c2 1f       	add %d15,1
8000b1f4:	b7 02 81 25 	insert %d2,%d2,0,11,1
8000b1f8:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b1fa:	48 02       	ld.w %d2,[%a15]0
8000b1fc:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b200:	68 02       	st.w [%a15]0,%d2

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b202:	74 c8       	st.w [%a12],%d8
   delay_us(10);

   //MODULE_P11.OUT.U=0x00000200;
   MODULE_P11.OUT.B.P2 = 0;
8000b204:	48 02       	ld.w %d2,[%a15]0
8000b206:	8f 42 c0 21 	andn %d2,%d2,4
8000b20a:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b20c:	48 02       	ld.w %d2,[%a15]0
8000b20e:	b7 02 81 25 	insert %d2,%d2,0,11,1
8000b212:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b214:	48 02       	ld.w %d2,[%a15]0
8000b216:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b21a:	68 02       	st.w [%a15]0,%d2

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
		write_data(' ');
		delay_ms(10);
8000b21c:	6d ff e2 fc 	call 8000abe0 <delay_ms>
	}
}

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
8000b220:	8b 0f 21 22 	ne %d2,%d15,16
8000b224:	df 02 e0 ff 	jne %d2,0,8000b1e4 <clear_lcdprint+0x16>
		write_data(' ');
		delay_ms(10);
	}
}
8000b228:	00 90       	ret 

8000b22a <clear_two_lines>:
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b22a:	91 40 00 ff 	movh.a %a15,61444
8000b22e:	d9 ff 00 4b 	lea %a15,[%a15]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
		write_data(' ');
		delay_ms(10);
	}
}
void clear_two_lines(void){
	delay_ms(50);
8000b232:	3b 20 03 40 	mov %d4,50
8000b236:	6d ff d5 fc 	call 8000abe0 <delay_ms>
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b23a:	4c f0       	ld.w %d15,[%a15]0
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b23c:	91 40 00 2f 	movh.a %a2,61444
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b240:	96 04       	or %d15,4
8000b242:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b244:	4c f0       	ld.w %d15,[%a15]0
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b246:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b24a:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
	}
}
void clear_two_lines(void){
	delay_ms(50);
	write_instruction(0x80);
	delay_ms(50);
8000b24e:	3b 20 03 40 	mov %d4,50

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b252:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b254:	4c f0       	ld.w %d15,[%a15]0
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b256:	91 40 00 df 	movh.a %a13,61444
    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
8000b25a:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b25e:	d9 dd 00 0a 	lea %a13,[%a13]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
8000b262:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b264:	da 80       	mov %d15,128
8000b266:	6c 20       	st.w [%a2]0,%d15
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b268:	4c f0       	ld.w %d15,[%a15]0
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b26a:	3b 00 02 80 	mov %d8,32

    MODULE_P00.OUT.U=i;
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b26e:	8f 4f c0 f1 	andn %d15,%d15,4
8000b272:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b274:	4c f0       	ld.w %d15,[%a15]0
8000b276:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b27a:	68 0f       	st.w [%a15]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b27c:	4c f0       	ld.w %d15,[%a15]0
8000b27e:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b282:	68 0f       	st.w [%a15]0,%d15
	}
}
void clear_two_lines(void){
	delay_ms(50);
	write_instruction(0x80);
	delay_ms(50);
8000b284:	6d ff ae fc 	call 8000abe0 <delay_ms>
8000b288:	82 0f       	mov %d15,0
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b28a:	48 02       	ld.w %d2,[%a15]0

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
		write_data(' ');
		delay_ms(10);
8000b28c:	3b a0 00 40 	mov %d4,10
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b290:	8f 42 40 21 	or %d2,%d2,4
8000b294:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b296:	48 02       	ld.w %d2,[%a15]0
8000b298:	c2 1f       	add %d15,1
8000b29a:	b7 02 81 25 	insert %d2,%d2,0,11,1
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b29e:	91 40 00 cf 	movh.a %a12,61444
   MODULE_P11.OUT.B.P11 = 0;
8000b2a2:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b2a4:	48 02       	ld.w %d2,[%a15]0
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b2a6:	d9 cc 00 4b 	lea %a12,[%a12]-20224 <f003b100 <_SMALL_DATA4_+0x40033100>>
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;
8000b2aa:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b2ae:	68 02       	st.w [%a15]0,%d2

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b2b0:	74 d8       	st.w [%a13],%d8
   delay_us(10);

   //MODULE_P11.OUT.U=0x00000200;
   MODULE_P11.OUT.B.P2 = 0;
8000b2b2:	48 02       	ld.w %d2,[%a15]0
8000b2b4:	8f 42 c0 21 	andn %d2,%d2,4
8000b2b8:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b2ba:	48 02       	ld.w %d2,[%a15]0
8000b2bc:	b7 02 81 25 	insert %d2,%d2,0,11,1
8000b2c0:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b2c2:	48 02       	ld.w %d2,[%a15]0
8000b2c4:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b2c8:	68 02       	st.w [%a15]0,%d2

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
		write_data(' ');
		delay_ms(10);
8000b2ca:	6d ff 8b fc 	call 8000abe0 <delay_ms>
	}
}

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
8000b2ce:	8b 0f 21 22 	ne %d2,%d15,16
8000b2d2:	df 02 dc ff 	jne %d2,0,8000b28a <clear_two_lines+0x60>
	delay_ms(50);
	write_instruction(0x80);
	delay_ms(50);
	clear_lcdprint();

	delay_ms(50);
8000b2d6:	3b 20 03 40 	mov %d4,50
8000b2da:	6d ff 83 fc 	call 8000abe0 <delay_ms>
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b2de:	4c c0       	ld.w %d15,[%a12]0
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b2e0:	91 40 00 ff 	movh.a %a15,61444
void write_instruction(unsigned char i){

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
8000b2e4:	96 04       	or %d15,4
8000b2e6:	6c c0       	st.w [%a12]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b2e8:	4c c0       	ld.w %d15,[%a12]0
    MODULE_P11.OUT.B.P9=0;
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b2ea:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b2ee:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
	delay_ms(50);
	clear_lcdprint();

	delay_ms(50);
	write_instruction(0xc0);
	delay_ms(50);
8000b2f2:	3b 20 03 40 	mov %d4,50

    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
8000b2f6:	6c c0       	st.w [%a12]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b2f8:	4c c0       	ld.w %d15,[%a12]0
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b2fa:	3b 00 02 80 	mov %d8,32
    //PORTG=0x04; --> 100    init gpio

    //MODULE_P11.OUT.U=0x00000004;
    MODULE_P11.OUT.B.P2=1;
    MODULE_P11.OUT.B.P11=0;
    MODULE_P11.OUT.B.P9=0;
8000b2fe:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b302:	6c c0       	st.w [%a12]0,%d15
    delay_us(10);

    MODULE_P00.OUT.U=i;
8000b304:	da c0       	mov %d15,192
8000b306:	68 0f       	st.w [%a15]0,%d15
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b308:	4c c0       	ld.w %d15,[%a12]0
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b30a:	40 cf       	mov.aa %a15,%a12

    MODULE_P00.OUT.U=i;
    delay_us(10);

    //MODULE_P11.OUT.U=0x0;
    MODULE_P11.OUT.B.P2=0;
8000b30c:	8f 4f c0 f1 	andn %d15,%d15,4
8000b310:	6c c0       	st.w [%a12]0,%d15
    MODULE_P11.OUT.B.P11=0;
8000b312:	4c c0       	ld.w %d15,[%a12]0
8000b314:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
8000b318:	6c c0       	st.w [%a12]0,%d15
    MODULE_P11.OUT.B.P9=0;
8000b31a:	4c c0       	ld.w %d15,[%a12]0
8000b31c:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000b320:	6c c0       	st.w [%a12]0,%d15
	delay_ms(50);
	clear_lcdprint();

	delay_ms(50);
	write_instruction(0xc0);
	delay_ms(50);
8000b322:	6d ff 5f fc 	call 8000abe0 <delay_ms>
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b326:	91 40 00 cf 	movh.a %a12,61444
	delay_ms(50);
	clear_lcdprint();

	delay_ms(50);
	write_instruction(0xc0);
	delay_ms(50);
8000b32a:	82 0f       	mov %d15,0
   MODULE_P11.OUT.B.P2 = 1;
   MODULE_P11.OUT.B.P11 = 0;
   MODULE_P11.OUT.B.P9 = 1;

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b32c:	d9 cc 00 0a 	lea %a12,[%a12]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b330:	48 02       	ld.w %d2,[%a15]0

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
		write_data(' ');
		delay_ms(10);
8000b332:	3b a0 00 40 	mov %d4,10
    delay_us(100);
}
void write_data(char d){ //  

   //MODULE_P11.OUT.U=0x00000204;
   MODULE_P11.OUT.B.P2 = 1;
8000b336:	8f 42 40 21 	or %d2,%d2,4
8000b33a:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b33c:	48 02       	ld.w %d2,[%a15]0
8000b33e:	c2 1f       	add %d15,1
8000b340:	b7 02 81 25 	insert %d2,%d2,0,11,1
8000b344:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b346:	48 02       	ld.w %d2,[%a15]0
8000b348:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b34c:	68 02       	st.w [%a15]0,%d2

   delay_us(10);
   MODULE_P00.OUT.U =d;//d
8000b34e:	74 c8       	st.w [%a12],%d8
   delay_us(10);

   //MODULE_P11.OUT.U=0x00000200;
   MODULE_P11.OUT.B.P2 = 0;
8000b350:	48 02       	ld.w %d2,[%a15]0
8000b352:	8f 42 c0 21 	andn %d2,%d2,4
8000b356:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P11 = 0;
8000b358:	48 02       	ld.w %d2,[%a15]0
8000b35a:	b7 02 81 25 	insert %d2,%d2,0,11,1
8000b35e:	68 02       	st.w [%a15]0,%d2
   MODULE_P11.OUT.B.P9 = 1;
8000b360:	48 02       	ld.w %d2,[%a15]0
8000b362:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000b366:	68 02       	st.w [%a15]0,%d2

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
		write_data(' ');
		delay_ms(10);
8000b368:	6d ff 3c fc 	call 8000abe0 <delay_ms>
	}
}

void clear_lcdprint(void){
	unsigned char i=0;
	for(i=0;i<16;i++){
8000b36c:	8b 0f 21 22 	ne %d2,%d15,16
8000b370:	df 02 e0 ff 	jne %d2,0,8000b330 <clear_two_lines+0x106>

	delay_ms(50);
	write_instruction(0xc0);
	delay_ms(50);
	clear_lcdprint();
}
8000b374:	00 90       	ret 

8000b376 <delay_us>:
void delay_us(unsigned int m){
8000b376:	00 90       	ret 

8000b378 <Init_DCMotor>:
#include "../system/interrupts.h"

void Init_DCMotor(void)
{
	/* Init CH-A (Left Motor) */
	MODULE_P10.IOCR0.B.PC1 = 0b10000; /* DIR-A    */
8000b378:	91 40 00 ff 	movh.a %a15,61444
8000b37c:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b380:	4c f4       	ld.w %d15,[%a15]16
	MODULE_P02.IOCR0.B.PC1= 0b10000; /* PWM-A    */
8000b382:	91 40 00 2f 	movh.a %a2,61444
#include "../system/interrupts.h"

void Init_DCMotor(void)
{
	/* Init CH-A (Left Motor) */
	MODULE_P10.IOCR0.B.PC1 = 0b10000; /* DIR-A    */
8000b386:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000b38a:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
	MODULE_P02.IOCR0.B.PC1= 0b10000; /* PWM-A    */
8000b38e:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
#include "../system/interrupts.h"

void Init_DCMotor(void)
{
	/* Init CH-A (Left Motor) */
	MODULE_P10.IOCR0.B.PC1 = 0b10000; /* DIR-A    */
8000b392:	68 4f       	st.w [%a15]16,%d15
	MODULE_P02.IOCR0.B.PC1= 0b10000; /* PWM-A    */
8000b394:	4c 24       	ld.w %d15,[%a2]16
8000b396:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000b39a:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000b39e:	6c 24       	st.w [%a2]16,%d15
	MODULE_P02.IOCR4.B.PC7 = 0b10000; /* BRAKE-A    */
8000b3a0:	4c 25       	ld.w %d15,[%a2]20
8000b3a2:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000b3a6:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000b3aa:	6c 25       	st.w [%a2]20,%d15
	MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b3ac:	4c f0       	ld.w %d15,[%a15]0
8000b3ae:	96 02       	or %d15,2
8000b3b0:	68 0f       	st.w [%a15]0,%d15
	MODULE_P02.OUT.B.P7 = 1; /*   (1: , 0: PWM-A  ) */
8000b3b2:	4c 20       	ld.w %d15,[%a2]0
8000b3b4:	96 80       	or %d15,128
8000b3b6:	6c 20       	st.w [%a2]0,%d15
	MODULE_P02.OUT.B.P1 = 0; /* 100% PWM duty  */
8000b3b8:	4c 20       	ld.w %d15,[%a2]0
8000b3ba:	8f 2f c0 f1 	andn %d15,%d15,2
8000b3be:	6c 20       	st.w [%a2]0,%d15

	/* Init CH-B (Right Motor) */
	MODULE_P10.IOCR0.B.PC2 = 0b10000; /* DIR-B    */
8000b3c0:	4c f4       	ld.w %d15,[%a15]16
8000b3c2:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000b3c6:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000b3ca:	68 4f       	st.w [%a15]16,%d15
	MODULE_P10.IOCR0.B.PC3 = 0b10000; /* PWM-B    */
8000b3cc:	4c f4       	ld.w %d15,[%a15]16
8000b3ce:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000b3d2:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000b3d6:	68 4f       	st.w [%a15]16,%d15
	MODULE_P02.IOCR4.B.PC6 = 0b10000; /* BRAKE-B    */
8000b3d8:	4c 25       	ld.w %d15,[%a2]20
8000b3da:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000b3de:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000b3e2:	6c 25       	st.w [%a2]20,%d15
	MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b3e4:	4c f0       	ld.w %d15,[%a15]0
8000b3e6:	96 04       	or %d15,4
8000b3e8:	68 0f       	st.w [%a15]0,%d15
	MODULE_P02.OUT.B.P6 = 1; /*   (1: , 0: PWM-B  ) */
8000b3ea:	4c 20       	ld.w %d15,[%a2]0
8000b3ec:	96 40       	or %d15,64
8000b3ee:	6c 20       	st.w [%a2]0,%d15
	MODULE_P10.OUT.B.P3 = 0; /* 100% PWM duty  */
8000b3f0:	4c f0       	ld.w %d15,[%a15]0
8000b3f2:	8f 8f c0 f1 	andn %d15,%d15,8
8000b3f6:	68 0f       	st.w [%a15]0,%d15
8000b3f8:	00 90       	ret 

8000b3fa <Init_DCMotorPWM>:
#include "../system/interrupts.h"

void Init_DCMotor(void)
{
	/* Init CH-A (Left Motor) */
	MODULE_P10.IOCR0.B.PC1 = 0b10000; /* DIR-A    */
8000b3fa:	91 40 00 2f 	movh.a %a2,61444
8000b3fe:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b402:	4c 24       	ld.w %d15,[%a2]16
	MODULE_P02.IOCR0.B.PC1= 0b10000; /* PWM-A    */
8000b404:	91 40 00 ff 	movh.a %a15,61444
#include "../system/interrupts.h"

void Init_DCMotor(void)
{
	/* Init CH-A (Left Motor) */
	MODULE_P10.IOCR0.B.PC1 = 0b10000; /* DIR-A    */
8000b408:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000b40c:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
	MODULE_P02.IOCR0.B.PC1= 0b10000; /* PWM-A    */
8000b410:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
#include "../system/interrupts.h"

void Init_DCMotor(void)
{
	/* Init CH-A (Left Motor) */
	MODULE_P10.IOCR0.B.PC1 = 0b10000; /* DIR-A    */
8000b414:	6c 24       	st.w [%a2]16,%d15
	MODULE_P02.IOCR0.B.PC1= 0b10000; /* PWM-A    */
8000b416:	4c f4       	ld.w %d15,[%a15]16
8000b418:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000b41c:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000b420:	68 4f       	st.w [%a15]16,%d15
	MODULE_P02.IOCR4.B.PC7 = 0b10000; /* BRAKE-A    */
8000b422:	4c f5       	ld.w %d15,[%a15]20
8000b424:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000b428:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000b42c:	68 5f       	st.w [%a15]20,%d15
	MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b42e:	4c 20       	ld.w %d15,[%a2]0
8000b430:	96 02       	or %d15,2
8000b432:	6c 20       	st.w [%a2]0,%d15
	MODULE_P02.OUT.B.P7 = 1; /*   (1: , 0: PWM-A  ) */
8000b434:	4c f0       	ld.w %d15,[%a15]0
8000b436:	96 80       	or %d15,128
8000b438:	68 0f       	st.w [%a15]0,%d15
	MODULE_P02.OUT.B.P1 = 0; /* 100% PWM duty  */
8000b43a:	4c f0       	ld.w %d15,[%a15]0
8000b43c:	8f 2f c0 f1 	andn %d15,%d15,2
8000b440:	68 0f       	st.w [%a15]0,%d15

	/* Init CH-B (Right Motor) */
	MODULE_P10.IOCR0.B.PC2 = 0b10000; /* DIR-B    */
8000b442:	4c 24       	ld.w %d15,[%a2]16
8000b444:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000b448:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000b44c:	6c 24       	st.w [%a2]16,%d15
	MODULE_P10.IOCR0.B.PC3 = 0b10000; /* PWM-B    */
8000b44e:	4c 24       	ld.w %d15,[%a2]16
8000b450:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000b454:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000b458:	6c 24       	st.w [%a2]16,%d15
	MODULE_P02.IOCR4.B.PC6 = 0b10000; /* BRAKE-B    */
8000b45a:	4c f5       	ld.w %d15,[%a15]20
8000b45c:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000b460:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000b464:	68 5f       	st.w [%a15]20,%d15
	MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b466:	4c 20       	ld.w %d15,[%a2]0
8000b468:	96 04       	or %d15,4
8000b46a:	6c 20       	st.w [%a2]0,%d15
	MODULE_P02.OUT.B.P6 = 1; /*   (1: , 0: PWM-B  ) */
8000b46c:	4c f0       	ld.w %d15,[%a15]0
8000b46e:	96 40       	or %d15,64
8000b470:	68 0f       	st.w [%a15]0,%d15
	MODULE_P10.OUT.B.P3 = 0; /* 100% PWM duty  */
8000b472:	4c 20       	ld.w %d15,[%a2]0
8000b474:	8f 8f c0 f1 	andn %d15,%d15,8
8000b478:	6c 20       	st.w [%a2]0,%d15

void Init_DCMotorPWM(void)
{
	Init_DCMotor();
	/* PWM Init */
	init_gpt2();
8000b47a:	6d ff ea fa 	call 8000aa4e <init_gpt2>
	MODULE_P10.OUT.B.P3 = 1; /* 100% PWM duty  */
}

void stopChA(void)
{
	MODULE_P02.OUT.B.P7 = 1; /*   (1: , 0: PWM-A  ) */
8000b47e:	4c f0       	ld.w %d15,[%a15]0
8000b480:	96 80       	or %d15,128
8000b482:	68 0f       	st.w [%a15]0,%d15
}
void stopChB(void)
{
	MODULE_P02.OUT.B.P6 = 1; /*   (1: , 0: PWM-B  ) */
8000b484:	4c f0       	ld.w %d15,[%a15]0
8000b486:	96 40       	or %d15,64
8000b488:	68 0f       	st.w [%a15]0,%d15
	Init_DCMotor();
	/* PWM Init */
	init_gpt2();
	stopChA();
	stopChB();
	runGpt12_T6();
8000b48a:	1d ff 1e fb 	j 8000aac6 <runGpt12_T6>

8000b48e <movChA>:
/* 1: , 2:  */
void movChA(int dir)
{
	if(dir)
	{
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b48e:	91 40 00 ff 	movh.a %a15,61444
8000b492:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b496:	4c f0       	ld.w %d15,[%a15]0
}

/* 1: , 2:  */
void movChA(int dir)
{
	if(dir)
8000b498:	df 04 11 80 	jne %d4,0,8000b4ba <movChA+0x2c>
	{
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
	}
	else {
		MODULE_P10.OUT.B.P1 = 0; /*    (1: , 0: ) */
8000b49c:	8f 2f c0 f1 	andn %d15,%d15,2
8000b4a0:	68 0f       	st.w [%a15]0,%d15
	}
	MODULE_P02.OUT.B.P7 = 0; /*   (1: , 0: PWM-A  ) */
8000b4a2:	91 40 00 ff 	movh.a %a15,61444
8000b4a6:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b4aa:	4c f0       	ld.w %d15,[%a15]0
8000b4ac:	8f 0f c8 f1 	andn %d15,%d15,128
8000b4b0:	68 0f       	st.w [%a15]0,%d15
	MODULE_P02.OUT.B.P1 = 1; /* 100% PWM duty  */
8000b4b2:	4c f0       	ld.w %d15,[%a15]0
8000b4b4:	96 02       	or %d15,2
8000b4b6:	68 0f       	st.w [%a15]0,%d15
8000b4b8:	00 90       	ret 
/* 1: , 2:  */
void movChA(int dir)
{
	if(dir)
	{
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b4ba:	96 02       	or %d15,2
8000b4bc:	68 0f       	st.w [%a15]0,%d15
8000b4be:	3c f2       	j 8000b4a2 <movChA+0x14>

8000b4c0 <movChB>:
/* 1: , 2:  */
void movChB(int dir)
{
	if(dir)
	{
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b4c0:	91 40 00 ff 	movh.a %a15,61444
8000b4c4:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b4c8:	4c f0       	ld.w %d15,[%a15]0
}

/* 1: , 2:  */
void movChB(int dir)
{
	if(dir)
8000b4ca:	df 04 15 80 	jne %d4,0,8000b4f4 <movChB+0x34>
	{
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
	}
	else {
		MODULE_P10.OUT.B.P2 = 0; /*    (1: , 0: ) */
8000b4ce:	8f 4f c0 f1 	andn %d15,%d15,4
8000b4d2:	68 0f       	st.w [%a15]0,%d15
	}
	MODULE_P02.OUT.B.P6 = 0; /*   (1: , 0: PWM-A  ) */
8000b4d4:	91 40 00 ff 	movh.a %a15,61444
8000b4d8:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b4dc:	4c f0       	ld.w %d15,[%a15]0
8000b4de:	8f 0f c4 f1 	andn %d15,%d15,64
8000b4e2:	68 0f       	st.w [%a15]0,%d15
	MODULE_P10.OUT.B.P3 = 1; /* 100% PWM duty  */
8000b4e4:	91 40 00 ff 	movh.a %a15,61444
8000b4e8:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b4ec:	4c f0       	ld.w %d15,[%a15]0
8000b4ee:	96 08       	or %d15,8
8000b4f0:	68 0f       	st.w [%a15]0,%d15
8000b4f2:	00 90       	ret 
/* 1: , 2:  */
void movChB(int dir)
{
	if(dir)
	{
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b4f4:	96 04       	or %d15,4
8000b4f6:	68 0f       	st.w [%a15]0,%d15
8000b4f8:	3c ee       	j 8000b4d4 <movChB+0x14>

8000b4fa <stopChA>:
	MODULE_P10.OUT.B.P3 = 1; /* 100% PWM duty  */
}

void stopChA(void)
{
	MODULE_P02.OUT.B.P7 = 1; /*   (1: , 0: PWM-A  ) */
8000b4fa:	91 40 00 ff 	movh.a %a15,61444
8000b4fe:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b502:	4c f0       	ld.w %d15,[%a15]0
8000b504:	96 80       	or %d15,128
8000b506:	68 0f       	st.w [%a15]0,%d15
8000b508:	00 90       	ret 

8000b50a <stopChB>:
}
void stopChB(void)
{
	MODULE_P02.OUT.B.P6 = 1; /*   (1: , 0: PWM-B  ) */
8000b50a:	91 40 00 ff 	movh.a %a15,61444
8000b50e:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b512:	4c f0       	ld.w %d15,[%a15]0
8000b514:	96 40       	or %d15,64
8000b516:	68 0f       	st.w [%a15]0,%d15
8000b518:	00 90       	ret 

8000b51a <movChA_PWM>:
}

/* 1: , 0:  */
void movChA_PWM(int duty, int dir)
{
8000b51a:	02 5f       	mov %d15,%d5
	setLeftMotorDuty(duty);
	if (dir) {
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b51c:	91 40 00 ff 	movh.a %a15,61444
}

/* 1: , 0:  */
void movChA_PWM(int duty, int dir)
{
	setLeftMotorDuty(duty);
8000b520:	6d ff 46 fa 	call 8000a9ac <setLeftMotorDuty>
	if (dir) {
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b524:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>

/* 1: , 0:  */
void movChA_PWM(int duty, int dir)
{
	setLeftMotorDuty(duty);
	if (dir) {
8000b528:	ee 0e       	jnz %d15,8000b544 <movChA_PWM+0x2a>
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
	} else 	{
		MODULE_P10.OUT.B.P1 = 0; /*    (1: , 0: ) */
8000b52a:	4c f0       	ld.w %d15,[%a15]0
8000b52c:	8f 2f c0 f1 	andn %d15,%d15,2
8000b530:	68 0f       	st.w [%a15]0,%d15
	}
	MODULE_P02.OUT.B.P7 = 0; /*   (1: , 0: PWM-A  ) */
8000b532:	91 40 00 ff 	movh.a %a15,61444
8000b536:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b53a:	4c f0       	ld.w %d15,[%a15]0
8000b53c:	8f 0f c8 f1 	andn %d15,%d15,128
8000b540:	68 0f       	st.w [%a15]0,%d15
8000b542:	00 90       	ret 
/* 1: , 0:  */
void movChA_PWM(int duty, int dir)
{
	setLeftMotorDuty(duty);
	if (dir) {
		MODULE_P10.OUT.B.P1 = 1; /*    (1: , 0: ) */
8000b544:	4c f0       	ld.w %d15,[%a15]0
8000b546:	96 02       	or %d15,2
8000b548:	68 0f       	st.w [%a15]0,%d15
8000b54a:	3c f4       	j 8000b532 <movChA_PWM+0x18>

8000b54c <movChB_PWM>:
	MODULE_P02.OUT.B.P7 = 0; /*   (1: , 0: PWM-A  ) */
}

/* 1: , 0:  */
void movChB_PWM(int duty, int dir)
{
8000b54c:	02 5f       	mov %d15,%d5
	setRightMotorDuty(duty);
	if (dir) {
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b54e:	91 40 00 ff 	movh.a %a15,61444
}

/* 1: , 0:  */
void movChB_PWM(int duty, int dir)
{
	setRightMotorDuty(duty);
8000b552:	6d ff 32 fa 	call 8000a9b6 <setRightMotorDuty>
	if (dir) {
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b556:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>

/* 1: , 0:  */
void movChB_PWM(int duty, int dir)
{
	setRightMotorDuty(duty);
	if (dir) {
8000b55a:	ee 0e       	jnz %d15,8000b576 <movChB_PWM+0x2a>
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
	} else {
		MODULE_P10.OUT.B.P2 = 0; /*    (1: , 0: ) */
8000b55c:	4c f0       	ld.w %d15,[%a15]0
8000b55e:	8f 4f c0 f1 	andn %d15,%d15,4
8000b562:	68 0f       	st.w [%a15]0,%d15
	}
	MODULE_P02.OUT.B.P6 = 0; /*   (1: , 0: PWM-B  ) */
8000b564:	91 40 00 ff 	movh.a %a15,61444
8000b568:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b56c:	4c f0       	ld.w %d15,[%a15]0
8000b56e:	8f 0f c4 f1 	andn %d15,%d15,64
8000b572:	68 0f       	st.w [%a15]0,%d15
8000b574:	00 90       	ret 
/* 1: , 0:  */
void movChB_PWM(int duty, int dir)
{
	setRightMotorDuty(duty);
	if (dir) {
		MODULE_P10.OUT.B.P2 = 1; /*    (1: , 0: ) */
8000b576:	4c f0       	ld.w %d15,[%a15]0
8000b578:	96 04       	or %d15,4
8000b57a:	68 0f       	st.w [%a15]0,%d15
8000b57c:	3c f4       	j 8000b564 <movChB_PWM+0x18>

8000b57e <Init_ToF>:
static unsigned int rxBufIdx = 0;
static unsigned char gBuf_tof[16] = { 0 };

void Init_ToF(void)
{
    _init_uart1();
8000b57e:	1d ff d0 f8 	j 8000a71e <_init_uart1>

8000b582 <IsrUart1RxHandler_tof>:
/* Interrupt Service Routine for RX */
void IsrUart1RxHandler_tof(void)
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();
8000b582:	6d ff 17 f9 	call 8000a7b0 <_in_uart1>

	rxBuf[rxBufIdx] = c;
8000b586:	91 00 00 f7 	movh.a %a15,28672
8000b58a:	99 f2 b0 f1 	ld.a %a2,[%a15]7152 <70001bf0 <rxBufIdx>>
	++rxBufIdx;
8000b58e:	19 ff b0 f1 	ld.w %d15,[%a15]7152 <70001bf0 <rxBufIdx>>
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();

	rxBuf[rxBufIdx] = c;
8000b592:	91 00 00 37 	movh.a %a3,28672
8000b596:	d9 33 90 f1 	lea %a3,[%a3]7120 <70001bd0 <rxBuf.37695>>
	++rxBufIdx;
8000b59a:	c2 1f       	add %d15,1
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();

	rxBuf[rxBufIdx] = c;
8000b59c:	30 32       	add.a %a2,%a3
	++rxBufIdx;
8000b59e:	59 ff b0 f1 	st.w [%a15]7152 <70001bf0 <rxBufIdx>>,%d15
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();

	rxBuf[rxBufIdx] = c;
8000b5a2:	34 22       	st.b [%a2],%d2
	++rxBufIdx;

	/*   , buf_tof  */
	if (rxBufIdx == TOF_length) {
8000b5a4:	8b 0f 21 f2 	ne %d15,%d15,16
8000b5a8:	6e 02       	jz %d15,8000b5ac <IsrUart1RxHandler_tof+0x2a>
8000b5aa:	00 90       	ret 
		memcpy(gBuf_tof, rxBuf, TOF_length);
8000b5ac:	91 00 00 27 	movh.a %a2,28672
8000b5b0:	d9 22 a0 f1 	lea %a2,[%a2]7136 <70001be0 <gBuf_tof>>
8000b5b4:	a0 f4       	mov.a %a4,15
8000b5b6:	04 3f       	ld.bu %d15,[%a3+]
8000b5b8:	24 2f       	st.b [%a2+],%d15
8000b5ba:	fc 4e       	loop %a4,8000b5b6 <IsrUart1RxHandler_tof+0x34>
		rxBufIdx = 0;
8000b5bc:	82 0f       	mov %d15,0
8000b5be:	59 ff b0 f1 	st.w [%a15]7152,%d15
8000b5c2:	00 90       	ret 

8000b5c4 <getTofDistance>:
	}
}

/* Return Distance(mm) */
int getTofDistance (void)
{
8000b5c4:	20 10       	sub.a %sp,16
    int TOF_distance = 0;
    unsigned char buf_ToF[TOF_length];

    /* copy buf_tof into tmp */
    memcpy(buf_ToF, gBuf_tof, TOF_length);
8000b5c6:	91 00 00 27 	movh.a %a2,28672
8000b5ca:	40 af       	mov.aa %a15,%sp
8000b5cc:	d9 22 a0 f1 	lea %a2,[%a2]7136 <70001be0 <gBuf_tof>>
8000b5d0:	a0 f3       	mov.a %a3,15
8000b5d2:	04 2f       	ld.bu %d15,[%a2+]
8000b5d4:	24 ff       	st.b [%a15+],%d15
8000b5d6:	fc 3e       	loop %a3,8000b5d2 <getTofDistance+0xe>
/*    1,   0  */
static int verifyCheckSum(unsigned char data[])
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
8000b5d8:	19 a5 04 00 	ld.w %d5,[%sp]4
8000b5dc:	54 a2       	ld.w %d2,[%sp]
8000b5de:	7b f0 f7 f7 	movh %d15,32639
8000b5e2:	1b ff f7 f7 	addi %d15,%d15,32639
8000b5e6:	0f f5 80 30 	and %d3,%d5,%d15
8000b5ea:	0f f2 80 40 	and %d4,%d2,%d15
8000b5ee:	42 34       	add %d4,%d3
8000b5f0:	c6 52       	xor %d2,%d5
8000b5f2:	8b ff 1f 31 	rsub %d3,%d15,-1
8000b5f6:	26 32       	and %d2,%d3
8000b5f8:	19 a5 08 00 	ld.w %d5,[%sp]8
8000b5fc:	c6 42       	xor %d2,%d4
8000b5fe:	0f f2 80 40 	and %d4,%d2,%d15
8000b602:	c6 52       	xor %d2,%d5
8000b604:	26 5f       	and %d15,%d5
8000b606:	26 23       	and %d3,%d2
8000b608:	42 4f       	add %d15,%d4
8000b60a:	c6 3f       	xor %d15,%d3
8000b60c:	39 a2 0c 00 	ld.bu %d2,[%sp]12
8000b610:	39 a3 0d 00 	ld.bu %d3,[%sp]13
8000b614:	42 23       	add %d3,%d2
8000b616:	39 a2 0e 00 	ld.bu %d2,[%sp]14
8000b61a:	42 23       	add %d3,%d2
8000b61c:	37 0f 68 24 	extr.u %d2,%d15,8,8
8000b620:	42 f3       	add %d3,%d15
8000b622:	42 23       	add %d3,%d2
8000b624:	37 0f 68 28 	extr.u %d2,%d15,16,8
8000b628:	37 0f 68 fc 	extr.u %d15,%d15,24,8
8000b62c:	42 32       	add %d2,%d3
8000b62e:	42 2f       	add %d15,%d2
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b630:	14 a2       	ld.bu %d2,[%sp]
/*    1,   0  */
static int verifyCheckSum(unsigned char data[])
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
8000b632:	16 ff       	and %d15,255
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b634:	8b 72 25 32 	ne %d3,%d2,87
//     for (int i = 0; i < 16; i++) {
//         my_printf("%.2X ", buf_ToF[i]);
//     }

    if (!verifyCheckSum(buf_ToF)) {
		return -1;
8000b638:	82 f2       	mov %d2,-1
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b63a:	76 32       	jz %d3,8000b63e <getTofDistance+0x7a>
	}

    TOF_distance = buf_ToF[8] | (buf_ToF[9] << 8) | (buf_ToF[10] << 16);

    return TOF_distance;
}
8000b63c:	00 90       	ret 
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b63e:	39 a3 01 00 	ld.bu %d3,[%sp]1
8000b642:	df 03 fd ff 	jne %d3,0,8000b63c <getTofDistance+0x78>
8000b646:	39 a3 02 00 	ld.bu %d3,[%sp]2
8000b64a:	8b f3 2f 32 	ne %d3,%d3,255
8000b64e:	df 03 f7 ff 	jne %d3,0,8000b63c <getTofDistance+0x78>
    /* for debugging */
//     for (int i = 0; i < 16; i++) {
//         my_printf("%.2X ", buf_ToF[i]);
//     }

    if (!verifyCheckSum(buf_ToF)) {
8000b652:	39 a3 0f 00 	ld.bu %d3,[%sp]15
8000b656:	5f f3 f3 ff 	jne %d3,%d15,8000b63c <getTofDistance+0x78>
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b65a:	0c a9       	ld.bu %d15,[%sp]9
	int TOF_signal_strength = data[12] | (data[13] << 8);
8000b65c:	39 a3 0d 00 	ld.bu %d3,[%sp]13
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b660:	8f 8f 00 20 	sh %d2,%d15,8
8000b664:	0c aa       	ld.bu %d15,[%sp]10
	int TOF_signal_strength = data[12] | (data[13] << 8);
	/* when distance over 2m - out of range */
	if (TOF_signal_strength != 0 && TOF_distance != 0xFFFFF6u) {
8000b666:	7b 00 10 40 	movh %d4,256
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b66a:	8f 0f 01 f0 	sh %d15,%d15,16
8000b66e:	a6 2f       	or %d15,%d2
8000b670:	39 a2 08 00 	ld.bu %d2,[%sp]8
	int TOF_signal_strength = data[12] | (data[13] << 8);
	/* when distance over 2m - out of range */
	if (TOF_signal_strength != 0 && TOF_distance != 0xFFFFF6u) {
8000b674:	1b 64 ff 4f 	addi %d4,%d4,-10
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b678:	a6 2f       	or %d15,%d2
	int TOF_signal_strength = data[12] | (data[13] << 8);
8000b67a:	8f 83 00 20 	sh %d2,%d3,8
8000b67e:	39 a3 0c 00 	ld.bu %d3,[%sp]12
8000b682:	a6 23       	or %d3,%d2
	/* when distance over 2m - out of range */
	if (TOF_signal_strength != 0 && TOF_distance != 0xFFFFF6u) {
8000b684:	8b 03 20 22 	ne %d2,%d3,0
8000b688:	0b 4f 10 22 	and.ne %d2,%d15,%d4

    if (!verifyCheckSum(buf_ToF)) {
		return -1;
	}
	if (!checkTofStrength(buf_ToF)) {
		return -2;
8000b68c:	ab ef 9f 22 	sel %d2,%d2,%d15,-2
	}

    TOF_distance = buf_ToF[8] | (buf_ToF[9] << 8) | (buf_ToF[10] << 16);

    return TOF_distance;
}
8000b690:	00 90       	ret 

8000b692 <Init_Ultrasonics>:
#include <tc27xd/Ifx_reg.h>

void Init_Ultrasonics(void)
{
	/* Init Rear Ultrasonic Pin */
	MODULE_P00.IOCR0.B.PC0 = 0b10000; /* Rear TRIG */
8000b692:	91 40 00 ff 	movh.a %a15,61444
8000b696:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b69a:	4c f4       	ld.w %d15,[%a15]16
8000b69c:	8f 8f cf f1 	andn %d15,%d15,248
8000b6a0:	96 80       	or %d15,128
8000b6a2:	68 4f       	st.w [%a15]16,%d15
	MODULE_P00.IOCR0.B.PC1 = 0b00010; /* Rear ECHO */
8000b6a4:	4c f4       	ld.w %d15,[%a15]16
8000b6a6:	b7 2f 85 f5 	insert %d15,%d15,2,11,5
8000b6aa:	68 4f       	st.w [%a15]16,%d15

	// Init GPT1 for T4 timer
	init_gpt1();
8000b6ac:	1d ff 94 f9 	j 8000a9d4 <init_gpt1>

8000b6b0 <ReadUltrasonic_noFilt>:
}

double ReadUltrasonic_noFilt(void)
{
8000b6b0:	20 08       	sub.a %sp,8
	volatile int j=0;
8000b6b2:	82 0f       	mov %d15,0
	unsigned int timer_end;
	double duration;
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
8000b6b4:	91 40 00 ff 	movh.a %a15,61444
	init_gpt1();
}

double ReadUltrasonic_noFilt(void)
{
	volatile int j=0;
8000b6b8:	78 01       	st.w [%sp]4,%d15
	unsigned int timer_end;
	double duration;
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
8000b6ba:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b6be:	48 02       	ld.w %d2,[%a15]0
8000b6c0:	8f 12 40 21 	or %d2,%d2,1
8000b6c4:	68 02       	st.w [%a15]0,%d2
	for(j=0; j<1000; j++) continue;
8000b6c6:	78 01       	st.w [%sp]4,%d15
8000b6c8:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b6cc:	3b 80 3e f0 	mov %d15,1000
8000b6d0:	3f f2 26 00 	jlt %d2,%d15,8000b71c <ReadUltrasonic_noFilt+0x6c>
	MODULE_P00.OUT.B.P0 = 0; // TRIG_LOW
8000b6d4:	91 40 00 ff 	movh.a %a15,61444
8000b6d8:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b6dc:	4c f0       	ld.w %d15,[%a15]0

	/* Calculate Distance */
	setGpt12_T4(0);
8000b6de:	82 04       	mov %d4,0
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
	for(j=0; j<1000; j++) continue;
	MODULE_P00.OUT.B.P0 = 0; // TRIG_LOW
8000b6e0:	8f 1f c0 f1 	andn %d15,%d15,1
8000b6e4:	68 0f       	st.w [%a15]0,%d15

	/* Calculate Distance */
	setGpt12_T4(0);
8000b6e6:	6d ff 0a fa 	call 8000aafa <setGpt12_T4>
	while (MODULE_P00.IN.B.P1 == 0); // wait for ECHO_HIGH
8000b6ea:	4c f9       	ld.w %d15,[%a15]36
8000b6ec:	6f 1f ff 7f 	jz.t %d15,1,8000b6ea <ReadUltrasonic_noFilt+0x3a>
	runGpt12_T4();
8000b6f0:	6d ff f8 f9 	call 8000aae0 <runGpt12_T4>
	while (MODULE_P00.IN.B.P1 == 1); // wait for ECHO_LOW
8000b6f4:	91 40 00 ff 	movh.a %a15,61444
8000b6f8:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b6fc:	4c f9       	ld.w %d15,[%a15]36
8000b6fe:	6f 1f ff ff 	jnz.t %d15,1,8000b6fc <ReadUltrasonic_noFilt+0x4c>
	stopGpt12_T4();
8000b702:	6d ff f5 f9 	call 8000aaec <stopGpt12_T4>

	timer_end = getGpt12_T4();
8000b706:	6d ff fd f9 	call 8000ab00 <getGpt12_T4>
	duration = (timer_end - 0) * 10.24;

	distance = 0.0343 * duration / 2.0; // cm/us
	return distance;
}
8000b70a:	7b 40 e3 f3 	movh %d15,15924
	runGpt12_T4();
	while (MODULE_P00.IN.B.P1 == 1); // wait for ECHO_LOW
	stopGpt12_T4();

	timer_end = getGpt12_T4();
	duration = (timer_end - 0) * 10.24;
8000b70e:	4b 02 61 21 	utof %d2,%d2

	distance = 0.0343 * duration / 2.0; // cm/us
	return distance;
}
8000b712:	1b ef 4a fd 	addi %d15,%d15,-11090
8000b716:	4b f2 41 20 	mul.f %d2,%d2,%d15
8000b71a:	00 90       	ret 
	double duration;
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
	for(j=0; j<1000; j++) continue;
8000b71c:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b720:	c2 12       	add %d2,1
8000b722:	59 a2 04 00 	st.w [%sp]4,%d2
8000b726:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b72a:	7f f2 d5 7f 	jge %d2,%d15,8000b6d4 <ReadUltrasonic_noFilt+0x24>
8000b72e:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b732:	c2 12       	add %d2,1
8000b734:	59 a2 04 00 	st.w [%sp]4,%d2
8000b738:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b73c:	3f f2 f0 7f 	jlt %d2,%d15,8000b71c <ReadUltrasonic_noFilt+0x6c>
8000b740:	3c ca       	j 8000b6d4 <ReadUltrasonic_noFilt+0x24>

8000b742 <ReadUltrasonic_Filt>:
	distance = 0.0343 * duration / 2.0; // cm/us
	return distance;
}

double ReadUltrasonic_Filt(void)
{
8000b742:	20 08       	sub.a %sp,8
	init_gpt1();
}

double ReadUltrasonic_noFilt(void)
{
	volatile int j=0;
8000b744:	82 0f       	mov %d15,0
	unsigned int timer_end;
	double duration;
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
8000b746:	91 40 00 ff 	movh.a %a15,61444
	init_gpt1();
}

double ReadUltrasonic_noFilt(void)
{
	volatile int j=0;
8000b74a:	78 01       	st.w [%sp]4,%d15
	unsigned int timer_end;
	double duration;
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
8000b74c:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b750:	48 02       	ld.w %d2,[%a15]0
8000b752:	8f 12 40 21 	or %d2,%d2,1
8000b756:	68 02       	st.w [%a15]0,%d2
	for(j=0; j<1000; j++) continue;
8000b758:	78 01       	st.w [%sp]4,%d15
8000b75a:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b75e:	3b 80 3e f0 	mov %d15,1000
8000b762:	3f f2 54 00 	jlt %d2,%d15,8000b80a <ReadUltrasonic_Filt+0xc8>
	MODULE_P00.OUT.B.P0 = 0; // TRIG_LOW
8000b766:	91 40 00 ff 	movh.a %a15,61444
8000b76a:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b76e:	4c f0       	ld.w %d15,[%a15]0

	/* Calculate Distance */
	setGpt12_T4(0);
8000b770:	82 04       	mov %d4,0
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
	for(j=0; j<1000; j++) continue;
	MODULE_P00.OUT.B.P0 = 0; // TRIG_LOW
8000b772:	8f 1f c0 f1 	andn %d15,%d15,1
8000b776:	68 0f       	st.w [%a15]0,%d15

	/* Calculate Distance */
	setGpt12_T4(0);
8000b778:	6d ff c1 f9 	call 8000aafa <setGpt12_T4>
	while (MODULE_P00.IN.B.P1 == 0); // wait for ECHO_HIGH
8000b77c:	4c f9       	ld.w %d15,[%a15]36
8000b77e:	6f 1f ff 7f 	jz.t %d15,1,8000b77c <ReadUltrasonic_Filt+0x3a>
	runGpt12_T4();
8000b782:	6d ff af f9 	call 8000aae0 <runGpt12_T4>
	while (MODULE_P00.IN.B.P1 == 1); // wait for ECHO_LOW
8000b786:	91 40 00 ff 	movh.a %a15,61444
8000b78a:	d9 ff 00 0a 	lea %a15,[%a15]-24576 <f003a000 <_SMALL_DATA4_+0x40032000>>
8000b78e:	4c f9       	ld.w %d15,[%a15]36
8000b790:	6f 1f ff ff 	jnz.t %d15,1,8000b78e <ReadUltrasonic_Filt+0x4c>
	stopGpt12_T4();
8000b794:	6d ff ac f9 	call 8000aaec <stopGpt12_T4>

	timer_end = getGpt12_T4();
8000b798:	6d ff b4 f9 	call 8000ab00 <getGpt12_T4>
	duration = (timer_end - 0) * 10.24;

	distance = 0.0343 * duration / 2.0; // cm/us
8000b79c:	7b 40 e3 f3 	movh %d15,15924
	runGpt12_T4();
	while (MODULE_P00.IN.B.P1 == 1); // wait for ECHO_LOW
	stopGpt12_T4();

	timer_end = getGpt12_T4();
	duration = (timer_end - 0) * 10.24;
8000b7a0:	4b 02 61 21 	utof %d2,%d2
	double distance_filt;
	static int sensorRxCnt = 0;

	distance_nofilt = ReadUltrasonic_noFilt();

	++old_index;
8000b7a4:	91 00 00 f7 	movh.a %a15,28672
	stopGpt12_T4();

	timer_end = getGpt12_T4();
	duration = (timer_end - 0) * 10.24;

	distance = 0.0343 * duration / 2.0; // cm/us
8000b7a8:	1b ef 4a fd 	addi %d15,%d15,-11090
8000b7ac:	4b f2 41 20 	mul.f %d2,%d2,%d15
	double distance_filt;
	static int sensorRxCnt = 0;

	distance_nofilt = ReadUltrasonic_noFilt();

	++old_index;
8000b7b0:	19 ff d0 01 	ld.w %d15,[%a15]7184 <70001c10 <old_index.37638>>
	old_index %= FILT_SIZE;  // Buffer Size = 5
8000b7b4:	82 54       	mov %d4,5
	double distance_filt;
	static int sensorRxCnt = 0;

	distance_nofilt = ReadUltrasonic_noFilt();

	++old_index;
8000b7b6:	c2 1f       	add %d15,1
	old_index %= FILT_SIZE;  // Buffer Size = 5
8000b7b8:	4b 4f 01 42 	div %e4,%d15,%d4
	avg_filt_buf[old_index] = distance_nofilt;
8000b7bc:	91 00 00 37 	movh.a %a3,28672
	static int sensorRxCnt = 0;

	distance_nofilt = ReadUltrasonic_noFilt();

	++old_index;
	old_index %= FILT_SIZE;  // Buffer Size = 5
8000b7c0:	59 f5 d0 01 	st.w [%a15]7184 <70001c10 <old_index.37638>>,%d5
	avg_filt_buf[old_index] = distance_nofilt;
8000b7c4:	d9 3f bc f1 	lea %a15,[%a3]7164 <70001bfc <avg_filt_buf.37637>>
8000b7c8:	01 f5 02 26 	addsc.a %a2,%a15,%d5,2
8000b7cc:	74 22       	st.w [%a2],%d2
	sensorRxCnt++;
8000b7ce:	91 00 00 27 	movh.a %a2,28672
8000b7d2:	19 2f b8 f1 	ld.w %d15,[%a2]7160 <70001bf8 <sensorRxCnt.37640>>
8000b7d6:	c2 1f       	add %d15,1
8000b7d8:	59 2f b8 f1 	st.w [%a2]7160 <70001bf8 <sensorRxCnt.37640>>,%d15

	/* Calculate Moving Average Filter */
	if (sensorRxCnt >= FILT_SIZE) {
8000b7dc:	bf 5f 16 00 	jlt %d15,5,8000b808 <ReadUltrasonic_Filt+0xc6>
		double sum = 0;
		for (int i = 0; i < FILT_SIZE; i++) { sum += avg_filt_buf[i]; }
8000b7e0:	4c f1       	ld.w %d15,[%a15]4
8000b7e2:	19 32 bc f1 	ld.w %d2,[%a3]7164 <70001bfc <avg_filt_buf.37637>>
8000b7e6:	6b 0f 21 22 	add.f %d2,%d2,%d15
8000b7ea:	4c f2       	ld.w %d15,[%a15]8
8000b7ec:	6b 0f 21 22 	add.f %d2,%d2,%d15
8000b7f0:	4c f3       	ld.w %d15,[%a15]12
8000b7f2:	6b 0f 21 22 	add.f %d2,%d2,%d15
8000b7f6:	4c f4       	ld.w %d15,[%a15]16
8000b7f8:	6b 0f 21 22 	add.f %d2,%d2,%d15
		distance_filt = sum / FILT_SIZE;
8000b7fc:	7b d0 e4 f3 	movh %d15,15949
8000b800:	1b df cc fc 	addi %d15,%d15,-13107
8000b804:	4b f2 41 20 	mul.f %d2,%d2,%d15
	}
	else
		distance_filt = distance_nofilt;

	return distance_filt;
}
8000b808:	00 90       	ret 
	double duration;
	double distance;

	/* Send Trigger Pulse */
	MODULE_P00.OUT.B.P0 = 1; // TRIG_HIGH
	for(j=0; j<1000; j++) continue;
8000b80a:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b80e:	c2 12       	add %d2,1
8000b810:	59 a2 04 00 	st.w [%sp]4,%d2
8000b814:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b818:	7f f2 a7 7f 	jge %d2,%d15,8000b766 <ReadUltrasonic_Filt+0x24>
8000b81c:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b820:	c2 12       	add %d2,1
8000b822:	59 a2 04 00 	st.w [%sp]4,%d2
8000b826:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b82a:	3f f2 f0 7f 	jlt %d2,%d15,8000b80a <ReadUltrasonic_Filt+0xc8>
8000b82e:	3c 9c       	j 8000b766 <ReadUltrasonic_Filt+0x24>

8000b830 <InterruptInit>:
	Return:		void
---------------------------------------------------------------------*/
void InterruptInit(void)
{
	/* basic initialisation of vector tables */
	_init_vectab();
8000b830:	6d 00 ee 2f 	call 8001180c <_init_vectab>
}

static __inline__ __attribute__((__always_inline__))
void _enable (void)
{
  __asm__ volatile ("enable" ::: "memory");
8000b834:	0d 00 00 03 	enable 
8000b838:	00 90       	ret 

8000b83a <InterruptInstall>:
				int prio         - priority (1-255)
				int arg          - argument for service routine
	Return:		void
---------------------------------------------------------------------*/
void InterruptInstall(int irqNum, isrhnd_t isrProc, int prio, int arg)
{
8000b83a:	02 4f       	mov %d15,%d4
8000b83c:	02 58       	mov %d8,%d5

static __inline__ __attribute__((__always_inline__))
unsigned _mfcr (const unsigned __regaddr)
{
  unsigned __res;
  __asm__ volatile ("mfcr %0, LO:%1"
8000b83e:	4d c0 e1 9f 	mfcr %d9,$core_id
	unsigned int coreId = _mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK;

	if ((irqNum < 0) || (IRQ_ID_MAX_NUM <= irqNum))
8000b842:	3b 40 77 20 	mov %d2,1908
8000b846:	3f 24 03 80 	jlt.u %d4,%d2,8000b84c <InterruptInstall+0x12>
8000b84a:	00 90       	ret 
	{
		return;
	}

	/* install the service routine */
	_install_int_handler(prio, isrProc, arg);
8000b84c:	0b 56 10 48 	mov %e4,%d6,%d5
8000b850:	6d 00 cb 2f 	call 800117e6 <_install_int_handler>

	/* set processor and priority values */
	tabSRC[irqNum].B.TOS  = coreId;
8000b854:	06 2f       	sh %d15,2
8000b856:	60 f2       	mov.a %a2,%d15
	tabSRC[irqNum].B.SRPN = prio;
8000b858:	8f f8 0f 81 	and %d8,%d8,255

	/* install the service routine */
	_install_int_handler(prio, isrProc, arg);

	/* set processor and priority values */
	tabSRC[irqNum].B.TOS  = coreId;
8000b85c:	d9 2f 00 08 	lea %a15,[%a2]-32768
8000b860:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000b864:	4c f0       	ld.w %d15,[%a15]0
8000b866:	37 9f 82 95 	insert %d9,%d15,%d9,11,2
8000b86a:	68 09       	st.w [%a15]0,%d9
	tabSRC[irqNum].B.SRPN = prio;
8000b86c:	4c f0       	ld.w %d15,[%a15]0
8000b86e:	8f ff cf f1 	andn %d15,%d15,255
8000b872:	a6 f8       	or %d8,%d15
8000b874:	68 08       	st.w [%a15]0,%d8
	/* ... and enable it */
	tabSRC[irqNum].B.SRE = 1;
8000b876:	4c f0       	ld.w %d15,[%a15]0
8000b878:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000b87c:	68 0f       	st.w [%a15]0,%d15
8000b87e:	00 90       	ret 

8000b880 <SYSTEM_Init>:
8000b880:	4d c0 e1 ff 	mfcr %d15,$core_id
 */
static void SYSTEM_InitExt(const PllInitValue_t *pPllInitValue)
{
#ifndef SYSTEM_DONT_SET_PLL
	/* initialise PLL (only done by CPU0) */
	if (0 == (_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
8000b884:	16 07       	and %d15,7
8000b886:	6e 02       	jz %d15,8000b88a <SYSTEM_Init+0xa>
8000b888:	00 90       	ret 
{
	unsigned int k;

	unlock_safety_wdtcon();

	pSCU->OSCCON.U = pPllInitValue->valOSCCON;
8000b88a:	7b 70 00 f0 	movh %d15,7
8000b88e:	91 30 00 ff 	movh.a %a15,61443
8000b892:	1b cf 01 f0 	addi %d15,%d15,28
8000b896:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>

static void system_set_pll(const PllInitValue_t *pPllInitValue)
{
	unsigned int k;

	unlock_safety_wdtcon();
8000b89a:	6d 00 3b 30 	call 80011910 <unlock_safety_wdtcon>

	pSCU->OSCCON.U = pPllInitValue->valOSCCON;
8000b89e:	68 4f       	st.w [%a15]16,%d15

	while (pSCU->CCUCON1.B.LCK)
8000b8a0:	4c fd       	ld.w %d15,[%a15]52
8000b8a2:	bf 0f ff 7f 	jlt %d15,0,8000b8a0 <SYSTEM_Init+0x20>
		;
	pSCU->CCUCON1.U = pPllInitValue->valCCUCON1 | (1 << IFX_SCU_CCUCON1_UP_OFF);
8000b8a6:	7b 10 00 f5 	movh %d15,20481
8000b8aa:	91 30 00 ff 	movh.a %a15,61443
8000b8ae:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b8b2:	1b 2f 24 f2 	addi %d15,%d15,8770
8000b8b6:	68 df       	st.w [%a15]52,%d15

	while (pSCU->CCUCON2.B.LCK)
8000b8b8:	40 f2       	mov.aa %a2,%a15
8000b8ba:	19 2f 00 10 	ld.w %d15,[%a2]64 <70000040 <__DSPR0_START+0x40>>
8000b8be:	91 30 00 ff 	movh.a %a15,61443
8000b8c2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b8c6:	bf 0f fa 7f 	jlt %d15,0,8000b8ba <SYSTEM_Init+0x3a>
		;
	pSCU->CCUCON2.U = pPllInitValue->valCCUCON2 | (1 << IFX_SCU_CCUCON2_UP_OFF);
8000b8ca:	7b 00 00 f4 	movh %d15,16384
8000b8ce:	c2 2f       	add %d15,2
8000b8d0:	59 ff 00 10 	st.w [%a15]64 <f0030040 <_SMALL_DATA4_+0x40028040>>,%d15

	pSCU->PLLCON0.U |= ((1 << IFX_SCU_PLLCON0_VCOBYP_OFF) | (1 << IFX_SCU_PLLCON0_SETFINDIS_OFF));
8000b8d4:	4c f6       	ld.w %d15,[%a15]24
8000b8d6:	96 11       	or %d15,17
8000b8d8:	68 6f       	st.w [%a15]24,%d15
	pSCU->PLLCON1.U =  pPllInitValue->valPLLCON1;				/* set Kn divider */
8000b8da:	7b 20 00 f0 	movh %d15,2
8000b8de:	1b 5f 50 f0 	addi %d15,%d15,1285
8000b8e2:	68 7f       	st.w [%a15]28,%d15
	pSCU->PLLCON0.U =  pPllInitValue->valPLLCON0				/* set P,N divider */
8000b8e4:	7b 10 10 f0 	movh %d15,257
8000b8e8:	1b 1f 62 f7 	addi %d15,%d15,30241
8000b8ec:	68 6f       	st.w [%a15]24,%d15
					| ((1 << IFX_SCU_PLLCON0_VCOBYP_OFF) | (1 << IFX_SCU_PLLCON0_CLRFINDIS_OFF));

	while (pSCU->CCUCON0.B.LCK)
8000b8ee:	4c fc       	ld.w %d15,[%a15]48
8000b8f0:	bf 0f ff 7f 	jlt %d15,0,8000b8ee <SYSTEM_Init+0x6e>
		;
	pSCU->CCUCON0.U =  pPllInitValue->valCCUCON0 | (1 << IFX_SCU_CCUCON0_UP_OFF);
8000b8f4:	7b 20 21 f5 	movh %d15,21010
8000b8f8:	91 30 00 ff 	movh.a %a15,61443
8000b8fc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b900:	1b 2f 11 f0 	addi %d15,%d15,274
8000b904:	68 cf       	st.w [%a15]48,%d15

	lock_safety_wdtcon();
8000b906:	6d 00 15 30 	call 80011930 <lock_safety_wdtcon>

	if (0 == (pPllInitValue->valPLLCON0 & (1 << IFX_SCU_PLLCON0_VCOBYP_OFF)))	/* no prescaler mode requested */
	{
#ifndef SYSTEM_PLL_HAS_NO_LOCK
		/* wait for PLL locked */
		while (0 == pSCU->PLLSTAT.B.VCOLOCK)
8000b90a:	40 f2       	mov.aa %a2,%a15
8000b90c:	4c 25       	ld.w %d15,[%a2]20
8000b90e:	91 30 00 ff 	movh.a %a15,61443
8000b912:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b916:	6f 2f fb 7f 	jz.t %d15,2,8000b90c <SYSTEM_Init+0x8c>
			;
#endif

		unlock_safety_wdtcon();
8000b91a:	6d 00 fb 2f 	call 80011910 <unlock_safety_wdtcon>
		pSCU->PLLCON0.B.VCOBYP = 0;			/* disable VCO bypass */
8000b91e:	4c f6       	ld.w %d15,[%a15]24
8000b920:	8f 1f c0 f1 	andn %d15,%d15,1
8000b924:	68 6f       	st.w [%a15]24,%d15
		lock_safety_wdtcon();
8000b926:	6d 00 05 30 	call 80011930 <lock_safety_wdtcon>
	}

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
8000b92a:	48 79       	ld.w %d9,[%a15]28
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b92c:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b92e:	7b 60 5f 20 	movh %d2,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b932:	37 0f 62 fe 	extr.u %d15,%d15,28,2
		pSCU->PLLCON0.B.VCOBYP = 0;			/* disable VCO bypass */
		lock_safety_wdtcon();
	}

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
8000b936:	8f f9 07 91 	and %d9,%d9,127
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b93a:	1b 02 10 2e 	addi %d2,%d2,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b93e:	df 1f bd 00 	jeq %d15,1,8000bab8 <SYSTEM_Init+0x238>
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000b942:	91 30 00 ff 	movh.a %a15,61443
8000b946:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b94a:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
8000b94c:	82 03       	mov %d3,0
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000b94e:	37 0f 64 f4 	extr.u %d15,%d15,8,4
	if (0 == divider)
8000b952:	6e 15       	jz %d15,8000b97c <SYSTEM_Init+0xfc>
		return 0;
	return (frequency / divider);
8000b954:	4b f2 11 22 	div.u %e2,%d2,%d15
8000b958:	7b c0 1e f5 	movh %d15,20972
8000b95c:	1b ff 51 f8 	addi %d15,%d15,-31457
8000b960:	73 f2 68 20 	mul.u %e2,%d2,%d15
8000b964:	8f b3 1f 20 	sh %d2,%d3,-5
8000b968:	53 42 26 f0 	mul %d15,%d2,100
8000b96c:	7b 70 1b 2d 	movh %d2,53687
8000b970:	1b 92 75 21 	addi %d2,%d2,5977
8000b974:	73 2f 68 20 	mul.u %e2,%d15,%d2
8000b978:	8f 33 1f 30 	sh %d3,%d3,-13
{
	unsigned int fSTM = (unsigned int)SYSTEM_GetStmClock();
	unsigned int stmWaitCount = (fSTM / TIME_SCALE_DN) * time / TIME_SCALE_UP;

	/* prepare compare register */
	STM0_CMP0.U = STM0_TIM0.U + stmWaitCount;
8000b97c:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000b980:	42 3f       	add %d15,%d3
8000b982:	a5 ff 30 00 	st.w f0000030 <_SMALL_DATA4_+0x3fff8030>,%d15
	STM0_CMCON.U = 31;
8000b986:	da 1f       	mov %d15,31
8000b988:	a5 ff 38 00 	st.w f0000038 <_SMALL_DATA4_+0x3fff8038>,%d15
	/* Attention: keep this order, otherwise first match will trigger too soon */
	/* reset interrupt flag */
	STM0_ISCR.U = (IFX_STM_ISCR_CMP0IRR_MSK << IFX_STM_ISCR_CMP0IRR_OFF);
8000b98c:	82 1f       	mov %d15,1
8000b98e:	a5 ff 00 10 	st.w f0000040 <_SMALL_DATA4_+0x3fff8040>,%d15
	/* enable compare match */
	STM0_ICR.B.CMP0EN = 1;
8000b992:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000b996:	96 01       	or %d15,1
8000b998:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15
	/* wait for compare match */
	while (0 == STM0_ICR.B.CMP0IR)
8000b99c:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000b9a0:	6f 1f fe 7f 	jz.t %d15,1,8000b99c <SYSTEM_Init+0x11c>
		;
	STM0_ICR.B.CMP0EN = 0;
8000b9a4:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000b9a8:	8f 1f c0 f1 	andn %d15,%d15,1
8000b9ac:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
	/* wait some time (100 us) */
	wait(100);
	while (k > pPllInitValue->finalK)
8000b9b0:	bf 39 6c ff 	jlt.u %d9,3,8000b888 <SYSTEM_Init+0x8>
	{
		Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000b9b4:	91 30 00 ff 	movh.a %a15,61443
8000b9b8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000b9bc:	7b 10 13 c0 	movh %d12,305
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000b9c0:	7b f0 fa d2 	movh %d13,12207
8000b9c4:	c2 f9       	add %d9,-1
#if (USE_OLD_CLOCK_SCHEME == 0)
		/* A step devices don't have this field */
		pllcon1.B.K3DIV = k;
#endif /* USE_OLD_CLOCK_SCHEME == 0 */
		/* wait until K2 operation is stable */
		while (0 == pSCU->PLLSTAT.B.K2RDY)
8000b9c6:	40 fc       	mov.aa %a12,%a15
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000b9c8:	1b 0c d0 c2 	addi %d12,%d12,11520
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000b9cc:	1b 0d 80 d0 	addi %d13,%d13,2048
	unsigned int fSTM = (unsigned int)SYSTEM_GetStmClock();
	unsigned int stmWaitCount = (fSTM / TIME_SCALE_DN) * time / TIME_SCALE_UP;

	/* prepare compare register */
	STM0_CMP0.U = STM0_TIM0.U + stmWaitCount;
	STM0_CMCON.U = 31;
8000b9d0:	3b f0 01 b0 	mov %d11,31
	k = pSCU->PLLCON1.B.K2DIV;
	/* wait some time (100 us) */
	wait(100);
	while (k > pPllInitValue->finalK)
	{
		Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000b9d4:	48 78       	ld.w %d8,[%a15]28

		--k;
		/* prepare value to write */
		pllcon1.B.K2DIV = k;
8000b9d6:	8f f9 07 a1 	and %d10,%d9,127
#if (USE_OLD_CLOCK_SCHEME == 0)
		/* A step devices don't have this field */
		pllcon1.B.K3DIV = k;
#endif /* USE_OLD_CLOCK_SCHEME == 0 */
		/* wait until K2 operation is stable */
		while (0 == pSCU->PLLSTAT.B.K2RDY)
8000b9da:	4c f5       	ld.w %d15,[%a15]20
8000b9dc:	6f 5f ff 7f 	jz.t %d15,5,8000b9da <SYSTEM_Init+0x15a>
			;
		unlock_safety_wdtcon();
		pSCU->PLLCON1 = pllcon1;
8000b9e0:	37 a8 07 80 	insert %d8,%d8,%d10,0,7
8000b9e4:	37 a8 07 84 	insert %d8,%d8,%d10,8,7
		pllcon1.B.K3DIV = k;
#endif /* USE_OLD_CLOCK_SCHEME == 0 */
		/* wait until K2 operation is stable */
		while (0 == pSCU->PLLSTAT.B.K2RDY)
			;
		unlock_safety_wdtcon();
8000b9e8:	6d 00 94 2f 	call 80011910 <unlock_safety_wdtcon>
		pSCU->PLLCON1 = pllcon1;
8000b9ec:	59 c8 1c 00 	st.w [%a12]28 <f004001c <_SMALL_DATA4_+0x4003801c>>,%d8
		lock_safety_wdtcon();
8000b9f0:	6d 00 a0 2f 	call 80011930 <lock_safety_wdtcon>
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b9f4:	4c cc       	ld.w %d15,[%a12]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b9f6:	7b 60 5f 20 	movh %d2,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b9fa:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b9fe:	1b 02 10 2e 	addi %d2,%d2,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000ba02:	df 1f 38 00 	jeq %d15,1,8000ba72 <SYSTEM_Init+0x1f2>
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000ba06:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
8000ba08:	82 03       	mov %d3,0
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000ba0a:	37 0f 64 f4 	extr.u %d15,%d15,8,4
	if (0 == divider)
8000ba0e:	6e 15       	jz %d15,8000ba38 <SYSTEM_Init+0x1b8>
		return 0;
	return (frequency / divider);
8000ba10:	4b f2 11 22 	div.u %e2,%d2,%d15
8000ba14:	7b c0 1e f5 	movh %d15,20972
8000ba18:	1b ff 51 f8 	addi %d15,%d15,-31457
8000ba1c:	73 f2 68 20 	mul.u %e2,%d2,%d15
8000ba20:	8f b3 1f 20 	sh %d2,%d3,-5
8000ba24:	53 42 26 f0 	mul %d15,%d2,100
8000ba28:	7b 70 1b 2d 	movh %d2,53687
8000ba2c:	1b 92 75 21 	addi %d2,%d2,5977
8000ba30:	73 2f 68 20 	mul.u %e2,%d15,%d2
8000ba34:	8f 33 1f 30 	sh %d3,%d3,-13
{
	unsigned int fSTM = (unsigned int)SYSTEM_GetStmClock();
	unsigned int stmWaitCount = (fSTM / TIME_SCALE_DN) * time / TIME_SCALE_UP;

	/* prepare compare register */
	STM0_CMP0.U = STM0_TIM0.U + stmWaitCount;
8000ba38:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000ba3c:	42 3f       	add %d15,%d3
8000ba3e:	a5 ff 30 00 	st.w f0000030 <_SMALL_DATA4_+0x3fff8030>,%d15
	STM0_CMCON.U = 31;
8000ba42:	a5 fb 38 00 	st.w f0000038 <_SMALL_DATA4_+0x3fff8038>,%d11
	/* Attention: keep this order, otherwise first match will trigger too soon */
	/* reset interrupt flag */
	STM0_ISCR.U = (IFX_STM_ISCR_CMP0IRR_MSK << IFX_STM_ISCR_CMP0IRR_OFF);
8000ba46:	82 1f       	mov %d15,1
8000ba48:	a5 ff 00 10 	st.w f0000040 <_SMALL_DATA4_+0x3fff8040>,%d15
	/* enable compare match */
	STM0_ICR.B.CMP0EN = 1;
8000ba4c:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000ba50:	96 01       	or %d15,1
8000ba52:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15
	/* wait for compare match */
	while (0 == STM0_ICR.B.CMP0IR)
8000ba56:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000ba5a:	6f 1f fe 7f 	jz.t %d15,1,8000ba56 <SYSTEM_Init+0x1d6>
		;
	STM0_ICR.B.CMP0EN = 0;
8000ba5e:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000ba62:	c2 f9       	add %d9,-1
8000ba64:	8f 1f c0 f1 	andn %d15,%d15,1
8000ba68:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
	/* wait some time (100 us) */
	wait(100);
	while (k > pPllInitValue->finalK)
8000ba6c:	df 19 b4 ff 	jne %d9,1,8000b9d4 <SYSTEM_Init+0x154>
8000ba70:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000ba72:	19 c3 14 00 	ld.w %d3,[%a12]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000ba76:	19 c2 18 00 	ld.w %d2,[%a12]24
8000ba7a:	37 02 e7 44 	extr.u %d4,%d2,9,7
8000ba7e:	37 02 64 7c 	extr.u %d7,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000ba82:	19 c2 1c 00 	ld.w %d2,[%a12]28
8000ba86:	8f f2 07 61 	and %d6,%d2,127
8000ba8a:	37 02 67 58 	extr.u %d5,%d2,16,7

	if (0 == (pllstat.B.VCOBYST))
8000ba8e:	6f 03 0d 80 	jnz.t %d3,0,8000baa8 <SYSTEM_Init+0x228>
	{
		if (0 == (pllstat.B.FINDIS))
8000ba92:	6f 33 0f 80 	jnz.t %d3,3,8000bab0 <SYSTEM_Init+0x230>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000ba96:	03 c4 0a 4c 	madd %d4,%d12,%d4,%d12
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000ba9a:	9a 17       	add %d15,%d7,1
8000ba9c:	4b f4 11 42 	div.u %e4,%d4,%d15
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000baa0:	9a 16       	add %d15,%d6,1
8000baa2:	4b f4 11 22 	div.u %e2,%d4,%d15
8000baa6:	3c b0       	j 8000ba06 <SYSTEM_Init+0x186>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000baa8:	9a 15       	add %d15,%d5,1
8000baaa:	4b fc 11 22 	div.u %e2,%d12,%d15
8000baae:	3c ac       	j 8000ba06 <SYSTEM_Init+0x186>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bab0:	9a 16       	add %d15,%d6,1
8000bab2:	4b fd 11 22 	div.u %e2,%d13,%d15
8000bab6:	3c a8       	j 8000ba06 <SYSTEM_Init+0x186>

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bab8:	48 53       	ld.w %d3,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000baba:	4c f6       	ld.w %d15,[%a15]24
8000babc:	37 0f e7 54 	extr.u %d5,%d15,9,7
8000bac0:	37 0f 64 7c 	extr.u %d7,%d15,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bac4:	4c f7       	ld.w %d15,[%a15]28
8000bac6:	8f ff 07 61 	and %d6,%d15,127
8000baca:	37 0f 67 28 	extr.u %d2,%d15,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bace:	6f 03 14 80 	jnz.t %d3,0,8000baf6 <SYSTEM_Init+0x276>
	{
		if (0 == (pllstat.B.FINDIS))
8000bad2:	6f 33 1b 80 	jnz.t %d3,3,8000bb08 <SYSTEM_Init+0x288>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bad6:	7b 10 13 20 	movh %d2,305
8000bada:	1b 02 d0 22 	addi %d2,%d2,11520
8000bade:	03 25 0a 22 	madd %d2,%d2,%d5,%d2
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bae2:	1b 17 00 40 	addi %d4,%d7,1
8000bae6:	4b 42 11 42 	div.u %e4,%d2,%d4
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000baea:	1b 16 00 20 	addi %d2,%d6,1
8000baee:	4b 24 11 22 	div.u %e2,%d4,%d2
8000baf2:	1d ff 28 ff 	j 8000b942 <SYSTEM_Init+0xc2>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000baf6:	7b 10 13 30 	movh %d3,305
8000bafa:	c2 12       	add %d2,1
8000bafc:	1b 03 d0 32 	addi %d3,%d3,11520
8000bb00:	4b 23 11 22 	div.u %e2,%d3,%d2
8000bb04:	1d ff 1f ff 	j 8000b942 <SYSTEM_Init+0xc2>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bb08:	7b f0 fa f2 	movh %d15,12207
8000bb0c:	1b 16 00 20 	addi %d2,%d6,1
8000bb10:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bb14:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bb18:	1d ff 15 ff 	j 8000b942 <SYSTEM_Init+0xc2>

8000bb1c <SYSTEM_GetExtClock>:
}

unsigned long SYSTEM_GetExtClock(void)
{
	return EXTCLK;
}
8000bb1c:	7b 10 13 20 	movh %d2,305
8000bb20:	1b 02 d0 22 	addi %d2,%d2,11520
8000bb24:	00 90       	ret 

8000bb26 <SYSTEM_GetCpuClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bb26:	91 30 00 ff 	movh.a %a15,61443
8000bb2a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bb2e:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bb30:	7b 60 5f 40 	movh %d4,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bb34:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bb38:	1b 04 10 4e 	addi %d4,%d4,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bb3c:	9e 1f       	jeq %d15,1,8000bb7a <SYSTEM_GetCpuClock+0x54>
	unsigned long divider;

	unsigned long cpudiv = 0;
	/* B + C Step devices */
	/* fCPU = fSRI */
	divider = pSCU->CCUCON0.B.SRIDIV;
8000bb3e:	91 30 00 ff 	movh.a %a15,61443
8000bb42:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bb46:	4c fc       	ld.w %d15,[%a15]48

	if (0 == divider)
		return 0;
8000bb48:	82 02       	mov %d2,0
	unsigned long divider;

	unsigned long cpudiv = 0;
	/* B + C Step devices */
	/* fCPU = fSRI */
	divider = pSCU->CCUCON0.B.SRIDIV;
8000bb4a:	37 0f 64 f4 	extr.u %d15,%d15,8,4

	if (0 == divider)
8000bb4e:	6e 15       	jz %d15,8000bb78 <SYSTEM_GetCpuClock+0x52>
		return 0;
	frequency /= divider;
8000bb50:	4b f4 11 42 	div.u %e4,%d4,%d15
8000bb54:	02 42       	mov %d2,%d4
8000bb56:	4d c0 e1 ff 	mfcr %d15,$core_id

#if (USE_OLD_CLOCK_SCHEME == 0)
	/* determine correct CPU<n>DIV field */
	switch ((_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
8000bb5a:	16 07       	and %d15,7
8000bb5c:	df 1f 2c 00 	jeq %d15,1,8000bbb4 <SYSTEM_GetCpuClock+0x8e>
8000bb60:	6e 36       	jz %d15,8000bbcc <SYSTEM_GetCpuClock+0xa6>
8000bb62:	5e 2a       	jne %d15,2,8000bb76 <SYSTEM_GetCpuClock+0x50>
	{
		case 0 : cpudiv = pSCU->CCUCON6.B.CPU0DIV; break;
		case 1 : cpudiv = pSCU->CCUCON7.B.CPU1DIV; break;
		case 2 : cpudiv = pSCU->CCUCON8.B.CPU2DIV; break;
8000bb64:	19 ff 08 20 	ld.w %d15,[%a15]136 <f0030088 <_SMALL_DATA4_+0x40028088>>
8000bb68:	16 3f       	and %d15,63
	}

	if (cpudiv != 0)
8000bb6a:	6e 07       	jz %d15,8000bb78 <SYSTEM_GetCpuClock+0x52>
	{
		frequency *= (64 - cpudiv);
8000bb6c:	8b 0f 04 f1 	rsub %d15,%d15,64
8000bb70:	e2 f2       	mul %d2,%d15
		frequency /= 64;
8000bb72:	06 a2       	sh %d2,-6
8000bb74:	00 90       	ret 
	/* fCPU = fSRI */
	divider = pSCU->CCUCON0.B.SRIDIV;

	if (0 == divider)
		return 0;
	frequency /= divider;
8000bb76:	02 42       	mov %d2,%d4
		frequency /= 64;
	}
#endif /* USE_OLD_CLOCK_SCHEME == 0 */

	return frequency;
}
8000bb78:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bb7a:	48 53       	ld.w %d3,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bb7c:	4c f6       	ld.w %d15,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bb7e:	48 74       	ld.w %d4,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bb80:	37 0f e7 54 	extr.u %d5,%d15,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bb84:	8f f4 07 01 	and %d0,%d4,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bb88:	37 0f 64 7c 	extr.u %d7,%d15,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bb8c:	37 04 67 48 	extr.u %d4,%d4,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bb90:	6f 03 16 80 	jnz.t %d3,0,8000bbbc <SYSTEM_GetCpuClock+0x96>
	{
		if (0 == (pllstat.B.FINDIS))
8000bb94:	6f 33 20 80 	jnz.t %d3,3,8000bbd4 <SYSTEM_GetCpuClock+0xae>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bb98:	7b 10 13 f0 	movh %d15,305
8000bb9c:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bba0:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bba4:	1b 17 00 40 	addi %d4,%d7,1
8000bba8:	4b 4f 11 62 	div.u %e6,%d15,%d4
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bbac:	9a 10       	add %d15,%d0,1
8000bbae:	4b f6 11 42 	div.u %e4,%d6,%d15
8000bbb2:	3c c6       	j 8000bb3e <SYSTEM_GetCpuClock+0x18>
#if (USE_OLD_CLOCK_SCHEME == 0)
	/* determine correct CPU<n>DIV field */
	switch ((_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
	{
		case 0 : cpudiv = pSCU->CCUCON6.B.CPU0DIV; break;
		case 1 : cpudiv = pSCU->CCUCON7.B.CPU1DIV; break;
8000bbb4:	19 ff 04 20 	ld.w %d15,[%a15]132
8000bbb8:	16 3f       	and %d15,63
8000bbba:	3c d8       	j 8000bb6a <SYSTEM_GetCpuClock+0x44>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bbbc:	7b 10 13 f0 	movh %d15,305
8000bbc0:	c2 14       	add %d4,1
8000bbc2:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bbc6:	4b 4f 11 42 	div.u %e4,%d15,%d4
8000bbca:	3c ba       	j 8000bb3e <SYSTEM_GetCpuClock+0x18>

#if (USE_OLD_CLOCK_SCHEME == 0)
	/* determine correct CPU<n>DIV field */
	switch ((_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
	{
		case 0 : cpudiv = pSCU->CCUCON6.B.CPU0DIV; break;
8000bbcc:	19 ff 00 20 	ld.w %d15,[%a15]128
8000bbd0:	16 3f       	and %d15,63
8000bbd2:	3c cc       	j 8000bb6a <SYSTEM_GetCpuClock+0x44>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bbd4:	7b f0 fa f2 	movh %d15,12207
8000bbd8:	1b 10 00 40 	addi %d4,%d0,1
8000bbdc:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bbe0:	4b 4f 11 42 	div.u %e4,%d15,%d4
8000bbe4:	3c ad       	j 8000bb3e <SYSTEM_GetCpuClock+0x18>

8000bbe6 <SYSTEM_GetSysClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bbe6:	91 30 00 ff 	movh.a %a15,61443
8000bbea:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bbee:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bbf0:	7b 60 5f 30 	movh %d3,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bbf4:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bbf8:	1b 03 10 3e 	addi %d3,%d3,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bbfc:	1e 1d       	jeq %d15,1,8000bc16 <SYSTEM_GetSysClock+0x30>
}

unsigned long SYSTEM_GetSysClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON0.B.SPBDIV;
8000bbfe:	91 30 00 ff 	movh.a %a15,61443
8000bc02:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bc06:	4c fc       	ld.w %d15,[%a15]48
	if (0 == divider)
		return 0;
8000bc08:	82 02       	mov %d2,0
}

unsigned long SYSTEM_GetSysClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON0.B.SPBDIV;
8000bc0a:	37 0f 64 f8 	extr.u %d15,%d15,16,4
	if (0 == divider)
8000bc0e:	6e 03       	jz %d15,8000bc14 <SYSTEM_GetSysClock+0x2e>
		return 0;
	return (frequency / divider);
8000bc10:	4b f3 11 22 	div.u %e2,%d3,%d15
}
8000bc14:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bc16:	48 54       	ld.w %d4,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bc18:	48 62       	ld.w %d2,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bc1a:	48 73       	ld.w %d3,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bc1c:	37 02 e7 54 	extr.u %d5,%d2,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bc20:	8f f3 07 61 	and %d6,%d3,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bc24:	37 02 64 2c 	extr.u %d2,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bc28:	37 03 67 38 	extr.u %d3,%d3,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bc2c:	6f 04 12 80 	jnz.t %d4,0,8000bc50 <SYSTEM_GetSysClock+0x6a>
	{
		if (0 == (pllstat.B.FINDIS))
8000bc30:	6f 34 19 80 	jnz.t %d4,3,8000bc62 <SYSTEM_GetSysClock+0x7c>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bc34:	7b 10 13 f0 	movh %d15,305
8000bc38:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bc3c:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bc40:	c2 12       	add %d2,1
8000bc42:	4b 2f 11 42 	div.u %e4,%d15,%d2
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bc46:	9a 16       	add %d15,%d6,1
8000bc48:	4b f4 11 22 	div.u %e2,%d4,%d15
8000bc4c:	02 23       	mov %d3,%d2
8000bc4e:	3c d8       	j 8000bbfe <SYSTEM_GetSysClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bc50:	7b 10 13 f0 	movh %d15,305
8000bc54:	c2 13       	add %d3,1
8000bc56:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bc5a:	4b 3f 11 22 	div.u %e2,%d15,%d3
8000bc5e:	02 23       	mov %d3,%d2
8000bc60:	3c cf       	j 8000bbfe <SYSTEM_GetSysClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bc62:	7b f0 fa f2 	movh %d15,12207
8000bc66:	1b 16 00 20 	addi %d2,%d6,1
8000bc6a:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bc6e:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bc72:	02 23       	mov %d3,%d2
8000bc74:	3c c5       	j 8000bbfe <SYSTEM_GetSysClock+0x18>

8000bc76 <SYSTEM_GetStmClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bc76:	91 30 00 ff 	movh.a %a15,61443
8000bc7a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bc7e:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bc80:	7b 60 5f 30 	movh %d3,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bc84:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bc88:	1b 03 10 3e 	addi %d3,%d3,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bc8c:	1e 1d       	jeq %d15,1,8000bca6 <SYSTEM_GetStmClock+0x30>
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000bc8e:	91 30 00 ff 	movh.a %a15,61443
8000bc92:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bc96:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
		return 0;
8000bc98:	82 02       	mov %d2,0
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000bc9a:	37 0f 64 f4 	extr.u %d15,%d15,8,4
	if (0 == divider)
8000bc9e:	6e 03       	jz %d15,8000bca4 <SYSTEM_GetStmClock+0x2e>
		return 0;
	return (frequency / divider);
8000bca0:	4b f3 11 22 	div.u %e2,%d3,%d15
}
8000bca4:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bca6:	48 54       	ld.w %d4,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bca8:	48 62       	ld.w %d2,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bcaa:	48 73       	ld.w %d3,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bcac:	37 02 e7 54 	extr.u %d5,%d2,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bcb0:	8f f3 07 61 	and %d6,%d3,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bcb4:	37 02 64 2c 	extr.u %d2,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bcb8:	37 03 67 38 	extr.u %d3,%d3,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bcbc:	6f 04 12 80 	jnz.t %d4,0,8000bce0 <SYSTEM_GetStmClock+0x6a>
	{
		if (0 == (pllstat.B.FINDIS))
8000bcc0:	6f 34 19 80 	jnz.t %d4,3,8000bcf2 <SYSTEM_GetStmClock+0x7c>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bcc4:	7b 10 13 f0 	movh %d15,305
8000bcc8:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bccc:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bcd0:	c2 12       	add %d2,1
8000bcd2:	4b 2f 11 42 	div.u %e4,%d15,%d2
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bcd6:	9a 16       	add %d15,%d6,1
8000bcd8:	4b f4 11 22 	div.u %e2,%d4,%d15
8000bcdc:	02 23       	mov %d3,%d2
8000bcde:	3c d8       	j 8000bc8e <SYSTEM_GetStmClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bce0:	7b 10 13 f0 	movh %d15,305
8000bce4:	c2 13       	add %d3,1
8000bce6:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bcea:	4b 3f 11 22 	div.u %e2,%d15,%d3
8000bcee:	02 23       	mov %d3,%d2
8000bcf0:	3c cf       	j 8000bc8e <SYSTEM_GetStmClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bcf2:	7b f0 fa f2 	movh %d15,12207
8000bcf6:	1b 16 00 20 	addi %d2,%d6,1
8000bcfa:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bcfe:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bd02:	02 23       	mov %d3,%d2
8000bd04:	3c c5       	j 8000bc8e <SYSTEM_GetStmClock+0x18>

8000bd06 <SYSTEM_GetCanClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bd06:	91 30 00 ff 	movh.a %a15,61443
8000bd0a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bd0e:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bd10:	7b 60 5f 30 	movh %d3,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bd14:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bd18:	1b 03 10 3e 	addi %d3,%d3,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bd1c:	1e 1c       	jeq %d15,1,8000bd34 <SYSTEM_GetCanClock+0x2e>

unsigned long SYSTEM_GetCanClock(void)
{
	unsigned long frequency = system_GetIntClock();
    unsigned long divider;
    divider = pSCU->CCUCON1.B.CANDIV;
8000bd1e:	91 30 00 ff 	movh.a %a15,61443
8000bd22:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bd26:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
		return 0;
8000bd28:	82 02       	mov %d2,0

unsigned long SYSTEM_GetCanClock(void)
{
	unsigned long frequency = system_GetIntClock();
    unsigned long divider;
    divider = pSCU->CCUCON1.B.CANDIV;
8000bd2a:	16 0f       	and %d15,15
	if (0 == divider)
8000bd2c:	6e 03       	jz %d15,8000bd32 <SYSTEM_GetCanClock+0x2c>
		return 0;
	return (frequency / divider);
8000bd2e:	4b f3 11 22 	div.u %e2,%d3,%d15
}
8000bd32:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bd34:	48 54       	ld.w %d4,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bd36:	48 62       	ld.w %d2,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bd38:	48 73       	ld.w %d3,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bd3a:	37 02 e7 54 	extr.u %d5,%d2,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bd3e:	8f f3 07 61 	and %d6,%d3,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bd42:	37 02 64 2c 	extr.u %d2,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bd46:	37 03 67 38 	extr.u %d3,%d3,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bd4a:	6f 04 12 80 	jnz.t %d4,0,8000bd6e <SYSTEM_GetCanClock+0x68>
	{
		if (0 == (pllstat.B.FINDIS))
8000bd4e:	6f 34 19 80 	jnz.t %d4,3,8000bd80 <SYSTEM_GetCanClock+0x7a>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bd52:	7b 10 13 f0 	movh %d15,305
8000bd56:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bd5a:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bd5e:	c2 12       	add %d2,1
8000bd60:	4b 2f 11 42 	div.u %e4,%d15,%d2
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bd64:	9a 16       	add %d15,%d6,1
8000bd66:	4b f4 11 22 	div.u %e2,%d4,%d15
8000bd6a:	02 23       	mov %d3,%d2
8000bd6c:	3c d9       	j 8000bd1e <SYSTEM_GetCanClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bd6e:	7b 10 13 f0 	movh %d15,305
8000bd72:	c2 13       	add %d3,1
8000bd74:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bd78:	4b 3f 11 22 	div.u %e2,%d15,%d3
8000bd7c:	02 23       	mov %d3,%d2
8000bd7e:	3c d0       	j 8000bd1e <SYSTEM_GetCanClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bd80:	7b f0 fa f2 	movh %d15,12207
8000bd84:	1b 16 00 20 	addi %d2,%d6,1
8000bd88:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bd8c:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bd90:	02 23       	mov %d3,%d2
8000bd92:	3c c6       	j 8000bd1e <SYSTEM_GetCanClock+0x18>

8000bd94 <SYSTEM_EnableInterrupts>:
}

static __inline__ __attribute__((__always_inline__))
void _enable (void)
{
  __asm__ volatile ("enable" ::: "memory");
8000bd94:	0d 00 00 03 	enable 
8000bd98:	00 90       	ret 

8000bd9a <SYSTEM_DisableInterrupts>:
 **********************************************************************/

static __inline__ __attribute__((__always_inline__))
void _disable (void)
{
  __asm__ volatile ("disable" ::: "memory");
8000bd9a:	0d 00 40 03 	disable 
8000bd9e:	00 90       	ret 

8000bda0 <SYSTEM_EnableProtection>:
	_disable();
}

void SYSTEM_EnableProtection(void)
{
	lock_wdtcon();
8000bda0:	1d 00 a2 2d 	j 800118e4 <lock_wdtcon>

8000bda4 <SYSTEM_DisableProtection>:
}

void SYSTEM_DisableProtection(void)
{
	unlock_wdtcon();
8000bda4:	1d 00 8a 2d 	j 800118b8 <unlock_wdtcon>

8000bda8 <SYSTEM_EnableProtectionExt>:
}

void SYSTEM_EnableProtectionExt(int Sel)
{
	if (Sel < 3)
8000bda8:	bf 34 04 00 	jlt %d4,3,8000bdb0 <SYSTEM_EnableProtectionExt+0x8>
		lock_wdtcon();			/* CPU watchdog */
	else
		lock_safety_wdtcon();	/* safety watchdog */
8000bdac:	1d 00 c2 2d 	j 80011930 <lock_safety_wdtcon>
}

void SYSTEM_EnableProtectionExt(int Sel)
{
	if (Sel < 3)
		lock_wdtcon();			/* CPU watchdog */
8000bdb0:	1d 00 9a 2d 	j 800118e4 <lock_wdtcon>

8000bdb4 <SYSTEM_DisableProtectionExt>:
		lock_safety_wdtcon();	/* safety watchdog */
}

void SYSTEM_DisableProtectionExt(int Sel)
{
	if (Sel < 3)
8000bdb4:	bf 34 04 00 	jlt %d4,3,8000bdbc <SYSTEM_DisableProtectionExt+0x8>
		unlock_wdtcon();		/* CPU watchdog */
	else
		unlock_safety_wdtcon();	/* safety watchdog */
8000bdb8:	1d 00 ac 2d 	j 80011910 <unlock_safety_wdtcon>
}

void SYSTEM_DisableProtectionExt(int Sel)
{
	if (Sel < 3)
		unlock_wdtcon();		/* CPU watchdog */
8000bdbc:	1d 00 7e 2d 	j 800118b8 <unlock_wdtcon>

8000bdc0 <SYSTEM_EnableSecProtection>:
		unlock_safety_wdtcon();	/* safety watchdog */
}

void SYSTEM_EnableSecProtection(void)
{
	lock_safety_wdtcon();
8000bdc0:	1d 00 b8 2d 	j 80011930 <lock_safety_wdtcon>

8000bdc4 <SYSTEM_DisableSecProtection>:
}

void SYSTEM_DisableSecProtection(void)
{
	unlock_safety_wdtcon();
8000bdc4:	1d 00 a6 2d 	j 80011910 <unlock_safety_wdtcon>

8000bdc8 <SYSTEM_Reset>:


int SYSTEM_Reset(void)
{
	unlock_safety_wdtcon();
	pSCU->SWRSTCON.B.SWRSTREQ = 1;
8000bdc8:	91 30 00 ff 	movh.a %a15,61443
8000bdcc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
}


int SYSTEM_Reset(void)
{
	unlock_safety_wdtcon();
8000bdd0:	6d 00 a0 2d 	call 80011910 <unlock_safety_wdtcon>
	pSCU->SWRSTCON.B.SWRSTREQ = 1;
8000bdd4:	19 ff 20 10 	ld.w %d15,[%a15]96 <f0030060 <_SMALL_DATA4_+0x40028060>>
8000bdd8:	96 02       	or %d15,2
8000bdda:	59 ff 20 10 	st.w [%a15]96 <f0030060 <_SMALL_DATA4_+0x40028060>>,%d15
	while (1)
		;
8000bdde:	3c 00       	j 8000bdde <SYSTEM_Reset+0x16>

8000bde0 <SYSTEM_IdleExt>:
	return 0;
}

int SYSTEM_IdleExt(int CoreId)
{
8000bde0:	02 4f       	mov %d15,%d4
	unlock_wdtcon();
8000bde2:	6d 00 6b 2d 	call 800118b8 <unlock_wdtcon>
	switch (CoreId)
8000bde6:	9e 1d       	jeq %d15,1,8000be20 <SYSTEM_IdleExt+0x40>
8000bde8:	9e 21       	jeq %d15,2,8000be0a <SYSTEM_IdleExt+0x2a>
8000bdea:	6e 05       	jz %d15,8000bdf4 <SYSTEM_IdleExt+0x14>
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000bdec:	6d 00 7c 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000bdf0:	82 02       	mov %d2,0
8000bdf2:	00 90       	ret 
{
	unlock_wdtcon();
	switch (CoreId)
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
8000bdf4:	91 30 00 ff 	movh.a %a15,61443
8000bdf8:	82 1f       	mov %d15,1
8000bdfa:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bdfe:	59 ff 14 30 	st.w [%a15]212 <f00300d4 <_SMALL_DATA4_+0x400280d4>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be02:	6d 00 71 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000be06:	82 02       	mov %d2,0
8000be08:	00 90       	ret 
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
8000be0a:	91 30 00 ff 	movh.a %a15,61443
8000be0e:	82 1f       	mov %d15,1
8000be10:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be14:	59 ff 1c 30 	st.w [%a15]220 <f00300dc <_SMALL_DATA4_+0x400280dc>>,%d15
			break;
	}
	lock_wdtcon();
8000be18:	6d 00 66 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000be1c:	82 02       	mov %d2,0
8000be1e:	00 90       	ret 
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
8000be20:	91 30 00 ff 	movh.a %a15,61443
8000be24:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be28:	59 ff 18 30 	st.w [%a15]216 <f00300d8 <_SMALL_DATA4_+0x400280d8>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be2c:	6d 00 5c 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000be30:	82 02       	mov %d2,0
8000be32:	00 90       	ret 

8000be34 <SYSTEM_Idle>:

static __inline__ __attribute__((__always_inline__))
unsigned _mfcr (const unsigned __regaddr)
{
  unsigned __res;
  __asm__ volatile ("mfcr %0, LO:%1"
8000be34:	4d c0 e1 ff 	mfcr %d15,$core_id

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
8000be38:	16 07       	and %d15,7
	return 0;
}

int SYSTEM_IdleExt(int CoreId)
{
	unlock_wdtcon();
8000be3a:	6d 00 3f 2d 	call 800118b8 <unlock_wdtcon>
	switch (CoreId)
8000be3e:	9e 1d       	jeq %d15,1,8000be78 <SYSTEM_Idle+0x44>
8000be40:	9e 21       	jeq %d15,2,8000be62 <SYSTEM_Idle+0x2e>
8000be42:	6e 05       	jz %d15,8000be4c <SYSTEM_Idle+0x18>
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be44:	6d 00 50 2d 	call 800118e4 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be48:	82 02       	mov %d2,0
8000be4a:	00 90       	ret 
{
	unlock_wdtcon();
	switch (CoreId)
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
8000be4c:	91 30 00 ff 	movh.a %a15,61443
8000be50:	82 1f       	mov %d15,1
8000be52:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be56:	59 ff 14 30 	st.w [%a15]212 <f00300d4 <_SMALL_DATA4_+0x400280d4>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be5a:	6d 00 45 2d 	call 800118e4 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be5e:	82 02       	mov %d2,0
8000be60:	00 90       	ret 
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
8000be62:	91 30 00 ff 	movh.a %a15,61443
8000be66:	82 1f       	mov %d15,1
8000be68:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be6c:	59 ff 1c 30 	st.w [%a15]220 <f00300dc <_SMALL_DATA4_+0x400280dc>>,%d15
			break;
	}
	lock_wdtcon();
8000be70:	6d 00 3a 2d 	call 800118e4 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be74:	82 02       	mov %d2,0
8000be76:	00 90       	ret 
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
8000be78:	91 30 00 ff 	movh.a %a15,61443
8000be7c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be80:	59 ff 18 30 	st.w [%a15]216 <f00300d8 <_SMALL_DATA4_+0x400280d8>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be84:	6d 00 30 2d 	call 800118e4 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be88:	82 02       	mov %d2,0
8000be8a:	00 90       	ret 

8000be8c <SYSTEM_Sleep>:

int SYSTEM_Sleep(void)
{
	unlock_wdtcon();
8000be8c:	6d 00 16 2d 	call 800118b8 <unlock_wdtcon>
8000be90:	4d c0 e1 ff 	mfcr %d15,$core_id
	switch (_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK)
8000be94:	16 07       	and %d15,7
8000be96:	9e 18       	jeq %d15,1,8000bec6 <SYSTEM_Sleep+0x3a>
8000be98:	6e 0c       	jz %d15,8000beb0 <SYSTEM_Sleep+0x24>
8000be9a:	5e 27       	jne %d15,2,8000bea8 <SYSTEM_Sleep+0x1c>
			break;
		case 1:
			pSCU->PMCSR[1].U = 2;	/* request system sleep mode */
			break;
		case 2:
			pSCU->PMCSR[2].U = 2;	/* request system sleep mode */
8000be9c:	91 30 00 ff 	movh.a %a15,61443
8000bea0:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bea4:	59 ff 1c 30 	st.w [%a15]220 <f00300dc <_SMALL_DATA4_+0x400280dc>>,%d15
			break;
	}
	lock_wdtcon();
8000bea8:	6d 00 1e 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000beac:	82 02       	mov %d2,0
8000beae:	00 90       	ret 
{
	unlock_wdtcon();
	switch (_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK)
	{
		case 0:
			pSCU->PMCSR[0].U = 2;	/* request system sleep mode */
8000beb0:	91 30 00 ff 	movh.a %a15,61443
8000beb4:	82 2f       	mov %d15,2
8000beb6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000beba:	59 ff 14 30 	st.w [%a15]212 <f00300d4 <_SMALL_DATA4_+0x400280d4>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 2;	/* request system sleep mode */
			break;
	}
	lock_wdtcon();
8000bebe:	6d 00 13 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000bec2:	82 02       	mov %d2,0
8000bec4:	00 90       	ret 
	{
		case 0:
			pSCU->PMCSR[0].U = 2;	/* request system sleep mode */
			break;
		case 1:
			pSCU->PMCSR[1].U = 2;	/* request system sleep mode */
8000bec6:	91 30 00 ff 	movh.a %a15,61443
8000beca:	82 2f       	mov %d15,2
8000becc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bed0:	59 ff 18 30 	st.w [%a15]216 <f00300d8 <_SMALL_DATA4_+0x400280d8>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 2;	/* request system sleep mode */
			break;
	}
	lock_wdtcon();
8000bed4:	6d 00 08 2d 	call 800118e4 <lock_wdtcon>
	return 0;
}
8000bed8:	82 02       	mov %d2,0
8000beda:	00 90       	ret 

8000bedc <SYSTEM_IsCacheEnabled>:
8000bedc:	4d c0 20 f9 	mfcr %d15,$pcon0

int SYSTEM_IsCacheEnabled(void)
{
	unsigned int ui = _mfcr(CPU_PCON0);
	if (ui & 2)
		return 0;	/* Cache is in bypass mode */
8000bee0:	82 02       	mov %d2,0


int SYSTEM_IsCacheEnabled(void)
{
	unsigned int ui = _mfcr(CPU_PCON0);
	if (ui & 2)
8000bee2:	ae 17       	jnz.t %d15,1,8000bef0 <SYSTEM_IsCacheEnabled+0x14>
8000bee4:	4d 80 20 29 	mfcr %d2,$pcon2
		return 0;	/* Cache is in bypass mode */
	ui = _mfcr(CPU_PCON2);
	if (0 == (ui & (IFX_CPU_PCON2_PCACHE_SZE_MSK << IFX_CPU_PCON2_PCACHE_SZE_OFF)))
8000bee8:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000beec:	8b 02 20 22 	ne %d2,%d2,0
		return 0;	/* Cache size is 0 */
	return 1;
}
8000bef0:	00 90       	ret 

8000bef2 <SYSTEM_EnaDisCache>:

void SYSTEM_EnaDisCache(int Enable)
{
8000bef2:	02 4f       	mov %d15,%d4
	unlock_wdtcon();
8000bef4:	6d 00 e2 2c 	call 800118b8 <unlock_wdtcon>
	if (Enable)
8000bef8:	ee 0b       	jnz %d15,8000bf0e <SYSTEM_EnaDisCache+0x1c>
  } while (0)

static __inline__ __attribute__((__always_inline__))
void _mtcr (const unsigned __regaddr, const unsigned __val)
{
  __asm__ volatile ("mtcr LO:%0, %1"
8000befa:	82 2f       	mov %d15,2
8000befc:	cd cf 20 09 	mtcr $pcon0,%d15
8000bf00:	82 32       	mov %d2,3
8000bf02:	cd 42 20 09 	mtcr $pcon1,%d2
8000bf06:	cd 0f 04 09 	mtcr $dcon0,%d15
	{
		_mtcr(CPU_PCON0, 2);
		_mtcr(CPU_PCON1, 3);
		_mtcr(CPU_DCON0, 2);
	}
	lock_wdtcon();
8000bf0a:	1d 00 ed 2c 	j 800118e4 <lock_wdtcon>
8000bf0e:	82 0f       	mov %d15,0
8000bf10:	cd cf 20 09 	mtcr $pcon0,%d15
8000bf14:	cd 0f 04 09 	mtcr $dcon0,%d15
8000bf18:	1d 00 e6 2c 	j 800118e4 <lock_wdtcon>

8000bf1c <SYSTEM_DbgBreak>:
{
#ifdef DEBUG
	__asm volatile ("debug");
#else
	while (1)
		;
8000bf1c:	3c 00       	j 8000bf1c <SYSTEM_DbgBreak>

8000bf1e <StartupHook>:
void StartupHook(void)
{
	//my_printf("Hello aaaorld!\n");
	//ActivateTask(Task_Motor);
	//ActivateTask(Blink_LED);
	ActivateTask(OS_EE_Task_Init);
8000bf1e:	3b a0 00 40 	mov %d4,10
8000bf22:	1d 00 0f 09 	j 8000d140 <ActivateTask>

8000bf26 <FuncLCD_IsIntunnel>:
int flag=0;
int pwm=0;

TASK(LCD_IsIntunnel){ //Sensor ECU CAN    TASK

	char TunnelStatus=getTunnelStatus();
8000bf26:	6d ff fe ed 	call 80009b22 <getTunnelStatus>

	if(TunnelStatus){ //01   
8000bf2a:	df 02 1e 80 	jne %d2,0,8000bf66 <FuncLCD_IsIntunnel+0x40>
		delay_ms(1000);
		/*											*/
	}
	else{	//00   

		clear_two_lines();	//  
8000bf2e:	6d ff 7e f9 	call 8000b22a <clear_two_lines>

		delay_ms(200);
8000bf32:	3b 80 0c 40 	mov %d4,200
8000bf36:	6d ff 55 f6 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000bf3a:	3b 00 08 40 	mov %d4,128
8000bf3e:	6d ff d2 f8 	call 8000b0e2 <write_instruction>
		delay_ms(200);
8000bf42:	3b 80 0c 40 	mov %d4,200
8000bf46:	6d ff 4d f6 	call 8000abe0 <delay_ms>

		lcdprint_data("Tunnel MODE OFF!");
8000bf4a:	91 00 00 48 	movh.a %a4,32768
8000bf4e:	d9 44 91 10 	lea %a4,[%a4]2129 <80000851 <osEE_sdb_array+0x75>>
8000bf52:	6d ff 0a f9 	call 8000b166 <lcdprint_data>
		delay_ms(1000);
8000bf56:	3b 80 3e 40 	mov %d4,1000
8000bf5a:	6d ff 43 f6 	call 8000abe0 <delay_ms>
		clear_lcdprint();
8000bf5e:	6d ff 38 f9 	call 8000b1ce <clear_lcdprint>

	}


	TerminateTask();
8000bf62:	1d 00 7c 09 	j 8000d25a <TerminateTask>

	char TunnelStatus=getTunnelStatus();

	if(TunnelStatus){ //01   

		clear_two_lines();
8000bf66:	6d ff 62 f9 	call 8000b22a <clear_two_lines>
		/*											*/
		delay_ms(200);
8000bf6a:	3b 80 0c 40 	mov %d4,200
8000bf6e:	6d ff 39 f6 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000bf72:	3b 00 08 40 	mov %d4,128
8000bf76:	6d ff b6 f8 	call 8000b0e2 <write_instruction>
		delay_ms(200);
8000bf7a:	3b 80 0c 40 	mov %d4,200
8000bf7e:	6d ff 31 f6 	call 8000abe0 <delay_ms>
		lcdprint_data("THE CARS ENTER");
8000bf82:	91 00 00 48 	movh.a %a4,32768
8000bf86:	d9 44 b4 00 	lea %a4,[%a4]2100 <80000834 <osEE_sdb_array+0x58>>
8000bf8a:	6d ff ee f8 	call 8000b166 <lcdprint_data>

		delay_ms(200);
8000bf8e:	3b 80 0c 40 	mov %d4,200
8000bf92:	6d ff 27 f6 	call 8000abe0 <delay_ms>
		write_instruction(0xc0); //2  
8000bf96:	3b 00 0c 40 	mov %d4,192
8000bf9a:	6d ff a4 f8 	call 8000b0e2 <write_instruction>
		delay_ms(200);
8000bf9e:	3b 80 0c 40 	mov %d4,200
8000bfa2:	6d ff 1f f6 	call 8000abe0 <delay_ms>
		lcdprint_data("TUNNEL MODE!!");
8000bfa6:	91 00 00 48 	movh.a %a4,32768
8000bfaa:	d9 44 83 10 	lea %a4,[%a4]2115 <80000843 <osEE_sdb_array+0x67>>
8000bfae:	6d ff dc f8 	call 8000b166 <lcdprint_data>

		delay_ms(1000);
8000bfb2:	3b 80 3e 40 	mov %d4,1000
8000bfb6:	6d ff 15 f6 	call 8000abe0 <delay_ms>
		clear_lcdprint();

	}


	TerminateTask();
8000bfba:	1d 00 50 09 	j 8000d25a <TerminateTask>

8000bfbe <FuncDisplay_BodyStatus>:
}

TASK(Display_BodyStatus){ //Body ECU CAN    TASK

	char HeadLampStatus=getLEDKing(); //can 
8000bfbe:	6d ff ad ed 	call 80009b18 <getLEDKing>

	if(HeadLampStatus){ //  Body ECU  
8000bfc2:	df 02 7f 80 	jne %d2,0,8000c0c0 <FuncDisplay_BodyStatus+0x102>
		delay_ms(1300);
		clear_two_lines();

	}
	else{
		setHeadlampLED(0);
8000bfc6:	82 04       	mov %d4,0
8000bfc8:	6d ff 23 f7 	call 8000ae0e <setHeadlampLED>
		clear_two_lines();
8000bfcc:	6d ff 2f f9 	call 8000b22a <clear_two_lines>

		delay_ms(100);
8000bfd0:	3b 40 06 40 	mov %d4,100
8000bfd4:	6d ff 06 f6 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000bfd8:	3b 00 08 40 	mov %d4,128
8000bfdc:	6d ff 83 f8 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000bfe0:	3b 40 06 40 	mov %d4,100
8000bfe4:	6d ff fe f5 	call 8000abe0 <delay_ms>
		lcdprint_data("TURN TO");
8000bfe8:	91 00 00 48 	movh.a %a4,32768
8000bfec:	d9 44 b2 10 	lea %a4,[%a4]2162 <80000872 <osEE_sdb_array+0x96>>
8000bff0:	6d ff bb f8 	call 8000b166 <lcdprint_data>

		delay_ms(100);
8000bff4:	3b 40 06 40 	mov %d4,100
8000bff8:	6d ff f4 f5 	call 8000abe0 <delay_ms>
		write_instruction(0xc0); //2  
8000bffc:	3b 00 0c 40 	mov %d4,192
8000c000:	6d ff 71 f8 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c004:	3b 40 06 40 	mov %d4,100
8000c008:	6d ff ec f5 	call 8000abe0 <delay_ms>
		lcdprint_data("OUTSIDE AIR MODE");
8000c00c:	91 00 00 48 	movh.a %a4,32768
8000c010:	d9 44 ad 20 	lea %a4,[%a4]2221 <800008ad <osEE_sdb_array+0xd1>>
8000c014:	6d ff a9 f8 	call 8000b166 <lcdprint_data>
		delay_ms(1300);
8000c018:	3b 40 51 40 	mov %d4,1300
8000c01c:	6d ff e2 f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c020:	6d ff 05 f9 	call 8000b22a <clear_two_lines>

		delay_ms(100);
8000c024:	3b 40 06 40 	mov %d4,100
8000c028:	6d ff dc f5 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000c02c:	3b 00 08 40 	mov %d4,128
8000c030:	6d ff 59 f8 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c034:	3b 40 06 40 	mov %d4,100
8000c038:	6d ff d4 f5 	call 8000abe0 <delay_ms>
		//

		delay_ms(100);
8000c03c:	3b 40 06 40 	mov %d4,100
8000c040:	6d ff d0 f5 	call 8000abe0 <delay_ms>
		lcdprint_data("RETURN TO");
8000c044:	91 00 00 48 	movh.a %a4,32768
8000c048:	d9 44 be 20 	lea %a4,[%a4]2238 <800008be <osEE_sdb_array+0xe2>>
8000c04c:	6d ff 8d f8 	call 8000b166 <lcdprint_data>
		delay_ms(100);
8000c050:	3b 40 06 40 	mov %d4,100
8000c054:	6d ff c6 f5 	call 8000abe0 <delay_ms>
		write_instruction(0xc0); //2  
8000c058:	3b 00 0c 40 	mov %d4,192
8000c05c:	6d ff 43 f8 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c060:	3b 40 06 40 	mov %d4,100
8000c064:	6d ff be f5 	call 8000abe0 <delay_ms>
		lcdprint_data("PREVIOUS WINDOW");
8000c068:	91 00 00 48 	movh.a %a4,32768
8000c06c:	d9 44 88 30 	lea %a4,[%a4]2248 <800008c8 <osEE_sdb_array+0xec>>
8000c070:	6d ff 7b f8 	call 8000b166 <lcdprint_data>
		delay_ms(1300);
8000c074:	3b 40 51 40 	mov %d4,1300
8000c078:	6d ff b4 f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c07c:	6d ff d7 f8 	call 8000b22a <clear_two_lines>

		delay_ms(100);
8000c080:	3b 40 06 40 	mov %d4,100
8000c084:	6d ff ae f5 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000c088:	3b 00 08 40 	mov %d4,128
8000c08c:	6d ff 2b f8 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c090:	3b 40 06 40 	mov %d4,100
8000c094:	6d ff a6 f5 	call 8000abe0 <delay_ms>
		//
		delay_ms(200);
8000c098:	3b 80 0c 40 	mov %d4,200
8000c09c:	6d ff a2 f5 	call 8000abe0 <delay_ms>
		lcdprint_data("HEADLAMPS OFF!");
8000c0a0:	91 00 00 48 	movh.a %a4,32768
8000c0a4:	d9 44 98 30 	lea %a4,[%a4]2264 <800008d8 <osEE_sdb_array+0xfc>>
8000c0a8:	6d ff 5f f8 	call 8000b166 <lcdprint_data>
		delay_ms(1000);
8000c0ac:	3b 80 3e 40 	mov %d4,1000
8000c0b0:	6d ff 98 f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c0b4:	6d ff bb f8 	call 8000b22a <clear_two_lines>
		//delay_ms(100);
		//write_instruction(0x80); //  
		//delay_ms(100);
		//lcdprint_data("TUNNEL MODE: OFF");
		//delay_ms(500);
		clear_two_lines();
8000c0b8:	6d ff b9 f8 	call 8000b22a <clear_two_lines>

	}

	TerminateTask();
8000c0bc:	1d 00 cf 08 	j 8000d25a <TerminateTask>

	char HeadLampStatus=getLEDKing(); //can 

	if(HeadLampStatus){ //  Body ECU  

		setHeadlampLED(1);
8000c0c0:	82 14       	mov %d4,1
8000c0c2:	6d ff a6 f6 	call 8000ae0e <setHeadlampLED>
		clear_two_lines();
8000c0c6:	6d ff b2 f8 	call 8000b22a <clear_two_lines>

		delay_ms(100);
8000c0ca:	3b 40 06 40 	mov %d4,100
8000c0ce:	6d ff 89 f5 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000c0d2:	3b 00 08 40 	mov %d4,128
8000c0d6:	6d ff 06 f8 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c0da:	3b 40 06 40 	mov %d4,100
8000c0de:	6d ff 81 f5 	call 8000abe0 <delay_ms>
		lcdprint_data("TUNNEL MODE: ON");
8000c0e2:	91 00 00 48 	movh.a %a4,32768
8000c0e6:	d9 44 a2 10 	lea %a4,[%a4]2146 <80000862 <osEE_sdb_array+0x86>>
8000c0ea:	6d ff 3e f8 	call 8000b166 <lcdprint_data>

		delay_ms(1000);
8000c0ee:	3b 80 3e 40 	mov %d4,1000
8000c0f2:	6d ff 77 f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c0f6:	6d ff 9a f8 	call 8000b22a <clear_two_lines>

		delay_ms(100);
8000c0fa:	3b 40 06 40 	mov %d4,100
8000c0fe:	6d ff 71 f5 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000c102:	3b 00 08 40 	mov %d4,128
8000c106:	6d ff ee f7 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c10a:	3b 40 06 40 	mov %d4,100
8000c10e:	6d ff 69 f5 	call 8000abe0 <delay_ms>
		lcdprint_data("TURN TO");
8000c112:	91 00 00 48 	movh.a %a4,32768
8000c116:	d9 44 b2 10 	lea %a4,[%a4]2162 <80000872 <osEE_sdb_array+0x96>>
8000c11a:	6d ff 26 f8 	call 8000b166 <lcdprint_data>

		delay_ms(100);
8000c11e:	3b 40 06 40 	mov %d4,100
8000c122:	6d ff 5f f5 	call 8000abe0 <delay_ms>
		write_instruction(0xc0); //2  
8000c126:	3b 00 0c 40 	mov %d4,192
8000c12a:	6d ff dc f7 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c12e:	3b 40 06 40 	mov %d4,100
8000c132:	6d ff 57 f5 	call 8000abe0 <delay_ms>
		lcdprint_data("INSIDE AIR MODE");
8000c136:	91 00 00 48 	movh.a %a4,32768
8000c13a:	d9 44 ba 10 	lea %a4,[%a4]2170 <8000087a <osEE_sdb_array+0x9e>>
8000c13e:	6d ff 14 f8 	call 8000b166 <lcdprint_data>
		delay_ms(1300);
8000c142:	3b 40 51 40 	mov %d4,1300
8000c146:	6d ff 4d f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c14a:	6d ff 70 f8 	call 8000b22a <clear_two_lines>
		//
		delay_ms(100);
8000c14e:	3b 40 06 40 	mov %d4,100
8000c152:	6d ff 47 f5 	call 8000abe0 <delay_ms>
		write_instruction(0x80);
8000c156:	3b 00 08 40 	mov %d4,128
8000c15a:	6d ff c4 f7 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c15e:	3b 40 06 40 	mov %d4,100
8000c162:	6d ff 3f f5 	call 8000abe0 <delay_ms>
		lcdprint_data("ROLLS UP");
8000c166:	91 00 00 48 	movh.a %a4,32768
8000c16a:	d9 44 8a 20 	lea %a4,[%a4]2186 <8000088a <osEE_sdb_array+0xae>>
8000c16e:	6d ff fc f7 	call 8000b166 <lcdprint_data>

		delay_ms(100);
8000c172:	3b 40 06 40 	mov %d4,100
8000c176:	6d ff 35 f5 	call 8000abe0 <delay_ms>
		write_instruction(0xc0); //2  
8000c17a:	3b 00 0c 40 	mov %d4,192
8000c17e:	6d ff b2 f7 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c182:	3b 40 06 40 	mov %d4,100
8000c186:	6d ff 2d f5 	call 8000abe0 <delay_ms>
		lcdprint_data("THE WINDOW!");
8000c18a:	91 00 00 48 	movh.a %a4,32768
8000c18e:	d9 44 93 20 	lea %a4,[%a4]2195 <80000893 <osEE_sdb_array+0xb7>>
8000c192:	6d ff ea f7 	call 8000b166 <lcdprint_data>
		delay_ms(1300);
8000c196:	3b 40 51 40 	mov %d4,1300
8000c19a:	6d ff 23 f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c19e:	6d ff 46 f8 	call 8000b22a <clear_two_lines>

		delay_ms(100);
8000c1a2:	3b 40 06 40 	mov %d4,100
8000c1a6:	6d ff 1d f5 	call 8000abe0 <delay_ms>
		write_instruction(0x80); //  
8000c1aa:	3b 00 08 40 	mov %d4,128
8000c1ae:	6d ff 9a f7 	call 8000b0e2 <write_instruction>
		delay_ms(100);
8000c1b2:	3b 40 06 40 	mov %d4,100
8000c1b6:	6d ff 15 f5 	call 8000abe0 <delay_ms>
		//
		lcdprint_data("HEADLAMPS ON!");
8000c1ba:	91 00 00 48 	movh.a %a4,32768
8000c1be:	d9 44 9f 20 	lea %a4,[%a4]2207 <8000089f <osEE_sdb_array+0xc3>>
8000c1c2:	6d ff d2 f7 	call 8000b166 <lcdprint_data>
		delay_ms(1300);
8000c1c6:	3b 40 51 40 	mov %d4,1300
8000c1ca:	6d ff 0b f5 	call 8000abe0 <delay_ms>
		clear_two_lines();
8000c1ce:	6d ff 2e f8 	call 8000b22a <clear_two_lines>
		//delay_ms(500);
		clear_two_lines();

	}

	TerminateTask();
8000c1d2:	1d 00 44 08 	j 8000d25a <TerminateTask>

8000c1d6 <FuncTask_Motor>:
}

TASK(Task_Motor){
8000c1d6:	91 00 00 d7 	movh.a %a13,28672
8000c1da:	91 00 00 f7 	movh.a %a15,28672
8000c1de:	91 00 00 c7 	movh.a %a12,28672
8000c1e2:	d9 dd 59 24 	lea %a13,[%a13]17561 <70004499 <ch>>
8000c1e6:	d9 ff 5c 24 	lea %a15,[%a15]17564 <7000449c <duty>>
8000c1ea:	d9 cc 58 24 	lea %a12,[%a12]17560 <70004498 <dir>>
			}
			else if(ch=='s'||ch=='S'){
				//duty-=10;
				duty=duty-10;
				//dir=1;
				if(duty<0) dir=0;
8000c1ee:	82 0a       	mov %d10,0
	while(1){
			ch=_in_uart3();
			_out_uart3(ch);
			if(ch=='w'||ch=='W'){
				duty+=10;
				if(duty>0) dir=1;
8000c1f0:	82 19       	mov %d9,1
				duty=duty-10;
				//dir=1;
				if(duty<0) dir=0;
				}

			if(abs(duty)>100) {duty=100;}
8000c1f2:	3b 40 06 80 	mov %d8,100
8000c1f6:	3c 19       	j 8000c228 <FuncTask_Motor+0x52>

	while(1){
			ch=_in_uart3();
			_out_uart3(ch);
			if(ch=='w'||ch=='W'){
				duty+=10;
8000c1f8:	4c f0       	ld.w %d15,[%a15]0
8000c1fa:	1b af 00 40 	addi %d4,%d15,10
8000c1fe:	68 04       	st.w [%a15]0,%d4
				if(duty>0) dir=1;
8000c200:	bf 14 24 00 	jlt %d4,1,8000c248 <FuncTask_Motor+0x72>
8000c204:	34 c9       	st.b [%a12],%d9
8000c206:	82 15       	mov %d5,1
				duty=duty-10;
				//dir=1;
				if(duty<0) dir=0;
				}

			if(abs(duty)>100) {duty=100;}
8000c208:	0b 40 c0 41 	abs %d4,%d4
8000c20c:	8b 54 46 f2 	lt %d15,%d4,101
8000c210:	ee 04       	jnz %d15,8000c218 <FuncTask_Motor+0x42>
8000c212:	68 08       	st.w [%a15]0,%d8
8000c214:	3b 40 06 40 	mov %d4,100
			//else if(duty<0) {duty=0;}
			movChA_PWM(abs(duty),dir);
8000c218:	6d ff 81 f9 	call 8000b51a <movChA_PWM>
			movChB_PWM(abs(duty),dir);
8000c21c:	48 04       	ld.w %d4,[%a15]0
8000c21e:	14 c5       	ld.bu %d5,[%a12]
8000c220:	0b 40 c0 41 	abs %d4,%d4
8000c224:	6d ff 94 f9 	call 8000b54c <movChB_PWM>
}

TASK(Task_Motor){

	while(1){
			ch=_in_uart3();
8000c228:	6d ff ad ed 	call 80009d82 <_in_uart3>
			_out_uart3(ch);
8000c22c:	02 24       	mov %d4,%d2
}

TASK(Task_Motor){

	while(1){
			ch=_in_uart3();
8000c22e:	34 d2       	st.b [%a13],%d2
			_out_uart3(ch);
8000c230:	6d ff 9e ed 	call 80009d6c <_out_uart3>
			if(ch=='w'||ch=='W'){
8000c234:	0c d0       	ld.bu %d15,[%a13]0
8000c236:	16 df       	and %d15,223
8000c238:	8b 7f 25 22 	ne %d2,%d15,87
8000c23c:	df 02 de 7f 	jeq %d2,0,8000c1f8 <FuncTask_Motor+0x22>
				duty+=10;
				if(duty>0) dir=1;

			}
			else if(ch=='s'||ch=='S'){
8000c240:	8b 3f 05 f2 	eq %d15,%d15,83
8000c244:	ee 04       	jnz %d15,8000c24c <FuncTask_Motor+0x76>
8000c246:	48 04       	ld.w %d4,[%a15]0
8000c248:	14 c5       	ld.bu %d5,[%a12]
8000c24a:	3c df       	j 8000c208 <FuncTask_Motor+0x32>
				//duty-=10;
				duty=duty-10;
8000c24c:	4c f0       	ld.w %d15,[%a15]0
8000c24e:	1b 6f ff 4f 	addi %d4,%d15,-10
8000c252:	68 04       	st.w [%a15]0,%d4
				//dir=1;
				if(duty<0) dir=0;
8000c254:	ff 04 fa 7f 	jge %d4,0,8000c248 <FuncTask_Motor+0x72>
8000c258:	34 ca       	st.b [%a12],%d10
8000c25a:	82 05       	mov %d5,0
8000c25c:	3c d6       	j 8000c208 <FuncTask_Motor+0x32>

8000c25e <FuncTask_AEB>:
		}
		TerminateTask();

}
TASK(Task_AEB){
	toggleLED2();
8000c25e:	6d ff 0e f6 	call 8000ae7a <toggleLED2>
	TerminateTask();
8000c262:	1d 00 fc 07 	j 8000d25a <TerminateTask>

8000c266 <FuncBlink_LED>:
}
TASK(Blink_LED)
{
		toggleLED1();
8000c266:	6d ff fb f5 	call 8000ae5c <toggleLED1>
		delay_ms(500);
8000c26a:	3b 40 1f 40 	mov %d4,500
8000c26e:	6d ff b9 f4 	call 8000abe0 <delay_ms>
		//Driver_Can_TxTest();
		//can_Send(signal_type, wheretoecu);
		TerminateTask();
8000c272:	1d 00 f4 07 	j 8000d25a <TerminateTask>

8000c276 <FuncUART_Echo>:

TASK(UART_Echo)
{
	unsigned char c;
	while (1) {
		c = _in_uart3();
8000c276:	6d ff 86 ed 	call 80009d82 <_in_uart3>
8000c27a:	02 2f       	mov %d15,%d2
		_out_uart3(c);
8000c27c:	02 24       	mov %d4,%d2
		if (c == '\r') { _out_uart3('\n'); }
8000c27e:	8b df 20 f2 	ne %d15,%d15,13
TASK(UART_Echo)
{
	unsigned char c;
	while (1) {
		c = _in_uart3();
		_out_uart3(c);
8000c282:	6d ff 75 ed 	call 80009d6c <_out_uart3>
		if (c == '\r') { _out_uart3('\n'); }
8000c286:	ee f8       	jnz %d15,8000c276 <FuncUART_Echo>
8000c288:	3b a0 00 40 	mov %d4,10
8000c28c:	6d ff 70 ed 	call 80009d6c <_out_uart3>
8000c290:	3c f3       	j 8000c276 <FuncUART_Echo>

8000c292 <FuncDCMotor_Example>:

TASK(DCMotor_Example)
{
	unsigned int i;
	while (1) {
		movChA(1);
8000c292:	82 14       	mov %d4,1
8000c294:	6d ff fd f8 	call 8000b48e <movChA>
		movChB(1);
8000c298:	82 14       	mov %d4,1
8000c29a:	6d ff 13 f9 	call 8000b4c0 <movChB>
		i = 0; while (i++ < 10000000);
8000c29e:	91 90 09 f0 	movh.a %a15,153
8000c2a2:	d9 ff 40 a9 	lea %a15,[%a15]-27008 <989680 <__DSPR1_SIZE+0x96b680>>
8000c2a6:	fd f0 00 00 	loop %a15,8000c2a6 <FuncDCMotor_Example+0x14>
		movChA(0);
8000c2aa:	82 04       	mov %d4,0
8000c2ac:	6d ff f1 f8 	call 8000b48e <movChA>
		movChB(0);
8000c2b0:	82 04       	mov %d4,0
8000c2b2:	6d ff 07 f9 	call 8000b4c0 <movChB>

TASK(DCMotor_Example)
{
	unsigned int i;
	while (1) {
		movChA(1);
8000c2b6:	82 14       	mov %d4,1
8000c2b8:	6d ff eb f8 	call 8000b48e <movChA>
		movChB(1);
		i = 0; while (i++ < 10000000);
8000c2bc:	91 90 09 f0 	movh.a %a15,153
TASK(DCMotor_Example)
{
	unsigned int i;
	while (1) {
		movChA(1);
		movChB(1);
8000c2c0:	82 14       	mov %d4,1
8000c2c2:	6d ff ff f8 	call 8000b4c0 <movChB>
		i = 0; while (i++ < 10000000);
8000c2c6:	d9 ff 40 a9 	lea %a15,[%a15]-27008 <989680 <__DSPR1_SIZE+0x96b680>>
8000c2ca:	3c ee       	j 8000c2a6 <FuncDCMotor_Example+0x14>

8000c2cc <FuncTimer_Example>:
	}
	TerminateTask();
}

TASK(Timer_Example)
{
8000c2cc:	20 10       	sub.a %sp,16
	volatile int i, j;
	unsigned int timer_end;
	float execTime;

	setGpt12_T4(0);
8000c2ce:	82 04       	mov %d4,0
8000c2d0:	6d ff 15 f4 	call 8000aafa <setGpt12_T4>
	runGpt12_T4();
8000c2d4:	6d ff 06 f4 	call 8000aae0 <runGpt12_T4>
	for (i = 0; i < 1; i++)
8000c2d8:	82 0f       	mov %d15,0
8000c2da:	78 02       	st.w [%sp]8,%d15
8000c2dc:	19 a2 08 00 	ld.w %d2,[%sp]8
		for (j = 0; j < 18200; j++)
8000c2e0:	82 03       	mov %d3,0
8000c2e2:	3b 80 71 f4 	mov %d15,18200
	unsigned int timer_end;
	float execTime;

	setGpt12_T4(0);
	runGpt12_T4();
	for (i = 0; i < 1; i++)
8000c2e6:	8e 2b       	jlez %d2,8000c2fc <FuncTimer_Example+0x30>
8000c2e8:	3c 23       	j 8000c32e <FuncTimer_Example+0x62>
8000c2ea:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c2ee:	c2 12       	add %d2,1
8000c2f0:	59 a2 08 00 	st.w [%sp]8,%d2
8000c2f4:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c2f8:	ff 12 1b 00 	jge %d2,1,8000c32e <FuncTimer_Example+0x62>
		for (j = 0; j < 18200; j++)
8000c2fc:	59 a3 0c 00 	st.w [%sp]12,%d3
8000c300:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c304:	7f f2 f3 7f 	jge %d2,%d15,8000c2ea <FuncTimer_Example+0x1e>
8000c308:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c30c:	c2 12       	add %d2,1
8000c30e:	59 a2 0c 00 	st.w [%sp]12,%d2
8000c312:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c316:	7f f2 ea 7f 	jge %d2,%d15,8000c2ea <FuncTimer_Example+0x1e>
8000c31a:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c31e:	c2 12       	add %d2,1
8000c320:	59 a2 0c 00 	st.w [%sp]12,%d2
8000c324:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c328:	3f f2 f0 7f 	jlt %d2,%d15,8000c308 <FuncTimer_Example+0x3c>
8000c32c:	3c df       	j 8000c2ea <FuncTimer_Example+0x1e>
			continue;
	stopGpt12_T4();
8000c32e:	6d ff df f3 	call 8000aaec <stopGpt12_T4>
	timer_end = getGpt12_T4();
8000c332:	6d ff e7 f3 	call 8000ab00 <getGpt12_T4>
	execTime = (timer_end - 0) * 10.24;
8000c336:	7b 40 12 f4 	movh %d15,16676
8000c33a:	4b 02 61 21 	utof %d2,%d2
8000c33e:	1b af 70 fd 	addi %d15,%d15,-10486
8000c342:	4b f2 41 20 	mul.f %d2,%d2,%d15
	my_printf("Execution Time: %dus\n", (int) execTime);
8000c346:	91 00 00 48 	movh.a %a4,32768
8000c34a:	4b 02 31 21 	ftoiz %d2,%d2
8000c34e:	d9 44 a7 30 	lea %a4,[%a4]2279 <800008e7 <osEE_sdb_array+0x10b>>
8000c352:	74 a2       	st.w [%sp],%d2
8000c354:	6d ff 91 f0 	call 8000a476 <my_printf>
8000c358:	1d 00 81 07 	j 8000d25a <TerminateTask>

8000c35c <FuncUltrasonic_Example>:

	TerminateTask();
}

TASK(Ultrasonic_Example)
{
8000c35c:	91 00 00 f8 	movh.a %a15,32768
8000c360:	20 10       	sub.a %sp,16
8000c362:	d9 ff bd 30 	lea %a15,[%a15]2301
8000c366:	3c 0a       	j 8000c37a <FuncUltrasonic_Example+0x1e>
			stopChB();
		}
		else{
			;
		}
		my_printf("Distance: %dcm\n", dist);
8000c368:	58 03       	ld.w %d15,[%sp]12
8000c36a:	40 f4       	mov.aa %a4,%a15
8000c36c:	78 00       	st.w [%sp]0,%d15
8000c36e:	6d ff 84 f0 	call 8000a476 <my_printf>
		delay_ms(100);
8000c372:	3b 40 06 40 	mov %d4,100
8000c376:	6d ff 35 f4 	call 8000abe0 <delay_ms>

TASK(Ultrasonic_Example)
{
	volatile int dist;
	while(1) {
		dist = (int)ReadUltrasonic_noFilt();
8000c37a:	6d ff 9b f9 	call 8000b6b0 <ReadUltrasonic_noFilt>
8000c37e:	4b 02 31 21 	ftoiz %d2,%d2
8000c382:	59 a2 0c 00 	st.w [%sp]12,%d2
		if (dist >= 20&&dist<=30) {
8000c386:	58 03       	ld.w %d15,[%sp]12
8000c388:	8b 4f 41 f2 	lt %d15,%d15,20
8000c38c:	ee 05       	jnz %d15,8000c396 <FuncUltrasonic_Example+0x3a>
8000c38e:	58 03       	ld.w %d15,[%sp]12
8000c390:	8b ff 81 f2 	ge %d15,%d15,31
8000c394:	6e 10       	jz %d15,8000c3b4 <FuncUltrasonic_Example+0x58>
			//setLED1(1);
			ActivateTask(Buzzer_Example);
		} else if(dist>=10&&dist<20) {
8000c396:	58 03       	ld.w %d15,[%sp]12
8000c398:	8b af 40 f2 	lt %d15,%d15,10
8000c39c:	ee 05       	jnz %d15,8000c3a6 <FuncUltrasonic_Example+0x4a>
8000c39e:	58 03       	ld.w %d15,[%sp]12
8000c3a0:	8b 4f 41 f2 	lt %d15,%d15,20
8000c3a4:	ee 08       	jnz %d15,8000c3b4 <FuncUltrasonic_Example+0x58>
			//setLED1(0);
			ActivateTask(Buzzer_Example);
		}
		else if(dist<10){
8000c3a6:	58 03       	ld.w %d15,[%sp]12
8000c3a8:	8b af 80 f2 	ge %d15,%d15,10
8000c3ac:	ee de       	jnz %d15,8000c368 <FuncUltrasonic_Example+0xc>
			stopChB();
8000c3ae:	6d ff ae f8 	call 8000b50a <stopChB>
8000c3b2:	3c db       	j 8000c368 <FuncUltrasonic_Example+0xc>
	volatile int dist;
	while(1) {
		dist = (int)ReadUltrasonic_noFilt();
		if (dist >= 20&&dist<=30) {
			//setLED1(1);
			ActivateTask(Buzzer_Example);
8000c3b4:	82 74       	mov %d4,7
8000c3b6:	6d 00 c5 06 	call 8000d140 <ActivateTask>
8000c3ba:	3c d7       	j 8000c368 <FuncUltrasonic_Example+0xc>

8000c3bc <FuncBuzzer_Example>:
	}
	TerminateTask();
}

TASK(Buzzer_Example)
{
8000c3bc:	20 08       	sub.a %sp,8
	volatile unsigned int j = 0;
8000c3be:	82 0f       	mov %d15,0
8000c3c0:	78 01       	st.w [%sp]4,%d15
	while (j++ < 1000) {
8000c3c2:	19 a2 04 00 	ld.w %d2,[%sp]4
		MODULE_P02.OUT.B.P3 = 1;
8000c3c6:	91 40 00 ff 	movh.a %a15,61444
}

TASK(Buzzer_Example)
{
	volatile unsigned int j = 0;
	while (j++ < 1000) {
8000c3ca:	9a 12       	add %d15,%d2,1
8000c3cc:	78 01       	st.w [%sp]4,%d15
8000c3ce:	3b 80 3e f0 	mov %d15,1000
		MODULE_P02.OUT.B.P3 = 1;
8000c3d2:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
}

TASK(Buzzer_Example)
{
	volatile unsigned int j = 0;
	while (j++ < 1000) {
8000c3d6:	02 f8       	mov %d8,%d15
8000c3d8:	7f f2 17 80 	jge.u %d2,%d15,8000c406 <FuncBuzzer_Example+0x4a>
		MODULE_P02.OUT.B.P3 = 1;
8000c3dc:	4c f0       	ld.w %d15,[%a15]0
		Beep(130);
8000c3de:	3b 20 08 40 	mov %d4,130

TASK(Buzzer_Example)
{
	volatile unsigned int j = 0;
	while (j++ < 1000) {
		MODULE_P02.OUT.B.P3 = 1;
8000c3e2:	96 08       	or %d15,8
8000c3e4:	68 0f       	st.w [%a15]0,%d15
		Beep(130);
8000c3e6:	6d ff 4b f4 	call 8000ac7c <Beep>
		MODULE_P02.OUT.B.P3 = 0;
8000c3ea:	4c f0       	ld.w %d15,[%a15]0
		Beep(130);
8000c3ec:	3b 20 08 40 	mov %d4,130
{
	volatile unsigned int j = 0;
	while (j++ < 1000) {
		MODULE_P02.OUT.B.P3 = 1;
		Beep(130);
		MODULE_P02.OUT.B.P3 = 0;
8000c3f0:	8f 8f c0 f1 	andn %d15,%d15,8
8000c3f4:	68 0f       	st.w [%a15]0,%d15
		Beep(130);
8000c3f6:	6d ff 43 f4 	call 8000ac7c <Beep>
}

TASK(Buzzer_Example)
{
	volatile unsigned int j = 0;
	while (j++ < 1000) {
8000c3fa:	58 01       	ld.w %d15,[%sp]4
8000c3fc:	92 12       	add %d2,%d15,1
8000c3fe:	59 a2 04 00 	st.w [%sp]4,%d2
8000c402:	3f 8f ed ff 	jlt.u %d15,%d8,8000c3dc <FuncBuzzer_Example+0x20>
8000c406:	1d 00 2a 07 	j 8000d25a <TerminateTask>

8000c40a <FuncTOF_Example>:
	}
	TerminateTask();
}

TASK(TOF_Example)
{
8000c40a:	91 00 00 d8 	movh.a %a13,32768
8000c40e:	91 00 00 c8 	movh.a %a12,32768
8000c412:	91 00 00 f8 	movh.a %a15,32768
8000c416:	20 08       	sub.a %sp,8
8000c418:	d9 dd 8d 40 	lea %a13,[%a13]2317 <8000090d <osEE_sdb_array+0x131>>
8000c41c:	d9 cc a6 40 	lea %a12,[%a12]2342 <80000926 <osEE_sdb_array+0x14a>>
8000c420:	d9 ff b5 40 	lea %a15,[%a15]2357 <80000926 <osEE_sdb_array+0x14a>>
	int tof_distance;
	while (1) {
		tof_distance = getTofDistance();
8000c424:	6d ff d0 f8 	call 8000b5c4 <getTofDistance>
		if (tof_distance == -1) {
8000c428:	df f2 0a 00 	jeq %d2,-1,8000c43c <FuncTOF_Example+0x32>
			my_printf("Invalid checksum error!\n");
		} else if (tof_distance == 0) {
8000c42c:	f6 2c       	jnz %d2,8000c444 <FuncTOF_Example+0x3a>
			my_printf("Out of Range!\n");
8000c42e:	40 c4       	mov.aa %a4,%a12
8000c430:	6d ff 23 f0 	call 8000a476 <my_printf>

TASK(TOF_Example)
{
	int tof_distance;
	while (1) {
		tof_distance = getTofDistance();
8000c434:	6d ff c8 f8 	call 8000b5c4 <getTofDistance>
		if (tof_distance == -1) {
8000c438:	df f2 fa ff 	jne %d2,-1,8000c42c <FuncTOF_Example+0x22>
			my_printf("Invalid checksum error!\n");
8000c43c:	40 d4       	mov.aa %a4,%a13
8000c43e:	6d ff 1c f0 	call 8000a476 <my_printf>
8000c442:	3c f1       	j 8000c424 <FuncTOF_Example+0x1a>
		} else if (tof_distance == 0) {
			my_printf("Out of Range!\n");
		} else {
			my_printf("Distance: %dmm\n", tof_distance);
8000c444:	74 a2       	st.w [%sp],%d2
8000c446:	40 f4       	mov.aa %a4,%a15
8000c448:	6d ff 17 f0 	call 8000a476 <my_printf>
8000c44c:	3c ec       	j 8000c424 <FuncTOF_Example+0x1a>

8000c44e <FuncADC_Example>:
	}
	TerminateTask();
}

TASK(ADC_Example)
{
8000c44e:	20 10       	sub.a %sp,16
	volatile unsigned int adcResult = 0;
8000c450:	82 0f       	mov %d15,0
8000c452:	91 00 00 f8 	movh.a %a15,32768
8000c456:	78 03       	st.w [%sp]12,%d15
8000c458:	d9 ff 85 50 	lea %a15,[%a15]2373 <80000945 <osEE_sdb_array+0x169>>
	while(1) {
		VADC_startConversion();
8000c45c:	6d ff a0 f3 	call 8000ab9c <VADC_startConversion>
		adcResult = VADC_readResult();
8000c460:	6d ff b3 f3 	call 8000abc6 <VADC_readResult>
8000c464:	59 a2 0c 00 	st.w [%sp]12,%d2
		my_printf("%d\n", adcResult);
8000c468:	58 03       	ld.w %d15,[%sp]12
8000c46a:	40 f4       	mov.aa %a4,%a15
8000c46c:	78 00       	st.w [%sp]0,%d15
8000c46e:	6d ff 04 f0 	call 8000a476 <my_printf>
	}
8000c472:	3c f5       	j 8000c45c <FuncADC_Example+0xe>

8000c474 <FuncOS_EE_Task_Init>:
	TerminateTask();
}

TASK(OS_EE_Task_Init) //         
{
8000c474:	91 00 00 c8 	movh.a %a12,32768
8000c478:	91 00 00 f8 	movh.a %a15,32768
8000c47c:	d9 cc 89 50 	lea %a12,[%a12]2377 <80000949 <osEE_sdb_array+0x16d>>
8000c480:	d9 ff 98 50 	lea %a15,[%a15]2392 <80000958 <osEE_sdb_array+0x17c>>
8000c484:	3c 20       	j 8000c4c4 <FuncOS_EE_Task_Init+0x50>
			delay_ms(50);
			clear_lcdprint();
			delay_ms(100);
		}
		else {
			delay_ms(50);
8000c486:	6d ff ad f3 	call 8000abe0 <delay_ms>
			write_instruction(0x80); //  
8000c48a:	3b 00 08 40 	mov %d4,128
8000c48e:	6d ff 2a f6 	call 8000b0e2 <write_instruction>
			delay_ms(50);
8000c492:	3b 20 03 40 	mov %d4,50
8000c496:	6d ff a5 f3 	call 8000abe0 <delay_ms>


			lcdprint_data("TUNNEL MODE OFF");
8000c49a:	40 f4       	mov.aa %a4,%a15
8000c49c:	6d ff 65 f6 	call 8000b166 <lcdprint_data>

			delay_ms(50);
8000c4a0:	3b 20 03 40 	mov %d4,50
8000c4a4:	6d ff 9e f3 	call 8000abe0 <delay_ms>
			write_instruction(0xc0); //2  
8000c4a8:	3b 00 0c 40 	mov %d4,192
8000c4ac:	6d ff 1b f6 	call 8000b0e2 <write_instruction>
			delay_ms(50);
8000c4b0:	3b 20 03 40 	mov %d4,50
8000c4b4:	6d ff 96 f3 	call 8000abe0 <delay_ms>
			clear_lcdprint();
8000c4b8:	6d ff 8b f6 	call 8000b1ce <clear_lcdprint>
			delay_ms(100);
8000c4bc:	3b 40 06 40 	mov %d4,100
8000c4c0:	6d ff 90 f3 	call 8000abe0 <delay_ms>

TASK(OS_EE_Task_Init) //         
{
	while(1){

		if(getTunnelStatus()==1){ // in
8000c4c4:	6d ff 2f eb 	call 80009b22 <getTunnelStatus>
			//clear_two_lines();

			delay_ms(50);
8000c4c8:	3b 20 03 40 	mov %d4,50

TASK(OS_EE_Task_Init) //         
{
	while(1){

		if(getTunnelStatus()==1){ // in
8000c4cc:	df 12 dd ff 	jne %d2,1,8000c486 <FuncOS_EE_Task_Init+0x12>
			//clear_two_lines();

			delay_ms(50);
8000c4d0:	6d ff 88 f3 	call 8000abe0 <delay_ms>
			write_instruction(0x80); //  
8000c4d4:	3b 00 08 40 	mov %d4,128
8000c4d8:	6d ff 05 f6 	call 8000b0e2 <write_instruction>
			delay_ms(50);
8000c4dc:	3b 20 03 40 	mov %d4,50
8000c4e0:	6d ff 80 f3 	call 8000abe0 <delay_ms>
			lcdprint_data("TUNNEL MODE ON");
8000c4e4:	40 c4       	mov.aa %a4,%a12
8000c4e6:	3c db       	j 8000c49c <FuncOS_EE_Task_Init+0x28>

8000c4e8 <main>:
	TerminateTask();
}

int main(void)
{
	SYSTEM_Init();
8000c4e8:	6d ff cc f9 	call 8000b880 <SYSTEM_Init>
	InterruptInit();
8000c4ec:	6d ff a2 f9 	call 8000b830 <InterruptInit>

	Init_GPIO();
8000c4f0:	6d ff 05 f4 	call 8000acfa <Init_GPIO>
	init_lcd();
8000c4f4:	6d ff 77 f5 	call 8000afe2 <init_lcd>
	Driver_Can_Init();
8000c4f8:	6d ff 1a eb 	call 80009b2c <Driver_Can_Init>

	_init_uart3();
8000c4fc:	6d ff e2 eb 	call 80009cc0 <_init_uart3>
	StartOS(OSDEFAULTAPPMODE);
8000c500:	82 04       	mov %d4,0
8000c502:	6d 00 c6 05 	call 8000d08e <StartOS>

	return 0;
}
8000c506:	82 02       	mov %d2,0
8000c508:	00 90       	ret 

8000c50a <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c50a:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000c50e:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c512:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000c516:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c51a:	54 26       	ld.w %d6,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000c51c:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c51e:	37 06 6e 61 	extr.u %d6,%d6,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000c522:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000c526:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000c52a:	8f f6 83 61 	xor %d6,%d6,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000c52e:	8f f8 83 81 	xor %d8,%d8,63
8000c532:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
8000c536:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000c538:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
8000c53c:	3b 00 b8 f0 	mov %d15,2944
8000c540:	cd 4f e0 0f 	mtcr $psw,%d15
8000c544:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000c548:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
8000c54c:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
8000c550:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000c554:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000c558:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
8000c55c:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
8000c55e:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
8000c562:	cd 42 20 09 	mtcr $pcon1,%d2
8000c566:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c56a:	53 cf 20 f0 	mul %d15,%d15,12
8000c56e:	10 22       	addsc.a %a2,%a2,%d15,0
8000c570:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c572:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c574:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c578:	d9 2f 00 46 	lea %a15,[%a2]24832
8000c57c:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c580:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000c582:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c586:	2e 16       	jz.t %d15,1,8000c592 <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c588:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c58c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c590:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c592:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c596:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c59a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c59c:	4c f0       	ld.w %d15,[%a15]0
8000c59e:	6f 0f ff ff 	jnz.t %d15,0,8000c59c <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
8000c5a2:	82 0f       	mov %d15,0
8000c5a4:	cd cf 20 09 	mtcr $pcon0,%d15
8000c5a8:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c5ac:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c5ae:	2e 16       	jz.t %d15,1,8000c5ba <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c5b0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c5b4:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c5b8:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c5ba:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c5be:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c5c2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c5c4:	4c f0       	ld.w %d15,[%a15]0
8000c5c6:	6f 0f ff 7f 	jz.t %d15,0,8000c5c4 <osEE_tc_core0_start+0xba>
8000c5ca:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
8000c5ce:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c5d2:	91 30 00 ff 	movh.a %a15,61443
8000c5d6:	53 cf 20 f0 	mul %d15,%d15,12
8000c5da:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c5de:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c5e0:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c5e2:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c5e4:	d9 2f 00 46 	lea %a15,[%a2]24832
8000c5e8:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c5ec:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c5f0:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000c5f2:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c5f6:	2e 16       	jz.t %d15,1,8000c602 <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c5f8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c5fc:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c600:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c602:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c606:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c60a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c60c:	4c f0       	ld.w %d15,[%a15]0
8000c60e:	6f 0f ff ff 	jnz.t %d15,0,8000c60c <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
8000c612:	82 0f       	mov %d15,0
8000c614:	cd 0f 04 09 	mtcr $dcon0,%d15
8000c618:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c61c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c61e:	2e 16       	jz.t %d15,1,8000c62a <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c620:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c624:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c628:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c62a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c62e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c632:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c634:	4c f0       	ld.w %d15,[%a15]0
8000c636:	6f 0f ff 7f 	jz.t %d15,0,8000c634 <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c63a:	91 30 00 ff 	movh.a %a15,61443
8000c63e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c642:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c644:	2e 16       	jz.t %d15,1,8000c650 <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c646:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c64a:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c64e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c650:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c654:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c658:	91 30 00 ff 	movh.a %a15,61443
8000c65c:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c660:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c662:	4c f0       	ld.w %d15,[%a15]0
8000c664:	91 30 00 2f 	movh.a %a2,61443
8000c668:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c66c:	6f 0f fb ff 	jnz.t %d15,0,8000c662 <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
8000c670:	7b 00 00 f8 	movh %d15,32768
8000c674:	1b 0f 00 f1 	addi %d15,%d15,4096
8000c678:	cd 4f e2 0f 	mtcr $btv,%d15
8000c67c:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
8000c680:	7b 00 00 f8 	movh %d15,32768
8000c684:	1b 0f 00 f2 	addi %d15,%d15,8192
8000c688:	cd 0f e2 0f 	mtcr $biv,%d15
8000c68c:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
8000c690:	7b 20 00 f7 	movh %d15,28674
8000c694:	1b 0f b0 f9 	addi %d15,%d15,-25856
8000c698:	cd 8f e2 0f 	mtcr $isp,%d15
8000c69c:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c6a0:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c6a2:	2e 16       	jz.t %d15,1,8000c6ae <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c6a4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c6a8:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c6ac:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c6ae:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c6b2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c6b6:	91 30 00 ff 	movh.a %a15,61443
8000c6ba:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c6be:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c6c0:	4c f0       	ld.w %d15,[%a15]0
8000c6c2:	6f 0f ff 7f 	jz.t %d15,0,8000c6c0 <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
8000c6c6:	91 10 00 f7 	movh.a %a15,28673
8000c6ca:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
8000c6ce:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
8000c6d0:	91 10 00 f8 	movh.a %a15,32769
8000c6d4:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000c6d8:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
8000c6da:	91 10 00 f8 	movh.a %a15,32769
8000c6de:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000c6e2:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
8000c6e4:	91 10 00 fb 	movh.a %a15,45057
8000c6e8:	d9 ff 00 08 	lea %a15,[%a15]-32768 <b0008000 <_SMALL_DATA4_>>
8000c6ec:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
8000c6ee:	7b 20 00 f7 	movh %d15,28674
8000c6f2:	7b 20 00 47 	movh %d4,28674
8000c6f6:	1b 0f c0 59 	addi %d5,%d15,-25600
8000c6fa:	1b 04 c0 4b 	addi %d4,%d4,-17408
8000c6fe:	a2 54       	sub %d4,%d5
8000c700:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
8000c702:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
8000c704:	df 04 1b 00 	jeq %d4,0,8000c73a <osEE_tc_core0_start+0x230>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
8000c708:	9a f4       	add %d15,%d4,-1
8000c70a:	06 6f       	sh %d15,6
8000c70c:	12 53       	add %d3,%d15,%d5

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000c70e:	60 3f       	mov.a %a15,%d3
8000c710:	82 00       	mov %d0,0
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
8000c712:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c716:	37 03 70 73 	extr.u %d7,%d3,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000c71a:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000c71c:	60 4f       	mov.a %a15,%d4
8000c71e:	1b 0f fc ff 	addi %d15,%d15,-64
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c722:	37 27 10 28 	insert %d2,%d7,%d2,16,16
8000c726:	42 5f       	add %d15,%d5

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000c728:	82 53       	mov %d3,5
8000c72a:	b0 ff       	add.a %a15,-1
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
8000c72c:	8f 4f 1e 50 	sh %d5,%d15,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c730:	37 0f 70 43 	extr.u %d4,%d15,6,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000c734:	c2 f3       	add %d3,-1
8000c736:	fd f0 11 01 	loop %a15,8000c958 <osEE_tc_core0_start+0x44e>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
8000c73a:	cd 82 e3 0f 	mtcr $fcx,%d2
8000c73e:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c742:	91 30 00 ff 	movh.a %a15,61443
8000c746:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c74a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c74c:	2e 16       	jz.t %d15,1,8000c758 <osEE_tc_core0_start+0x24e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c74e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c752:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c756:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c758:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c75c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c760:	91 30 00 ff 	movh.a %a15,61443
8000c764:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c768:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c76a:	40 f2       	mov.aa %a2,%a15
8000c76c:	4c 20       	ld.w %d15,[%a2]0
8000c76e:	91 30 00 ff 	movh.a %a15,61443
8000c772:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c776:	6f 0f fb ff 	jnz.t %d15,0,8000c76c <osEE_tc_core0_start+0x262>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
8000c77a:	4c f1       	ld.w %d15,[%a15]4
8000c77c:	96 08       	or %d15,8
8000c77e:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c780:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c782:	2e 16       	jz.t %d15,1,8000c78e <osEE_tc_core0_start+0x284>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c784:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c788:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c78c:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c78e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c792:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c796:	91 30 00 ff 	movh.a %a15,61443
8000c79a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c79e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c7a0:	4c f0       	ld.w %d15,[%a15]0
8000c7a2:	6f 0f ff 7f 	jz.t %d15,0,8000c7a0 <osEE_tc_core0_start+0x296>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c7a6:	91 30 00 ff 	movh.a %a15,61443
8000c7aa:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c7ae:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c7b0:	2e 16       	jz.t %d15,1,8000c7bc <osEE_tc_core0_start+0x2b2>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c7b2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c7b6:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c7ba:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
8000c7bc:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
8000c7c0:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000c7c4:	91 30 00 ff 	movh.a %a15,61443
8000c7c8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c7cc:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
8000c7ce:	40 f2       	mov.aa %a2,%a15
8000c7d0:	4c 20       	ld.w %d15,[%a2]0
8000c7d2:	91 30 00 ff 	movh.a %a15,61443
8000c7d6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c7da:	6f 0f fb ff 	jnz.t %d15,0,8000c7d0 <osEE_tc_core0_start+0x2c6>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
8000c7de:	4c f1       	ld.w %d15,[%a15]4
8000c7e0:	96 08       	or %d15,8
8000c7e2:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c7e4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c7e6:	2e 16       	jz.t %d15,1,8000c7f2 <osEE_tc_core0_start+0x2e8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c7e8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c7ec:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c7f0:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000c7f2:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
8000c7f6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
8000c7fa:	91 30 00 ff 	movh.a %a15,61443
8000c7fe:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c802:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000c804:	4c f0       	ld.w %d15,[%a15]0
8000c806:	6f 0f ff 7f 	jz.t %d15,0,8000c804 <osEE_tc_core0_start+0x2fa>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
8000c80a:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
8000c80e:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
8000c810:	d9 44 d4 70 	lea %a4,[%a4]3540 <80000dd4 <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
8000c814:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
8000c816:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
8000c818:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
8000c81a:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
8000c81c:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
8000c81e:	9e f6       	jeq %d15,-1,8000c84a <osEE_tc_core0_start+0x340>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
8000c820:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000c824:	76 49       	jz %d4,8000c836 <osEE_tc_core0_start+0x32c>
        *block_to_clear.p_ull = 0ULL;
8000c826:	60 4f       	mov.a %a15,%d4
8000c828:	40 32       	mov.aa %a2,%a3
8000c82a:	b0 ff       	add.a %a15,-1
8000c82c:	89 22 48 01 	st.d [%a2+]8,%e2
8000c830:	fc fe       	loop %a15,8000c82c <osEE_tc_core0_start+0x322>
8000c832:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
8000c836:	2e 22       	jz.t %d15,2,8000c83a <osEE_tc_core0_start+0x330>
        *block_to_clear.p_ui = 0x0U;
8000c838:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
8000c83a:	2e 12       	jz.t %d15,1,8000c83e <osEE_tc_core0_start+0x334>
        *block_to_clear.p_us = 0x0U;
8000c83c:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
8000c83e:	2e 02       	jz.t %d15,0,8000c842 <osEE_tc_core0_start+0x338>
        *block_to_clear.p_uc = 0x0U;
8000c840:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
8000c842:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
8000c846:	bd 04 ea ff 	jnz.a %a4,8000c81a <osEE_tc_core0_start+0x310>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
8000c84a:	91 00 00 68 	movh.a %a6,32768
8000c84e:	d9 66 fc 80 	lea %a6,[%a6]3644 <80000e3c <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
8000c852:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
8000c854:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
8000c856:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
8000c85a:	df ff 21 00 	jeq %d15,-1,8000c89c <osEE_tc_core0_start+0x392>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
8000c85e:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000c862:	76 4f       	jz %d4,8000c880 <osEE_tc_core0_start+0x376>
8000c864:	60 4f       	mov.a %a15,%d4
8000c866:	40 43       	mov.aa %a3,%a4
8000c868:	40 52       	mov.aa %a2,%a5
8000c86a:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
8000c86c:	09 22 48 01 	ld.d %e2,[%a2+]8
8000c870:	89 32 48 01 	st.d [%a3+]8,%e2
8000c874:	fc fc       	loop %a15,8000c86c <osEE_tc_core0_start+0x362>
8000c876:	06 34       	sh %d4,3
8000c878:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
8000c87c:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
8000c880:	2e 23       	jz.t %d15,2,8000c886 <osEE_tc_core0_start+0x37c>
        *block_dest.p_ui = *block_src.p_ui;
8000c882:	44 52       	ld.w %d2,[%a5+]
8000c884:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
8000c886:	2e 14       	jz.t %d15,1,8000c88e <osEE_tc_core0_start+0x384>
        *block_dest.p_us = *block_src.p_us;
8000c888:	09 52 c2 00 	ld.hu %d2,[%a5+]2
8000c88c:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
8000c88e:	2e 03       	jz.t %d15,0,8000c894 <osEE_tc_core0_start+0x38a>
        *block_dest.p_uc = *block_src.p_uc;
8000c890:	0c 50       	ld.bu %d15,[%a5]0
8000c892:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
8000c894:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
8000c898:	bd 06 dd ff 	jnz.a %a6,8000c852 <osEE_tc_core0_start+0x348>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c89c:	91 30 00 ff 	movh.a %a15,61443
8000c8a0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c8a4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c8a6:	2e 16       	jz.t %d15,1,8000c8b2 <osEE_tc_core0_start+0x3a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c8a8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c8ac:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c8b0:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
8000c8b2:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
8000c8b6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000c8ba:	91 30 00 ff 	movh.a %a15,61443
8000c8be:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c8c2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
8000c8c4:	4c f0       	ld.w %d15,[%a15]0
8000c8c6:	6f 0f ff ff 	jnz.t %d15,0,8000c8c4 <osEE_tc_core0_start+0x3ba>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
8000c8ca:	7b 20 22 f1 	movh %d15,4642
8000c8ce:	91 30 00 ff 	movh.a %a15,61443
8000c8d2:	1b 1f 10 f0 	addi %d15,%d15,257
8000c8d6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000c8da:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
8000c8dc:	7b 00 00 f5 	movh %d15,20480
8000c8e0:	91 30 00 ff 	movh.a %a15,61443
8000c8e4:	1b 0f 10 f1 	addi %d15,%d15,4352
8000c8e8:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000c8ec:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
8000c8ee:	7b 70 00 f0 	movh %d15,7
8000c8f2:	91 30 00 ff 	movh.a %a15,61443
8000c8f6:	1b cf 01 f0 	addi %d15,%d15,28
8000c8fa:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
8000c8fe:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
8000c900:	4c f0       	ld.w %d15,[%a15]0
8000c902:	6f 1f ff 7f 	jz.t %d15,1,8000c900 <osEE_tc_core0_start+0x3f6>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
8000c906:	91 30 00 ff 	movh.a %a15,61443
8000c90a:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
8000c90e:	4c f0       	ld.w %d15,[%a15]0
8000c910:	6f 8f ff 7f 	jz.t %d15,8,8000c90e <osEE_tc_core0_start+0x404>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
8000c914:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c918:	91 30 00 ff 	movh.a %a15,61443
8000c91c:	1b 04 20 4c 	addi %d4,%d4,-15872
8000c920:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c924:	6d 00 9a 00 	call 8000ca58 <osEE_tc_set_pll_fsource>
8000c928:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c92a:	2e 16       	jz.t %d15,1,8000c936 <osEE_tc_core0_start+0x42c>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c92c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c930:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c934:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000c936:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
8000c93a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
8000c93e:	91 30 00 ff 	movh.a %a15,61443
8000c942:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c946:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000c948:	4c f0       	ld.w %d15,[%a15]0
8000c94a:	6f 0f ff 7f 	jz.t %d15,0,8000c948 <osEE_tc_core0_start+0x43e>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
8000c94e:	6d ff cd fd 	call 8000c4e8 <main>
8000c952:	02 24       	mov %d4,%d2
8000c954:	1d 00 fe 27 	j 80011950 <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000c958:	60 f2       	mov.a %a2,%d15
8000c95a:	74 22       	st.w [%a2],%d2
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c95c:	37 54 10 28 	insert %d2,%d4,%d5,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
8000c960:	76 35       	jz %d3,8000c96a <osEE_tc_core0_start+0x460>
8000c962:	1b 0f fc ff 	addi %d15,%d15,-64
8000c966:	1d ff e3 fe 	j 8000c72c <osEE_tc_core0_start+0x222>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
8000c96a:	cd c2 e3 0f 	mtcr $lcx,%d2
8000c96e:	0d 00 c0 04 	isync 
8000c972:	3c f8       	j 8000c962 <osEE_tc_core0_start+0x458>

8000c974 <osEE_tricore_system_timer_handler>:
8000c974:	4d c0 e1 4f 	mfcr %d4,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c978:	91 00 00 f7 	movh.a %a15,28672
8000c97c:	19 ff 60 24 	ld.w %d15,[%a15]17568 <700044a0 <osEE_tc_stm_freq_khz>>
8000c980:	3b 80 3e 50 	mov %d5,1000
8000c984:	37 04 48 40 	extr %d4,%d4,0,8
8000c988:	3f 5f 0b 80 	jlt.u %d15,%d5,8000c99e <osEE_tricore_system_timer_handler+0x2a>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c98c:	7b 20 06 21 	movh %d2,4194
8000c990:	1b 32 dd 24 	addi %d2,%d2,19923
8000c994:	73 2f 68 20 	mul.u %e2,%d15,%d2
8000c998:	8f a3 1f f0 	sh %d15,%d3,-6
8000c99c:	e2 5f       	mul %d15,%d5
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
8000c99e:	8f 34 00 41 	and %d4,%d4,3
8000c9a2:	9b 04 0f 40 	addih %d4,%d4,240
8000c9a6:	8f 84 00 40 	sh %d4,%d4,8
8000c9aa:	60 4f       	mov.a %a15,%d4
8000c9ac:	48 c2       	ld.w %d2,[%a15]48
8000c9ae:	42 2f       	add %d15,%d2
8000c9b0:	68 cf       	st.w [%a15]48,%d15
      break;
  }
#endif /* OSEE_SINGLECORE */

  p_cdb = osEE_get_curr_core();
  osEE_counter_increment(p_cdb->p_sys_counter_db);
8000c9b2:	91 00 00 f8 	movh.a %a15,32768
8000c9b6:	d9 ff 54 50 	lea %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
8000c9ba:	c8 24       	ld.a %a4,[%a15]8
8000c9bc:	1d 00 a4 0a 	j 8000df04 <osEE_counter_increment>

8000c9c0 <osEE_tc_initialize_system_timer>:
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000c9c0:	39 42 1c 00 	ld.bu %d2,[%a4]28
 * @brief  Used to set STM suspension when OCDS take control
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_stm_ocds_suspend_control(OsEE_reg stm_id)
{
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_OCS_OFF) =
8000c9c4:	7b 00 20 31 	movh %d3,4608
8000c9c8:	8f f2 07 21 	and %d2,%d2,127
8000c9cc:	1b 12 00 70 	addi %d7,%d2,1
8000c9d0:	a5 f3 28 30 	st.w f00000e8 <_SMALL_DATA4_+0x3fff80e8>,%d3
8000c9d4:	4d c0 e1 2f 	mfcr %d2,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c9d8:	91 00 00 f7 	movh.a %a15,28672
8000c9dc:	19 ff 60 24 	ld.w %d15,[%a15]17568 <700044a0 <osEE_tc_stm_freq_khz>>
8000c9e0:	3b 80 3e 60 	mov %d6,1000
8000c9e4:	37 02 48 30 	extr %d3,%d2,0,8
8000c9e8:	3f 6f 0b 80 	jlt.u %d15,%d6,8000c9fe <osEE_tc_initialize_system_timer+0x3e>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c9ec:	7b 20 06 41 	movh %d4,4194
8000c9f0:	1b 34 dd 44 	addi %d4,%d4,19923
8000c9f4:	73 4f 68 40 	mul.u %e4,%d15,%d4
8000c9f8:	8f a5 1f f0 	sh %d15,%d5,-6
8000c9fc:	e2 6f       	mul %d15,%d6
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
8000c9fe:	8f 33 00 31 	and %d3,%d3,3
8000ca02:	9b 03 0f 50 	addih %d5,%d3,240
8000ca06:	8f 85 00 50 	sh %d5,%d5,8
8000ca0a:	60 5f       	mov.a %a15,%d5
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000ca0c:	0f 0f b0 41 	clz %d4,%d15
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
8000ca10:	48 45       	ld.w %d5,[%a15]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
8000ca12:	8b f4 01 41 	rsub %d4,%d4,31

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
8000ca16:	42 5f       	add %d15,%d5
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
8000ca18:	68 cf       	st.w [%a15]48,%d15
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
8000ca1a:	48 e5       	ld.w %d5,[%a15]56
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
8000ca1c:	06 33       	sh %d3,3
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
8000ca1e:	b7 05 05 54 	insert %d5,%d5,0,8,5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000ca22:	60 32       	mov.a %a2,%d3
8000ca24:	68 e5       	st.w [%a15]56,%d5
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
8000ca26:	4c fe       	ld.w %d15,[%a15]56
8000ca28:	8f 32 00 21 	and %d2,%d2,3
8000ca2c:	37 4f 05 40 	insert %d4,%d15,%d4,0,5
8000ca30:	b7 87 99 f3 	insert %d15,%d7,8,7,25
8000ca34:	68 e4       	st.w [%a15]56,%d4
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
8000ca36:	48 f4       	ld.w %d4,[%a15]60
8000ca38:	8f b2 00 20 	sh %d2,%d2,11
8000ca3c:	8f 44 c0 41 	andn %d4,%d4,4
8000ca40:	68 f4       	st.w [%a15]60,%d4
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
8000ca42:	48 f4       	ld.w %d4,[%a15]60
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000ca44:	a6 f2       	or %d2,%d15
8000ca46:	8f 14 40 41 	or %d4,%d4,1
8000ca4a:	68 f4       	st.w [%a15]60,%d4
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000ca4c:	d9 2f 50 28 	lea %a15,[%a2]-31600
8000ca50:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000ca54:	68 02       	st.w [%a15]0,%d2
8000ca56:	00 90       	ret 

8000ca58 <osEE_tc_set_pll_fsource>:

  bestK2 = 0U;
  bestN  = 0U;
  bestP  = 0U;
  /* K2+1 div should be even for 50% duty cycle */
  k2Steps = 2;
8000ca58:	7b e0 e4 30 	movh %d3,3662
8000ca5c:	1b 13 c0 31 	addi %d3,%d3,7169
8000ca60:	82 1f       	mov %d15,1
8000ca62:	0b 34 50 21 	ge.u %d2,%d4,%d3
8000ca66:	7b c0 be 50 	movh %d5,3052
8000ca6a:	ab 2f 80 22 	sel %d2,%d2,%d15,2
8000ca6e:	1b 05 20 5c 	addi %d5,%d5,-15872
8000ca72:	53 f2 20 70 	mul %d7,%d2,15
8000ca76:	3b 00 01 a0 	mov %d10,16
8000ca7a:	02 56       	mov %d6,%d5
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000ca7c:	c2 fa       	add %d10,-1
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000ca7e:	8b 06 20 f2 	ne %d15,%d6,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000ca82:	7b 10 13 c0 	movh %d12,305

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000ca86:	91 40 0f 50 	movh.a %a5,244
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000ca8a:	a0 03       	mov.a %a3,0
8000ca8c:	91 80 82 2e 	movh.a %a2,59432
8000ca90:	91 80 7d 61 	movh.a %a6,6104
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000ca94:	8b 0a 20 f4 	and.ne %d15,%d10,0

  bestK2 = 0U;
  bestN  = 0U;
  bestP  = 0U;
  /* K2+1 div should be even for 50% duty cycle */
  k2Steps = 2;
8000ca98:	60 2f       	mov.a %a15,%d2
8000ca9a:	60 74       	mov.a %a4,%d7
8000ca9c:	d2 00       	mov %e0,0
8000ca9e:	82 08       	mov %d8,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000caa0:	1b 0c d0 c2 	addi %d12,%d12,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000caa4:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000caa8:	b0 f3       	add.a %a3,-1
8000caaa:	d9 22 c0 07 	lea %a2,[%a2]31744 <e8287c00 <_SMALL_DATA4_+0x3827fc00>>
8000caae:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000cab2:	6e 55       	jz %d15,8000cb5c <osEE_tc_set_pll_fsource+0x104>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000cab4:	4b ac 11 22 	div.u %e2,%d12,%d10

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000cab8:	7b 60 f8 7f 	movh %d7,65414
8000cabc:	1b 07 e0 7e 	addi %d7,%d7,-4608
8000cac0:	0b 72 40 70 	addx %d7,%d2,%d7
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000cac4:	82 03       	mov %d3,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000cac6:	8b f3 bf 20 	addc %d2,%d3,-1
8000caca:	80 5e       	mov.d %d14,%a5
8000cacc:	ba 02       	eq %d15,%d2,0
8000cace:	0b e7 50 f2 	and.ge.u %d15,%d7,%d14
8000cad2:	8b 02 00 f5 	or.ne %d15,%d2,0
8000cad6:	ee 3b       	jnz %d15,8000cb4c <osEE_tc_set_pll_fsource+0xf4>
8000cad8:	02 ab       	mov %d11,%d10
8000cada:	82 19       	mov %d9,1
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000cadc:	80 3f       	mov.d %d15,%a3
8000cade:	80 2e       	mov.d %d14,%a2
8000cae0:	80 67       	mov.d %d7,%a6
8000cae2:	03 49 68 2e 	madd.u %e2,%e14,%d9,%d4
8000cae6:	8b 06 20 d2 	ne %d13,%d6,0
8000caea:	ba 03       	eq %d15,%d3,0
8000caec:	0b 72 30 f2 	and.lt.u %d15,%d2,%d7
8000caf0:	6e 25       	jz %d15,8000cb3a <osEE_tc_set_pll_fsource+0xe2>
        {
          for (
8000caf2:	df 06 2d 00 	jeq %d6,0,8000cb4c <osEE_tc_set_pll_fsource+0xf4>
8000caf6:	82 12       	mov %d2,1
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
8000caf8:	4b b2 11 62 	div.u %e6,%d2,%d11
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
8000cafc:	82 13       	mov %d3,1
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
8000cafe:	02 6f       	mov %d15,%d6
8000cb00:	e2 cf       	mul %d15,%d12
8000cb02:	a2 4f       	sub %d15,%d4
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
8000cb04:	0b 5f 30 32 	and.lt.u %d3,%d15,%d5
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
8000cb08:	53 1f 40 60 	mul.u %e6,%d15,1
8000cb0c:	2b f5 50 53 	seln %d5,%d3,%d5,%d15
8000cb10:	2b a1 50 13 	seln %d1,%d3,%d1,%d10
8000cb14:	2b 20 50 03 	seln %d0,%d3,%d0,%d2
8000cb18:	2b 98 50 83 	seln %d8,%d3,%d8,%d9
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
8000cb1c:	ee 05       	jnz %d15,8000cb26 <osEE_tc_set_pll_fsource+0xce>
8000cb1e:	0b 2a 10 08 	mov %e0,%d10,%d2
8000cb22:	02 98       	mov %d8,%d9
8000cb24:	82 05       	mov %d5,0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
8000cb26:	c2 12       	add %d2,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
8000cb28:	8b 12 68 32 	lt.u %d3,%d2,129
8000cb2c:	8b 0f 20 34 	and.ne %d3,%d15,0
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
8000cb30:	8b 0f 20 d2 	ne %d13,%d15,0
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
8000cb34:	df 03 e2 ff 	jne %d3,0,8000caf8 <osEE_tc_set_pll_fsource+0xa0>
8000cb38:	a6 76       	or %d6,%d7
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
8000cb3a:	80 fe       	mov.d %d14,%a15
8000cb3c:	80 4f       	mov.d %d15,%a4
8000cb3e:	42 e9       	add %d9,%d14
8000cb40:	42 fb       	add %d11,%d15

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
8000cb42:	8b d9 61 f2 	lt.u %d15,%d9,29
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
8000cb46:	26 fd       	and %d13,%d15
8000cb48:	df 0d ca ff 	jne %d13,0,8000cadc <osEE_tc_set_pll_fsource+0x84>
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000cb4c:	c2 fa       	add %d10,-1
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000cb4e:	8b 06 20 f2 	ne %d15,%d6,0
8000cb52:	8b 0a 20 f4 	and.ne %d15,%d10,0
8000cb56:	01 f4 20 40 	sub.a %a4,%a4,%a15
8000cb5a:	ee ad       	jnz %d15,8000cab4 <osEE_tc_set_pll_fsource+0x5c>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
8000cb5c:	7b c0 1e 25 	movh %d2,20972
8000cb60:	06 14       	sh %d4,1
8000cb62:	1b f2 51 28 	addi %d2,%d2,-31457
8000cb66:	73 24 68 20 	mul.u %e2,%d4,%d2
8000cb6a:	8f b3 1f f0 	sh %d15,%d3,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
8000cb6e:	7f f5 65 80 	jge.u %d5,%d15,8000cc38 <osEE_tc_set_pll_fsource+0x1e0>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
8000cb72:	91 30 00 ff 	movh.a %a15,61443
8000cb76:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000cb7a:	4c f0       	ld.w %d15,[%a15]0
8000cb7c:	c2 f8       	add %d8,-1
8000cb7e:	37 8f 07 80 	insert %d8,%d15,%d8,0,7
8000cb82:	68 08       	st.w [%a15]0,%d8

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
8000cb84:	91 30 00 ff 	movh.a %a15,61443
8000cb88:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cb8c:	4c f0       	ld.w %d15,[%a15]0
8000cb8e:	6f 5f ff 7f 	jz.t %d15,5,8000cb8c <osEE_tc_set_pll_fsource+0x134>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
8000cb92:	91 30 00 ff 	movh.a %a15,61443
8000cb96:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000cb9a:	4c f0       	ld.w %d15,[%a15]0
8000cb9c:	96 01       	or %d15,1
8000cb9e:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
8000cba0:	91 30 00 ff 	movh.a %a15,61443
8000cba4:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cba8:	4c f0       	ld.w %d15,[%a15]0
8000cbaa:	6f 0f ff 7f 	jz.t %d15,0,8000cba8 <osEE_tc_set_pll_fsource+0x150>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000cbae:	91 30 00 ff 	movh.a %a15,61443
8000cbb2:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000cbb6:	4c f0       	ld.w %d15,[%a15]0
8000cbb8:	c2 f1       	add %d1,-1
8000cbba:	37 1f 04 1c 	insert %d1,%d15,%d1,24,4
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
8000cbbe:	c2 f0       	add %d0,-1
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000cbc0:	68 01       	st.w [%a15]0,%d1
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
8000cbc2:	4c f0       	ld.w %d15,[%a15]0
8000cbc4:	37 0f 87 04 	insert %d0,%d15,%d0,9,7
8000cbc8:	68 00       	st.w [%a15]0,%d0

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
8000cbca:	4c f0       	ld.w %d15,[%a15]0
8000cbcc:	8f 2f c0 f1 	andn %d15,%d15,2
8000cbd0:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
8000cbd2:	4c f0       	ld.w %d15,[%a15]0
8000cbd4:	96 40       	or %d15,64
8000cbd6:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
8000cbd8:	4c f0       	ld.w %d15,[%a15]0
8000cbda:	96 20       	or %d15,32
8000cbdc:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
8000cbde:	91 30 00 ff 	movh.a %a15,61443
8000cbe2:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cbe6:	4c f0       	ld.w %d15,[%a15]0
8000cbe8:	6f 3f ff ff 	jnz.t %d15,3,8000cbe6 <osEE_tc_set_pll_fsource+0x18e>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
8000cbec:	91 30 00 ff 	movh.a %a15,61443
8000cbf0:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000cbf4:	4c f0       	ld.w %d15,[%a15]0
8000cbf6:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
8000cbfa:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
8000cbfc:	91 30 00 ff 	movh.a %a15,61443
8000cc00:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cc04:	4c f0       	ld.w %d15,[%a15]0
8000cc06:	6f 2f ff 7f 	jz.t %d15,2,8000cc04 <osEE_tc_set_pll_fsource+0x1ac>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
8000cc0a:	91 30 00 ff 	movh.a %a15,61443
8000cc0e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000cc12:	4c f0       	ld.w %d15,[%a15]0
8000cc14:	8f 1f c0 f1 	andn %d15,%d15,1
8000cc18:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
8000cc1a:	91 30 00 ff 	movh.a %a15,61443
8000cc1e:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cc22:	4c f0       	ld.w %d15,[%a15]0
8000cc24:	6f 0f ff ff 	jnz.t %d15,0,8000cc22 <osEE_tc_set_pll_fsource+0x1ca>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
8000cc28:	91 30 00 ff 	movh.a %a15,61443
8000cc2c:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000cc30:	4c f0       	ld.w %d15,[%a15]0
8000cc32:	8f 0f c4 f1 	andn %d15,%d15,64
8000cc36:	68 0f       	st.w [%a15]0,%d15
8000cc38:	00 90       	ret 

8000cc3a <osEE_tc_get_fsource>:

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000cc3a:	91 30 00 ff 	movh.a %a15,61443
8000cc3e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000cc42:	4c f0       	ld.w %d15,[%a15]0
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
8000cc44:	7b 60 5f 20 	movh %d2,1526

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000cc48:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
8000cc4c:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000cc50:	ee 02       	jnz %d15,8000cc54 <osEE_tc_get_fsource+0x1a>
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
8000cc52:	00 90       	ret 
  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
8000cc54:	91 30 00 ff 	movh.a %a15,61443
8000cc58:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cc5c:	4c f0       	ld.w %d15,[%a15]0
8000cc5e:	6f 0f 2d 80 	jnz.t %d15,0,8000ccb8 <osEE_tc_get_fsource+0x7e>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000cc62:	4c f0       	ld.w %d15,[%a15]0
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cc64:	91 30 00 ff 	movh.a %a15,61443
8000cc68:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000cc6c:	6f 3f 1b 80 	jnz.t %d15,3,8000cca2 <osEE_tc_get_fsource+0x68>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cc70:	4c f0       	ld.w %d15,[%a15]0
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000cc72:	91 30 00 ff 	movh.a %a15,61443
8000cc76:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cc7a:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000cc7e:	4c f0       	ld.w %d15,[%a15]0
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000cc80:	48 02       	ld.w %d2,[%a15]0
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000cc82:	37 0f 64 3c 	extr.u %d3,%d15,24,4
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cc86:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000cc88:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000cc8c:	37 02 e7 44 	extr.u %d4,%d2,9,7

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000cc90:	7b 10 13 20 	movh %d2,305
8000cc94:	1b 02 d0 22 	addi %d2,%d2,11520
8000cc98:	4b f2 11 22 	div.u %e2,%d2,%d15
8000cc9c:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
8000cca0:	00 90       	ret 
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cca2:	48 02       	ld.w %d2,[%a15]0
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000cca4:	7b 10 13 f0 	movh %d15,305
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cca8:	8f f2 07 21 	and %d2,%d2,127
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000ccac:	1b 0f d0 f2 	addi %d15,%d15,11520
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000ccb0:	c2 12       	add %d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000ccb2:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000ccb6:	00 90       	ret 
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000ccb8:	91 30 00 ff 	movh.a %a15,61443
8000ccbc:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000ccc0:	48 02       	ld.w %d2,[%a15]0
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000ccc2:	7b 10 13 f0 	movh %d15,305
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000ccc6:	37 02 67 28 	extr.u %d2,%d2,16,7
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000ccca:	1b 0f d0 f2 	addi %d15,%d15,11520
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000ccce:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000ccd0:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000ccd4:	00 90       	ret 

8000ccd6 <osEE_tc_stm_set_clockpersec>:

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000ccd6:	91 30 00 ff 	movh.a %a15,61443
8000ccda:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000ccde:	48 02       	ld.w %d2,[%a15]0
8000cce0:	7b 60 5f f0 	movh %d15,1526
8000cce4:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000cce8:	1b 1f 10 fe 	addi %d15,%d15,-7935
8000ccec:	df 02 18 80 	jne %d2,0,8000cd1c <osEE_tc_stm_set_clockpersec+0x46>
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
8000ccf0:	91 30 00 ff 	movh.a %a15,61443
8000ccf4:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000ccf8:	48 02       	ld.w %d2,[%a15]0

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
8000ccfa:	91 00 00 f7 	movh.a %a15,28672
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
8000ccfe:	37 02 64 24 	extr.u %d2,%d2,8,4
8000cd02:	4b 2f 11 22 	div.u %e2,%d15,%d2

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
8000cd06:	7b 20 06 f1 	movh %d15,4194
8000cd0a:	1b 3f dd f4 	addi %d15,%d15,19923
8000cd0e:	73 f2 68 20 	mul.u %e2,%d2,%d15
8000cd12:	8f a3 1f f0 	sh %d15,%d3,-6
8000cd16:	59 ff 60 24 	st.w [%a15]17568 <700044a0 <osEE_tc_stm_freq_khz>>,%d15
8000cd1a:	00 90       	ret 
  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
8000cd1c:	91 30 00 ff 	movh.a %a15,61443
8000cd20:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000cd24:	4c f0       	ld.w %d15,[%a15]0
8000cd26:	6f 0f 2f 80 	jnz.t %d15,0,8000cd84 <osEE_tc_stm_set_clockpersec+0xae>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000cd2a:	4c f0       	ld.w %d15,[%a15]0
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cd2c:	91 30 00 ff 	movh.a %a15,61443
8000cd30:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000cd34:	6f 3f 1c 80 	jnz.t %d15,3,8000cd6c <osEE_tc_stm_set_clockpersec+0x96>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cd38:	4c f0       	ld.w %d15,[%a15]0
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000cd3a:	91 30 00 ff 	movh.a %a15,61443
8000cd3e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cd42:	8f ff 07 31 	and %d3,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000cd46:	4c f0       	ld.w %d15,[%a15]0
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000cd48:	48 04       	ld.w %d4,[%a15]0
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000cd4a:	37 0f 64 2c 	extr.u %d2,%d15,24,4
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cd4e:	9a 13       	add %d15,%d3,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000cd50:	03 f2 0a ff 	madd %d15,%d15,%d2,%d15
8000cd54:	7b 10 13 20 	movh %d2,305
8000cd58:	1b 02 d0 22 	addi %d2,%d2,11520
8000cd5c:	4b f2 11 22 	div.u %e2,%d2,%d15
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000cd60:	37 04 e7 44 	extr.u %d4,%d4,9,7

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000cd64:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
8000cd68:	9a 12       	add %d15,%d2,1
8000cd6a:	3c c3       	j 8000ccf0 <osEE_tc_stm_set_clockpersec+0x1a>
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cd6c:	48 02       	ld.w %d2,[%a15]0
8000cd6e:	8f f2 07 21 	and %d2,%d2,127
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000cd72:	7b 10 13 f0 	movh %d15,305
8000cd76:	1b 0f d0 f2 	addi %d15,%d15,11520
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000cd7a:	c2 12       	add %d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000cd7c:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000cd80:	9a 12       	add %d15,%d2,1
8000cd82:	3c b7       	j 8000ccf0 <osEE_tc_stm_set_clockpersec+0x1a>
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000cd84:	91 30 00 ff 	movh.a %a15,61443
8000cd88:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000cd8c:	48 02       	ld.w %d2,[%a15]0
8000cd8e:	37 02 67 28 	extr.u %d2,%d2,16,7
8000cd92:	3c f0       	j 8000cd72 <osEE_tc_stm_set_clockpersec+0x9c>

8000cd94 <osEE_tc_stm_set_sr1>:
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000cd94:	4d c0 e1 3f 	mfcr %d3,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000cd98:	91 00 00 f7 	movh.a %a15,28672
8000cd9c:	19 f2 60 24 	ld.w %d2,[%a15]17568 <700044a0 <osEE_tc_stm_freq_khz>>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000cda0:	7b 20 06 61 	movh %d6,4194
8000cda4:	1b 36 dd 64 	addi %d6,%d6,19923
8000cda8:	73 62 68 60 	mul.u %e6,%d2,%d6
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000cdac:	3b 80 3e 10 	mov %d1,1000
8000cdb0:	37 03 48 00 	extr %d0,%d3,0,8
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000cdb4:	8f a7 1f f0 	sh %d15,%d7,-6
8000cdb8:	e2 4f       	mul %d15,%d4
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000cdba:	7f 12 0e 80 	jge.u %d2,%d1,8000cdd6 <osEE_tc_stm_set_sr1+0x42>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000cdbe:	7b 20 06 f1 	movh %d15,4194
8000cdc2:	1b 3f dd f4 	addi %d15,%d15,19923
8000cdc6:	73 24 0a 60 	mul %d6,%d4,%d2
8000cdca:	73 f6 68 60 	mul.u %e6,%d6,%d15
8000cdce:	8f a7 1f f0 	sh %d15,%d7,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
8000cdd2:	7f 14 1c 80 	jge.u %d4,%d1,8000ce0a <osEE_tc_stm_set_sr1+0x76>
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
8000cdd6:	8f 30 00 21 	and %d2,%d0,3
8000cdda:	9b 02 0f 60 	addih %d6,%d2,240
8000cdde:	8f 86 00 60 	sh %d6,%d6,8
8000cde2:	60 6f       	mov.a %a15,%d6
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000cde4:	0f 0f b0 41 	clz %d4,%d15
8000cde8:	48 46       	ld.w %d6,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
8000cdea:	42 6f       	add %d15,%d6
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
8000cdec:	68 df       	st.w [%a15]52,%d15
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
8000cdee:	df 05 18 80 	jne %d5,0,8000ce1e <osEE_tc_stm_set_sr1+0x8a>
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
8000cdf2:	4c ff       	ld.w %d15,[%a15]60
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
8000cdf4:	06 32       	sh %d2,3
8000cdf6:	60 22       	mov.a %a2,%d2
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
8000cdf8:	8f 0f c1 f1 	andn %d15,%d15,16
8000cdfc:	68 ff       	st.w [%a15]60,%d15
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
8000cdfe:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000ce02:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000ce06:	68 05       	st.w [%a15]0,%d5
8000ce08:	00 90       	ret 
static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
8000ce0a:	7b 20 06 61 	movh %d6,4194
8000ce0e:	1b 36 dd 64 	addi %d6,%d6,19923
8000ce12:	73 64 68 60 	mul.u %e6,%d4,%d6
8000ce16:	8f a7 1f f0 	sh %d15,%d7,-6
8000ce1a:	e2 2f       	mul %d15,%d2
8000ce1c:	3c dd       	j 8000cdd6 <osEE_tc_stm_set_sr1+0x42>
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000ce1e:	4c fe       	ld.w %d15,[%a15]56
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
8000ce20:	8b f4 01 41 	rsub %d4,%d4,31
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000ce24:	b7 0f 05 fc 	insert %d15,%d15,0,24,5
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
8000ce28:	06 32       	sh %d2,3
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000ce2a:	68 ef       	st.w [%a15]56,%d15
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
8000ce2c:	4c fe       	ld.w %d15,[%a15]56
8000ce2e:	60 22       	mov.a %a2,%d2
8000ce30:	37 4f 05 48 	insert %d4,%d15,%d4,16,5
8000ce34:	b7 85 99 53 	insert %d5,%d5,8,7,25
8000ce38:	68 e4       	st.w [%a15]56,%d4
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
8000ce3a:	4c ff       	ld.w %d15,[%a15]60
8000ce3c:	8f 33 00 31 	and %d3,%d3,3
8000ce40:	96 40       	or %d15,64
8000ce42:	68 ff       	st.w [%a15]60,%d15
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
8000ce44:	4c ff       	ld.w %d15,[%a15]60
8000ce46:	8f b3 00 30 	sh %d3,%d3,11
8000ce4a:	96 10       	or %d15,16
8000ce4c:	68 ff       	st.w [%a15]60,%d15
8000ce4e:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000ce52:	11 4f 00 ff 	addih.a %a15,%a15,61444
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000ce56:	a6 35       	or %d5,%d3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000ce58:	68 05       	st.w [%a15]0,%d5
8000ce5a:	00 90       	ret 

8000ce5c <osEE_tc_stm_set_sr1_next_match>:
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000ce5c:	4d c0 e1 6f 	mfcr %d6,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000ce60:	91 00 00 f7 	movh.a %a15,28672
8000ce64:	19 ff 60 24 	ld.w %d15,[%a15]17568 <700044a0 <osEE_tc_stm_freq_khz>>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000ce68:	7b 20 06 21 	movh %d2,4194
8000ce6c:	1b 32 dd 24 	addi %d2,%d2,19923
8000ce70:	73 2f 68 20 	mul.u %e2,%d15,%d2
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000ce74:	3b 80 3e 50 	mov %d5,1000
8000ce78:	37 06 48 60 	extr %d6,%d6,0,8
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000ce7c:	8f a3 1f 20 	sh %d2,%d3,-6
8000ce80:	e2 42       	mul %d2,%d4
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000ce82:	7f 5f 0e 80 	jge.u %d15,%d5,8000ce9e <osEE_tc_stm_set_sr1_next_match+0x42>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000ce86:	7b 20 06 31 	movh %d3,4194
8000ce8a:	73 f4 0a 20 	mul %d2,%d4,%d15
8000ce8e:	1b 33 dd 34 	addi %d3,%d3,19923
8000ce92:	73 32 68 20 	mul.u %e2,%d2,%d3
8000ce96:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
8000ce9a:	7f 54 0d 80 	jge.u %d4,%d5,8000ceb4 <osEE_tc_stm_set_sr1_next_match+0x58>
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
8000ce9e:	8f 36 00 61 	and %d6,%d6,3
8000cea2:	9b 06 0f 60 	addih %d6,%d6,240
8000cea6:	8f 86 00 60 	sh %d6,%d6,8
8000ceaa:	60 6f       	mov.a %a15,%d6
8000ceac:	4c fd       	ld.w %d15,[%a15]52
8000ceae:	42 f2       	add %d2,%d15
8000ceb0:	68 d2       	st.w [%a15]52,%d2
8000ceb2:	00 90       	ret 
static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
8000ceb4:	7b 20 06 21 	movh %d2,4194
8000ceb8:	1b 32 dd 24 	addi %d2,%d2,19923
8000cebc:	73 24 68 40 	mul.u %e4,%d4,%d2
8000cec0:	8f a5 1f 20 	sh %d2,%d5,-6
8000cec4:	e2 f2       	mul %d2,%d15
8000cec6:	3c ec       	j 8000ce9e <osEE_tc_stm_set_sr1_next_match+0x42>

8000cec8 <osEE_tc_delay>:
8000cec8:	4d c0 e1 ff 	mfcr %d15,$core_id
8000cecc:	16 03       	and %d15,3
8000cece:	9b 0f 0f f0 	addih %d15,%d15,240
8000ced2:	8f 8f 00 f0 	sh %d15,%d15,8
8000ced6:	60 f2       	mov.a %a2,%d15
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000ced8:	7b 20 06 61 	movh %d6,4194
8000cedc:	d9 2f 10 00 	lea %a15,[%a2]16
8000cee0:	19 23 10 00 	ld.w %d3,[%a2]16
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000cee4:	91 00 00 27 	movh.a %a2,28672
8000cee8:	19 22 60 24 	ld.w %d2,[%a2]17568 <700044a0 <osEE_tc_stm_freq_khz>>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000ceec:	1b 36 dd 64 	addi %d6,%d6,19923
8000cef0:	73 62 68 60 	mul.u %e6,%d2,%d6
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000cef4:	3b 80 3e 50 	mov %d5,1000
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000cef8:	8f a7 1f f0 	sh %d15,%d7,-6
8000cefc:	e2 4f       	mul %d15,%d4
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000cefe:	7f 52 17 80 	jge.u %d2,%d5,8000cf2c <osEE_tc_delay+0x64>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000cf02:	7b 20 06 f1 	movh %d15,4194
8000cf06:	1b 3f dd f4 	addi %d15,%d15,19923
8000cf0a:	73 24 0a 60 	mul %d6,%d4,%d2
8000cf0e:	73 f6 68 60 	mul.u %e6,%d6,%d15
8000cf12:	8f a7 1f f0 	sh %d15,%d7,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
8000cf16:	3f 54 0b 80 	jlt.u %d4,%d5,8000cf2c <osEE_tc_delay+0x64>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
8000cf1a:	7b 20 06 f1 	movh %d15,4194
8000cf1e:	1b 3f dd f4 	addi %d15,%d15,19923
8000cf22:	73 f4 68 40 	mul.u %e4,%d4,%d15
8000cf26:	8f a5 1f f0 	sh %d15,%d5,-6
8000cf2a:	e2 2f       	mul %d15,%d2
8000cf2c:	48 02       	ld.w %d2,[%a15]0
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
8000cf2e:	a2 32       	sub %d2,%d3
8000cf30:	3f f2 fe ff 	jlt.u %d2,%d15,8000cf2c <osEE_tc_delay+0x64>
    ; /* Wait */
  }
}
8000cf34:	00 90       	ret 

8000cf36 <osEE_tc_isr2_wrapper>:
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
8000cf36:	6d 00 75 06 	call 8000dc20 <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
8000cf3a:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000cf3e:	00 80       	rfe 
8000cf40:	00 90       	ret 
	...

8000cf44 <DisableAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cf44:	91 00 00 f8 	movh.a %a15,32768
8000cf48:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000cf4c:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
8000cf50:	82 1f       	mov %d15,1
8000cf52:	e9 ff 1e 00 	st.b [%a15]30,%d15
8000cf56:	00 90       	ret 

8000cf58 <EnableAllInterrupts>:
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cf58:	91 00 00 f8 	movh.a %a15,32768
8000cf5c:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
8000cf60:	39 ff 1e 00 	ld.bu %d15,[%a15]30 <80000554 <osEE_cdb_var>>
8000cf64:	6e 06       	jz %d15,8000cf70 <EnableAllInterrupts+0x18>
    p_ccb->d_isr_all_cnt = 0U;
8000cf66:	82 0f       	mov %d15,0
8000cf68:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000cf6c:	0d 00 00 03 	enable 
8000cf70:	00 90       	ret 

8000cf72 <SuspendAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cf72:	91 00 00 f8 	movh.a %a15,32768
8000cf76:	d9 f2 54 50 	lea %a2,[%a15]1364 <80000554 <osEE_cdb_var>>
8000cf7a:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
8000cf7e:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <80000554 <osEE_cdb_var>>
8000cf82:	6e 09       	jz %d15,8000cf94 <SuspendAllInterrupts+0x22>
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
    ++p_ccb->s_isr_all_cnt;
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
8000cf84:	8b ff 0f 22 	eq %d2,%d15,255
8000cf88:	df 02 11 80 	jne %d2,0,8000cfaa <SuspendAllInterrupts+0x38>
    ++p_ccb->s_isr_all_cnt;
8000cf8c:	c2 1f       	add %d15,1
8000cf8e:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000cf92:	00 90       	ret 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cf94:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000cf98:	0d 00 40 03 	disable 
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
8000cf9c:	68 5f       	st.w [%a15]20,%d15
    ++p_ccb->s_isr_all_cnt;
8000cf9e:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000cfa2:	c2 1f       	add %d15,1
8000cfa4:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000cfa8:	00 90       	ret 
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000cfaa:	82 32       	mov %d2,3
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000cfac:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000cfb0:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000cfb4:	3b 90 01 20 	mov %d2,25
8000cfb8:	e9 f2 12 00 	st.b [%a15]18,%d2

  if (os_status == OSEE_KERNEL_STARTED) {
8000cfbc:	1e 22       	jeq %d15,2,8000cfc0 <SuspendAllInterrupts+0x4e>
8000cfbe:	3c 00       	j 8000cfbe <SuspendAllInterrupts+0x4c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000cfc0:	99 24 04 00 	ld.a %a4,[%a2]4
8000cfc4:	6d 00 c5 08 	call 8000e14e <osEE_idle_task_terminate>
8000cfc8:	3c fb       	j 8000cfbe <SuspendAllInterrupts+0x4c>

8000cfca <ResumeAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cfca:	91 00 00 f8 	movh.a %a15,32768
8000cfce:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
8000cfd2:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <80000554 <osEE_cdb_var>>
8000cfd6:	6e 0b       	jz %d15,8000cfec <ResumeAllInterrupts+0x22>
    --p_ccb->s_isr_all_cnt;
8000cfd8:	c2 ff       	add %d15,-1
8000cfda:	16 ff       	and %d15,255
8000cfdc:	e9 ff 1c 00 	st.b [%a15]28,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
8000cfe0:	ee 06       	jnz %d15,8000cfec <ResumeAllInterrupts+0x22>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cfe2:	4c f5       	ld.w %d15,[%a15]20
8000cfe4:	cd cf e2 0f 	mtcr $icr,%d15
8000cfe8:	0d 00 c0 04 	isync 
8000cfec:	00 90       	ret 

8000cfee <SuspendOSInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cfee:	91 00 00 f8 	movh.a %a15,32768
8000cff2:	d9 f2 54 50 	lea %a2,[%a15]1364 <80000554 <osEE_cdb_var>>
8000cff6:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
8000cffa:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <80000554 <osEE_cdb_var>>
8000cffe:	ee 15       	jnz %d15,8000d028 <SuspendOSInterrupts+0x3a>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d000:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d004:	8f ff 0f 21 	and %d2,%d15,255
8000d008:	ff 32 09 80 	jge.u %d2,3,8000d01a <SuspendOSInterrupts+0x2c>
    OsEE_icr icr_temp = icr;
8000d00c:	02 f2       	mov %d2,%d15
8000d00e:	b7 32 08 20 	insert %d2,%d2,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d012:	cd c2 e2 0f 	mtcr $icr,%d2
8000d016:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
8000d01a:	68 6f       	st.w [%a15]24,%d15
    ++p_ccb->s_isr_os_cnt;
8000d01c:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000d020:	c2 1f       	add %d15,1
8000d022:	e9 ff 1d 00 	st.b [%a15]29,%d15
8000d026:	00 90       	ret 
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
8000d028:	8b ff 0f 22 	eq %d2,%d15,255
8000d02c:	f6 25       	jnz %d2,8000d036 <SuspendOSInterrupts+0x48>
    ++p_ccb->s_isr_os_cnt;
8000d02e:	c2 1f       	add %d15,1
8000d030:	e9 ff 1d 00 	st.b [%a15]29,%d15
8000d034:	00 90       	ret 
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000d036:	82 32       	mov %d2,3
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000d038:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000d03c:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000d040:	3b 90 01 20 	mov %d2,25
8000d044:	e9 f2 12 00 	st.b [%a15]18,%d2

  if (os_status == OSEE_KERNEL_STARTED) {
8000d048:	1e 22       	jeq %d15,2,8000d04c <SuspendOSInterrupts+0x5e>
8000d04a:	3c 00       	j 8000d04a <SuspendOSInterrupts+0x5c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000d04c:	99 24 04 00 	ld.a %a4,[%a2]4
8000d050:	6d 00 7f 08 	call 8000e14e <osEE_idle_task_terminate>
8000d054:	3c fb       	j 8000d04a <SuspendOSInterrupts+0x5c>

8000d056 <ResumeOSInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000d056:	91 00 00 f8 	movh.a %a15,32768
8000d05a:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
8000d05e:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <80000554 <osEE_cdb_var>>
8000d062:	6e 15       	jz %d15,8000d08c <ResumeOSInterrupts+0x36>
    --p_ccb->s_isr_os_cnt;
8000d064:	c2 ff       	add %d15,-1
8000d066:	16 ff       	and %d15,255
8000d068:	e9 ff 1d 00 	st.b [%a15]29,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
8000d06c:	ee 10       	jnz %d15,8000d08c <ResumeOSInterrupts+0x36>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
8000d06e:	48 62       	ld.w %d2,[%a15]24
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d070:	4d c0 e2 ff 	mfcr %d15,$icr
8000d074:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d078:	8f f2 0f 21 	and %d2,%d2,255
8000d07c:	5f 23 08 00 	jeq %d3,%d2,8000d08c <ResumeOSInterrupts+0x36>
8000d080:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d084:	cd cf e2 0f 	mtcr $icr,%d15
8000d088:	0d 00 c0 04 	isync 
8000d08c:	00 90       	ret 

8000d08e <StartOS>:
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000d08e:	91 00 00 c8 	movh.a %a12,32768
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
8000d092:	02 49       	mov %d9,%d4
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000d094:	99 cf 54 50 	ld.a %a15,[%a12]1364 <80000554 <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d098:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d09c:	8f ff 0f 81 	and %d8,%d15,255
8000d0a0:	ff 38 08 80 	jge.u %d8,3,8000d0b0 <StartOS+0x22>
8000d0a4:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d0a8:	cd cf e2 0f 	mtcr $icr,%d15
8000d0ac:	0d 00 c0 04 	isync 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000d0b0:	39 ff 10 00 	ld.bu %d15,[%a15]16
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
8000d0b4:	82 13       	mov %d3,1
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000d0b6:	6e 0f       	jz %d15,8000d0d4 <StartOS+0x46>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d0b8:	4d c0 e2 ff 	mfcr %d15,$icr
8000d0bc:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d0c0:	5f 28 08 00 	jeq %d8,%d2,8000d0d0 <StartOS+0x42>
8000d0c4:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d0c8:	cd cf e2 0f 	mtcr $icr,%d15
8000d0cc:	0d 00 c0 04 	isync 
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
8000d0d0:	02 32       	mov %d2,%d3
8000d0d2:	00 90       	ret 
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
8000d0d4:	6d 00 4e 08 	call 8000e170 <osEE_cpu_startos>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
8000d0d8:	3b 80 01 30 	mov %d3,24
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
8000d0dc:	df 02 ee 7f 	jeq %d2,0,8000d0b8 <StartOS+0x2a>
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
8000d0e0:	82 1f       	mov %d15,1
8000d0e2:	e9 ff 10 00 	st.b [%a15]16,%d15
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
8000d0e6:	d9 cc 54 50 	lea %a12,[%a12]1364
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
    p_ccb->app_mode                 = real_mode;
8000d0ea:	e9 f9 11 00 	st.b [%a15]17,%d9
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
8000d0ee:	99 cc 04 00 	ld.a %a12,[%a12]4
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
/* Touch unused parameter */
  ((void)p_ccb);
  StartupHook();
8000d0f2:	6d ff 16 f7 	call 8000bf1e <StartupHook>
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
8000d0f6:	39 ff 10 00 	ld.bu %d15,[%a15]16
8000d0fa:	5e 14       	jne %d15,1,8000d102 <StartOS+0x74>
      p_ccb->os_status = OSEE_KERNEL_STARTED;
8000d0fc:	82 2f       	mov %d15,2
8000d0fe:	e9 ff 10 00 	st.b [%a15]16,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000d102:	39 ff 10 00 	ld.bu %d15,[%a15]16
8000d106:	1e 24       	jeq %d15,2,8000d10e <StartOS+0x80>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000d108:	0d 00 40 03 	disable 
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
8000d10c:	3c 00       	j 8000d10c <StartOS+0x7e>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
8000d10e:	99 c5 04 00 	ld.a %a5,[%a12]4
8000d112:	40 c4       	mov.aa %a4,%a12
8000d114:	40 56       	mov.aa %a6,%a5
8000d116:	6d 00 9b 08 	call 8000e24c <osEE_hal_save_ctx_and_ready2stacked>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
8000d11a:	40 c4       	mov.aa %a4,%a12
8000d11c:	6d 00 66 05 	call 8000dbe8 <osEE_task_end>
8000d120:	0d 00 40 03 	disable 
8000d124:	3c f4       	j 8000d10c <StartOS+0x7e>

8000d126 <GetActiveApplicationMode>:
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
8000d126:	91 00 00 f8 	movh.a %a15,32768
8000d12a:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
8000d12e:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
8000d132:	39 ff 10 00 	ld.bu %d15,[%a15]16
8000d136:	ee 02       	jnz %d15,8000d13a <GetActiveApplicationMode+0x14>
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
8000d138:	00 90       	ret 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
    app_mode = p_ccb->app_mode;
8000d13a:	39 f2 11 00 	ld.bu %d2,[%a15]17
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
8000d13e:	00 90       	ret 

8000d140 <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
8000d140:	91 00 00 f8 	movh.a %a15,32768
8000d144:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d148:	48 22       	ld.w %d2,[%a15]8
    ev = E_OS_ID;
8000d14a:	82 3f       	mov %d15,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d14c:	3f 24 04 80 	jlt.u %d4,%d2,8000d154 <ActivateTask+0x14>
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d150:	02 f2       	mov %d2,%d15
8000d152:	00 90       	ret 
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d154:	c8 12       	ld.a %a2,[%a15]4
8000d156:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000d15a:	d4 2c       	ld.a %a12,[%a2]

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000d15c:	39 c2 14 00 	ld.bu %d2,[%a12]20
8000d160:	ff 22 f8 ff 	jge.u %d2,2,8000d150 <ActivateTask+0x10>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d164:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d168:	8f ff 0f 81 	and %d8,%d15,255
8000d16c:	ff 38 08 80 	jge.u %d8,3,8000d17c <ActivateTask+0x3c>
8000d170:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d174:	cd cf e2 0f 	mtcr $icr,%d15
8000d178:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
8000d17c:	40 c4       	mov.aa %a4,%a12
8000d17e:	6d 00 29 05 	call 8000dbd0 <osEE_task_activated>
8000d182:	02 2f       	mov %d15,%d2

      if (ev == E_OK) {
8000d184:	76 2e       	jz %d2,8000d1a0 <ActivateTask+0x60>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d186:	4d c0 e2 2f 	mfcr %d2,$icr
8000d18a:	8f f2 0f 31 	and %d3,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d18e:	5f 83 e1 7f 	jeq %d3,%d8,8000d150 <ActivateTask+0x10>
8000d192:	37 82 08 20 	insert %d2,%d2,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d196:	cd c2 e2 0f 	mtcr $icr,%d2
8000d19a:	0d 00 c0 04 	isync 
8000d19e:	3c d9       	j 8000d150 <ActivateTask+0x10>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
8000d1a0:	40 f4       	mov.aa %a4,%a15
8000d1a2:	40 c5       	mov.aa %a5,%a12
8000d1a4:	6d 00 4d 05 	call 8000dc3e <osEE_scheduler_task_activated>
8000d1a8:	3c ef       	j 8000d186 <ActivateTask+0x46>

8000d1aa <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
8000d1aa:	91 00 00 f8 	movh.a %a15,32768
8000d1ae:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
8000d1b2:	91 00 00 c8 	movh.a %a12,32768
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d1b6:	4c f2       	ld.w %d15,[%a15]8
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
8000d1b8:	99 c4 54 50 	ld.a %a4,[%a12]1364 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000d1bc:	d4 43       	ld.a %a3,[%a4]
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000d1be:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d1c0:	3f f4 03 80 	jlt.u %d4,%d15,8000d1c6 <ChainTask+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
8000d1c4:	00 90       	ret 
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d1c6:	c8 12       	ld.a %a2,[%a15]4
8000d1c8:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000d1cc:	d4 2d       	ld.a %a13,[%a2]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000d1ce:	39 df 14 00 	ld.bu %d15,[%a13]20
8000d1d2:	ff 2f f9 ff 	jge.u %d15,2,8000d1c4 <ChainTask+0x1a>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
8000d1d6:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000d1da:	6e 09       	jz %d15,8000d1ec <ChainTask+0x42>
        p_ccb->s_isr_all_cnt = 0U;
8000d1dc:	82 0f       	mov %d15,0
8000d1de:	e9 4f 1c 00 	st.b [%a4]28,%d15
8000d1e2:	4c 45       	ld.w %d15,[%a4]20
8000d1e4:	cd cf e2 0f 	mtcr $icr,%d15
8000d1e8:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000d1ec:	39 4f 1e 00 	ld.bu %d15,[%a4]30
8000d1f0:	6e 06       	jz %d15,8000d1fc <ChainTask+0x52>
        p_ccb->d_isr_all_cnt = 0U;
8000d1f2:	82 0f       	mov %d15,0
8000d1f4:	e9 4f 1e 00 	st.b [%a4]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000d1f8:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d1fc:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d200:	8f ff 0f 81 	and %d8,%d15,255
8000d204:	ff 38 08 80 	jge.u %d8,3,8000d214 <ChainTask+0x6a>
8000d208:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d20c:	cd cf e2 0f 	mtcr $icr,%d15
8000d210:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
8000d214:	7d 3d 14 00 	jeq.a %a13,%a3,8000d23c <ChainTask+0x92>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
8000d218:	40 d4       	mov.aa %a4,%a13
8000d21a:	6d 00 db 04 	call 8000dbd0 <osEE_task_activated>
        if (ev == E_OK) {
8000d21e:	df 02 19 00 	jeq %d2,0,8000d250 <ChainTask+0xa6>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d222:	4d c0 e2 ff 	mfcr %d15,$icr
8000d226:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d22a:	5f 83 cd 7f 	jeq %d3,%d8,8000d1c4 <ChainTask+0x1a>
8000d22e:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d232:	cd cf e2 0f 	mtcr $icr,%d15
8000d236:	0d 00 c0 04 	isync 
8000d23a:	00 90       	ret 

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
8000d23c:	cc d3       	ld.a %a15,[%a13]12
8000d23e:	82 5f       	mov %d15,5
8000d240:	28 2f       	st.b [%a15]2,%d15
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000d242:	99 cf 54 50 	ld.a %a15,[%a12]1364
8000d246:	c8 0f       	ld.a %a15,[%a15]0
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
8000d248:	c8 14       	ld.a %a4,[%a15]4
8000d24a:	a0 05       	mov.a %a5,0
8000d24c:	1d 00 37 08 	j 8000e2ba <osEE_hal_terminate_ctx>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
        if (ev == E_OK) {
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
8000d250:	40 f4       	mov.aa %a4,%a15
8000d252:	40 d5       	mov.aa %a5,%a13
8000d254:	6d 00 27 05 	call 8000dca2 <osEE_scheduler_task_insert>
8000d258:	3c f5       	j 8000d242 <ChainTask+0x98>

8000d25a <TerminateTask>:
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
8000d25a:	91 00 00 f8 	movh.a %a15,32768
8000d25e:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000d262:	c8 02       	ld.a %a2,[%a15]0
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
8000d264:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <80000554 <osEE_cdb_var>>
8000d268:	6e 09       	jz %d15,8000d27a <TerminateTask+0x20>
        p_ccb->s_isr_all_cnt = 0U;
8000d26a:	82 0f       	mov %d15,0
8000d26c:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000d270:	4c f5       	ld.w %d15,[%a15]20
8000d272:	cd cf e2 0f 	mtcr $icr,%d15
8000d276:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000d27a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000d27e:	6e 06       	jz %d15,8000d28a <TerminateTask+0x30>
        p_ccb->d_isr_all_cnt = 0U;
8000d280:	82 0f       	mov %d15,0
8000d282:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000d286:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d28a:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d28e:	8f ff 0f 21 	and %d2,%d15,255
8000d292:	ff 32 08 80 	jge.u %d2,3,8000d2a2 <TerminateTask+0x48>
8000d296:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d29a:	cd cf e2 0f 	mtcr $icr,%d15
8000d29e:	0d 00 c0 04 	isync 
8000d2a2:	99 24 04 00 	ld.a %a4,[%a2]4
8000d2a6:	a0 05       	mov.a %a5,0
8000d2a8:	1d 00 09 08 	j 8000e2ba <osEE_hal_terminate_ctx>

8000d2ac <Schedule>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
8000d2ac:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
8000d2b0:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
8000d2b4:	c8 0f       	ld.a %a15,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
8000d2b6:	c8 3c       	ld.a %a12,[%a15]12
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
8000d2b8:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <80000554 <osEE_cdb_var>>
8000d2bc:	39 c2 01 00 	ld.bu %d2,[%a12]1 <80000554 <osEE_cdb_var>>
8000d2c0:	5f f2 04 00 	jeq %d2,%d15,8000d2c8 <Schedule+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000d2c4:	82 02       	mov %d2,0
8000d2c6:	00 90       	ret 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d2c8:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d2cc:	8f ff 0f 81 	and %d8,%d15,255
8000d2d0:	bf 38 1c 80 	jlt.u %d8,3,8000d308 <Schedule+0x5c>
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
8000d2d4:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
8000d2d8:	91 00 00 48 	movh.a %a4,32768
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
8000d2dc:	2c c1       	st.b [%a12]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
8000d2de:	d9 44 70 40 	lea %a4,[%a4]1328 <80000530 <osEE_kdb_var>>
8000d2e2:	6d 00 5e 05 	call 8000dd9e <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
8000d2e6:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000d2ea:	2c c1       	st.b [%a12]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d2ec:	4d c0 e2 ff 	mfcr %d15,$icr
8000d2f0:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d2f4:	5f 82 e8 7f 	jeq %d2,%d8,8000d2c4 <Schedule+0x18>
8000d2f8:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d2fc:	cd cf e2 0f 	mtcr $icr,%d15
8000d300:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000d304:	82 02       	mov %d2,0
8000d306:	00 90       	ret 
8000d308:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
8000d30c:	cd cf e2 0f 	mtcr $icr,%d15
8000d310:	0d 00 c0 04 	isync 
8000d314:	3c e0       	j 8000d2d4 <Schedule+0x28>

8000d316 <GetResource>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000d316:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000d31a:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
8000d31e:	c8 04       	ld.a %a4,[%a15]0
8000d320:	91 00 00 f8 	movh.a %a15,32768
8000d324:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000d328:	4c f4       	ld.w %d15,[%a15]16
    ev = E_OS_ID;
8000d32a:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000d32c:	3f f4 03 80 	jlt.u %d4,%d15,8000d332 <GetResource+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
8000d330:	00 90       	ret 
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
8000d332:	c8 3f       	ld.a %a15,[%a15]12
8000d334:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d338:	c8 02       	ld.a %a2,[%a15]0
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
8000d33a:	cc 43       	ld.a %a15,[%a4]12
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
8000d33c:	d4 23       	ld.a %a3,[%a2]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
    CONST(TaskPrio, AUTOMATIC)
      reso_prio     = p_reso_db->prio;
8000d33e:	39 23 04 00 	ld.bu %d3,[%a2]4
    CONST(TaskPrio, AUTOMATIC)
      current_prio  = p_curr_tcb->current_prio;
8000d342:	08 14       	ld.bu %d4,[%a15]1
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d344:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d348:	8f f2 0f 51 	and %d5,%d2,255
8000d34c:	02 2f       	mov %d15,%d2
8000d34e:	ff 35 09 80 	jge.u %d5,3,8000d360 <GetResource+0x4a>
8000d352:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d356:	cd cf e2 0f 	mtcr $icr,%d15
8000d35a:	0d 00 c0 04 	isync 
8000d35e:	02 2f       	mov %d15,%d2
      ev = E_OS_CORE;
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
8000d360:	3f 34 18 80 	jlt.u %d4,%d3,8000d390 <GetResource+0x7a>
        p_curr_tcb->current_prio = reso_prio;
        flags = osEE_hal_prepare_ipl(flags, reso_prio);
      }

      p_reso_cb->p_owner    = p_curr;
8000d364:	b5 34 08 00 	st.a [%a3]8,%a4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d368:	4d c0 e2 2f 	mfcr %d2,$icr
8000d36c:	8f f2 0f 31 	and %d3,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d370:	16 ff       	and %d15,255
8000d372:	5f f3 08 00 	jeq %d3,%d15,8000d382 <GetResource+0x6c>
8000d376:	37 f2 08 20 	insert %d2,%d2,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d37a:	cd c2 e2 0f 	mtcr $icr,%d2
8000d37e:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
8000d382:	4c f1       	ld.w %d15,[%a15]4
      p_reso_cb->prev_prio  = current_prio;
8000d384:	e9 34 04 00 	st.b [%a3]4,%d4

      p_reso_cb->p_owner    = p_curr;

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
8000d388:	6c 30       	st.w [%a3]0,%d15
      p_reso_cb->prev_prio  = current_prio;
      p_curr_tcb->p_last_m  = p_reso_db;
8000d38a:	e8 12       	st.a [%a15]4,%a2

      ev = E_OK;
8000d38c:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
8000d38e:	00 90       	ret 
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000d390:	8f f3 07 f1 	and %d15,%d3,127
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000d394:	8f f2 cf 51 	andn %d5,%d2,255

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000d398:	37 03 48 60 	extr %d6,%d3,0,8
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000d39c:	c2 1f       	add %d15,1
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000d39e:	8b f3 2f 72 	ne %d7,%d3,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000d3a2:	a6 5f       	or %d15,%d5
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000d3a4:	8f 02 d0 21 	andn %d2,%d2,256
8000d3a8:	2b 2f 40 f7 	sel %d15,%d7,%d15,%d2
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000d3ac:	8b 06 40 62 	lt %d6,%d6,0
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
        p_curr_tcb->current_prio = reso_prio;
8000d3b0:	28 13       	st.b [%a15]1,%d3
8000d3b2:	2b 5f 40 f6 	sel %d15,%d6,%d15,%d5
8000d3b6:	3c d7       	j 8000d364 <GetResource+0x4e>

8000d3b8 <ReleaseResource>:
FUNC(StatusType, OS_CODE)
  ReleaseResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
8000d3b8:	91 00 00 48 	movh.a %a4,32768
8000d3bc:	d9 44 70 40 	lea %a4,[%a4]1328 <80000530 <osEE_kdb_var>>
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000d3c0:	91 00 00 f8 	movh.a %a15,32768
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000d3c4:	4c 44       	ld.w %d15,[%a4]16
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_curr = p_ccb->p_curr;
8000d3c6:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
8000d3ca:	c8 03       	ld.a %a3,[%a15]0
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
8000d3cc:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000d3ce:	3f f4 03 80 	jlt.u %d4,%d15,8000d3d4 <ReleaseResource+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
8000d3d2:	00 90       	ret 
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
8000d3d4:	99 42 0c 00 	ld.a %a2,[%a4]12
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
8000d3d8:	cc 33       	ld.a %a15,[%a3]12
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
8000d3da:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, TYPEDEF)
      p_reso_cb   = p_reso_db->p_cb;
8000d3de:	d4 22       	ld.a %a2,[%a2]
8000d3e0:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d3e2:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d3e6:	8f f2 0f f1 	and %d15,%d2,255
8000d3ea:	bf 3f 2e 80 	jlt.u %d15,3,8000d446 <ReleaseResource+0x8e>
    {
      VAR(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      /* Pop the Resources head */
      p_curr_tcb->p_last_m = p_curr_tcb->p_last_m->p_cb->p_next;
8000d3ee:	c8 15       	ld.a %a5,[%a15]4
8000d3f0:	d4 55       	ld.a %a5,[%a5]
8000d3f2:	4c 50       	ld.w %d15,[%a5]0
8000d3f4:	68 1f       	st.w [%a15]4,%d15

      if (p_curr_tcb->p_last_m != NULL) {
8000d3f6:	6e 30       	jz %d15,8000d456 <ReleaseResource+0x9e>
        CONST(TaskPrio, AUTOMATIC)
          prev_prio = p_reso_cb->prev_prio;
8000d3f8:	0c 24       	ld.bu %d15,[%a2]4
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;

        p_curr_tcb->current_prio = dispatch_prio;
8000d3fa:	28 1f       	st.b [%a15]1,%d15
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000d3fc:	8b ff 2f 52 	ne %d5,%d15,255

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000d400:	37 0f 48 40 	extr %d4,%d15,0,8
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000d404:	16 7f       	and %d15,127
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000d406:	8f f2 cf 31 	andn %d3,%d2,255
8000d40a:	c2 1f       	add %d15,1
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000d40c:	a6 3f       	or %d15,%d3
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000d40e:	8f 02 d0 21 	andn %d2,%d2,256
8000d412:	2b 2f 40 f5 	sel %d15,%d5,%d15,%d2
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_reso_cb->p_owner = NULL;
8000d416:	82 02       	mov %d2,0
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000d418:	8b 04 40 42 	lt %d4,%d4,0
8000d41c:	59 22 08 00 	st.w [%a2]8,%d2
8000d420:	2b 3f 40 f4 	sel %d15,%d4,%d15,%d3

      /* Preemption point */
      (void)osEE_scheduler_task_preemption_point(p_kdb);
8000d424:	6d 00 bd 04 	call 8000dd9e <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d428:	4d c0 e2 2f 	mfcr %d2,$icr
8000d42c:	8f f2 0f 31 	and %d3,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d430:	16 ff       	and %d15,255
8000d432:	5f f3 08 00 	jeq %d3,%d15,8000d442 <ReleaseResource+0x8a>
8000d436:	37 f2 08 20 	insert %d2,%d2,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d43a:	cd c2 e2 0f 	mtcr $icr,%d2
8000d43e:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      ev = E_OK;
8000d442:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
8000d444:	00 90       	ret 
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
8000d446:	02 2f       	mov %d15,%d2
8000d448:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d44c:	cd cf e2 0f 	mtcr $icr,%d15
8000d450:	0d 00 c0 04 	isync 
8000d454:	3c cd       	j 8000d3ee <ReleaseResource+0x36>

        p_curr_tcb->current_prio = prev_prio;
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;
8000d456:	39 3f 1d 00 	ld.bu %d15,[%a3]29
8000d45a:	3c d0       	j 8000d3fa <ReleaseResource+0x42>

8000d45c <ShutdownOS>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000d45c:	91 00 00 f8 	movh.a %a15,32768
8000d460:	99 f2 54 50 	ld.a %a2,[%a15]1364 <80000554 <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d464:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d468:	8f ff 0f 21 	and %d2,%d15,255
8000d46c:	ff 32 08 80 	jge.u %d2,3,8000d47c <ShutdownOS+0x20>
8000d470:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d474:	cd cf e2 0f 	mtcr $icr,%d15
8000d478:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000d47c:	39 2f 10 00 	ld.bu %d15,[%a2]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
8000d480:	c2 ff       	add %d15,-1
8000d482:	bf 2f 10 80 	jlt.u %d15,2,8000d4a2 <ShutdownOS+0x46>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d486:	4d c0 e2 ff 	mfcr %d15,$icr
8000d48a:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d48e:	5f 23 08 00 	jeq %d3,%d2,8000d49e <ShutdownOS+0x42>
8000d492:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d496:	cd cf e2 0f 	mtcr $icr,%d15
8000d49a:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
8000d49e:	82 72       	mov %d2,7
8000d4a0:	00 90       	ret 
8000d4a2:	d9 f2 54 50 	lea %a2,[%a15]1364
8000d4a6:	99 ff 54 50 	ld.a %a15,[%a15]1364
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000d4aa:	82 32       	mov %d2,3
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000d4ac:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000d4b0:	e9 f4 12 00 	st.b [%a15]18,%d4
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000d4b4:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;

  if (os_status == OSEE_KERNEL_STARTED) {
8000d4b8:	1e 22       	jeq %d15,2,8000d4bc <ShutdownOS+0x60>
8000d4ba:	3c 00       	j 8000d4ba <ShutdownOS+0x5e>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000d4bc:	99 24 04 00 	ld.a %a4,[%a2]4
8000d4c0:	6d 00 47 06 	call 8000e14e <osEE_idle_task_terminate>
8000d4c4:	3c fb       	j 8000d4ba <ShutdownOS+0x5e>

8000d4c6 <GetTaskID>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000d4c6:	91 00 00 f8 	movh.a %a15,32768
8000d4ca:	19 ff 54 50 	ld.w %d15,[%a15]1364 <80000554 <osEE_cdb_var>>
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
8000d4ce:	20 08       	sub.a %sp,8
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000d4d0:	78 01       	st.w [%sp]4,%d15
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d4d2:	3b e0 00 20 	mov %d2,14
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
8000d4d6:	bc 4c       	jz.a %a4,8000d4ee <GetTaskID+0x28>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
8000d4d8:	60 f2       	mov.a %a2,%d15
8000d4da:	cc 20       	ld.a %a15,[%a2]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000d4dc:	39 f2 14 00 	ld.bu %d2,[%a15]20
8000d4e0:	bf 22 17 80 	jlt.u %d2,2,8000d50e <GetTaskID+0x48>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000d4e4:	82 ff       	mov %d15,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000d4e6:	df 22 05 00 	jeq %d2,2,8000d4f0 <GetTaskID+0x2a>
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
8000d4ea:	6c 40       	st.w [%a4]0,%d15
    ev = E_OK;
8000d4ec:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
8000d4ee:	00 90       	ret 
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
8000d4f0:	99 a2 04 00 	ld.a %a2,[%sp]4
8000d4f4:	cc 23       	ld.a %a15,[%a2]12
8000d4f6:	c8 0f       	ld.a %a15,[%a15]0

      while (p_sn != NULL) {
8000d4f8:	7c f4       	jnz.a %a15,8000d500 <GetTaskID+0x3a>
8000d4fa:	3c f8       	j 8000d4ea <GetTaskID+0x24>
          p_searched_tdb = p_sn->p_tdb;
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
          tid = p_searched_tdb->tid;
          break;
        } else {
          p_sn = p_sn->p_next;
8000d4fc:	c8 0f       	ld.a %a15,[%a15]0
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
8000d4fe:	bc fc       	jz.a %a15,8000d516 <GetTaskID+0x50>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
8000d500:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000d502:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000d506:	ff 2f fb ff 	jge.u %d15,2,8000d4fc <GetTaskID+0x36>
          tid = p_searched_tdb->tid;
8000d50a:	4c 24       	ld.w %d15,[%a2]16
          break;
8000d50c:	3c ef       	j 8000d4ea <GetTaskID+0x24>
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
8000d50e:	4c f4       	ld.w %d15,[%a15]16
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
    ev = E_OK;
8000d510:	82 02       	mov %d2,0
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
8000d512:	6c 40       	st.w [%a4]0,%d15
8000d514:	3c ed       	j 8000d4ee <GetTaskID+0x28>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000d516:	82 ff       	mov %d15,-1
8000d518:	3c e9       	j 8000d4ea <GetTaskID+0x24>

8000d51a <GetTaskState>:
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d51a:	3b e0 00 20 	mov %d2,14
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
8000d51e:	bc 49       	jz.a %a4,8000d530 <GetTaskState+0x16>
8000d520:	91 00 00 f8 	movh.a %a15,32768
8000d524:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d528:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_ID;
8000d52a:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d52c:	3f f4 03 80 	jlt.u %d4,%d15,8000d532 <GetTaskState+0x18>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
8000d530:	00 90       	ret 
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d532:	c8 1f       	ld.a %a15,[%a15]4
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d534:	82 02       	mov %d2,0
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d536:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
8000d53a:	c8 0f       	ld.a %a15,[%a15]0
8000d53c:	c8 3f       	ld.a %a15,[%a15]12
    switch (local_state) {
8000d53e:	0c f2       	ld.bu %d15,[%a15]2
8000d540:	ff 6f f8 ff 	jge.u %d15,6,8000d530 <GetTaskState+0x16>
8000d544:	91 10 00 f8 	movh.a %a15,32769
8000d548:	d9 ff 50 5d 	lea %a15,[%a15]-10928 <8000d550 <GetTaskState+0x36>>
8000d54c:	90 ff       	addsc.a %a15,%a15,%d15,2
8000d54e:	dc 0f       	ji %a15
8000d550:	1d 00 14 00 	j 8000d578 <GetTaskState+0x5e>
8000d554:	1d 00 0e 00 	j 8000d570 <GetTaskState+0x56>
8000d558:	1d 00 0c 00 	j 8000d570 <GetTaskState+0x56>
8000d55c:	1d 00 06 00 	j 8000d568 <GetTaskState+0x4e>
8000d560:	1d 00 10 00 	j 8000d580 <GetTaskState+0x66>
8000d564:	1d 00 0e 00 	j 8000d580 <GetTaskState+0x66>
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
8000d568:	82 3f       	mov %d15,3
8000d56a:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d56c:	82 02       	mov %d2,0
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
8000d56e:	00 90       	ret 
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
8000d570:	82 1f       	mov %d15,1
8000d572:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d574:	82 02       	mov %d2,0
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
8000d576:	00 90       	ret 
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
8000d578:	82 0f       	mov %d15,0
8000d57a:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d57c:	82 02       	mov %d2,0
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
8000d57e:	00 90       	ret 
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
8000d580:	82 4f       	mov %d15,4
8000d582:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d584:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
8000d586:	00 90       	ret 

8000d588 <SetRelAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  increment,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
8000d588:	91 00 00 f8 	movh.a %a15,32768
8000d58c:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d590:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d592:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d594:	3f f4 03 80 	jlt.u %d4,%d15,8000d59a <SetRelAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetRelAlarm);

  return ev;
}
8000d598:	00 90       	ret 
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d59a:	c8 7f       	ld.a %a15,[%a15]28
8000d59c:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d5a0:	c8 05       	ld.a %a5,[%a15]0
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
8000d5a2:	99 54 04 00 	ld.a %a4,[%a5]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d5a6:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d5aa:	8f ff 0f 81 	and %d8,%d15,255
8000d5ae:	bf 38 13 80 	jlt.u %d8,3,8000d5d4 <SetRelAlarm+0x4c>
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_rel(p_counter_db, p_alarm_db, increment, cycle);
8000d5b2:	0b 56 10 48 	mov %e4,%d6,%d5
8000d5b6:	6d 00 51 05 	call 8000e058 <osEE_alarm_set_rel>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d5ba:	4d c0 e2 ff 	mfcr %d15,$icr
8000d5be:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d5c2:	5f 83 eb 7f 	jeq %d3,%d8,8000d598 <SetRelAlarm+0x10>
8000d5c6:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d5ca:	cd cf e2 0f 	mtcr $icr,%d15
8000d5ce:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetRelAlarm);

  return ev;
}
8000d5d2:	00 90       	ret 
8000d5d4:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
8000d5d8:	cd cf e2 0f 	mtcr $icr,%d15
8000d5dc:	0d 00 c0 04 	isync 
8000d5e0:	3c e9       	j 8000d5b2 <SetRelAlarm+0x2a>

8000d5e2 <SetAbsAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  start,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
8000d5e2:	91 00 00 f8 	movh.a %a15,32768
8000d5e6:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d5ea:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d5ec:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d5ee:	3f f4 03 80 	jlt.u %d4,%d15,8000d5f4 <SetAbsAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetAbsAlarm);

  return ev;
}
8000d5f2:	00 90       	ret 
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d5f4:	c8 7f       	ld.a %a15,[%a15]28
8000d5f6:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d5fa:	c8 05       	ld.a %a5,[%a15]0
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
8000d5fc:	99 54 04 00 	ld.a %a4,[%a5]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d600:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d604:	8f ff 0f 81 	and %d8,%d15,255
8000d608:	bf 38 13 80 	jlt.u %d8,3,8000d62e <SetAbsAlarm+0x4c>
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_abs(p_counter_db, p_alarm_db, start, cycle);
8000d60c:	0b 56 10 48 	mov %e4,%d6,%d5
8000d610:	6d 00 49 05 	call 8000e0a2 <osEE_alarm_set_abs>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d614:	4d c0 e2 ff 	mfcr %d15,$icr
8000d618:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d61c:	5f 83 eb 7f 	jeq %d3,%d8,8000d5f2 <SetAbsAlarm+0x10>
8000d620:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d624:	cd cf e2 0f 	mtcr $icr,%d15
8000d628:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetAbsAlarm);

  return ev;
}
8000d62c:	00 90       	ret 
8000d62e:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
8000d632:	cd cf e2 0f 	mtcr $icr,%d15
8000d636:	0d 00 c0 04 	isync 
8000d63a:	3c e9       	j 8000d60c <SetAbsAlarm+0x2a>

8000d63c <CancelAlarm>:
FUNC(StatusType, OS_CODE)
  CancelAlarm
(
  VAR(AlarmType, AUTOMATIC) AlarmID
)
{
8000d63c:	91 00 00 f8 	movh.a %a15,32768
8000d640:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d644:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d646:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d648:	3f f4 03 80 	jlt.u %d4,%d15,8000d64e <CancelAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_CancelAlarm);

  return ev;
}
8000d64c:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db  = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d64e:	c8 7f       	ld.a %a15,[%a15]28
8000d650:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d654:	c8 04       	ld.a %a4,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d656:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d65a:	8f ff 0f 81 	and %d8,%d15,255
8000d65e:	bf 38 11 80 	jlt.u %d8,3,8000d680 <CancelAlarm+0x44>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_cancel(p_alarm_db);
8000d662:	6d 00 33 05 	call 8000e0c8 <osEE_alarm_cancel>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d666:	4d c0 e2 ff 	mfcr %d15,$icr
8000d66a:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d66e:	5f 83 ef 7f 	jeq %d3,%d8,8000d64c <CancelAlarm+0x10>
8000d672:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d676:	cd cf e2 0f 	mtcr $icr,%d15
8000d67a:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_CancelAlarm);

  return ev;
}
8000d67e:	00 90       	ret 
8000d680:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
8000d684:	cd cf e2 0f 	mtcr $icr,%d15
8000d688:	0d 00 c0 04 	isync 
8000d68c:	3c eb       	j 8000d662 <CancelAlarm+0x26>

8000d68e <GetAlarm>:
  GetAlarm
(
  VAR(AlarmType, AUTOMATIC)   AlarmID,
  VAR(TickRefType, AUTOMATIC) Tick
)
{
8000d68e:	91 00 00 f8 	movh.a %a15,32768
8000d692:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d696:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d698:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d69a:	3f f4 03 80 	jlt.u %d4,%d15,8000d6a0 <GetAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarm);

  return ev;
}
8000d69e:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d6a0:	3b e0 00 20 	mov %d2,14
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
8000d6a4:	bd 04 fd 7f 	jz.a %a4,8000d69e <GetAlarm+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d6a8:	c8 7f       	ld.a %a15,[%a15]28
8000d6aa:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d6ae:	c8 0f       	ld.a %a15,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d6b0:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d6b4:	8f ff 0f 81 	and %d8,%d15,255
8000d6b8:	ff 38 08 80 	jge.u %d8,3,8000d6c8 <GetAlarm+0x3a>
8000d6bc:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d6c0:	cd cf e2 0f 	mtcr $icr,%d15
8000d6c4:	0d 00 c0 04 	isync 
8000d6c8:	40 45       	mov.aa %a5,%a4
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_get(p_alarm_db, Tick);
8000d6ca:	40 f4       	mov.aa %a4,%a15
8000d6cc:	6d 00 12 05 	call 8000e0f0 <osEE_alarm_get>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d6d0:	4d c0 e2 ff 	mfcr %d15,$icr
8000d6d4:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d6d8:	5f 83 e3 7f 	jeq %d3,%d8,8000d69e <GetAlarm+0x10>
8000d6dc:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d6e0:	cd cf e2 0f 	mtcr $icr,%d15
8000d6e4:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarm);

  return ev;
}
8000d6e8:	00 90       	ret 

8000d6ea <GetAlarmBase>:
  GetAlarmBase
(
  VAR(AlarmType, AUTOMATIC)         AlarmID,
  VAR(AlarmBaseRefType, AUTOMATIC)  Info
)
{
8000d6ea:	91 00 00 f8 	movh.a %a15,32768
8000d6ee:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d6f2:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d6f4:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d6f6:	3f f4 03 80 	jlt.u %d4,%d15,8000d6fc <GetAlarmBase+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarmBase);

  return ev;
}
8000d6fa:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d6fc:	3b e0 00 20 	mov %d2,14
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
8000d700:	bd 04 fd 7f 	jz.a %a4,8000d6fa <GetAlarmBase+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d704:	c8 7f       	ld.a %a15,[%a15]28
8000d706:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
      p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = p_trigger_db->p_counter_db;
8000d70a:	c8 0f       	ld.a %a15,[%a15]0

    *Info = p_counter_db->info;
8000d70c:	c8 1f       	ld.a %a15,[%a15]4
8000d70e:	09 f2 44 09 	ld.d %e2,[%a15]4
8000d712:	89 42 40 09 	st.d [%a4],%e2

    ev = E_OK;
8000d716:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarmBase);

  return ev;
}
8000d718:	00 90       	ret 

8000d71a <WaitEvent>:
{
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
8000d71a:	91 00 00 48 	movh.a %a4,32768
8000d71e:	99 4d 54 50 	ld.a %a13,[%a4]1364 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000d722:	d4 dc       	ld.a %a12,[%a13]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000d724:	cc c3       	ld.a %a15,[%a12]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d726:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d72a:	8f ff 0f 81 	and %d8,%d15,255
8000d72e:	ff 38 08 80 	jge.u %d8,3,8000d73e <WaitEvent+0x24>
8000d732:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d736:	cd cf e2 0f 	mtcr $icr,%d15
8000d73a:	0d 00 c0 04 	isync 
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
8000d73e:	4c f3       	ld.w %d15,[%a15]12
8000d740:	26 4f       	and %d15,%d4
8000d742:	6e 0f       	jz %d15,8000d760 <WaitEvent+0x46>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d744:	4d c0 e2 ff 	mfcr %d15,$icr
8000d748:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d74c:	5f 82 08 00 	jeq %d2,%d8,8000d75c <WaitEvent+0x42>
8000d750:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d754:	cd cf e2 0f 	mtcr $icr,%d15
8000d758:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
8000d75c:	82 02       	mov %d2,0
8000d75e:	00 90       	ret 
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
8000d760:	68 24       	st.w [%a15]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000d762:	d9 44 54 50 	lea %a4,[%a4]1364
8000d766:	d9 d5 04 00 	lea %a5,[%a13]4
8000d76a:	6d 00 fd 01 	call 8000db64 <osEE_scheduler_core_pop_running>

      p_curr_tcb->status = OSEE_TASK_WAITING;

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
8000d76e:	d4 d5       	ld.a %a5,[%a13]
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
8000d770:	82 32       	mov %d2,3
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
8000d772:	e8 42       	st.a [%a15]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
8000d774:	28 22       	st.b [%a15]2,%d2

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
8000d776:	40 c4       	mov.aa %a4,%a12
8000d778:	6d 00 d4 04 	call 8000e120 <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
8000d77c:	68 2f       	st.w [%a15]8,%d15
8000d77e:	3c e3       	j 8000d744 <WaitEvent+0x2a>

8000d780 <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000d780:	91 00 00 f8 	movh.a %a15,32768
8000d784:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d788:	4c f2       	ld.w %d15,[%a15]8
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000d78a:	20 08       	sub.a %sp,8
8000d78c:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d78e:	7f f4 2c 80 	jge.u %d4,%d15,8000d7e6 <SetEvent+0x66>
    ev = E_OS_ID;
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d792:	c8 12       	ld.a %a2,[%a15]4
8000d794:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000d798:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d79a:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d79e:	8f ff 0f 81 	and %d8,%d15,255
8000d7a2:	ff 38 08 80 	jge.u %d8,3,8000d7b2 <SetEvent+0x32>
8000d7a6:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d7aa:	cd cf e2 0f 	mtcr $icr,%d15
8000d7ae:	0d 00 c0 04 	isync 
8000d7b2:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
8000d7b4:	d9 a5 07 00 	lea %a5,[%sp]7
8000d7b8:	6d 00 24 02 	call 8000dc00 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
8000d7bc:	bc 27       	jz.a %a2,8000d7ca <SetEvent+0x4a>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
8000d7be:	40 f4       	mov.aa %a4,%a15
8000d7c0:	40 25       	mov.aa %a5,%a2
8000d7c2:	6d 00 84 02 	call 8000dcca <osEE_scheduler_task_unblocked>
8000d7c6:	df 02 11 80 	jne %d2,0,8000d7e8 <SetEvent+0x68>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d7ca:	4d c0 e2 ff 	mfcr %d15,$icr
8000d7ce:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d7d2:	5f 82 08 00 	jeq %d2,%d8,8000d7e2 <SetEvent+0x62>
8000d7d6:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d7da:	cd cf e2 0f 	mtcr $icr,%d15
8000d7de:	0d 00 c0 04 	isync 
8000d7e2:	39 a2 07 00 	ld.bu %d2,[%sp]7
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d7e6:	00 90       	ret 

    if (p_sn != NULL) {
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000d7e8:	40 f4       	mov.aa %a4,%a15
8000d7ea:	6d 00 da 02 	call 8000dd9e <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d7ee:	4d c0 e2 ff 	mfcr %d15,$icr
8000d7f2:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d7f6:	5f 82 f0 ff 	jne %d2,%d8,8000d7d6 <SetEvent+0x56>
8000d7fa:	3c f4       	j 8000d7e2 <SetEvent+0x62>

8000d7fc <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
8000d7fc:	91 00 00 f8 	movh.a %a15,32768
8000d800:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d804:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_ID;
8000d806:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d808:	3f f4 03 80 	jlt.u %d4,%d15,8000d80e <GetEvent+0x12>
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d80c:	00 90       	ret 
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d80e:	c8 1f       	ld.a %a15,[%a15]4
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
8000d810:	3b e0 00 20 	mov %d2,14
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d814:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
8000d818:	c8 0f       	ld.a %a15,[%a15]0
8000d81a:	c8 3f       	ld.a %a15,[%a15]12
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
8000d81c:	bd 04 f8 7f 	jz.a %a4,8000d80c <GetEvent+0x10>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
8000d820:	4c f3       	ld.w %d15,[%a15]12

      ev = E_OK;
8000d822:	82 02       	mov %d2,0
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
8000d824:	6c 40       	st.w [%a4]0,%d15
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d826:	00 90       	ret 

8000d828 <ClearEvent>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
8000d828:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000d82c:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000d830:	c8 0f       	ld.a %a15,[%a15]0
8000d832:	c8 3f       	ld.a %a15,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d834:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d838:	8f ff 0f 21 	and %d2,%d15,255
8000d83c:	ff 32 08 80 	jge.u %d2,3,8000d84c <ClearEvent+0x24>
8000d840:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d844:	cd cf e2 0f 	mtcr $icr,%d15
8000d848:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
8000d84c:	4c f3       	ld.w %d15,[%a15]12
8000d84e:	0f 4f e0 40 	andn %d4,%d15,%d4
8000d852:	68 34       	st.w [%a15]12,%d4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d854:	4d c0 e2 ff 	mfcr %d15,$icr
8000d858:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d85c:	5f 23 08 00 	jeq %d3,%d2,8000d86c <ClearEvent+0x44>
8000d860:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d864:	cd cf e2 0f 	mtcr $icr,%d15
8000d868:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
8000d86c:	82 02       	mov %d2,0
8000d86e:	00 90       	ret 

8000d870 <GetCounterValue>:
  GetCounterValue
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value
)
{
8000d870:	91 00 00 f8 	movh.a %a15,32768
8000d874:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d878:	4c f6       	ld.w %d15,[%a15]24
    ev = E_OS_ID;
8000d87a:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d87c:	3f f4 03 80 	jlt.u %d4,%d15,8000d882 <GetCounterValue+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetCounterValue);

  return ev;
}
8000d880:	00 90       	ret 
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d882:	3b e0 00 20 	mov %d2,14
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
8000d886:	bd 04 fd 7f 	jz.a %a4,8000d880 <GetCounterValue+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d88a:	c8 5f       	ld.a %a15,[%a15]20
    wraps at its modulus. (SRS_Frt_00030, SRS_Frt_00031) */
/* EG  TODO: Add support for HARDWARE counters */

      (*Value) = p_counter_db->p_counter_cb->value;

      ev = E_OK;
8000d88c:	82 02       	mov %d2,0
  if (Value == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d88e:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    of hardware timers (which drive counters) in such that the lowest value is
    zero and consecutive reads return an increasing count value until the timer
    wraps at its modulus. (SRS_Frt_00030, SRS_Frt_00031) */
/* EG  TODO: Add support for HARDWARE counters */

      (*Value) = p_counter_db->p_counter_cb->value;
8000d892:	c8 0f       	ld.a %a15,[%a15]0
8000d894:	c8 0f       	ld.a %a15,[%a15]0
8000d896:	4c f1       	ld.w %d15,[%a15]4
8000d898:	6c 40       	st.w [%a4]0,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetCounterValue);

  return ev;
}
8000d89a:	00 90       	ret 

8000d89c <GetElapsedValue>:
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value,
  VAR(TickRefType, AUTOMATIC) ElapsedValue
)
{
8000d89c:	91 00 00 f8 	movh.a %a15,32768
8000d8a0:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d8a4:	4c f6       	ld.w %d15,[%a15]24
    ev = E_OS_ID;
8000d8a6:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d8a8:	3f f4 03 80 	jlt.u %d4,%d15,8000d8ae <GetElapsedValue+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetElapsedValue);

  return ev;
}
8000d8ac:	00 90       	ret 
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
8000d8ae:	80 43       	mov.d %d3,%a4
8000d8b0:	80 55       	mov.d %d5,%a5
8000d8b2:	ba 03       	eq %d15,%d3,0
8000d8b4:	8b 05 e0 f4 	or.eq %d15,%d5,0
    ev = E_OS_PARAM_POINTER;
8000d8b8:	3b e0 00 20 	mov %d2,14
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
8000d8bc:	ee f8       	jnz %d15,8000d8ac <GetElapsedValue+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d8be:	c8 5f       	ld.a %a15,[%a15]20
    CONST(TickType, AUTOMATIC)
      local_value = (*Value);
8000d8c0:	54 42       	ld.w %d2,[%a4]
  if ((Value == NULL) || (ElapsedValue == NULL)) {
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d8c2:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d8c6:	c8 0f       	ld.a %a15,[%a15]0
/* [SWS_Os_00382] If the input parameters in a call of GetElapsedValue()
     are valid, GetElapsedValue() shall return the number of elapsed ticks
     since the given <Value> value via <ElapsedValue> and shall return
     E_OK. (SRS_Frt_00034) */
      CONST(TickType, AUTOMATIC)
        local_curr_value = p_counter_db->p_counter_cb->value;
8000d8c8:	c8 02       	ld.a %a2,[%a15]0
8000d8ca:	4c 21       	ld.w %d15,[%a2]4
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
        /* Timer did not pass the <value> yet */
        (local_curr_value - local_value):
8000d8cc:	3f 2f 07 80 	jlt.u %d15,%d2,8000d8da <GetElapsedValue+0x3e>
8000d8d0:	52 22       	sub %d2,%d15,%d2

/* [SWS_Os_00533] Caveats of GetElapsedValue(): If the timer already passed the
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
8000d8d2:	74 52       	st.w [%a5],%d2
        ((p_counter_db->info.maxallowedvalue -
          (local_value - local_curr_value)) + 1U);

/* [SWS_Os_00460] GetElapsedValue() shall return the current tick value of the
    counter in the <Value> parameter. */
      (*Value) = local_curr_value;
8000d8d4:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
8000d8d6:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetElapsedValue);

  return ev;
}
8000d8d8:	00 90       	ret 
8000d8da:	48 13       	ld.w %d3,[%a15]4
8000d8dc:	42 f3       	add %d3,%d15
8000d8de:	c2 13       	add %d3,1
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
        /* Timer did not pass the <value> yet */
        (local_curr_value - local_value):
8000d8e0:	0b 23 80 20 	sub %d2,%d3,%d2
8000d8e4:	3c f7       	j 8000d8d2 <GetElapsedValue+0x36>

8000d8e6 <IncrementCounter>:
FUNC(StatusType, OS_CODE)
  IncrementCounter
(
  VAR(CounterType, AUTOMATIC) CounterID
)
{
8000d8e6:	91 00 00 f8 	movh.a %a15,32768
8000d8ea:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d8ee:	4c f6       	ld.w %d15,[%a15]24
    ev = E_OS_ID;
8000d8f0:	82 32       	mov %d2,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d8f2:	3f f4 03 80 	jlt.u %d4,%d15,8000d8f8 <IncrementCounter+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_IncrementCounter);

  return ev;
}
8000d8f6:	00 90       	ret 
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d8f8:	c8 52       	ld.a %a2,[%a15]20
8000d8fa:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000d8fe:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d900:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d904:	8f ff 0f 81 	and %d8,%d15,255
8000d908:	bf 38 1b 80 	jlt.u %d8,3,8000d93e <IncrementCounter+0x58>
      CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();

/* N.B. Multi-core critical sections are handled inside
   TODO: Pass flags to osEE_counter_increment so it could re-enable
         interrupts/lower IPL outside critical sections. */
      osEE_counter_increment(p_counter_db);
8000d90c:	6d 00 fc 02 	call 8000df04 <osEE_counter_increment>
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000d910:	91 00 00 28 	movh.a %a2,32768
8000d914:	99 22 54 50 	ld.a %a2,[%a2]1364 <80000554 <osEE_cdb_var>>

/* [SWS_Os_00529] Caveats of IncrementCounter(): If called from a task,
    rescheduling may take place. */
      if (osEE_get_curr_task()->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000d918:	d4 22       	ld.a %a2,[%a2]
8000d91a:	39 2f 14 00 	ld.bu %d15,[%a2]20 <80000554 <osEE_cdb_var>>
8000d91e:	bf 2f 17 80 	jlt.u %d15,2,8000d94c <IncrementCounter+0x66>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d922:	4d c0 e2 ff 	mfcr %d15,$icr
8000d926:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d92a:	5f 82 08 00 	jeq %d2,%d8,8000d93a <IncrementCounter+0x54>
8000d92e:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d932:	cd cf e2 0f 	mtcr $icr,%d15
8000d936:	0d 00 c0 04 	isync 
        (void)osEE_scheduler_task_preemption_point(p_kdb);
      }

      osEE_end_primitive(flags);

      ev = E_OK;
8000d93a:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_IncrementCounter);

  return ev;
}
8000d93c:	00 90       	ret 
8000d93e:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
8000d942:	cd cf e2 0f 	mtcr $icr,%d15
8000d946:	0d 00 c0 04 	isync 
8000d94a:	3c e1       	j 8000d90c <IncrementCounter+0x26>
      osEE_counter_increment(p_counter_db);

/* [SWS_Os_00529] Caveats of IncrementCounter(): If called from a task,
    rescheduling may take place. */
      if (osEE_get_curr_task()->task_type <= OSEE_TASK_TYPE_EXTENDED) {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000d94c:	40 f4       	mov.aa %a4,%a15
8000d94e:	6d 00 28 02 	call 8000dd9e <osEE_scheduler_task_preemption_point>
8000d952:	3c e8       	j 8000d922 <IncrementCounter+0x3c>

8000d954 <GetISRID>:
8000d954:	91 00 00 f8 	movh.a %a15,32768
8000d958:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
8000d95c:	c8 0f       	ld.a %a15,[%a15]0
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
8000d95e:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000d960:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000d964:	1e 22       	jeq %d15,2,8000d968 <GetISRID+0x14>
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
8000d966:	00 90       	ret 
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
    isr_id = p_tdb->tid;
8000d968:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
8000d96a:	00 90       	ret 

8000d96c <osEE_scheduler_task_wrapper_restore>:
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000d96c:	cc 43       	ld.a %a15,[%a4]12
8000d96e:	82 4f       	mov %d15,4
8000d970:	28 2f       	st.b [%a15]2,%d15
8000d972:	00 90       	ret 

8000d974 <osEE_scheduler_task_wrapper_run>:
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
8000d974:	cc 43       	ld.a %a15,[%a4]12
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000d976:	82 4f       	mov %d15,4
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
8000d978:	40 4c       	mov.aa %a12,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
8000d97a:	08 12       	ld.bu %d2,[%a15]1
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000d97c:	28 2f       	st.b [%a15]2,%d15
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_priority < OSEE_ISR_ALL_PRIO) {
8000d97e:	8b f2 0f f2 	eq %d15,%d2,255
8000d982:	ee 10       	jnz %d15,8000d9a2 <osEE_scheduler_task_wrapper_run+0x2e>
8000d984:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
8000d988:	37 02 48 30 	extr %d3,%d2,0,8
8000d98c:	82 04       	mov %d4,0
8000d98e:	bf 03 4e 00 	jlt %d3,0,8000da2a <osEE_scheduler_task_wrapper_run+0xb6>
8000d992:	37 4f 08 f0 	insert %d15,%d15,%d4,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d996:	cd cf e2 0f 	mtcr $icr,%d15
8000d99a:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000d99e:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000d9a2:	cc c6       	ld.a %a15,[%a12]24

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
8000d9a4:	82 0f       	mov %d15,0
  if (task_priority < OSEE_ISR_ALL_PRIO) {
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000d9a6:	2d 0f 00 00 	calli %a15
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000d9aa:	91 00 00 f8 	movh.a %a15,32768
8000d9ae:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000d9b2:	39 f2 1c 00 	ld.bu %d2,[%a15]28 <80000554 <osEE_cdb_var>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
8000d9b6:	e9 ff 1d 00 	st.b [%a15]29 <80000554 <osEE_cdb_var>>,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000d9ba:	76 28       	jz %d2,8000d9ca <osEE_scheduler_task_wrapper_run+0x56>
    p_ccb->s_isr_all_cnt = 0U;
8000d9bc:	e9 ff 1c 00 	st.b [%a15]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d9c0:	4c f5       	ld.w %d15,[%a15]20
8000d9c2:	cd cf e2 0f 	mtcr $icr,%d15
8000d9c6:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
8000d9ca:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000d9ce:	6e 06       	jz %d15,8000d9da <osEE_scheduler_task_wrapper_run+0x66>
    p_ccb->d_isr_all_cnt = 0U;
8000d9d0:	82 0f       	mov %d15,0
8000d9d2:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000d9d6:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d9da:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d9de:	8f ff 0f 21 	and %d2,%d15,255
8000d9e2:	ff 32 08 80 	jge.u %d2,3,8000d9f2 <osEE_scheduler_task_wrapper_run+0x7e>
8000d9e6:	b7 3f 08 f0 	insert %d15,%d15,3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d9ea:	cd cf e2 0f 	mtcr $icr,%d15
8000d9ee:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000d9f2:	39 cf 14 00 	ld.bu %d15,[%a12]20
8000d9f6:	99 c2 0c 00 	ld.a %a2,[%a12]12
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d9fa:	cc 21       	ld.a %a15,[%a2]4

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000d9fc:	1e 2e       	jeq %d15,2,8000da18 <osEE_scheduler_task_wrapper_run+0xa4>
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d9fe:	bc f8       	jz.a %a15,8000da0e <osEE_scheduler_task_wrapper_run+0x9a>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000da00:	82 0f       	mov %d15,0
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
8000da02:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000da04:	68 2f       	st.w [%a15]8,%d15
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
8000da06:	c8 0f       	ld.a %a15,[%a15]0
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000da08:	bd 0f fd ff 	jnz.a %a15,8000da02 <osEE_scheduler_task_wrapper_run+0x8e>
8000da0c:	ec 21       	st.a [%a2]4,%a15
8000da0e:	99 c4 04 00 	ld.a %a4,[%a12]4
8000da12:	a0 05       	mov.a %a5,0
8000da14:	1d 00 53 04 	j 8000e2ba <osEE_hal_terminate_ctx>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000da18:	82 0f       	mov %d15,0
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000da1a:	bd 0f fa 7f 	jz.a %a15,8000da0e <osEE_scheduler_task_wrapper_run+0x9a>
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
8000da1e:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000da20:	68 2f       	st.w [%a15]8,%d15
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
8000da22:	c8 0f       	ld.a %a15,[%a15]0
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000da24:	bd 0f fd ff 	jnz.a %a15,8000da1e <osEE_scheduler_task_wrapper_run+0xaa>
8000da28:	3c f2       	j 8000da0c <osEE_scheduler_task_wrapper_run+0x98>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000da2a:	8f f2 07 21 	and %d2,%d2,127
8000da2e:	1b 12 00 40 	addi %d4,%d2,1
8000da32:	3c b0       	j 8000d992 <osEE_scheduler_task_wrapper_run+0x1e>

8000da34 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
8000da34:	91 00 00 28 	movh.a %a2,32768
8000da38:	99 2f 54 50 	ld.a %a15,[%a2]1364 <80000554 <osEE_cdb_var>>
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000da3c:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000554 <osEE_cdb_var>>
8000da40:	df 2f fe 7f 	jeq %d15,2,8000da3c <osEE_idle_hook_wrapper+0x8>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
8000da44:	d9 22 54 50 	lea %a2,[%a2]1364 <80000554 <osEE_cdb_var>>
8000da48:	99 24 04 00 	ld.a %a4,[%a2]4 <80000004 <BootModeHeader0+0x4>>
8000da4c:	1d 00 81 03 	j 8000e14e <osEE_idle_task_terminate>

8000da50 <osEE_scheduler_rq_insert>:
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
  p_sn_new->p_tdb = p_tdb_new;
8000da50:	b5 56 04 00 	st.a [%a5]4,%a6
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000da54:	d4 42       	ld.a %a2,[%a4]
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000da56:	39 62 1c 00 	ld.bu %d2,[%a6]28
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000da5a:	bd 02 15 00 	jz.a %a2,8000da84 <osEE_scheduler_rq_insert+0x34>
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
8000da5e:	cc 21       	ld.a %a15,[%a2]4
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
8000da60:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000da64:	7f 2f 09 80 	jge.u %d15,%d2,8000da76 <osEE_scheduler_rq_insert+0x26>
8000da68:	3c 0e       	j 8000da84 <osEE_scheduler_rq_insert+0x34>
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
8000da6a:	c8 13       	ld.a %a3,[%a15]4
8000da6c:	39 3f 1c 00 	ld.bu %d15,[%a3]28
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
8000da70:	3f 2f 06 80 	jlt.u %d15,%d2,8000da7c <osEE_scheduler_rq_insert+0x2c>
8000da74:	40 f2       	mov.aa %a2,%a15
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000da76:	cc 20       	ld.a %a15,[%a2]0
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000da78:	bd 0f f9 ff 	jnz.a %a15,8000da6a <osEE_scheduler_rq_insert+0x1a>
      break;
    }
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
8000da7c:	f4 25       	st.a [%a2],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000da7e:	82 02       	mov %d2,0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
8000da80:	ec 50       	st.a [%a5]0,%a15
8000da82:	00 90       	ret 
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000da84:	f4 45       	st.a [%a4],%a5
8000da86:	40 2f       	mov.aa %a15,%a2
    head_changed  = OSEE_TRUE;
8000da88:	82 12       	mov %d2,1
8000da8a:	3c fb       	j 8000da80 <osEE_scheduler_rq_insert+0x30>

8000da8c <osEE_scheduler_core_rq_preempt_stk>:
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000da8c:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
8000da8e:	99 32 0c 00 	ld.a %a2,[%a3]12
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000da92:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000da94:	bd 02 26 00 	jz.a %a2,8000dae0 <osEE_scheduler_core_rq_preempt_stk+0x54>
    p_ret_tdb = p_ret_sn->p_tdb;
8000da98:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
8000da9c:	bd 0f 1f 00 	jz.a %a15,8000dada <osEE_scheduler_core_rq_preempt_stk+0x4e>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000daa0:	c8 16       	ld.a %a6,[%a15]4

  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000daa2:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000daa6:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000daaa:	39 42 01 00 	ld.bu %d2,[%a4]1
8000daae:	0c 61       	ld.bu %d15,[%a6]1
8000dab0:	7f f2 15 80 	jge.u %d2,%d15,8000dada <osEE_scheduler_core_rq_preempt_stk+0x4e>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000dab4:	82 2f       	mov %d15,2
8000dab6:	2c 42       	st.b [%a4]2,%d15
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000dab8:	4c f0       	ld.w %d15,[%a15]0
8000daba:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000dabc:	c8 14       	ld.a %a4,[%a15]4
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000dabe:	4c 33       	ld.w %d15,[%a3]12
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000dac0:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000dac4:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000dac6:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000dac8:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000daca:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000dace:	39 52 01 00 	ld.bu %d2,[%a5]1
8000dad2:	7f f2 06 80 	jge.u %d2,%d15,8000dade <osEE_scheduler_core_rq_preempt_stk+0x52>
      p_tcb->current_prio = dispatch_prio;
8000dad6:	2c 51       	st.b [%a5]1,%d15
8000dad8:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000dada:	a0 02       	mov.a %a2,0
8000dadc:	00 90       	ret 
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
8000dade:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000dae0:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000dae2:	bd 0f fe 7f 	jz.a %a15,8000dade <osEE_scheduler_core_rq_preempt_stk+0x52>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
8000dae6:	99 42 04 00 	ld.a %a2,[%a4]4
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000daea:	99 24 0c 00 	ld.a %a4,[%a2]12
8000daee:	3c e3       	j 8000dab4 <osEE_scheduler_core_rq_preempt_stk+0x28>

8000daf0 <osEE_sn_priority_insert>:
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
8000daf0:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
8000daf2:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000daf4:	df 04 1b 00 	jeq %d4,0,8000db2a <osEE_sn_priority_insert+0x3a>
8000daf8:	39 f2 1c 00 	ld.bu %d2,[%a15]28
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000dafc:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000dafe:	a0 02       	mov.a %a2,0
8000db00:	7c fa       	jnz.a %a15,8000db14 <osEE_sn_priority_insert+0x24>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000db02:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
8000db04:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
8000db06:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000db08:	00 90       	ret 
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000db0a:	c8 03       	ld.a %a3,[%a15]0
8000db0c:	40 f2       	mov.aa %a2,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000db0e:	bd 03 28 00 	jz.a %a3,8000db5e <osEE_sn_priority_insert+0x6e>
8000db12:	40 3f       	mov.aa %a15,%a3
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
8000db14:	c8 13       	ld.a %a3,[%a15]4
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
8000db16:	39 3f 1c 00 	ld.bu %d15,[%a3]28
8000db1a:	7f 2f f8 ff 	jge.u %d15,%d2,8000db0a <osEE_sn_priority_insert+0x1a>
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
8000db1e:	bd 02 f2 7f 	jz.a %a2,8000db02 <osEE_sn_priority_insert+0x12>
    p_prev->p_next = p_sn_new;
8000db22:	f4 25       	st.a [%a2],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000db24:	82 02       	mov %d2,0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
8000db26:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000db28:	00 90       	ret 
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000db2a:	cc 40       	ld.a %a15,[%a4]0
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000db2c:	39 22 01 00 	ld.bu %d2,[%a2]1
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000db30:	a0 02       	mov.a %a2,0
8000db32:	bd 0f e8 7f 	jz.a %a15,8000db02 <osEE_sn_priority_insert+0x12>
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000db36:	c8 13       	ld.a %a3,[%a15]4

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000db38:	99 33 0c 00 	ld.a %a3,[%a3]12
    }

    if (new_task_prio <= prio_to_check)
8000db3c:	0c 31       	ld.bu %d15,[%a3]1
8000db3e:	3f 2f f0 ff 	jlt.u %d15,%d2,8000db1e <osEE_sn_priority_insert+0x2e>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000db42:	c8 03       	ld.a %a3,[%a15]0
8000db44:	40 f2       	mov.aa %a2,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000db46:	bc 3c       	jz.a %a3,8000db5e <osEE_sn_priority_insert+0x6e>
8000db48:	40 3f       	mov.aa %a15,%a3
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000db4a:	c8 13       	ld.a %a3,[%a15]4

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000db4c:	99 33 0c 00 	ld.a %a3,[%a3]12
    }

    if (new_task_prio <= prio_to_check)
8000db50:	0c 31       	ld.bu %d15,[%a3]1
8000db52:	3f 2f e6 ff 	jlt.u %d15,%d2,8000db1e <osEE_sn_priority_insert+0x2e>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000db56:	c8 03       	ld.a %a3,[%a15]0
8000db58:	40 f2       	mov.aa %a2,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000db5a:	bd 03 f7 ff 	jnz.a %a3,8000db48 <osEE_sn_priority_insert+0x58>
8000db5e:	40 f2       	mov.aa %a2,%a15
8000db60:	a0 0f       	mov.a %a15,0
8000db62:	3c e0       	j 8000db22 <osEE_sn_priority_insert+0x32>

8000db64 <osEE_scheduler_core_pop_running>:
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
8000db64:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
8000db66:	99 32 0c 00 	ld.a %a2,[%a3]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;
8000db6a:	d4 26       	ld.a %a6,[%a2]

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
8000db6c:	b5 36 0c 00 	st.a [%a3]12,%a6
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000db70:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000db72:	bd 06 27 00 	jz.a %a6,8000dbc0 <osEE_scheduler_core_pop_running+0x5c>
    p_ret_tdb = p_ret_sn->p_tdb;
8000db76:	99 64 04 00 	ld.a %a4,[%a6]4
    if (p_rq_sn != NULL) {
8000db7a:	bd 0f 20 00 	jz.a %a15,8000dbba <osEE_scheduler_core_pop_running+0x56>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000db7e:	c8 17       	ld.a %a7,[%a15]4

  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000db80:	99 44 0c 00 	ld.a %a4,[%a4]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000db84:	99 77 0c 00 	ld.a %a7,[%a7]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000db88:	39 42 01 00 	ld.bu %d2,[%a4]1
8000db8c:	0c 71       	ld.bu %d15,[%a7]1
8000db8e:	7f f2 16 80 	jge.u %d2,%d15,8000dbba <osEE_scheduler_core_pop_running+0x56>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000db92:	82 2f       	mov %d15,2
8000db94:	2c 42       	st.b [%a4]2,%d15
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000db96:	4c f0       	ld.w %d15,[%a15]0
8000db98:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000db9a:	c8 14       	ld.a %a4,[%a15]4
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000db9c:	4c 33       	ld.w %d15,[%a3]12
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000db9e:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000dba2:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000dba4:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000dba6:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000dba8:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000dbac:	39 52 01 00 	ld.bu %d2,[%a5]1
8000dbb0:	7f f2 04 80 	jge.u %d2,%d15,8000dbb8 <osEE_scheduler_core_pop_running+0x54>
      p_tcb->current_prio = dispatch_prio;
8000dbb4:	2c 51       	st.b [%a5]1,%d15
8000dbb6:	00 90       	ret 
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
8000dbb8:	00 90       	ret 
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
8000dbba:	4c 61       	ld.w %d15,[%a6]4
      } else {
        /* Resume IDLE TASK */
        p_tdb_stk = p_cdb->p_idle_task;
      }

      p_ccb->p_curr            = p_tdb_stk;
8000dbbc:	6c 30       	st.w [%a3]0,%d15
8000dbbe:	00 90       	ret 

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000dbc0:	bc f6       	jz.a %a15,8000dbcc <osEE_scheduler_core_pop_running+0x68>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000dbc2:	99 44 04 00 	ld.a %a4,[%a4]4
8000dbc6:	99 44 0c 00 	ld.a %a4,[%a4]12
8000dbca:	3c e4       	j 8000db92 <osEE_scheduler_core_pop_running+0x2e>
      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
      } else {
        /* Resume IDLE TASK */
        p_tdb_stk = p_cdb->p_idle_task;
8000dbcc:	4c 41       	ld.w %d15,[%a4]4
8000dbce:	3c f7       	j 8000dbbc <osEE_scheduler_core_pop_running+0x58>

8000dbd0 <osEE_task_activated>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
8000dbd0:	cc 43       	ld.a %a15,[%a4]12
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000dbd2:	39 43 1e 00 	ld.bu %d3,[%a4]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
8000dbd6:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000dbd8:	0c f0       	ld.bu %d15,[%a15]0
8000dbda:	3f 3f 03 80 	jlt.u %d15,%d3,8000dbe0 <osEE_task_activated+0x10>
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000dbde:	00 90       	ret 
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
    ++p_tcb_act->current_num_of_act;
8000dbe0:	c2 1f       	add %d15,1
8000dbe2:	28 0f       	st.b [%a15]0,%d15
    ev = E_OK;
8000dbe4:	82 02       	mov %d2,0
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000dbe6:	00 90       	ret 

8000dbe8 <osEE_task_end>:
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000dbe8:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
8000dbea:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000dbee:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
8000dbf0:	0c f0       	ld.bu %d15,[%a15]0
8000dbf2:	c2 ff       	add %d15,-1
8000dbf4:	16 ff       	and %d15,255
8000dbf6:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
8000dbf8:	8b 0f 20 f2 	ne %d15,%d15,0
8000dbfc:	28 2f       	st.b [%a15]2,%d15
8000dbfe:	00 90       	ret 

8000dc00 <osEE_task_event_set_mask>:
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
8000dc00:	cc 43       	ld.a %a15,[%a4]12
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000dc02:	02 42       	mov %d2,%d4
8000dc04:	02 43       	mov %d3,%d4

    *p_ev = E_OK;
8000dc06:	82 0f       	mov %d15,0
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000dc08:	49 f2 4c 08 	ldmst [%a15]12,%e2

    *p_ev = E_OK;
8000dc0c:	2c 50       	st.b [%a5]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000dc0e:	4c f2       	ld.w %d15,[%a15]8
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000dc10:	a0 02       	mov.a %a2,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000dc12:	26 f4       	and %d4,%d15
8000dc14:	76 45       	jz %d4,8000dc1e <osEE_task_event_set_mask+0x1e>
      p_own_sn = p_tcb_waking_up->p_own_sn;
8000dc16:	c8 42       	ld.a %a2,[%a15]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
8000dc18:	bc 23       	jz.a %a2,8000dc1e <osEE_task_event_set_mask+0x1e>
        p_tcb_waking_up->p_own_sn = NULL;
8000dc1a:	82 0f       	mov %d15,0
8000dc1c:	68 4f       	st.w [%a15]16,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
8000dc1e:	00 90       	ret 

8000dc20 <osEE_activate_isr2>:
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000dc20:	91 00 00 48 	movh.a %a4,32768
8000dc24:	d9 44 70 40 	lea %a4,[%a4]1328 <80000530 <osEE_kdb_var>>
8000dc28:	cc 41       	ld.a %a15,[%a4]4
    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000dc2a:	a0 06       	mov.a %a6,0
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000dc2c:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000dc30:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
8000dc32:	cc 53       	ld.a %a15,[%a5]12
8000dc34:	0c f0       	ld.bu %d15,[%a15]0
8000dc36:	c2 1f       	add %d15,1
8000dc38:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000dc3a:	1d 00 c4 00 	j 8000ddc2 <osEE_scheduler_task_set_running>

8000dc3e <osEE_scheduler_task_activated>:
{
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000dc3e:	91 00 00 f8 	movh.a %a15,32768
8000dc42:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
8000dc46:	c8 04       	ld.a %a4,[%a15]0
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
8000dc48:	99 52 0c 00 	ld.a %a2,[%a5]12 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
8000dc4c:	99 43 0c 00 	ld.a %a3,[%a4]12 <80000554 <osEE_cdb_var>>
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000dc50:	40 56       	mov.aa %a6,%a5
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
8000dc52:	0c 21       	ld.bu %d15,[%a2]1
8000dc54:	39 32 01 00 	ld.bu %d2,[%a3]1
8000dc58:	3f f2 13 80 	jlt.u %d2,%d15,8000dc7e <osEE_scheduler_task_activated+0x40>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000dc5c:	0c 22       	ld.bu %d15,[%a2]2
8000dc5e:	ee 05       	jnz %d15,8000dc68 <osEE_scheduler_task_activated+0x2a>
    p_tcb_act->status = OSEE_TASK_READY;
8000dc60:	82 12       	mov %d2,1
8000dc62:	e9 22 02 00 	st.b [%a2]2,%d2
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
8000dc66:	6c 23       	st.w [%a2]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000dc68:	c8 25       	ld.a %a5,[%a15]8
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000dc6a:	d9 f4 04 00 	lea %a4,[%a15]4
  (*pp_first)              = p_sn_allocated->p_next;
8000dc6e:	4c 50       	ld.w %d15,[%a5]0
8000dc70:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000dc72:	82 0f       	mov %d15,0
8000dc74:	6c 50       	st.w [%a5]0,%d15
8000dc76:	6d ff ed fe 	call 8000da50 <osEE_scheduler_rq_insert>
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
8000dc7a:	82 02       	mov %d2,0
  }

  return is_preemption;
}
8000dc7c:	00 90       	ret 
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000dc7e:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000dc80:	4c 20       	ld.w %d15,[%a2]0
8000dc82:	68 2f       	st.w [%a15]8,%d15
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
8000dc84:	82 2f       	mov %d15,2
8000dc86:	2c 32       	st.b [%a3]2,%d15

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000dc88:	4c f3       	ld.w %d15,[%a15]12

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
8000dc8a:	b5 25 04 00 	st.a [%a2]4,%a5
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000dc8e:	6c 20       	st.w [%a2]0,%d15
    p_ccb->p_stk_sn             = p_new_stk;
8000dc90:	e8 32       	st.a [%a15]12,%a2
    p_ccb->p_curr               = p_tdb_act;
8000dc92:	e8 05       	st.a [%a15]0,%a5
8000dc94:	cc 53       	ld.a %a15,[%a5]12
8000dc96:	82 0f       	mov %d15,0
8000dc98:	68 3f       	st.w [%a15]12,%d15
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
8000dc9a:	6d 00 43 02 	call 8000e120 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000dc9e:	82 12       	mov %d2,1
8000dca0:	00 90       	ret 

8000dca2 <osEE_scheduler_task_insert>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
8000dca2:	cc 53       	ld.a %a15,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000dca4:	91 00 00 28 	movh.a %a2,32768
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000dca8:	40 56       	mov.aa %a6,%a5
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000dcaa:	0c f2       	ld.bu %d15,[%a15]2
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000dcac:	99 24 54 50 	ld.a %a4,[%a2]1364 <80000554 <osEE_cdb_var>>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000dcb0:	ee 04       	jnz %d15,8000dcb8 <osEE_scheduler_task_insert+0x16>
    p_tcb_act->status = OSEE_TASK_READY;
8000dcb2:	82 12       	mov %d2,1
8000dcb4:	28 22       	st.b [%a15]2,%d2
8000dcb6:	68 3f       	st.w [%a15]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000dcb8:	99 45 08 00 	ld.a %a5,[%a4]8 <80000003 <BootModeHeader0+0x3>>
  (*pp_first)              = p_sn_allocated->p_next;
8000dcbc:	4c 50       	ld.w %d15,[%a5]0
8000dcbe:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
8000dcc0:	82 0f       	mov %d15,0
8000dcc2:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000dcc4:	b0 44       	add.a %a4,4
8000dcc6:	1d ff c5 fe 	j 8000da50 <osEE_scheduler_rq_insert>

8000dcca <osEE_scheduler_task_unblocked>:
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
8000dcca:	99 56 04 00 	ld.a %a6,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000dcce:	91 00 00 28 	movh.a %a2,32768
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
8000dcd2:	cc 63       	ld.a %a15,[%a6]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000dcd4:	19 2f 54 50 	ld.w %d15,[%a2]1364
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
8000dcd8:	20 08       	sub.a %sp,8
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000dcda:	78 01       	st.w [%sp]4,%d15

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
8000dcdc:	82 2f       	mov %d15,2
8000dcde:	28 2f       	st.b [%a15]2,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000dce0:	99 a4 04 00 	ld.a %a4,[%sp]4
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000dce4:	39 6f 1c 00 	ld.bu %d15,[%a6]28
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000dce8:	b0 44       	add.a %a4,4
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000dcea:	28 1f       	st.b [%a15]1,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000dcec:	6d ff b2 fe 	call 8000da50 <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
8000dcf0:	82 0f       	mov %d15,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
8000dcf2:	df 12 0c 80 	jne %d2,1,8000dd0a <osEE_scheduler_task_unblocked+0x40>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
8000dcf6:	99 a3 04 00 	ld.a %a3,[%sp]4
8000dcfa:	d4 32       	ld.a %a2,[%a3]
8000dcfc:	99 22 0c 00 	ld.a %a2,[%a2]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
8000dd00:	0c f1       	ld.bu %d15,[%a15]1
8000dd02:	39 22 01 00 	ld.bu %d2,[%a2]1
8000dd06:	0b f2 30 f1 	lt.u %d15,%d2,%d15
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
8000dd0a:	02 f2       	mov %d2,%d15
8000dd0c:	00 90       	ret 

8000dd0e <osEE_scheduler_task_terminated>:
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000dd0e:	91 00 00 f8 	movh.a %a15,32768
8000dd12:	99 fc 54 50 	ld.a %a12,[%a15]1364 <80000554 <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
8000dd16:	d4 c6       	ld.a %a6,[%a12]
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000dd18:	d9 fd 54 50 	lea %a13,[%a15]1364 <80000554 <osEE_cdb_var>>
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
8000dd1c:	cc 63       	ld.a %a15,[%a6]12

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
8000dd1e:	f4 56       	st.a [%a5],%a6
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
8000dd20:	20 08       	sub.a %sp,8
      p_tcb_term  = p_tdb_term->p_tcb;

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
8000dd22:	0c f2       	ld.bu %d15,[%a15]2
8000dd24:	9e 4c       	jeq %d15,4,8000dd5c <osEE_scheduler_task_terminated+0x4e>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
8000dd26:	99 c5 0c 00 	ld.a %a5,[%a12]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
8000dd2a:	4c 50       	ld.w %d15,[%a5]0
8000dd2c:	6c c3       	st.w [%a12]12,%d15
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
8000dd2e:	39 6f 1c 00 	ld.bu %d15,[%a6]28
8000dd32:	28 1f       	st.b [%a15]1,%d15
      p_tcb_term->status = OSEE_TASK_READY;
8000dd34:	82 1f       	mov %d15,1
8000dd36:	28 2f       	st.b [%a15]2,%d15
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
8000dd38:	0c f0       	ld.bu %d15,[%a15]0
8000dd3a:	1e 1e       	jeq %d15,1,8000dd56 <osEE_scheduler_task_terminated+0x48>
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
8000dd3c:	d9 cf 04 00 	lea %a15,[%a12]4
8000dd40:	40 f4       	mov.aa %a4,%a15
8000dd42:	6d ff 87 fe 	call 8000da50 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000dd46:	40 d4       	mov.aa %a4,%a13
8000dd48:	40 f5       	mov.aa %a5,%a15
8000dd4a:	6d ff a1 fe 	call 8000da8c <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
8000dd4e:	bd 02 20 00 	jz.a %a2,8000dd8e <osEE_scheduler_task_terminated+0x80>
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
          p_ccb->p_curr           = p_tdb_to;
        } else {
          p_tdb_to = p_ccb->p_curr;
8000dd52:	d4 c2       	ld.a %a2,[%a12]
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
8000dd54:	00 90       	ret 
8000dd56:	82 0f       	mov %d15,0
8000dd58:	68 3f       	st.w [%a15]12,%d15
8000dd5a:	3c f1       	j 8000dd3c <osEE_scheduler_task_terminated+0x2e>
    (*pp_tdb_from) = p_tdb_term;

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000dd5c:	40 d4       	mov.aa %a4,%a13
8000dd5e:	d9 c5 04 00 	lea %a5,[%a12]4
8000dd62:	b5 a6 04 00 	st.a [%sp]4,%a6
8000dd66:	6d ff ff fe 	call 8000db64 <osEE_scheduler_core_pop_running>

      p_tdb_to = p_ccb->p_curr;

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000dd6a:	99 a6 04 00 	ld.a %a6,[%sp]4
    (*pp_tdb_from) = p_tdb_term;

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000dd6e:	40 2d       	mov.aa %a13,%a2

      p_tdb_to = p_ccb->p_curr;
8000dd70:	d4 c2       	ld.a %a2,[%a12]

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000dd72:	7d 26 12 00 	jeq.a %a6,%a2,8000dd96 <osEE_scheduler_task_terminated+0x88>
        osEE_task_end(p_tdb_term);
8000dd76:	40 64       	mov.aa %a4,%a6
8000dd78:	b5 a2 04 00 	st.a [%sp]4,%a2
8000dd7c:	6d ff 36 ff 	call 8000dbe8 <osEE_task_end>
8000dd80:	99 a2 04 00 	ld.a %a2,[%sp]4
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
8000dd84:	4c c2       	ld.w %d15,[%a12]8
8000dd86:	6c d0       	st.w [%a13]0,%d15
  (*pp_first)       = p_to_free;
8000dd88:	b5 cd 08 00 	st.a [%a12]8,%a13
8000dd8c:	00 90       	ret 

        if (p_prev == NULL) {
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
8000dd8e:	cc c3       	ld.a %a15,[%a12]12
8000dd90:	c8 12       	ld.a %a2,[%a15]4
          p_ccb->p_curr           = p_tdb_to;
8000dd92:	f4 c2       	st.a [%a12],%a2
8000dd94:	00 90       	ret 
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
8000dd96:	0c f0       	ld.bu %d15,[%a15]0
8000dd98:	c2 ff       	add %d15,-1
8000dd9a:	28 0f       	st.b [%a15]0,%d15
8000dd9c:	3c f4       	j 8000dd84 <osEE_scheduler_task_terminated+0x76>

8000dd9e <osEE_scheduler_task_preemption_point>:
)
{
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000dd9e:	91 00 00 48 	movh.a %a4,32768
8000dda2:	99 4f 54 50 	ld.a %a15,[%a4]1364 <80000554 <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000dda6:	d9 44 54 50 	lea %a4,[%a4]1364 <80000554 <osEE_cdb_var>>
8000ddaa:	d9 f5 04 00 	lea %a5,[%a15]4 <80000554 <osEE_cdb_var>>
8000ddae:	6d ff 6f fe 	call 8000da8c <osEE_scheduler_core_rq_preempt_stk>

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
8000ddb2:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
8000ddb4:	bc 26       	jz.a %a2,8000ddc0 <osEE_scheduler_task_preemption_point+0x22>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
8000ddb6:	c8 05       	ld.a %a5,[%a15]0
8000ddb8:	40 24       	mov.aa %a4,%a2
8000ddba:	6d 00 b3 01 	call 8000e120 <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000ddbe:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
8000ddc0:	00 90       	ret 

8000ddc2 <osEE_scheduler_task_set_running>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000ddc2:	91 00 00 f8 	movh.a %a15,32768
8000ddc6:	99 ff 54 50 	ld.a %a15,[%a15]1364 <80000554 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
8000ddca:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000ddcc:	99 42 0c 00 	ld.a %a2,[%a4]12 <80000554 <osEE_cdb_var>>
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
8000ddd0:	48 32       	ld.w %d2,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000ddd2:	0c 22       	ld.bu %d15,[%a2]2
8000ddd4:	1e 49       	jeq %d15,4,8000dde6 <osEE_scheduler_task_set_running+0x24>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
  }
  p_ccb->p_curr                 = p_tdb;
8000ddd6:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000ddd8:	bc 6c       	jz.a %a6,8000ddf0 <osEE_scheduler_task_set_running+0x2e>
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
8000ddda:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000dddc:	b5 65 04 00 	st.a [%a6]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000dde0:	74 62       	st.w [%a6],%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000dde2:	1d 00 9f 01 	j 8000e120 <osEE_change_context_from_running>
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000dde6:	82 2f       	mov %d15,2
8000dde8:	2c 22       	st.b [%a2]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
8000ddea:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000ddec:	bd 06 f7 ff 	jnz.a %a6,8000ddda <osEE_scheduler_task_set_running+0x18>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000ddf0:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000ddf2:	4c 20       	ld.w %d15,[%a2]0
8000ddf4:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000ddf6:	f4 26       	st.a [%a2],%a6
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
8000ddf8:	e8 32       	st.a [%a15]12,%a2
8000ddfa:	40 26       	mov.aa %a6,%a2
  } else {
    p_ccb->p_stk_sn             = p_sn;
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000ddfc:	b5 65 04 00 	st.a [%a6]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000de00:	74 62       	st.w [%a6],%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000de02:	1d 00 8f 01 	j 8000e120 <osEE_change_context_from_running>
	...

8000de08 <osEE_counter_insert_rel_trigger>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       delta
)
{
8000de08:	d4 46       	ld.a %a6,[%a4]
8000de0a:	4c 41       	ld.w %d15,[%a4]4
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000de0c:	cc 60       	ld.a %a15,[%a6]0
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000de0e:	19 65 04 00 	ld.w %d5,[%a6]4

  if ((maxallowedvalue - delta) >= value) {
8000de12:	52 43       	sub %d3,%d15,%d4
8000de14:	1b f5 ff 6f 	addi %d6,%d5,-1
8000de18:	42 46       	add %d6,%d4
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000de1a:	d4 54       	ld.a %a4,[%a5]
    when = value + delta;
8000de1c:	0b 54 00 20 	add %d2,%d4,%d5
8000de20:	5a f6       	sub %d15,%d6,%d15
8000de22:	0b 53 30 41 	lt.u %d4,%d3,%d5
8000de26:	2b 2f 40 44 	sel %d4,%d4,%d15,%d2
8000de2a:	59 44 04 00 	st.w [%a4]4,%d4
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000de2e:	82 12       	mov %d2,1
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000de30:	a0 03       	mov.a %a3,0
8000de32:	01 0f 90 34 	nez.a %d3,%a15
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000de36:	0b 45 50 61 	ge.u %d6,%d5,%d4
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000de3a:	26 32       	and %d2,%d3
8000de3c:	df 02 14 00 	jeq %d2,0,8000de64 <osEE_counter_insert_rel_trigger+0x5c>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000de40:	c8 02       	ld.a %a2,[%a15]0
8000de42:	4c 21       	ld.w %d15,[%a2]4

    if (current_when > counter_value) {
8000de44:	7f f5 15 80 	jge.u %d5,%d15,8000de6e <osEE_counter_insert_rel_trigger+0x66>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000de48:	02 62       	mov %d2,%d6
8000de4a:	0b f4 c0 22 	or.ge.u %d2,%d4,%d15
8000de4e:	02 2f       	mov %d15,%d2
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000de50:	82 02       	mov %d2,0
  while ((p_current != NULL) && work_not_done) {
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;

    if (current_when > counter_value) {
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000de52:	6e f4       	jz %d15,8000de3a <osEE_counter_insert_rel_trigger+0x32>
      if ((when <= counter_value) && (when >= current_when)) {
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000de54:	40 f3       	mov.aa %a3,%a15
8000de56:	cc 20       	ld.a %a15,[%a2]0
8000de58:	82 12       	mov %d2,1
8000de5a:	01 0f 90 34 	nez.a %d3,%a15
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000de5e:	26 32       	and %d2,%d3
8000de60:	df 02 f0 ff 	jne %d2,0,8000de40 <osEE_counter_insert_rel_trigger+0x38>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000de64:	bc 3b       	jz.a %a3,8000de7a <osEE_counter_insert_rel_trigger+0x72>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000de66:	d4 32       	ld.a %a2,[%a3]
8000de68:	f4 25       	st.a [%a2],%a5
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000de6a:	ec 40       	st.a [%a4]0,%a15
8000de6c:	00 90       	ret 
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000de6e:	0b f4 50 f1 	ge.u %d15,%d4,%d15
8000de72:	26 6f       	and %d15,%d6
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000de74:	82 02       	mov %d2,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000de76:	6e e2       	jz %d15,8000de3a <osEE_counter_insert_rel_trigger+0x32>
8000de78:	3c ee       	j 8000de54 <osEE_counter_insert_rel_trigger+0x4c>
  }

  if (p_previous != NULL) {
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000de7a:	f4 65       	st.a [%a6],%a5
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000de7c:	ec 40       	st.a [%a4]0,%a15
8000de7e:	00 90       	ret 

8000de80 <osEE_counter_insert_abs_trigger>:
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       when
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
8000de80:	d4 44       	ld.a %a4,[%a4]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000de82:	cc 40       	ld.a %a15,[%a4]0
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000de84:	d4 56       	ld.a %a6,[%a5]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
8000de86:	19 45 04 00 	ld.w %d5,[%a4]4
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000de8a:	82 12       	mov %d2,1

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000de8c:	59 64 04 00 	st.w [%a6]4,%d4
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000de90:	a0 03       	mov.a %a3,0
8000de92:	01 0f 90 34 	nez.a %d3,%a15
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000de96:	0b 45 50 61 	ge.u %d6,%d5,%d4
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000de9a:	26 32       	and %d2,%d3
8000de9c:	df 02 14 00 	jeq %d2,0,8000dec4 <osEE_counter_insert_abs_trigger+0x44>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000dea0:	c8 02       	ld.a %a2,[%a15]0
8000dea2:	4c 21       	ld.w %d15,[%a2]4

    if (current_when > counter_value) {
8000dea4:	7f f5 15 80 	jge.u %d5,%d15,8000dece <osEE_counter_insert_abs_trigger+0x4e>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000dea8:	02 62       	mov %d2,%d6
8000deaa:	0b f4 c0 22 	or.ge.u %d2,%d4,%d15
8000deae:	02 2f       	mov %d15,%d2
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000deb0:	82 02       	mov %d2,0
  while ((p_current != NULL) && work_not_done) {
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;

    if (current_when > counter_value) {
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000deb2:	6e f4       	jz %d15,8000de9a <osEE_counter_insert_abs_trigger+0x1a>
8000deb4:	40 f3       	mov.aa %a3,%a15
      if ((when <= counter_value) && (when >= current_when)) {
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000deb6:	cc 20       	ld.a %a15,[%a2]0
8000deb8:	82 12       	mov %d2,1
8000deba:	01 0f 90 34 	nez.a %d3,%a15
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000debe:	26 32       	and %d2,%d3
8000dec0:	df 02 f0 ff 	jne %d2,0,8000dea0 <osEE_counter_insert_abs_trigger+0x20>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000dec4:	bc 3b       	jz.a %a3,8000deda <osEE_counter_insert_abs_trigger+0x5a>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000dec6:	d4 32       	ld.a %a2,[%a3]
8000dec8:	f4 25       	st.a [%a2],%a5
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000deca:	ec 60       	st.a [%a6]0,%a15
8000decc:	00 90       	ret 
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000dece:	0b f4 50 f1 	ge.u %d15,%d4,%d15
8000ded2:	26 6f       	and %d15,%d6
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000ded4:	82 02       	mov %d2,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000ded6:	6e e2       	jz %d15,8000de9a <osEE_counter_insert_abs_trigger+0x1a>
8000ded8:	3c ee       	j 8000deb4 <osEE_counter_insert_abs_trigger+0x34>
  }

  if (p_previous != NULL) {
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000deda:	f4 45       	st.a [%a4],%a5
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000dedc:	ec 60       	st.a [%a6]0,%a15
8000dede:	00 90       	ret 

8000dee0 <osEE_counter_cancel_trigger>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
8000dee0:	cc 40       	ld.a %a15,[%a4]0
  osEE_counter_cancel_trigger
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db
)
{
8000dee2:	80 53       	mov.d %d3,%a5
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb  = p_trigger_db->p_trigger_cb;
8000dee4:	d4 52       	ld.a %a2,[%a5]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000dee6:	4c f0       	ld.w %d15,[%a15]0

  if (p_current == p_trigger_db) {
8000dee8:	3e 3b       	jeq %d15,%d3,8000defe <osEE_counter_cancel_trigger+0x1e>
    p_counter_cb->trigger_queue = p_trigger_cb->p_next;
  } else {
    P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_previous;
    do {
      p_previous = p_current;
      p_current  = p_current->p_trigger_cb->p_next;
8000deea:	60 f3       	mov.a %a3,%d15
8000deec:	cc 30       	ld.a %a15,[%a3]0
8000deee:	4c f0       	ld.w %d15,[%a15]0
    } while ((p_current != NULL) && (p_current != p_trigger_db));
8000def0:	8b 0f 20 22 	ne %d2,%d15,0
8000def4:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000def8:	df 02 f9 ff 	jne %d2,0,8000deea <osEE_counter_cancel_trigger+0xa>

    if (p_current != NULL) {
8000defc:	6e 03       	jz %d15,8000df02 <osEE_counter_cancel_trigger+0x22>
      /* Remove p_trigger_db from the list */
      p_previous->p_trigger_cb->p_next = p_trigger_cb->p_next;
8000defe:	4c 20       	ld.w %d15,[%a2]0
8000df00:	68 0f       	st.w [%a15]0,%d15
8000df02:	00 90       	ret 

8000df04 <osEE_counter_increment>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb = p_counter_db->p_counter_cb;
8000df04:	d4 47       	ld.a %a7,[%a4]
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
8000df06:	19 43 04 00 	ld.w %d3,[%a4]4
            to not have nested critical sections.
            To handle possible races due to cycling triggers a state
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;
8000df0a:	cc 70       	ld.a %a15,[%a7]0
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
8000df0c:	19 72 04 00 	ld.w %d2,[%a7]4
FUNC(void, OS_CODE)
  osEE_counter_increment
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
8000df10:	20 08       	sub.a %sp,8
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
      counter_value       = 0U;
      p_counter_cb->value = 0U;
    } else {
      ++p_counter_cb->value;
8000df12:	9a 12       	add %d15,%d2,1
8000df14:	0b 32 30 21 	lt.u %d2,%d2,%d3
8000df18:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000df1c:	59 72 04 00 	st.w [%a7]4,%d2
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;

    if (p_triggered_db != NULL) {
8000df20:	bc f4       	jz.a %a15,8000df28 <osEE_counter_increment+0x24>
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;
8000df22:	c8 02       	ld.a %a2,[%a15]0

      if (p_triggered_cb->when == counter_value) {
8000df24:	4c 21       	ld.w %d15,[%a2]4
8000df26:	3e 22       	jeq %d15,%d2,8000df2a <osEE_counter_increment+0x26>
8000df28:	00 90       	ret 
8000df2a:	40 23       	mov.aa %a3,%a2
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
8000df2c:	82 32       	mov %d2,3
8000df2e:	3c 06       	j 8000df3a <osEE_counter_increment+0x36>
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
          (p_current->p_trigger_cb->when == counter_value));
8000df30:	d4 56       	ld.a %a6,[%a5]
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
8000df32:	19 63 04 00 	ld.w %d3,[%a6]4
8000df36:	7e 37       	jne %d15,%d3,8000df44 <osEE_counter_increment+0x40>
8000df38:	40 63       	mov.aa %a3,%a6
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
8000df3a:	d4 35       	ld.a %a5,[%a3]
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
8000df3c:	e9 32 08 00 	st.b [%a3]8,%d2
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
          (p_current->p_trigger_cb->when == counter_value));
8000df40:	bd 05 f8 ff 	jnz.a %a5,8000df30 <osEE_counter_increment+0x2c>

        /* I set the end of handled queue */
        p_previous->p_trigger_cb->p_next = NULL;
8000df44:	82 0f       	mov %d15,0
8000df46:	6c 30       	st.w [%a3]0,%d15
8000df48:	91 10 00 d8 	movh.a %a13,32769

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);

      if (p_sn != NULL) {
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000df4c:	7b 00 00 98 	movh %d9,32768
8000df50:	40 4e       	mov.aa %a14,%a4

        /* I set the end of handled queue */
        p_previous->p_trigger_cb->p_next = NULL;
        /* I set the head of the trigger queue to the current value
           (maybe NULL) */
        p_counter_cb->trigger_queue = p_current;
8000df52:	f4 75       	st.a [%a7],%a5
8000df54:	d9 dd f0 dd 	lea %a13,[%a13]-8336 <8000df70 <osEE_counter_increment+0x6c>>
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
8000df58:	82 08       	mov %d8,0

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);

      if (p_sn != NULL) {
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000df5a:	1b 09 53 90 	addi %d9,%d9,1328
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
  switch (p_action->type) {
8000df5e:	39 ff 18 00 	ld.bu %d15,[%a15]24
#endif /* OSEE_HAS_ALARMS || OSEE_HAS_SCHEDULE_TABLES */

          /* Prepare next trigger to be handled here, before actually handle
           * the current one, otherwise cycling triggers will mess with the
           * list of triggers that have to be handled now */
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
8000df62:	d4 2c       	ld.a %a12,[%a2]
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
8000df64:	e9 a8 07 00 	st.b [%sp]7,%d8
  switch (p_action->type) {
8000df68:	ff 4f 10 80 	jge.u %d15,4,8000df88 <osEE_counter_increment+0x84>
8000df6c:	90 d2       	addsc.a %a2,%a13,%d15,2
8000df6e:	dc 02       	ji %a2
8000df70:	1d 00 29 00 	j 8000dfc2 <osEE_counter_increment+0xbe>
8000df74:	1d 00 15 00 	j 8000df9e <osEE_counter_increment+0x9a>
8000df78:	1d 00 04 00 	j 8000df80 <osEE_counter_increment+0x7c>
8000df7c:	1d 00 1e 00 	j 8000dfb8 <osEE_counter_increment+0xb4>
      }
    }
    break;
#endif /* OSEE_HAS_EVENTS */
    case OSEE_ACTION_COUNTER:
      osEE_counter_increment(p_action->param.p_counter_db);
8000df80:	c8 44       	ld.a %a4,[%a15]16
8000df82:	6d ff c1 ff 	call 8000df04 <osEE_counter_increment>
8000df86:	c8 02       	ld.a %a2,[%a15]0
  /* Re-enter in critical section to reinsert alarm-trigger if needed */
  p_cdb = osEE_lock_and_get_curr_core();

  p_trigger_to_be_handled_cb = p_trigger_to_be_handled_db->p_trigger_cb;

  if (p_trigger_to_be_handled_cb->status == OSEE_TRIGGER_EXPIRED) {
8000df88:	0c 28       	ld.bu %d15,[%a2]8
8000df8a:	1e 36       	jeq %d15,3,8000df96 <osEE_counter_increment+0x92>
#elif (defined(OSEE_HAS_SCHEDULE_TABLES))
          osEE_counter_handle_st_expiry_point(p_counter_db,
            p_trigger_to_be_handled_db);
#endif /* OSEE_COUNTER_TRIGGER_TYPES elif OSEE_HAS_ALARMS elif
          OSEE_HAS_SCHEDULE_TABLES */
        } while (p_triggered_db != NULL);
8000df8c:	bd 0c ce 7f 	jz.a %a12,8000df28 <osEE_counter_increment+0x24>
8000df90:	d4 c2       	ld.a %a2,[%a12]
8000df92:	40 cf       	mov.aa %a15,%a12
8000df94:	3c e5       	j 8000df5e <osEE_counter_increment+0x5a>
  p_cdb = osEE_lock_and_get_curr_core();

  p_trigger_to_be_handled_cb = p_trigger_to_be_handled_db->p_trigger_cb;

  if (p_trigger_to_be_handled_cb->status == OSEE_TRIGGER_EXPIRED) {
    CONST(TickType, AUTOMATIC) cycle = osEE_alarm_get_cb(
8000df96:	4c 23       	ld.w %d15,[%a2]12
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
8000df98:	ee 23       	jnz %d15,8000dfde <osEE_counter_increment+0xda>
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
      osEE_counter_insert_rel_trigger(p_counter_db,
        p_trigger_to_be_handled_db, cycle);
    } else {
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_INACTIVE;
8000df9a:	2c 28       	st.b [%a2]8,%d15
8000df9c:	3c f8       	j 8000df8c <osEE_counter_increment+0x88>
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb = p_action->param.p_tdb;
      CONST(EventMaskType, AUTOMATIC)
        mask = p_action->param.mask;

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);
8000df9e:	c8 34       	ld.a %a4,[%a15]12
8000dfa0:	48 54       	ld.w %d4,[%a15]20
8000dfa2:	d9 a5 07 00 	lea %a5,[%sp]7
8000dfa6:	6d ff 2d fe 	call 8000dc00 <osEE_task_event_set_mask>

      if (p_sn != NULL) {
8000dfaa:	bc 2a       	jz.a %a2,8000dfbe <osEE_counter_increment+0xba>
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000dfac:	60 94       	mov.a %a4,%d9
8000dfae:	40 25       	mov.aa %a5,%a2
8000dfb0:	6d ff 8d fe 	call 8000dcca <osEE_scheduler_task_unblocked>
8000dfb4:	c8 02       	ld.a %a2,[%a15]0
8000dfb6:	3c e9       	j 8000df88 <osEE_counter_increment+0x84>
      CONST(OsEE_os_context, AUTOMATIC)
        prev_os_context = p_ccb->os_context;

      p_ccb->os_context = OSEE_ALARMCALLBACK_CTX;
#endif /* OSEE_HAS_CONTEXT */
      p_action->param.f();
8000dfb8:	c8 22       	ld.a %a2,[%a15]8
8000dfba:	2d 02 00 00 	calli %a2
8000dfbe:	c8 02       	ld.a %a2,[%a15]0
8000dfc0:	3c e4       	j 8000df88 <osEE_counter_increment+0x84>
  VAR(StatusType, AUTOMATIC) ev = E_OK;
  switch (p_action->type) {
    case OSEE_ACTION_TASK:
    {
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb     = p_action->param.p_tdb;
8000dfc2:	4c f3       	ld.w %d15,[%a15]12

      ev = osEE_task_activated(p_tdb);
8000dfc4:	60 f4       	mov.a %a4,%d15
8000dfc6:	6d ff 05 fe 	call 8000dbd0 <osEE_task_activated>
8000dfca:	e9 a2 07 00 	st.b [%sp]7,%d2
      if (ev == E_OK) {
8000dfce:	df 02 f8 ff 	jne %d2,0,8000dfbe <osEE_counter_increment+0xba>
        (void)osEE_scheduler_task_insert(osEE_get_kernel(), p_tdb);
8000dfd2:	60 94       	mov.a %a4,%d9
8000dfd4:	60 f5       	mov.a %a5,%d15
8000dfd6:	6d ff 66 fe 	call 8000dca2 <osEE_scheduler_task_insert>
8000dfda:	c8 02       	ld.a %a2,[%a15]0
8000dfdc:	3c d6       	j 8000df88 <osEE_counter_increment+0x84>
8000dfde:	d4 e7       	ld.a %a7,[%a14]
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
      /* Reinsert the trigger in timer wheel as relative with delta equal to
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
8000dfe0:	82 22       	mov %d2,2
8000dfe2:	e9 22 08 00 	st.b [%a2]8,%d2
8000dfe6:	19 e2 04 00 	ld.w %d2,[%a14]4
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000dfea:	19 75 04 00 	ld.w %d5,[%a7]4

  if ((maxallowedvalue - delta) >= value) {
8000dfee:	0b f2 80 40 	sub %d4,%d2,%d15
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000dff2:	d4 73       	ld.a %a3,[%a7]
    when = value + delta;
8000dff4:	46 02       	not %d2
8000dff6:	0b 54 30 31 	lt.u %d3,%d4,%d5
8000dffa:	42 5f       	add %d15,%d5
8000dffc:	2b 2f 00 43 	cadd %d4,%d3,%d15,%d2
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000e000:	59 24 04 00 	st.w [%a2]4,%d4
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000e004:	82 12       	mov %d2,1
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000e006:	a0 06       	mov.a %a6,0
8000e008:	01 03 90 34 	nez.a %d3,%a3
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000e00c:	0b 45 50 61 	ge.u %d6,%d5,%d4
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000e010:	26 32       	and %d2,%d3
8000e012:	df 02 14 00 	jeq %d2,0,8000e03a <osEE_counter_increment+0x136>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000e016:	d4 35       	ld.a %a5,[%a3]
8000e018:	4c 51       	ld.w %d15,[%a5]4

    if (current_when > counter_value) {
8000e01a:	7f f5 15 80 	jge.u %d5,%d15,8000e044 <osEE_counter_increment+0x140>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000e01e:	02 62       	mov %d2,%d6
8000e020:	0b f4 c0 22 	or.ge.u %d2,%d4,%d15
8000e024:	02 2f       	mov %d15,%d2
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000e026:	82 02       	mov %d2,0
  while ((p_current != NULL) && work_not_done) {
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;

    if (current_when > counter_value) {
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000e028:	6e f4       	jz %d15,8000e010 <osEE_counter_increment+0x10c>
      if ((when <= counter_value) && (when >= current_when)) {
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000e02a:	40 36       	mov.aa %a6,%a3
8000e02c:	d4 53       	ld.a %a3,[%a5]
8000e02e:	82 12       	mov %d2,1
8000e030:	01 03 90 34 	nez.a %d3,%a3
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000e034:	26 32       	and %d2,%d3
8000e036:	df 02 f0 ff 	jne %d2,0,8000e016 <osEE_counter_increment+0x112>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000e03a:	bc 6b       	jz.a %a6,8000e050 <osEE_counter_increment+0x14c>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000e03c:	d4 64       	ld.a %a4,[%a6]
8000e03e:	ec 40       	st.a [%a4]0,%a15
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000e040:	f4 23       	st.a [%a2],%a3
8000e042:	3c a5       	j 8000df8c <osEE_counter_increment+0x88>
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000e044:	0b f4 50 f1 	ge.u %d15,%d4,%d15
8000e048:	26 6f       	and %d15,%d6
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000e04a:	82 02       	mov %d2,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000e04c:	6e e2       	jz %d15,8000e010 <osEE_counter_increment+0x10c>
8000e04e:	3c ee       	j 8000e02a <osEE_counter_increment+0x126>
  }

  if (p_previous != NULL) {
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000e050:	ec 70       	st.a [%a7]0,%a15
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000e052:	f4 23       	st.a [%a2],%a3
8000e054:	3c 9c       	j 8000df8c <osEE_counter_increment+0x88>
	...

8000e058 <osEE_alarm_set_rel>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      increment,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
8000e058:	cc 50       	ld.a %a15,[%a5]0
8000e05a:	02 4f       	mov %d15,%d4
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
8000e05c:	82 72       	mov %d2,7
    counter_core_id = p_counter_db->core_id;
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000e05e:	08 83       	ld.bu %d3,[%a15]8
8000e060:	bf 23 03 80 	jlt.u %d3,2,8000e066 <osEE_alarm_set_rel+0xe>
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000e064:	00 90       	ret 
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
8000e066:	68 35       	st.w [%a15]12,%d5
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
8000e068:	df 13 17 80 	jne %d3,1,8000e096 <osEE_alarm_set_rel+0x3e>
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000e06c:	d4 42       	ld.a %a2,[%a4]
8000e06e:	19 44 04 00 	ld.w %d4,[%a4]4
8000e072:	19 23 04 00 	ld.w %d3,[%a2]4

  if ((maxallowedvalue - delta) >= value) {
8000e076:	0b f4 80 50 	sub %d5,%d4,%d15
8000e07a:	1b f3 ff 2f 	addi %d2,%d3,-1
8000e07e:	42 f2       	add %d2,%d15
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
8000e080:	a2 42       	sub %d2,%d4
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
8000e082:	42 3f       	add %d15,%d3
8000e084:	0b 35 30 31 	lt.u %d3,%d5,%d3
8000e088:	2b f2 40 23 	sel %d2,%d3,%d2,%d15
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       'here' when based on increment */
    p_trigger_cb->when   = osEE_counter_eval_when(p_counter_db, increment);
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000e08c:	82 4f       	mov %d15,4
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       'here' when based on increment */
    p_trigger_cb->when   = osEE_counter_eval_when(p_counter_db, increment);
8000e08e:	68 12       	st.w [%a15]4,%d2
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000e090:	28 8f       	st.b [%a15]8,%d15

    ev = E_OK;
8000e092:	82 02       	mov %d2,0
8000e094:	00 90       	ret 
  } else {
    p_alarm_cb->cycle = cycle;
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000e096:	82 2f       	mov %d15,2
8000e098:	28 8f       	st.b [%a15]8,%d15
 
    osEE_counter_insert_rel_trigger(
8000e09a:	6d ff b7 fe 	call 8000de08 <osEE_counter_insert_rel_trigger>
      p_counter_db, p_trigger_db, increment
    );
 
    ev = E_OK;
8000e09e:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000e0a0:	00 90       	ret 

8000e0a2 <osEE_alarm_set_abs>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      start,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
8000e0a2:	cc 50       	ld.a %a15,[%a5]0
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
8000e0a4:	82 72       	mov %d2,7
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000e0a6:	0c f8       	ld.bu %d15,[%a15]8
8000e0a8:	bf 2f 03 80 	jlt.u %d15,2,8000e0ae <osEE_alarm_set_abs+0xc>
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000e0ac:	00 90       	ret 
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
8000e0ae:	68 35       	st.w [%a15]12,%d5
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
8000e0b0:	1e 17       	jeq %d15,1,8000e0be <osEE_alarm_set_abs+0x1c>

    ev = E_OK;
  } else {
    p_alarm_cb->cycle = cycle;
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000e0b2:	82 2f       	mov %d15,2
8000e0b4:	28 8f       	st.b [%a15]8,%d15

    osEE_counter_insert_abs_trigger(
8000e0b6:	6d ff e5 fe 	call 8000de80 <osEE_counter_insert_abs_trigger>
      p_counter_db, p_trigger_db, start
    );

    ev = E_OK;
8000e0ba:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000e0bc:	00 90       	ret 
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       here 'when' based on start */
    p_trigger_cb->when   = start;
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000e0be:	82 4f       	mov %d15,4
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       here 'when' based on start */
    p_trigger_cb->when   = start;
8000e0c0:	68 14       	st.w [%a15]4,%d4
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000e0c2:	28 8f       	st.b [%a15]8,%d15

    ev = E_OK;
8000e0c4:	82 02       	mov %d2,0
8000e0c6:	00 90       	ret 

8000e0c8 <osEE_alarm_cancel>:
{
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000e0c8:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
8000e0ca:	99 42 04 00 	ld.a %a2,[%a4]4
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
    ev = E_OS_NOFUNC;
8000e0ce:	82 52       	mov %d2,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000e0d0:	0c f8       	ld.bu %d15,[%a15]8
8000e0d2:	bf 2f 0e 80 	jlt.u %d15,2,8000e0ee <osEE_alarm_cancel+0x26>
    ev = E_OS_NOFUNC;
  } else if (p_trigger_cb->status >= OSEE_TRIGGER_EXPIRED) {
8000e0d6:	1e 25       	jeq %d15,2,8000e0e0 <osEE_alarm_cancel+0x18>
    p_trigger_cb->status = OSEE_TRIGGER_CANCELED;
8000e0d8:	82 1f       	mov %d15,1
8000e0da:	28 8f       	st.b [%a15]8,%d15
    ev = E_OK;
8000e0dc:	82 02       	mov %d2,0
8000e0de:	00 90       	ret 
  } else {
    p_trigger_cb->status = OSEE_TRIGGER_INACTIVE;
8000e0e0:	82 0f       	mov %d15,0
8000e0e2:	40 45       	mov.aa %a5,%a4
8000e0e4:	28 8f       	st.b [%a15]8,%d15
    osEE_counter_cancel_trigger(p_counter_db, p_trigger_db);
8000e0e6:	40 24       	mov.aa %a4,%a2
8000e0e8:	6d ff fc fe 	call 8000dee0 <osEE_counter_cancel_trigger>
    ev = E_OK;
8000e0ec:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000e0ee:	00 90       	ret 

8000e0f0 <osEE_alarm_get>:
{
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000e0f0:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
8000e0f2:	99 42 04 00 	ld.a %a2,[%a4]4
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
    ev = E_OS_NOFUNC;
8000e0f6:	82 52       	mov %d2,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000e0f8:	0c f8       	ld.bu %d15,[%a15]8
8000e0fa:	bf 2f 12 80 	jlt.u %d15,2,8000e11e <osEE_alarm_get+0x2e>
    ev = E_OS_NOFUNC;
  } else {
    *p_tick = osEE_counter_eval_delta(p_counter_db, p_trigger_cb->when);
8000e0fe:	48 13       	ld.w %d3,[%a15]4
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000e100:	cc 20       	ld.a %a15,[%a2]0
8000e102:	4c 21       	ld.w %d15,[%a2]4
8000e104:	1b 13 00 40 	addi %d4,%d3,1
8000e108:	48 12       	ld.w %d2,[%a15]4
8000e10a:	42 4f       	add %d15,%d4

  if (when > value) {
    delta = when - value;
  } else {
    delta = (maxallowedvalue - value) + when + 1U;
8000e10c:	a2 2f       	sub %d15,%d2
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if (when > value) {
    delta = when - value;
8000e10e:	0b 23 80 40 	sub %d4,%d3,%d2
8000e112:	0b 32 50 21 	ge.u %d2,%d2,%d3
8000e116:	2b 4f 40 f2 	sel %d15,%d2,%d15,%d4
8000e11a:	6c 50       	st.w [%a5]0,%d15
    ev = E_OK;
8000e11c:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000e11e:	00 90       	ret 

8000e120 <osEE_change_context_from_running>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e120:	99 52 0c 00 	ld.a %a2,[%a5]12
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000e124:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000e126:	c8 16       	ld.a %a6,[%a15]4
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e128:	0c 22       	ld.bu %d15,[%a2]2
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000e12a:	40 54       	mov.aa %a4,%a5
8000e12c:	99 55 04 00 	ld.a %a5,[%a5]4
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e130:	1e 23       	jeq %d15,2,8000e136 <osEE_change_context_from_running+0x16>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
8000e132:	1d 00 8d 00 	j 8000e24c <osEE_hal_save_ctx_and_ready2stacked>
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000e136:	1d 00 6c 00 	j 8000e20e <osEE_hal_save_ctx_and_restore_ctx>

8000e13a <osEE_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e13a:	cc 53       	ld.a %a15,[%a5]12
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000e13c:	40 54       	mov.aa %a4,%a5
8000e13e:	99 55 04 00 	ld.a %a5,[%a5]4
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e142:	0c f2       	ld.bu %d15,[%a15]2
8000e144:	1e 23       	jeq %d15,2,8000e14a <osEE_change_context_from_task_end+0x10>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
8000e146:	1d 00 95 00 	j 8000e270 <osEE_hal_ready2stacked>
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000e14a:	1d 00 74 00 	j 8000e232 <osEE_hal_restore_ctx>

8000e14e <osEE_idle_task_terminate>:
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000e14e:	cc 40       	ld.a %a15,[%a4]0
{
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
8000e150:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000e154:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000e156:	cc 50       	ld.a %a15,[%a5]0
8000e158:	3c 02       	j 8000e15c <osEE_idle_task_terminate+0xe>
8000e15a:	60 ff       	mov.a %a15,%d15

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000e15c:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
8000e15e:	8b 0f 20 22 	ne %d2,%d15,0
8000e162:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000e166:	df 02 fa ff 	jne %d2,0,8000e15a <osEE_idle_task_terminate+0xc>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000e16a:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
8000e16c:	1d 00 63 00 	j 8000e232 <osEE_hal_restore_ctx>

8000e170 <osEE_cpu_startos>:
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000e170:	4d c0 e1 bf 	mfcr %d11,$core_id
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000e174:	91 00 00 f8 	movh.a %a15,32768
8000e178:	d9 ff 70 40 	lea %a15,[%a15]1328 <80000530 <osEE_kdb_var>>

#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_0) {
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_SYSTEM_TIMER))
    osEE_tc_stm_set_clockpersec();
8000e17c:	6d ff ad f5 	call 8000ccd6 <osEE_tc_stm_set_clockpersec>
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000e180:	48 28       	ld.w %d8,[%a15]8
8000e182:	c2 f8       	add %d8,-1
  for (i = 0U; i < tdb_size; ++i) {
8000e184:	df 08 2f 00 	jeq %d8,0,8000e1e2 <osEE_cpu_startos+0x72>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000e188:	8f 3b 00 b1 	and %d11,%d11,3
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
8000e18c:	7b 10 00 a8 	movh %d10,32769
8000e190:	c8 1c       	ld.a %a12,[%a15]4
8000e192:	8f bb 00 b0 	sh %d11,%d11,11
8000e196:	82 0f       	mov %d15,0
8000e198:	1b 4a 97 ac 	addi %d10,%d10,-13964
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000e19c:	bb f0 ff 9f 	mov.u %d9,65535
8000e1a0:	3c 04       	j 8000e1a8 <osEE_cpu_startos+0x38>
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000e1a2:	c2 1f       	add %d15,1
8000e1a4:	5f f8 1f 00 	jeq %d8,%d15,8000e1e2 <osEE_cpu_startos+0x72>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000e1a8:	90 cf       	addsc.a %a15,%a12,%d15,2
8000e1aa:	c8 04       	ld.a %a4,[%a15]0
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000e1ac:	39 42 14 00 	ld.bu %d2,[%a4]20
8000e1b0:	df 22 f9 ff 	jne %d2,2,8000e1a2 <osEE_cpu_startos+0x32>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
8000e1b4:	19 42 18 00 	ld.w %d2,[%a4]24
8000e1b8:	5f a2 17 00 	jeq %d2,%d10,8000e1e6 <osEE_cpu_startos+0x76>
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000e1bc:	b9 42 08 00 	ld.hu %d2,[%a4]8
8000e1c0:	5f 92 f1 7f 	jeq %d2,%d9,8000e1a2 <osEE_cpu_startos+0x32>
8000e1c4:	60 22       	mov.a %a2,%d2
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000e1c6:	39 42 1c 00 	ld.bu %d2,[%a4]28
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000e1ca:	d9 2f 00 08 	lea %a15,[%a2]-32768
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000e1ce:	c2 12       	add %d2,1
8000e1d0:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000e1d4:	11 4f 00 ff 	addih.a %a15,%a15,61444
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000e1d8:	a6 b2       	or %d2,%d11
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000e1da:	68 02       	st.w [%a15]0,%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000e1dc:	c2 1f       	add %d15,1
8000e1de:	5f f8 e5 ff 	jne %d8,%d15,8000e1a8 <osEE_cpu_startos+0x38>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000e1e2:	82 12       	mov %d2,1
8000e1e4:	00 90       	ret 
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
8000e1e6:	6d ff ed f3 	call 8000c9c0 <osEE_tc_initialize_system_timer>
8000e1ea:	3c dc       	j 8000e1a2 <osEE_cpu_startos+0x32>

8000e1ec <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e1ec:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000e1f0:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000e1f2:	0c 22       	ld.bu %d15,[%a2]2
8000e1f4:	1e 27       	jeq %d15,2,8000e202 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000e1f6:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000e1f8:	c8 1f       	ld.a %a15,[%a15]4
8000e1fa:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
8000e1fc:	1d 00 3a 00 	j 8000e270 <osEE_hal_ready2stacked>
8000e200:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
8000e202:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000e204:	c8 1f       	ld.a %a15,[%a15]4
8000e206:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000e208:	1d 00 15 00 	j 8000e232 <osEE_hal_restore_ctx>
8000e20c:	00 90       	ret 

8000e20e <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000e20e:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000e210:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000e214:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000e216:	4c 60       	ld.w %d15,[%a6]0
8000e218:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000e21c:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000e220:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000e224:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000e226:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000e22a:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
8000e22c:	1d 00 03 00 	j 8000e232 <osEE_hal_restore_ctx>
8000e230:	00 90       	ret 

8000e232 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
8000e232:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000e234:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
8000e236:	4c f2       	ld.w %d15,[%a15]8
8000e238:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000e23a:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000e23e:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
8000e242:	4c f0       	ld.w %d15,[%a15]0
8000e244:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
8000e246:	1d ff 93 fb 	j 8000d96c <osEE_scheduler_task_wrapper_restore>
8000e24a:	00 90       	ret 

8000e24c <osEE_hal_save_ctx_and_ready2stacked>:
8000e24c:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000e24e:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000e252:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000e254:	4c 60       	ld.w %d15,[%a6]0
8000e256:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000e25a:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000e25e:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000e262:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000e264:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000e268:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
8000e26a:	1d 00 03 00 	j 8000e270 <osEE_hal_ready2stacked>
8000e26e:	00 90       	ret 

8000e270 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000e270:	cc 50       	ld.a %a15,[%a5]0
8000e272:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
8000e274:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000e278:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000e27a:	d9 f2 f0 ff 	lea %a2,[%a15]-16
8000e27e:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000e280:	4c 50       	ld.w %d15,[%a5]0
8000e282:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000e286:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000e28a:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000e28e:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000e290:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000e294:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000e296:	1d ff 6f fb 	j 8000d974 <osEE_scheduler_task_wrapper_run>
8000e29a:	00 90       	ret 

8000e29c <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
8000e29c:	4d 40 e0 ff 	mfcr %d15,$psw
8000e2a0:	8f ff c7 f1 	andn %d15,%d15,127
8000e2a4:	cd 4f e0 0f 	mtcr $psw,%d15
8000e2a8:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000e2ac:	91 10 00 f8 	movh.a %a15,32769
8000e2b0:	d9 ff 2c 7e 	lea %a15,[%a15]-7700 <8000e1ec <osEE_tc_change_context_from_task_end>>
8000e2b4:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000e2b6:	00 80       	rfe 
8000e2b8:	00 90       	ret 

8000e2ba <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000e2ba:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
8000e2bc:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000e2c0:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
8000e2c4:	cc 40       	ld.a %a15,[%a4]0
8000e2c6:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000e2c8:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000e2cc:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000e2d0:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000e2d2:	8f c3 01 30 	sh %d3,%d3,28
8000e2d6:	a6 43       	or %d3,%d4
8000e2d8:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000e2da:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
8000e2dc:	bc f3       	jz.a %a15,8000e2e2 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
8000e2de:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
8000e2e0:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
8000e2e2:	cd 8f e3 0f 	mtcr $fcx,%d15
8000e2e6:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000e2ea:	cd 03 e0 0f 	mtcr $pcxi,%d3
8000e2ee:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
8000e2f2:	cc 40       	ld.a %a15,[%a4]0
8000e2f4:	4c f0       	ld.w %d15,[%a15]0
8000e2f6:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000e2f8:	91 00 00 48 	movh.a %a4,32768
8000e2fc:	d9 44 70 40 	lea %a4,[%a4]1328 <80000530 <osEE_kdb_var>>
8000e300:	d9 a5 04 00 	lea %a5,[%sp]4 <80000530 <osEE_kdb_var>>
8000e304:	6d ff 05 fd 	call 8000dd0e <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000e308:	d8 01       	ld.a %a15,[%sp]4
8000e30a:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000e30e:	1e 25       	jeq %d15,2,8000e318 <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
8000e310:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
8000e312:	1d ff 6d ff 	j 8000e1ec <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000e316:	3c 00       	j 8000e316 <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000e318:	40 24       	mov.aa %a4,%a2
8000e31a:	6d ff c1 ff 	call 8000e29c <osEE_tc_change_context_from_isr2_end>
8000e31e:	3c fc       	j 8000e316 <osEE_hal_terminate_ctx+0x5c>

8000e320 <__interrupt_1>:
8000e320:	0d 00 80 04 	dsync 
8000e324:	e0 01       	bisr 1
8000e326:	91 00 00 f7 	movh.a %a15,28672
8000e32a:	d9 ff 68 34 	lea %a15,[%a15]17640 <700044e8 <Cdisptab>>
8000e32e:	c8 2e       	ld.a %a14,[%a15]8
8000e330:	48 34       	ld.w %d4,[%a15]12
8000e332:	2d 0e 00 00 	calli %a14
8000e336:	0d 00 40 02 	rslcx 
8000e33a:	00 80       	rfe 

8000e33c <__trap_6>:
8000e33c:	0d 00 80 04 	dsync 
8000e340:	4d 00 e0 8f 	mfcr %d8,$pcxi
8000e344:	ef 78 04 00 	jz.t %d8,23,8000e34c <__trap_6+0x10>
8000e348:	0d 00 00 03 	enable 
8000e34c:	0d 00 00 02 	svlcx 
8000e350:	91 00 00 f7 	movh.a %a15,28672
8000e354:	19 f4 c0 44 	ld.w %d4,[%a15]19712 <70004d00 <Tdisptab+0x18>>
8000e358:	60 4f       	mov.a %a15,%d4
8000e35a:	02 f4       	mov %d4,%d15
8000e35c:	2d 0f 00 00 	calli %a15
8000e360:	0d 00 40 02 	rslcx 
8000e364:	00 80       	rfe 

8000e366 <atoi>:
8000e366:	a0 05       	mov.a %a5,0
8000e368:	3b a0 00 40 	mov %d4,10
8000e36c:	1d 00 9d 00 	j 8000e4a6 <strtol>

8000e370 <strchr>:
8000e370:	8f f4 0f 41 	and %d4,%d4,255
8000e374:	0c 40       	ld.bu %d15,[%a4]0
8000e376:	6e 06       	jz %d15,8000e382 <strchr+0x12>
8000e378:	3e 43       	jeq %d15,%d4,8000e37e <strchr+0xe>
8000e37a:	b0 14       	add.a %a4,1
8000e37c:	3c fc       	j 8000e374 <strchr+0x4>
8000e37e:	40 42       	mov.aa %a2,%a4
8000e380:	00 90       	ret 
8000e382:	80 4f       	mov.d %d15,%a4
8000e384:	ab 0f a0 f4 	seln %d15,%d4,%d15,0
8000e388:	60 f2       	mov.a %a2,%d15
8000e38a:	00 90       	ret 

8000e38c <strlen>:
8000e38c:	80 42       	mov.d %d2,%a4
8000e38e:	80 4f       	mov.d %d15,%a4
8000e390:	60 ff       	mov.a %a15,%d15
8000e392:	79 f3 00 00 	ld.b %d3,[%a15]0
8000e396:	76 33       	jz %d3,8000e39c <strlen+0x10>
8000e398:	c2 1f       	add %d15,1
8000e39a:	3c fb       	j 8000e390 <strlen+0x4>
8000e39c:	52 22       	sub %d2,%d15,%d2
8000e39e:	00 90       	ret 

8000e3a0 <_strtol_r>:
8000e3a0:	91 00 00 f7 	movh.a %a15,28672
8000e3a4:	99 f7 10 51 	ld.a %a7,[%a15]4432 <70001150 <__ctype_ptr__>>
8000e3a8:	40 52       	mov.aa %a2,%a5
8000e3aa:	79 2f 00 00 	ld.b %d15,[%a2]0
8000e3ae:	d9 2f 01 00 	lea %a15,[%a2]1
8000e3b2:	10 73       	addsc.a %a3,%a7,%d15,0
8000e3b4:	39 32 01 00 	ld.bu %d2,[%a3]1
8000e3b8:	6f 32 04 00 	jz.t %d2,3,8000e3c0 <_strtol_r+0x20>
8000e3bc:	40 f2       	mov.aa %a2,%a15
8000e3be:	3c f6       	j 8000e3aa <_strtol_r+0xa>
8000e3c0:	8b df 22 22 	ne %d2,%d15,45
8000e3c4:	f6 27       	jnz %d2,8000e3d2 <_strtol_r+0x32>
8000e3c6:	d9 2f 02 00 	lea %a15,[%a2]2 <80000002 <BootModeHeader0+0x2>>
8000e3ca:	79 2f 01 00 	ld.b %d15,[%a2]1 <80000001 <BootModeHeader0+0x1>>
8000e3ce:	82 12       	mov %d2,1
8000e3d0:	3c 09       	j 8000e3e2 <_strtol_r+0x42>
8000e3d2:	8b bf 22 52 	ne %d5,%d15,43
8000e3d6:	82 02       	mov %d2,0
8000e3d8:	f6 55       	jnz %d5,8000e3e2 <_strtol_r+0x42>
8000e3da:	79 2f 01 00 	ld.b %d15,[%a2]1 <80000001 <BootModeHeader0+0x1>>
8000e3de:	d9 2f 02 00 	lea %a15,[%a2]2 <80000002 <BootModeHeader0+0x2>>
8000e3e2:	8f 04 c1 51 	andn %d5,%d4,16
8000e3e6:	df 05 19 80 	jne %d5,0,8000e418 <_strtol_r+0x78>
8000e3ea:	8b 0f 23 32 	ne %d3,%d15,48
8000e3ee:	8b 04 00 62 	eq %d6,%d4,0
8000e3f2:	df 03 11 80 	jne %d3,0,8000e414 <_strtol_r+0x74>
8000e3f6:	79 f5 00 00 	ld.b %d5,[%a15]0 <70000000 <__DSPR0_START>>
8000e3fa:	ab 84 a0 46 	seln %d4,%d6,%d4,8
8000e3fe:	8f 05 c2 51 	andn %d5,%d5,32
8000e402:	8b 85 25 52 	ne %d5,%d5,88
8000e406:	f6 59       	jnz %d5,8000e418 <_strtol_r+0x78>
8000e408:	79 ff 01 00 	ld.b %d15,[%a15]1 <70000001 <__DSPR0_START+0x1>>
8000e40c:	3b 00 01 40 	mov %d4,16
8000e410:	b0 2f       	add.a %a15,2
8000e412:	3c 03       	j 8000e418 <_strtol_r+0x78>
8000e414:	ab a4 a0 46 	seln %d4,%d6,%d4,10
8000e418:	7b 00 00 68 	movh %d6,32768
8000e41c:	1b f6 ff 3f 	addi %d3,%d6,-1
8000e420:	2b 36 40 62 	sel %d6,%d2,%d6,%d3
8000e424:	4b 46 11 62 	div.u %e6,%d6,%d4
8000e428:	82 05       	mov %d5,0
8000e42a:	82 03       	mov %d3,0
8000e42c:	02 70       	mov %d0,%d7
8000e42e:	3b 70 03 10 	mov %d1,55
8000e432:	10 72       	addsc.a %a2,%a7,%d15,0
8000e434:	39 27 01 00 	ld.bu %d7,[%a2]1
8000e438:	6f 27 05 00 	jz.t %d7,2,8000e442 <_strtol_r+0xa2>
8000e43c:	1b 0f fd ff 	addi %d15,%d15,-48
8000e440:	3c 0a       	j 8000e454 <_strtol_r+0xb4>
8000e442:	8f 37 00 71 	and %d7,%d7,3
8000e446:	df 07 1b 00 	jeq %d7,0,8000e47c <_strtol_r+0xdc>
8000e44a:	8b 17 00 72 	eq %d7,%d7,1
8000e44e:	ab 71 85 77 	sel %d7,%d7,%d1,87
8000e452:	a2 7f       	sub %d15,%d7
8000e454:	7f 4f 14 00 	jge %d15,%d4,8000e47c <_strtol_r+0xdc>
8000e458:	0b 36 30 71 	lt.u %d7,%d6,%d3
8000e45c:	8b 05 20 75 	or.lt %d7,%d5,0
8000e460:	82 f5       	mov %d5,-1
8000e462:	f6 79       	jnz %d7,8000e474 <_strtol_r+0xd4>
8000e464:	0b 63 00 71 	eq %d7,%d3,%d6
8000e468:	0b f0 20 72 	and.lt %d7,%d0,%d15
8000e46c:	f6 74       	jnz %d7,8000e474 <_strtol_r+0xd4>
8000e46e:	03 43 0a 3f 	madd %d3,%d15,%d3,%d4
8000e472:	82 15       	mov %d5,1
8000e474:	79 ff 00 00 	ld.b %d15,[%a15]0
8000e478:	b0 1f       	add.a %a15,1
8000e47a:	3c dc       	j 8000e432 <_strtol_r+0x92>
8000e47c:	df f5 0b 80 	jne %d5,-1,8000e492 <_strtol_r+0xf2>
8000e480:	7b 00 00 38 	movh %d3,32768
8000e484:	9a f3       	add %d15,%d3,-1
8000e486:	2b f3 40 22 	sel %d2,%d2,%d3,%d15
8000e48a:	da 22       	mov %d15,34
8000e48c:	6c 40       	st.w [%a4]0,%d15
8000e48e:	7c 68       	jnz.a %a6,8000e49e <_strtol_r+0xfe>
8000e490:	00 90       	ret 
8000e492:	8b 03 00 f1 	rsub %d15,%d3,0
8000e496:	2b 3f 40 22 	sel %d2,%d2,%d15,%d3
8000e49a:	bc 65       	jz.a %a6,8000e4a4 <_strtol_r+0x104>
8000e49c:	76 53       	jz %d5,8000e4a2 <_strtol_r+0x102>
8000e49e:	d9 f5 ff ff 	lea %a5,[%a15]-1
8000e4a2:	f4 65       	st.a [%a6],%a5
8000e4a4:	00 90       	ret 

8000e4a6 <strtol>:
8000e4a6:	91 00 00 27 	movh.a %a2,28672
8000e4aa:	40 4f       	mov.aa %a15,%a4
8000e4ac:	99 24 18 51 	ld.a %a4,[%a2]4440 <70001158 <_impure_ptr>>
8000e4b0:	40 56       	mov.aa %a6,%a5
8000e4b2:	40 f5       	mov.aa %a5,%a15
8000e4b4:	1d ff 76 ff 	j 8000e3a0 <_strtol_r>

8000e4b8 <_vsprintf_r>:
8000e4b8:	20 68       	sub.a %sp,104
8000e4ba:	3b 80 20 f0 	mov %d15,520
8000e4be:	ac a6       	st.h [%sp]12,%d15
8000e4c0:	82 ff       	mov %d15,-1
8000e4c2:	06 ff       	sh %d15,-1
8000e4c4:	f4 a5       	st.a [%sp],%a5
8000e4c6:	b5 a5 10 00 	st.a [%sp]16,%a5
8000e4ca:	78 02       	st.w [%sp]8,%d15
8000e4cc:	78 05       	st.w [%sp]20,%d15
8000e4ce:	40 a5       	mov.aa %a5,%sp
8000e4d0:	82 ff       	mov %d15,-1
8000e4d2:	ac a7       	st.h [%sp]14,%d15
8000e4d4:	6d 00 12 00 	call 8000e4f8 <_svfprintf_r>
8000e4d8:	d8 00       	ld.a %a15,[%sp]0
8000e4da:	82 0f       	mov %d15,0
8000e4dc:	28 0f       	st.b [%a15]0,%d15
8000e4de:	00 90       	ret 

8000e4e0 <vsprintf>:
8000e4e0:	91 00 00 37 	movh.a %a3,28672
8000e4e4:	40 42       	mov.aa %a2,%a4
8000e4e6:	99 34 18 51 	ld.a %a4,[%a3]4440 <70001158 <_impure_ptr>>
8000e4ea:	40 5f       	mov.aa %a15,%a5
8000e4ec:	40 67       	mov.aa %a7,%a6
8000e4ee:	40 25       	mov.aa %a5,%a2
8000e4f0:	40 f6       	mov.aa %a6,%a15
8000e4f2:	1d ff e3 ff 	j 8000e4b8 <_vsprintf_r>
	...

8000e4f8 <_svfprintf_r>:
8000e4f8:	20 d0       	sub.a %sp,208
8000e4fa:	80 5b       	mov.d %d11,%a5
8000e4fc:	80 4c       	mov.d %d12,%a4
8000e4fe:	b5 a6 18 00 	st.a [%sp]24,%a6
8000e502:	40 7f       	mov.aa %a15,%a7
8000e504:	6d 00 c4 0f 	call 8001048c <_localeconv_r>
8000e508:	d4 22       	ld.a %a2,[%a2]
8000e50a:	40 24       	mov.aa %a4,%a2
8000e50c:	b5 a2 34 00 	st.a [%sp]52,%a2
8000e510:	6d ff 3e ff 	call 8000e38c <strlen>
8000e514:	60 b2       	mov.a %a2,%d11
8000e516:	59 a2 20 00 	st.w [%sp]32,%d2
8000e51a:	8c 26       	ld.h %d15,[%a2]12
8000e51c:	6f 7f 16 00 	jz.t %d15,7,8000e548 <_svfprintf_r+0x50>
8000e520:	4c 24       	ld.w %d15,[%a2]16
8000e522:	ee 13       	jnz %d15,8000e548 <_svfprintf_r+0x50>
8000e524:	60 c4       	mov.a %a4,%d12
8000e526:	3b 00 04 40 	mov %d4,64
8000e52a:	6d 00 b6 0f 	call 80010496 <_malloc_r>
8000e52e:	60 b3       	mov.a %a3,%d11
8000e530:	f4 32       	st.a [%a3],%a2
8000e532:	b5 32 10 00 	st.a [%a3]16,%a2
8000e536:	7c 26       	jnz.a %a2,8000e542 <_svfprintf_r+0x4a>
8000e538:	60 cf       	mov.a %a15,%d12
8000e53a:	da 0c       	mov %d15,12
8000e53c:	68 0f       	st.w [%a15]0,%d15
8000e53e:	82 f2       	mov %d2,-1
8000e540:	00 90       	ret 
8000e542:	60 b2       	mov.a %a2,%d11
8000e544:	da 40       	mov %d15,64
8000e546:	6c 25       	st.w [%a2]20,%d15
8000e548:	82 0f       	mov %d15,0
8000e54a:	d9 a2 10 20 	lea %a2,[%sp]144
8000e54e:	a0 03       	mov.a %a3,0
8000e550:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000e554:	78 19       	st.w [%sp]100,%d15
8000e556:	78 18       	st.w [%sp]96,%d15
8000e558:	78 05       	st.w [%sp]20,%d15
8000e55a:	78 0b       	st.w [%sp]44,%d15
8000e55c:	78 0c       	st.w [%sp]48,%d15
8000e55e:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000e562:	78 0e       	st.w [%sp]56,%d15
8000e564:	78 0a       	st.w [%sp]40,%d15
8000e566:	40 2e       	mov.aa %a14,%a2
8000e568:	99 ac 18 00 	ld.a %a12,[%sp]24
8000e56c:	79 cf 00 00 	ld.b %d15,[%a12]0
8000e570:	8b 0f 20 32 	ne %d3,%d15,0
8000e574:	8b 5f 22 34 	and.ne %d3,%d15,37
8000e578:	76 33       	jz %d3,8000e57e <_svfprintf_r+0x86>
8000e57a:	b0 1c       	add.a %a12,1
8000e57c:	3c f8       	j 8000e56c <_svfprintf_r+0x74>
8000e57e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e582:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000e586:	80 3f       	mov.d %d15,%a3
8000e588:	6e 23       	jz %d15,8000e5ce <_svfprintf_r+0xd6>
8000e58a:	19 a3 24 10 	ld.w %d3,[%sp]100
8000e58e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e592:	42 f3       	add %d3,%d15
8000e594:	59 a3 24 10 	st.w [%sp]100,%d3
8000e598:	19 a3 20 10 	ld.w %d3,[%sp]96
8000e59c:	f4 e3       	st.a [%a14],%a3
8000e59e:	c2 13       	add %d3,1
8000e5a0:	6c e1       	st.w [%a14]4,%d15
8000e5a2:	59 a3 20 10 	st.w [%sp]96,%d3
8000e5a6:	8b 83 80 32 	ge %d3,%d3,8
8000e5aa:	d9 ee 08 00 	lea %a14,[%a14]8
8000e5ae:	76 3b       	jz %d3,8000e5c4 <_svfprintf_r+0xcc>
8000e5b0:	60 c4       	mov.a %a4,%d12
8000e5b2:	60 b5       	mov.a %a5,%d11
8000e5b4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000e5b8:	6d 00 db 14 	call 80010f6e <__ssprint_r>
8000e5bc:	df 02 69 88 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000e5c0:	d9 ae 10 20 	lea %a14,[%sp]144
8000e5c4:	19 a2 28 00 	ld.w %d2,[%sp]40
8000e5c8:	42 f2       	add %d2,%d15
8000e5ca:	59 a2 28 00 	st.w [%sp]40,%d2
8000e5ce:	79 cf 00 00 	ld.b %d15,[%a12]0
8000e5d2:	df 0f 56 08 	jeq %d15,0,8000f67e <_svfprintf_r+0x1186>
8000e5d6:	82 0f       	mov %d15,0
8000e5d8:	82 02       	mov %d2,0
8000e5da:	e9 af 01 10 	st.b [%sp]65,%d15
8000e5de:	d9 c2 01 00 	lea %a2,[%a12]1
8000e5e2:	82 0f       	mov %d15,0
8000e5e4:	82 fe       	mov %d14,-1
8000e5e6:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e5ea:	82 0a       	mov %d10,0
8000e5ec:	79 22 00 00 	ld.b %d2,[%a2]0
8000e5f0:	d9 23 01 00 	lea %a3,[%a2]1
8000e5f4:	b5 a3 18 00 	st.a [%sp]24,%a3
8000e5f8:	59 a2 10 00 	st.w [%sp]16,%d2
8000e5fc:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e600:	1b 02 fe 3f 	addi %d3,%d2,-32
8000e604:	8b 93 a5 42 	ge.u %d4,%d3,89
8000e608:	df 04 19 84 	jne %d4,0,8000ee3a <_svfprintf_r+0x942>
8000e60c:	91 10 00 28 	movh.a %a2,32769
8000e610:	d9 22 5c 8e 	lea %a2,[%a2]-6628 <8000e61c <_svfprintf_r+0x124>>
8000e614:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000e618:	dc 07       	ji %a7
8000e61a:	00 00       	nop 
8000e61c:	1d 00 c3 00 	j 8000e7a2 <_svfprintf_r+0x2aa>
8000e620:	1d 00 0d 04 	j 8000ee3a <_svfprintf_r+0x942>
8000e624:	1d 00 0b 04 	j 8000ee3a <_svfprintf_r+0x942>
8000e628:	1d 00 c0 00 	j 8000e7a8 <_svfprintf_r+0x2b0>
8000e62c:	1d 00 07 04 	j 8000ee3a <_svfprintf_r+0x942>
8000e630:	1d 00 05 04 	j 8000ee3a <_svfprintf_r+0x942>
8000e634:	1d 00 03 04 	j 8000ee3a <_svfprintf_r+0x942>
8000e638:	1d 00 01 04 	j 8000ee3a <_svfprintf_r+0x942>
8000e63c:	1d 00 ff 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e640:	1d 00 fd 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e644:	1d 00 b5 00 	j 8000e7ae <_svfprintf_r+0x2b6>
8000e648:	1d 00 9c 00 	j 8000e780 <_svfprintf_r+0x288>
8000e64c:	1d 00 f7 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e650:	1d 00 b8 00 	j 8000e7c0 <_svfprintf_r+0x2c8>
8000e654:	1d 00 b9 00 	j 8000e7c6 <_svfprintf_r+0x2ce>
8000e658:	1d 00 f1 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e65c:	1d 00 de 00 	j 8000e818 <_svfprintf_r+0x320>
8000e660:	1d 00 df 00 	j 8000e81e <_svfprintf_r+0x326>
8000e664:	1d 00 dd 00 	j 8000e81e <_svfprintf_r+0x326>
8000e668:	1d 00 db 00 	j 8000e81e <_svfprintf_r+0x326>
8000e66c:	1d 00 d9 00 	j 8000e81e <_svfprintf_r+0x326>
8000e670:	1d 00 d7 00 	j 8000e81e <_svfprintf_r+0x326>
8000e674:	1d 00 d5 00 	j 8000e81e <_svfprintf_r+0x326>
8000e678:	1d 00 d3 00 	j 8000e81e <_svfprintf_r+0x326>
8000e67c:	1d 00 d1 00 	j 8000e81e <_svfprintf_r+0x326>
8000e680:	1d 00 cf 00 	j 8000e81e <_svfprintf_r+0x326>
8000e684:	1d 00 db 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e688:	1d 00 d9 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e68c:	1d 00 d7 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e690:	1d 00 d5 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e694:	1d 00 d3 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e698:	1d 00 d1 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e69c:	1d 00 cf 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6a0:	1d 00 cd 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6a4:	1d 00 cb 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6a8:	1d 00 c9 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6ac:	1d 00 f9 00 	j 8000e89e <_svfprintf_r+0x3a6>
8000e6b0:	1d 00 21 01 	j 8000e8f2 <_svfprintf_r+0x3fa>
8000e6b4:	1d 00 c3 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6b8:	1d 00 1d 01 	j 8000e8f2 <_svfprintf_r+0x3fa>
8000e6bc:	1d 00 bf 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6c0:	1d 00 bd 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6c4:	1d 00 bb 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6c8:	1d 00 b9 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6cc:	1d 00 c6 00 	j 8000e858 <_svfprintf_r+0x360>
8000e6d0:	1d 00 b5 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6d4:	1d 00 b3 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6d8:	1d 00 92 02 	j 8000ebfc <_svfprintf_r+0x704>
8000e6dc:	1d 00 af 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6e0:	1d 00 ad 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6e4:	1d 00 ab 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6e8:	1d 00 a9 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6ec:	1d 00 a7 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6f0:	1d 00 d0 02 	j 8000ec90 <_svfprintf_r+0x798>
8000e6f4:	1d 00 a3 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6f8:	1d 00 a1 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e6fc:	1d 00 4b 00 	j 8000e792 <_svfprintf_r+0x29a>
8000e700:	1d 00 9d 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e704:	1d 00 9b 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e708:	1d 00 99 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e70c:	1d 00 97 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e710:	1d 00 95 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e714:	1d 00 93 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e718:	1d 00 91 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e71c:	1d 00 8f 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e720:	1d 00 8d 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e724:	1d 00 8b 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e728:	1d 00 b0 00 	j 8000e888 <_svfprintf_r+0x390>
8000e72c:	1d 00 2f 00 	j 8000e78a <_svfprintf_r+0x292>
8000e730:	1d 00 e1 00 	j 8000e8f2 <_svfprintf_r+0x3fa>
8000e734:	1d 00 df 00 	j 8000e8f2 <_svfprintf_r+0x3fa>
8000e738:	1d 00 dd 00 	j 8000e8f2 <_svfprintf_r+0x3fa>
8000e73c:	1d 00 91 00 	j 8000e85e <_svfprintf_r+0x366>
8000e740:	1d 00 25 00 	j 8000e78a <_svfprintf_r+0x292>
8000e744:	1d 00 7b 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e748:	1d 00 79 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e74c:	1d 00 8c 00 	j 8000e864 <_svfprintf_r+0x36c>
8000e750:	1d 00 75 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e754:	1d 00 39 02 	j 8000ebc6 <_svfprintf_r+0x6ce>
8000e758:	1d 00 54 02 	j 8000ec00 <_svfprintf_r+0x708>
8000e75c:	1d 00 66 02 	j 8000ec28 <_svfprintf_r+0x730>
8000e760:	1d 00 90 00 	j 8000e880 <_svfprintf_r+0x388>
8000e764:	1d 00 6b 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e768:	1d 00 77 02 	j 8000ec56 <_svfprintf_r+0x75e>
8000e76c:	1d 00 67 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e770:	1d 00 92 02 	j 8000ec94 <_svfprintf_r+0x79c>
8000e774:	1d 00 63 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e778:	1d 00 61 03 	j 8000ee3a <_svfprintf_r+0x942>
8000e77c:	1d 00 a0 02 	j 8000ecbc <_svfprintf_r+0x7c4>
8000e780:	da 2b       	mov %d15,43
8000e782:	99 a2 18 00 	ld.a %a2,[%sp]24
8000e786:	1d ff 33 ff 	j 8000e5ec <_svfprintf_r+0xf4>
8000e78a:	e9 af 01 10 	st.b [%sp]65,%d15
8000e78e:	1d 00 8c 00 	j 8000e8a6 <_svfprintf_r+0x3ae>
8000e792:	e9 af 01 10 	st.b [%sp]65,%d15
8000e796:	7b 00 00 f8 	movh %d15,32768
8000e79a:	1b 4f c0 f0 	addi %d15,%d15,3076
8000e79e:	1d 00 95 02 	j 8000ecc8 <_svfprintf_r+0x7d0>
8000e7a2:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000e7a6:	3c ee       	j 8000e782 <_svfprintf_r+0x28a>
8000e7a8:	8f 1a 40 a1 	or %d10,%d10,1
8000e7ac:	3c eb       	j 8000e782 <_svfprintf_r+0x28a>
8000e7ae:	48 02       	ld.w %d2,[%a15]0
8000e7b0:	b0 4f       	add.a %a15,4
8000e7b2:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e7b6:	ff 02 e6 7f 	jge %d2,0,8000e782 <_svfprintf_r+0x28a>
8000e7ba:	32 52       	rsub %d2
8000e7bc:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e7c0:	8f 4a 40 a1 	or %d10,%d10,4
8000e7c4:	3c df       	j 8000e782 <_svfprintf_r+0x28a>
8000e7c6:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e7ca:	99 a2 18 00 	ld.a %a2,[%sp]24
8000e7ce:	79 32 00 00 	ld.b %d2,[%a3]0
8000e7d2:	b0 12       	add.a %a2,1
8000e7d4:	59 a2 10 00 	st.w [%sp]16,%d2
8000e7d8:	8b a2 02 32 	eq %d3,%d2,42
8000e7dc:	f6 33       	jnz %d3,8000e7e2 <_svfprintf_r+0x2ea>
8000e7de:	82 05       	mov %d5,0
8000e7e0:	3c 08       	j 8000e7f0 <_svfprintf_r+0x2f8>
8000e7e2:	48 0e       	ld.w %d14,[%a15]0
8000e7e4:	b5 a2 18 00 	st.a [%sp]24,%a2
8000e7e8:	b0 4f       	add.a %a15,4
8000e7ea:	8b fe 5f e3 	max %d14,%d14,-1
8000e7ee:	3c ca       	j 8000e782 <_svfprintf_r+0x28a>
8000e7f0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e7f4:	1b 02 fd 3f 	addi %d3,%d2,-48
8000e7f8:	ff a3 0a 80 	jge.u %d3,10,8000e80c <_svfprintf_r+0x314>
8000e7fc:	79 22 00 00 	ld.b %d2,[%a2]0
8000e800:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000e804:	59 a2 10 00 	st.w [%sp]16,%d2
8000e808:	b0 12       	add.a %a2,1
8000e80a:	3c f3       	j 8000e7f0 <_svfprintf_r+0x2f8>
8000e80c:	8b f5 5f e3 	max %d14,%d5,-1
8000e810:	b5 a2 18 00 	st.a [%sp]24,%a2
8000e814:	1d ff f4 fe 	j 8000e5fc <_svfprintf_r+0x104>
8000e818:	8f 0a 48 a1 	or %d10,%d10,128
8000e81c:	3c b3       	j 8000e782 <_svfprintf_r+0x28a>
8000e81e:	82 02       	mov %d2,0
8000e820:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e824:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e828:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e82c:	1b 02 fd 4f 	addi %d4,%d2,-48
8000e830:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000e834:	99 a2 18 00 	ld.a %a2,[%sp]24
8000e838:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000e83c:	b0 12       	add.a %a2,1
8000e83e:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e842:	79 32 00 00 	ld.b %d2,[%a3]0
8000e846:	b5 a2 18 00 	st.a [%sp]24,%a2
8000e84a:	59 a2 10 00 	st.w [%sp]16,%d2
8000e84e:	1b 02 fd 4f 	addi %d4,%d2,-48
8000e852:	bf a4 e9 ff 	jlt.u %d4,10,8000e824 <_svfprintf_r+0x32c>
8000e856:	3c dd       	j 8000e810 <_svfprintf_r+0x318>
8000e858:	8f 8a 40 a1 	or %d10,%d10,8
8000e85c:	3c 93       	j 8000e782 <_svfprintf_r+0x28a>
8000e85e:	8f 0a 44 a1 	or %d10,%d10,64
8000e862:	3c 90       	j 8000e782 <_svfprintf_r+0x28a>
8000e864:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e868:	79 33 00 00 	ld.b %d3,[%a3]0
8000e86c:	8b c3 26 32 	ne %d3,%d3,108
8000e870:	f6 35       	jnz %d3,8000e87a <_svfprintf_r+0x382>
8000e872:	b0 13       	add.a %a3,1
8000e874:	b5 a3 18 00 	st.a [%sp]24,%a3
8000e878:	3c 04       	j 8000e880 <_svfprintf_r+0x388>
8000e87a:	8f 0a 41 a1 	or %d10,%d10,16
8000e87e:	3c 82       	j 8000e782 <_svfprintf_r+0x28a>
8000e880:	8f 0a 42 a1 	or %d10,%d10,32
8000e884:	1d ff 7f ff 	j 8000e782 <_svfprintf_r+0x28a>
8000e888:	48 03       	ld.w %d3,[%a15]0
8000e88a:	d9 fc 04 00 	lea %a12,[%a15]4
8000e88e:	e9 a3 28 10 	st.b [%sp]104,%d3
8000e892:	82 03       	mov %d3,0
8000e894:	e9 a3 01 10 	st.b [%sp]65,%d3
8000e898:	60 ad       	mov.a %a13,%d10
8000e89a:	1d 00 dc 02 	j 8000ee52 <_svfprintf_r+0x95a>
8000e89e:	e9 af 01 10 	st.b [%sp]65,%d15
8000e8a2:	8f 0a 41 a1 	or %d10,%d10,16
8000e8a6:	60 ad       	mov.a %a13,%d10
8000e8a8:	6f 5a 07 00 	jz.t %d10,5,8000e8b6 <_svfprintf_r+0x3be>
8000e8ac:	d9 fc 08 00 	lea %a12,[%a15]8
8000e8b0:	09 f8 40 09 	ld.d %e8,[%a15]
8000e8b4:	3c 12       	j 8000e8d8 <_svfprintf_r+0x3e0>
8000e8b6:	d9 f2 04 00 	lea %a2,[%a15]4
8000e8ba:	6f 4a 05 00 	jz.t %d10,4,8000e8c4 <_svfprintf_r+0x3cc>
8000e8be:	40 2c       	mov.aa %a12,%a2
8000e8c0:	48 08       	ld.w %d8,[%a15]0
8000e8c2:	3c 09       	j 8000e8d4 <_svfprintf_r+0x3dc>
8000e8c4:	48 03       	ld.w %d3,[%a15]0
8000e8c6:	40 2c       	mov.aa %a12,%a2
8000e8c8:	0b 30 00 88 	mov %e8,%d3
8000e8cc:	6f 6a 06 00 	jz.t %d10,6,8000e8d8 <_svfprintf_r+0x3e0>
8000e8d0:	37 03 50 80 	extr %d8,%d3,0,16
8000e8d4:	0b 80 00 88 	mov %e8,%d8
8000e8d8:	82 13       	mov %d3,1
8000e8da:	ff 09 1d 02 	jge %d9,0,8000ed14 <_svfprintf_r+0x81c>
8000e8de:	32 59       	rsub %d9
8000e8e0:	32 58       	rsub %d8
8000e8e2:	3b d0 02 70 	mov %d7,45
8000e8e6:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000e8ea:	e9 a7 01 10 	st.b [%sp]65,%d7
8000e8ee:	1d 00 13 02 	j 8000ed14 <_svfprintf_r+0x81c>
8000e8f2:	e9 af 01 10 	st.b [%sp]65,%d15
8000e8f6:	4c f0       	ld.w %d15,[%a15]0
8000e8f8:	d9 fc 08 00 	lea %a12,[%a15]8
8000e8fc:	78 0b       	st.w [%sp]44,%d15
8000e8fe:	4c f1       	ld.w %d15,[%a15]4
8000e900:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000e904:	78 0c       	st.w [%sp]48,%d15
8000e906:	19 a5 30 00 	ld.w %d5,[%sp]48
8000e90a:	6d 00 02 13 	call 80010f0e <__fpclassifyd>
8000e90e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000e912:	19 a5 30 00 	ld.w %d5,[%sp]48
8000e916:	df 12 18 80 	jne %d2,1,8000e946 <_svfprintf_r+0x44e>
8000e91a:	d2 06       	mov %e6,0
8000e91c:	6d 00 36 1b 	call 80011f88 <__ltdf2>
8000e920:	ce 25       	jgez %d2,8000e92a <_svfprintf_r+0x432>
8000e922:	3b d0 02 30 	mov %d3,45
8000e926:	e9 a3 01 10 	st.b [%sp]65,%d3
8000e92a:	58 04       	ld.w %d15,[%sp]16
8000e92c:	7b 00 00 78 	movh %d7,32768
8000e930:	8b 8f 84 32 	ge %d3,%d15,72
8000e934:	1b 87 bf d0 	addi %d13,%d7,3064
8000e938:	df 03 17 80 	jne %d3,0,8000e966 <_svfprintf_r+0x46e>
8000e93c:	7b 00 00 78 	movh %d7,32768
8000e940:	1b 47 bf d0 	addi %d13,%d7,3060
8000e944:	3c 11       	j 8000e966 <_svfprintf_r+0x46e>
8000e946:	6d 00 e4 12 	call 80010f0e <__fpclassifyd>
8000e94a:	58 04       	ld.w %d15,[%sp]16
8000e94c:	df 02 13 80 	jne %d2,0,8000e972 <_svfprintf_r+0x47a>
8000e950:	7b 00 00 78 	movh %d7,32768
8000e954:	8b 8f 84 32 	ge %d3,%d15,72
8000e958:	1b 07 c0 d0 	addi %d13,%d7,3072
8000e95c:	f6 35       	jnz %d3,8000e966 <_svfprintf_r+0x46e>
8000e95e:	7b 00 00 78 	movh %d7,32768
8000e962:	1b c7 bf d0 	addi %d13,%d7,3068
8000e966:	8f 0a c8 a1 	andn %d10,%d10,128
8000e96a:	60 ad       	mov.a %a13,%d10
8000e96c:	82 39       	mov %d9,3
8000e96e:	1d 00 78 02 	j 8000ee5e <_svfprintf_r+0x966>
8000e972:	8f 0f c2 f1 	andn %d15,%d15,32
8000e976:	78 01       	st.w [%sp]4,%d15
8000e978:	df fe 09 00 	jeq %d14,-1,8000e98a <_svfprintf_r+0x492>
8000e97c:	8b 0e 00 72 	eq %d7,%d14,0
8000e980:	8b 7f 04 74 	and.eq %d7,%d15,71
8000e984:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000e988:	3c 02       	j 8000e98c <_svfprintf_r+0x494>
8000e98a:	82 6e       	mov %d14,6
8000e98c:	19 a3 30 00 	ld.w %d3,[%sp]48
8000e990:	8f 0a 50 21 	or %d2,%d10,256
8000e994:	60 2d       	mov.a %a13,%d2
8000e996:	d8 0b       	ld.a %a15,[%sp]44
8000e998:	82 0f       	mov %d15,0
8000e99a:	ce 34       	jgez %d3,8000e9a2 <_svfprintf_r+0x4aa>
8000e99c:	9b 03 00 38 	addih %d3,%d3,32768
8000e9a0:	da 2d       	mov %d15,45
8000e9a2:	78 09       	st.w [%sp]36,%d15
8000e9a4:	58 01       	ld.w %d15,[%sp]4
8000e9a6:	02 e9       	mov %d9,%d14
8000e9a8:	8b 6f 04 22 	eq %d2,%d15,70
8000e9ac:	82 36       	mov %d6,3
8000e9ae:	f6 28       	jnz %d2,8000e9be <_svfprintf_r+0x4c6>
8000e9b0:	8b 5f 24 12 	ne %d1,%d15,69
8000e9b4:	1b 1e 00 50 	addi %d5,%d14,1
8000e9b8:	82 26       	mov %d6,2
8000e9ba:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000e9be:	60 c4       	mov.a %a4,%d12
8000e9c0:	80 f4       	mov.d %d4,%a15
8000e9c2:	02 35       	mov %d5,%d3
8000e9c4:	02 97       	mov %d7,%d9
8000e9c6:	d9 a5 04 10 	lea %a5,[%sp]68
8000e9ca:	d9 a6 08 10 	lea %a6,[%sp]72
8000e9ce:	d9 a7 14 10 	lea %a7,[%sp]84
8000e9d2:	59 a2 0c 00 	st.w [%sp]12,%d2
8000e9d6:	59 a3 08 00 	st.w [%sp]8,%d3
8000e9da:	6d 00 ef 06 	call 8000f7b8 <_dtoa_r>
8000e9de:	58 01       	ld.w %d15,[%sp]4
8000e9e0:	80 2d       	mov.d %d13,%a2
8000e9e2:	8b 7f 24 12 	ne %d1,%d15,71
8000e9e6:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000e9ea:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e9ee:	df 01 11 80 	jne %d1,0,8000ea10 <_svfprintf_r+0x518>
8000e9f2:	6f 0a 0f 80 	jnz.t %d10,0,8000ea10 <_svfprintf_r+0x518>
8000e9f6:	19 a2 14 10 	ld.w %d2,[%sp]84
8000e9fa:	58 01       	ld.w %d15,[%sp]4
8000e9fc:	a2 d2       	sub %d2,%d13
8000e9fe:	59 a2 14 00 	st.w [%sp]20,%d2
8000ea02:	8b 7f 04 42 	eq %d4,%d15,71
8000ea06:	19 a5 04 10 	ld.w %d5,[%sp]68
8000ea0a:	df 04 36 80 	jne %d4,0,8000ea76 <_svfprintf_r+0x57e>
8000ea0e:	3c 3e       	j 8000ea8a <_svfprintf_r+0x592>
8000ea10:	0b 9d 00 80 	add %d8,%d13,%d9
8000ea14:	df 02 1c 00 	jeq %d2,0,8000ea4c <_svfprintf_r+0x554>
8000ea18:	60 d2       	mov.a %a2,%d13
8000ea1a:	80 f4       	mov.d %d4,%a15
8000ea1c:	79 20 00 00 	ld.b %d0,[%a2]0
8000ea20:	d2 06       	mov %e6,0
8000ea22:	02 35       	mov %d5,%d3
8000ea24:	8b 00 03 f2 	eq %d15,%d0,48
8000ea28:	59 a3 08 00 	st.w [%sp]8,%d3
8000ea2c:	6d 00 4e 1a 	call 80011ec8 <__nedf2>
8000ea30:	8b 02 20 22 	ne %d2,%d2,0
8000ea34:	0f 2f 80 00 	and %d0,%d15,%d2
8000ea38:	19 a3 08 00 	ld.w %d3,[%sp]8
8000ea3c:	76 05       	jz %d0,8000ea46 <_svfprintf_r+0x54e>
8000ea3e:	8b 19 00 01 	rsub %d0,%d9,1
8000ea42:	59 a0 04 10 	st.w [%sp]68,%d0
8000ea46:	19 a2 04 10 	ld.w %d2,[%sp]68
8000ea4a:	42 28       	add %d8,%d2
8000ea4c:	80 f4       	mov.d %d4,%a15
8000ea4e:	d2 06       	mov %e6,0
8000ea50:	02 35       	mov %d5,%d3
8000ea52:	6d 00 1b 1a 	call 80011e88 <__eqdf2>
8000ea56:	f6 23       	jnz %d2,8000ea5c <_svfprintf_r+0x564>
8000ea58:	59 a8 14 10 	st.w [%sp]84,%d8
8000ea5c:	3b 00 03 00 	mov %d0,48
8000ea60:	19 a3 14 10 	ld.w %d3,[%sp]84
8000ea64:	7f 83 c9 ff 	jge.u %d3,%d8,8000e9f6 <_svfprintf_r+0x4fe>
8000ea68:	1b 13 00 10 	addi %d1,%d3,1
8000ea6c:	60 32       	mov.a %a2,%d3
8000ea6e:	59 a1 14 10 	st.w [%sp]84,%d1
8000ea72:	34 20       	st.b [%a2],%d0
8000ea74:	3c f6       	j 8000ea60 <_svfprintf_r+0x568>
8000ea76:	0b 5e 20 31 	lt %d3,%d14,%d5
8000ea7a:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000ea7e:	df 03 88 00 	jeq %d3,0,8000eb8e <_svfprintf_r+0x696>
8000ea82:	58 04       	ld.w %d15,[%sp]16
8000ea84:	c2 ef       	add %d15,-2
8000ea86:	78 04       	st.w [%sp]16,%d15
8000ea88:	3c 06       	j 8000ea94 <_svfprintf_r+0x59c>
8000ea8a:	58 04       	ld.w %d15,[%sp]16
8000ea8c:	8b 6f 86 32 	ge %d3,%d15,102
8000ea90:	df 03 69 80 	jne %d3,0,8000eb62 <_svfprintf_r+0x66a>
8000ea94:	19 a2 10 00 	ld.w %d2,[%sp]16
8000ea98:	9a f5       	add %d15,%d5,-1
8000ea9a:	78 11       	st.w [%sp]68,%d15
8000ea9c:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000eaa0:	3b b0 02 30 	mov %d3,43
8000eaa4:	ce f4       	jgez %d15,8000eaac <_svfprintf_r+0x5b4>
8000eaa6:	32 5f       	rsub %d15
8000eaa8:	3b d0 02 30 	mov %d3,45
8000eaac:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000eab0:	8b af 40 32 	lt %d3,%d15,10
8000eab4:	df 03 3e 80 	jne %d3,0,8000eb30 <_svfprintf_r+0x638>
8000eab8:	82 06       	mov %d6,0
8000eaba:	3b a0 00 00 	mov %d0,10
8000eabe:	4b 0f 01 42 	div %e4,%d15,%d0
8000eac2:	8b 66 00 71 	rsub %d7,%d6,6
8000eac6:	60 72       	mov.a %a2,%d7
8000eac8:	d9 af 14 10 	lea %a15,[%sp]84
8000eacc:	1b 05 03 30 	addi %d3,%d5,48
8000ead0:	30 2f       	add.a %a15,%a2
8000ead2:	28 03       	st.b [%a15]0,%d3
8000ead4:	8b a4 80 32 	ge %d3,%d4,10
8000ead8:	02 4f       	mov %d15,%d4
8000eada:	c2 16       	add %d6,1
8000eadc:	df 03 f1 ff 	jne %d3,0,8000eabe <_svfprintf_r+0x5c6>
8000eae0:	60 74       	mov.a %a4,%d7
8000eae2:	d9 a2 10 30 	lea %a2,[%sp]208
8000eae6:	1b 04 03 f0 	addi %d15,%d4,48
8000eaea:	30 42       	add.a %a2,%a4
8000eaec:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000eaf0:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000eaf4:	80 22       	mov.d %d2,%a2
8000eaf6:	d9 af 1b 10 	lea %a15,[%sp]91
8000eafa:	80 ff       	mov.d %d15,%a15
8000eafc:	1b 32 f8 4f 	addi %d4,%d2,-125
8000eb00:	82 03       	mov %d3,0
8000eb02:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000eb06:	3f 4f 08 80 	jlt.u %d15,%d4,8000eb16 <_svfprintf_r+0x61e>
8000eb0a:	80 a2       	mov.d %d2,%sp
8000eb0c:	1b 02 0d 20 	addi %d2,%d2,208
8000eb10:	8b 52 07 42 	eq %d4,%d2,117
8000eb14:	76 46       	jz %d4,8000eb20 <_svfprintf_r+0x628>
8000eb16:	a0 03       	mov.a %a3,0
8000eb18:	3c 04       	j 8000eb20 <_svfprintf_r+0x628>
8000eb1a:	0c 70       	ld.bu %d15,[%a7]0
8000eb1c:	b0 17       	add.a %a7,1
8000eb1e:	28 0f       	st.b [%a15]0,%d15
8000eb20:	60 3f       	mov.a %a15,%d3
8000eb22:	d9 a2 0d 10 	lea %a2,[%sp]77
8000eb26:	b0 2f       	add.a %a15,2
8000eb28:	30 2f       	add.a %a15,%a2
8000eb2a:	c2 13       	add %d3,1
8000eb2c:	fc 37       	loop %a3,8000eb1a <_svfprintf_r+0x622>
8000eb2e:	3c 0b       	j 8000eb44 <_svfprintf_r+0x64c>
8000eb30:	3b 00 03 30 	mov %d3,48
8000eb34:	1b 0f 03 f0 	addi %d15,%d15,48
8000eb38:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000eb3c:	e9 af 10 10 	st.b [%sp]80,%d15
8000eb40:	d9 af 11 10 	lea %a15,[%sp]81
8000eb44:	d9 a7 0d 10 	lea %a7,[%sp]77
8000eb48:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000eb4c:	80 79       	mov.d %d9,%a7
8000eb4e:	58 05       	ld.w %d15,[%sp]20
8000eb50:	b5 a7 38 00 	st.a [%sp]56,%a7
8000eb54:	42 f9       	add %d9,%d15
8000eb56:	ff 2f 04 00 	jge %d15,2,8000eb5e <_svfprintf_r+0x666>
8000eb5a:	6f 0a 2c 00 	jz.t %d10,0,8000ebb2 <_svfprintf_r+0x6ba>
8000eb5e:	c2 19       	add %d9,1
8000eb60:	3c 29       	j 8000ebb2 <_svfprintf_r+0x6ba>
8000eb62:	58 04       	ld.w %d15,[%sp]16
8000eb64:	8b 6f 26 42 	ne %d4,%d15,102
8000eb68:	df 04 15 80 	jne %d4,0,8000eb92 <_svfprintf_r+0x69a>
8000eb6c:	02 59       	mov %d9,%d5
8000eb6e:	8e 59       	jlez %d5,8000eb80 <_svfprintf_r+0x688>
8000eb70:	f6 e3       	jnz %d14,8000eb76 <_svfprintf_r+0x67e>
8000eb72:	6f 0a 20 00 	jz.t %d10,0,8000ebb2 <_svfprintf_r+0x6ba>
8000eb76:	1b 1e 00 30 	addi %d3,%d14,1
8000eb7a:	0b 35 00 90 	add %d9,%d5,%d3
8000eb7e:	3c 1a       	j 8000ebb2 <_svfprintf_r+0x6ba>
8000eb80:	f6 e4       	jnz %d14,8000eb88 <_svfprintf_r+0x690>
8000eb82:	82 19       	mov %d9,1
8000eb84:	6f 0a 17 00 	jz.t %d10,0,8000ebb2 <_svfprintf_r+0x6ba>
8000eb88:	1b 2e 00 90 	addi %d9,%d14,2
8000eb8c:	3c 13       	j 8000ebb2 <_svfprintf_r+0x6ba>
8000eb8e:	da 67       	mov %d15,103
8000eb90:	78 04       	st.w [%sp]16,%d15
8000eb92:	58 05       	ld.w %d15,[%sp]20
8000eb94:	8f 1a 00 a1 	and %d10,%d10,1
8000eb98:	0b a5 00 90 	add %d9,%d5,%d10
8000eb9c:	7f f5 0b 00 	jge %d5,%d15,8000ebb2 <_svfprintf_r+0x6ba>
8000eba0:	8b 15 40 92 	lt %d9,%d5,1
8000eba4:	8b 25 00 31 	rsub %d3,%d5,2
8000eba8:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000ebac:	19 a9 14 00 	ld.w %d9,[%sp]20
8000ebb0:	42 39       	add %d9,%d3
8000ebb2:	58 09       	ld.w %d15,[%sp]36
8000ebb4:	82 0e       	mov %d14,0
8000ebb6:	df 0f 55 01 	jeq %d15,0,8000ee60 <_svfprintf_r+0x968>
8000ebba:	3b d0 02 70 	mov %d7,45
8000ebbe:	e9 a7 01 10 	st.b [%sp]65,%d7
8000ebc2:	1d 00 4f 01 	j 8000ee60 <_svfprintf_r+0x968>
8000ebc6:	e9 af 01 10 	st.b [%sp]65,%d15
8000ebca:	d9 f2 04 00 	lea %a2,[%a15]4
8000ebce:	6f 5a 09 00 	jz.t %d10,5,8000ebe0 <_svfprintf_r+0x6e8>
8000ebd2:	58 0a       	ld.w %d15,[%sp]40
8000ebd4:	c8 03       	ld.a %a3,[%a15]0
8000ebd6:	0b f0 00 48 	mov %e4,%d15
8000ebda:	89 34 40 09 	st.d [%a3],%e4
8000ebde:	3c 0c       	j 8000ebf6 <_svfprintf_r+0x6fe>
8000ebe0:	6f 4a 08 80 	jnz.t %d10,4,8000ebf0 <_svfprintf_r+0x6f8>
8000ebe4:	6f 6a 06 00 	jz.t %d10,6,8000ebf0 <_svfprintf_r+0x6f8>
8000ebe8:	c8 03       	ld.a %a3,[%a15]0
8000ebea:	58 0a       	ld.w %d15,[%sp]40
8000ebec:	ac 30       	st.h [%a3]0,%d15
8000ebee:	3c 04       	j 8000ebf6 <_svfprintf_r+0x6fe>
8000ebf0:	c8 03       	ld.a %a3,[%a15]0
8000ebf2:	58 0a       	ld.w %d15,[%sp]40
8000ebf4:	6c 30       	st.w [%a3]0,%d15
8000ebf6:	40 2f       	mov.aa %a15,%a2
8000ebf8:	1d ff b8 fc 	j 8000e568 <_svfprintf_r+0x70>
8000ebfc:	8f 0a 41 a1 	or %d10,%d10,16
8000ec00:	6f 5a 07 00 	jz.t %d10,5,8000ec0e <_svfprintf_r+0x716>
8000ec04:	d9 fc 08 00 	lea %a12,[%a15]8
8000ec08:	09 f8 40 09 	ld.d %e8,[%a15]
8000ec0c:	3c 0c       	j 8000ec24 <_svfprintf_r+0x72c>
8000ec0e:	d9 fc 04 00 	lea %a12,[%a15]4
8000ec12:	6f 4a 07 80 	jnz.t %d10,4,8000ec20 <_svfprintf_r+0x728>
8000ec16:	6f 6a 05 00 	jz.t %d10,6,8000ec20 <_svfprintf_r+0x728>
8000ec1a:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000ec1e:	3c 02       	j 8000ec22 <_svfprintf_r+0x72a>
8000ec20:	48 08       	ld.w %d8,[%a15]0
8000ec22:	82 09       	mov %d9,0
8000ec24:	82 03       	mov %d3,0
8000ec26:	3c 73       	j 8000ed0c <_svfprintf_r+0x814>
8000ec28:	3b 00 03 40 	mov %d4,48
8000ec2c:	7b 00 00 f8 	movh %d15,32768
8000ec30:	1b 5f c1 f0 	addi %d15,%d15,3093
8000ec34:	e9 a4 02 10 	st.b [%sp]66,%d4
8000ec38:	3b 80 07 40 	mov %d4,120
8000ec3c:	78 0f       	st.w [%sp]60,%d15
8000ec3e:	02 4f       	mov %d15,%d4
8000ec40:	d9 fc 04 00 	lea %a12,[%a15]4
8000ec44:	48 08       	ld.w %d8,[%a15]0
8000ec46:	82 09       	mov %d9,0
8000ec48:	8f 2a 40 a1 	or %d10,%d10,2
8000ec4c:	e9 a4 03 10 	st.b [%sp]67,%d4
8000ec50:	82 23       	mov %d3,2
8000ec52:	78 04       	st.w [%sp]16,%d15
8000ec54:	3c 5c       	j 8000ed0c <_svfprintf_r+0x814>
8000ec56:	82 07       	mov %d7,0
8000ec58:	48 0d       	ld.w %d13,[%a15]0
8000ec5a:	e9 a7 01 10 	st.b [%sp]65,%d7
8000ec5e:	02 e9       	mov %d9,%d14
8000ec60:	60 ad       	mov.a %a13,%d10
8000ec62:	d9 fc 04 00 	lea %a12,[%a15]4
8000ec66:	60 d4       	mov.a %a4,%d13
8000ec68:	0e ef       	jltz %d14,8000ec86 <_svfprintf_r+0x78e>
8000ec6a:	82 04       	mov %d4,0
8000ec6c:	02 e5       	mov %d5,%d14
8000ec6e:	6d 00 61 0e 	call 80010930 <memchr>
8000ec72:	bd 02 f6 00 	jz.a %a2,8000ee5e <_svfprintf_r+0x966>
8000ec76:	60 d4       	mov.a %a4,%d13
8000ec78:	01 42 20 30 	sub.a %a3,%a2,%a4
8000ec7c:	80 32       	mov.d %d2,%a3
8000ec7e:	0b e2 80 91 	min %d9,%d2,%d14
8000ec82:	1d 00 ee 00 	j 8000ee5e <_svfprintf_r+0x966>
8000ec86:	6d ff 83 fb 	call 8000e38c <strlen>
8000ec8a:	02 29       	mov %d9,%d2
8000ec8c:	1d 00 e9 00 	j 8000ee5e <_svfprintf_r+0x966>
8000ec90:	8f 0a 41 a1 	or %d10,%d10,16
8000ec94:	6f 5a 07 00 	jz.t %d10,5,8000eca2 <_svfprintf_r+0x7aa>
8000ec98:	d9 fc 08 00 	lea %a12,[%a15]8
8000ec9c:	09 f8 40 09 	ld.d %e8,[%a15]
8000eca0:	3c 0c       	j 8000ecb8 <_svfprintf_r+0x7c0>
8000eca2:	d9 fc 04 00 	lea %a12,[%a15]4
8000eca6:	6f 4a 07 80 	jnz.t %d10,4,8000ecb4 <_svfprintf_r+0x7bc>
8000ecaa:	6f 6a 05 00 	jz.t %d10,6,8000ecb4 <_svfprintf_r+0x7bc>
8000ecae:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000ecb2:	3c 02       	j 8000ecb6 <_svfprintf_r+0x7be>
8000ecb4:	48 08       	ld.w %d8,[%a15]0
8000ecb6:	82 09       	mov %d9,0
8000ecb8:	82 13       	mov %d3,1
8000ecba:	3c 29       	j 8000ed0c <_svfprintf_r+0x814>
8000ecbc:	e9 af 01 10 	st.b [%sp]65,%d15
8000ecc0:	7b 00 00 f8 	movh %d15,32768
8000ecc4:	1b 5f c1 f0 	addi %d15,%d15,3093
8000ecc8:	78 0f       	st.w [%sp]60,%d15
8000ecca:	6f 5a 07 00 	jz.t %d10,5,8000ecd8 <_svfprintf_r+0x7e0>
8000ecce:	d9 fc 08 00 	lea %a12,[%a15]8
8000ecd2:	09 f8 40 09 	ld.d %e8,[%a15]
8000ecd6:	3c 0c       	j 8000ecee <_svfprintf_r+0x7f6>
8000ecd8:	d9 fc 04 00 	lea %a12,[%a15]4
8000ecdc:	6f 4a 07 80 	jnz.t %d10,4,8000ecea <_svfprintf_r+0x7f2>
8000ece0:	6f 6a 05 00 	jz.t %d10,6,8000ecea <_svfprintf_r+0x7f2>
8000ece4:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000ece8:	3c 02       	j 8000ecec <_svfprintf_r+0x7f4>
8000ecea:	48 08       	ld.w %d8,[%a15]0
8000ecec:	82 09       	mov %d9,0
8000ecee:	82 23       	mov %d3,2
8000ecf0:	6f 0a 0e 00 	jz.t %d10,0,8000ed0c <_svfprintf_r+0x814>
8000ecf4:	0f 89 a0 40 	or %d4,%d9,%d8
8000ecf8:	76 4a       	jz %d4,8000ed0c <_svfprintf_r+0x814>
8000ecfa:	58 04       	ld.w %d15,[%sp]16
8000ecfc:	3b 00 03 70 	mov %d7,48
8000ed00:	e9 a7 02 10 	st.b [%sp]66,%d7
8000ed04:	e9 af 03 10 	st.b [%sp]67,%d15
8000ed08:	8f 2a 40 a1 	or %d10,%d10,2
8000ed0c:	82 07       	mov %d7,0
8000ed0e:	60 ad       	mov.a %a13,%d10
8000ed10:	e9 a7 01 10 	st.b [%sp]65,%d7
8000ed14:	80 d2       	mov.d %d2,%a13
8000ed16:	8b 0e 80 72 	ge %d7,%d14,0
8000ed1a:	8f 02 c8 41 	andn %d4,%d2,128
8000ed1e:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000ed22:	0f 98 a0 60 	or %d6,%d8,%d9
8000ed26:	8b 0e 20 42 	ne %d4,%d14,0
8000ed2a:	8b 06 00 45 	or.ne %d4,%d6,0
8000ed2e:	60 2d       	mov.a %a13,%d2
8000ed30:	df 04 72 00 	jeq %d4,0,8000ee14 <_svfprintf_r+0x91c>
8000ed34:	df 13 06 00 	jeq %d3,1,8000ed40 <_svfprintf_r+0x848>
8000ed38:	df 23 57 00 	jeq %d3,2,8000ede6 <_svfprintf_r+0x8ee>
8000ed3c:	82 03       	mov %d3,0
8000ed3e:	3c 03       	j 8000ed44 <_svfprintf_r+0x84c>
8000ed40:	82 04       	mov %d4,0
8000ed42:	3c 22       	j 8000ed86 <_svfprintf_r+0x88e>
8000ed44:	8b 73 02 71 	rsub %d7,%d3,39
8000ed48:	60 72       	mov.a %a2,%d7
8000ed4a:	8f 78 00 41 	and %d4,%d8,7
8000ed4e:	d9 a3 28 10 	lea %a3,[%sp]104
8000ed52:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000ed56:	30 23       	add.a %a3,%a2
8000ed58:	1b 04 03 40 	addi %d4,%d4,48
8000ed5c:	06 d9       	sh %d9,-3
8000ed5e:	34 34       	st.b [%a3],%d4
8000ed60:	0f 89 a0 60 	or %d6,%d9,%d8
8000ed64:	c2 13       	add %d3,1
8000ed66:	df 06 ef ff 	jne %d6,0,8000ed44 <_svfprintf_r+0x84c>
8000ed6a:	80 d2       	mov.d %d2,%a13
8000ed6c:	80 3d       	mov.d %d13,%a3
8000ed6e:	6f 02 61 00 	jz.t %d2,0,8000ee30 <_svfprintf_r+0x938>
8000ed72:	8b 04 03 42 	eq %d4,%d4,48
8000ed76:	df 04 5d 80 	jne %d4,0,8000ee30 <_svfprintf_r+0x938>
8000ed7a:	3b 00 03 70 	mov %d7,48
8000ed7e:	c2 fd       	add %d13,-1
8000ed80:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000ed84:	3c 56       	j 8000ee30 <_svfprintf_r+0x938>
8000ed86:	8b 84 02 71 	rsub %d7,%d4,40
8000ed8a:	8b 09 00 32 	eq %d3,%d9,0
8000ed8e:	60 73       	mov.a %a3,%d7
8000ed90:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000ed94:	d9 a7 28 10 	lea %a7,[%sp]104
8000ed98:	8b 09 00 35 	or.ne %d3,%d9,0
8000ed9c:	30 37       	add.a %a7,%a3
8000ed9e:	1b 14 00 d0 	addi %d13,%d4,1
8000eda2:	df 03 1b 00 	jeq %d3,0,8000edd8 <_svfprintf_r+0x8e0>
8000eda6:	8b 74 02 41 	rsub %d4,%d4,39
8000edaa:	60 42       	mov.a %a2,%d4
8000edac:	fb a0 00 60 	mov %e6,10
8000edb0:	0b 89 10 48 	mov %e4,%d9,%d8
8000edb4:	d9 af 28 10 	lea %a15,[%sp]104
8000edb8:	30 2f       	add.a %a15,%a2
8000edba:	6d 00 bb 19 	call 80012130 <__umoddi3>
8000edbe:	0b 89 10 48 	mov %e4,%d9,%d8
8000edc2:	1b 02 03 20 	addi %d2,%d2,48
8000edc6:	fb a0 00 60 	mov %e6,10
8000edca:	28 02       	st.b [%a15]0,%d2
8000edcc:	6d 00 62 19 	call 80012090 <__udivdi3>
8000edd0:	02 d4       	mov %d4,%d13
8000edd2:	0b 23 10 88 	mov %e8,%d3,%d2
8000edd6:	3c d8       	j 8000ed86 <_svfprintf_r+0x88e>
8000edd8:	80 7d       	mov.d %d13,%a7
8000edda:	1b 08 03 80 	addi %d8,%d8,48
8000edde:	c2 fd       	add %d13,-1
8000ede0:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000ede4:	3c 26       	j 8000ee30 <_svfprintf_r+0x938>
8000ede6:	82 03       	mov %d3,0
8000ede8:	d8 0f       	ld.a %a15,[%sp]60
8000edea:	80 ad       	mov.d %d13,%sp
8000edec:	8f f8 00 f1 	and %d15,%d8,15
8000edf0:	8b 73 02 71 	rsub %d7,%d3,39
8000edf4:	1b 8d 06 d0 	addi %d13,%d13,104
8000edf8:	10 f7       	addsc.a %a7,%a15,%d15,0
8000edfa:	42 7d       	add %d13,%d7
8000edfc:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000ee00:	0c 70       	ld.bu %d15,[%a7]0
8000ee02:	60 d2       	mov.a %a2,%d13
8000ee04:	06 c9       	sh %d9,-4
8000ee06:	2c 20       	st.b [%a2]0,%d15
8000ee08:	0f 89 a0 40 	or %d4,%d9,%d8
8000ee0c:	c2 13       	add %d3,1
8000ee0e:	df 04 ed ff 	jne %d4,0,8000ede8 <_svfprintf_r+0x8f0>
8000ee12:	3c 0f       	j 8000ee30 <_svfprintf_r+0x938>
8000ee14:	80 a2       	mov.d %d2,%sp
8000ee16:	1b 02 09 d0 	addi %d13,%d2,144
8000ee1a:	f6 3b       	jnz %d3,8000ee30 <_svfprintf_r+0x938>
8000ee1c:	80 df       	mov.d %d15,%a13
8000ee1e:	2e 09       	jz.t %d15,0,8000ee30 <_svfprintf_r+0x938>
8000ee20:	1b 02 0d d0 	addi %d13,%d2,208
8000ee24:	60 d2       	mov.a %a2,%d13
8000ee26:	3b 00 03 70 	mov %d7,48
8000ee2a:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000ee2e:	80 2d       	mov.d %d13,%a2
8000ee30:	d9 a3 10 20 	lea %a3,[%sp]144
8000ee34:	80 39       	mov.d %d9,%a3
8000ee36:	a2 d9       	sub %d9,%d13
8000ee38:	3c 14       	j 8000ee60 <_svfprintf_r+0x968>
8000ee3a:	e9 af 01 10 	st.b [%sp]65,%d15
8000ee3e:	58 04       	ld.w %d15,[%sp]16
8000ee40:	df 0f 1f 04 	jeq %d15,0,8000f67e <_svfprintf_r+0x1186>
8000ee44:	82 03       	mov %d3,0
8000ee46:	60 ad       	mov.a %a13,%d10
8000ee48:	e9 af 28 10 	st.b [%sp]104,%d15
8000ee4c:	e9 a3 01 10 	st.b [%sp]65,%d3
8000ee50:	40 fc       	mov.aa %a12,%a15
8000ee52:	80 a2       	mov.d %d2,%sp
8000ee54:	82 19       	mov %d9,1
8000ee56:	82 0e       	mov %d14,0
8000ee58:	1b 82 06 d0 	addi %d13,%d2,104
8000ee5c:	3c 02       	j 8000ee60 <_svfprintf_r+0x968>
8000ee5e:	82 0e       	mov %d14,0
8000ee60:	79 a7 01 10 	ld.b %d7,[%sp]65
8000ee64:	80 df       	mov.d %d15,%a13
8000ee66:	0b e9 a0 a1 	max %d10,%d9,%d14
8000ee6a:	80 d2       	mov.d %d2,%a13
8000ee6c:	16 02       	and %d15,2
8000ee6e:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000ee72:	60 ff       	mov.a %a15,%d15
8000ee74:	8a 2a       	cadd %d10,%d15,2
8000ee76:	8f 42 08 f1 	and %d15,%d2,132
8000ee7a:	ee 48       	jnz %d15,8000ef0a <_svfprintf_r+0xa12>
8000ee7c:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000ee80:	a2 a8       	sub %d8,%d10
8000ee82:	bf 18 44 00 	jlt %d8,1,8000ef0a <_svfprintf_r+0xa12>
8000ee86:	91 00 00 28 	movh.a %a2,32768
8000ee8a:	d9 22 f8 00 	lea %a2,[%a2]3128 <80000c38 <blanks.4035>>
8000ee8e:	19 a1 24 10 	ld.w %d1,[%sp]100 <80000c38 <blanks.4035>>
8000ee92:	19 a4 20 10 	ld.w %d4,[%sp]96 <80000c38 <blanks.4035>>
8000ee96:	8b 18 81 72 	ge %d7,%d8,17
8000ee9a:	f4 e2       	st.a [%a14],%a2
8000ee9c:	df 07 20 00 	jeq %d7,0,8000eedc <_svfprintf_r+0x9e4>
8000eea0:	1b 14 00 00 	addi %d0,%d4,1
8000eea4:	3b 00 01 20 	mov %d2,16
8000eea8:	1b 01 01 10 	addi %d1,%d1,16
8000eeac:	59 e2 04 00 	st.w [%a14]4,%d2
8000eeb0:	59 a0 20 10 	st.w [%sp]96,%d0
8000eeb4:	59 a1 24 10 	st.w [%sp]100,%d1
8000eeb8:	8b 80 80 02 	ge %d0,%d0,8
8000eebc:	d9 ee 08 00 	lea %a14,[%a14]8
8000eec0:	76 0b       	jz %d0,8000eed6 <_svfprintf_r+0x9de>
8000eec2:	60 c4       	mov.a %a4,%d12
8000eec4:	60 b5       	mov.a %a5,%d11
8000eec6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000eeca:	6d 00 52 10 	call 80010f6e <__ssprint_r>
8000eece:	df 02 e0 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000eed2:	d9 ae 10 20 	lea %a14,[%sp]144
8000eed6:	1b 08 ff 8f 	addi %d8,%d8,-16
8000eeda:	3c d6       	j 8000ee86 <_svfprintf_r+0x98e>
8000eedc:	c2 14       	add %d4,1
8000eede:	42 81       	add %d1,%d8
8000eee0:	59 e8 04 00 	st.w [%a14]4,%d8
8000eee4:	59 a4 20 10 	st.w [%sp]96,%d4
8000eee8:	59 a1 24 10 	st.w [%sp]100,%d1
8000eeec:	8b 84 80 42 	ge %d4,%d4,8
8000eef0:	d9 ee 08 00 	lea %a14,[%a14]8
8000eef4:	76 4b       	jz %d4,8000ef0a <_svfprintf_r+0xa12>
8000eef6:	60 c4       	mov.a %a4,%d12
8000eef8:	60 b5       	mov.a %a5,%d11
8000eefa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000eefe:	6d 00 38 10 	call 80010f6e <__ssprint_r>
8000ef02:	df 02 c6 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000ef06:	d9 ae 10 20 	lea %a14,[%sp]144
8000ef0a:	79 a4 01 10 	ld.b %d4,[%sp]65
8000ef0e:	df 04 21 00 	jeq %d4,0,8000ef50 <_svfprintf_r+0xa58>
8000ef12:	19 a4 24 10 	ld.w %d4,[%sp]100
8000ef16:	d9 a7 01 10 	lea %a7,[%sp]65
8000ef1a:	c2 14       	add %d4,1
8000ef1c:	59 a4 24 10 	st.w [%sp]100,%d4
8000ef20:	19 a4 20 10 	ld.w %d4,[%sp]96
8000ef24:	82 17       	mov %d7,1
8000ef26:	c2 14       	add %d4,1
8000ef28:	f4 e7       	st.a [%a14],%a7
8000ef2a:	59 e7 04 00 	st.w [%a14]4,%d7
8000ef2e:	59 a4 20 10 	st.w [%sp]96,%d4
8000ef32:	8b 84 80 42 	ge %d4,%d4,8
8000ef36:	d9 ee 08 00 	lea %a14,[%a14]8
8000ef3a:	76 4b       	jz %d4,8000ef50 <_svfprintf_r+0xa58>
8000ef3c:	60 c4       	mov.a %a4,%d12
8000ef3e:	60 b5       	mov.a %a5,%d11
8000ef40:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ef44:	6d 00 15 10 	call 80010f6e <__ssprint_r>
8000ef48:	df 02 a3 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000ef4c:	d9 ae 10 20 	lea %a14,[%sp]144
8000ef50:	bd 0f 21 00 	jz.a %a15,8000ef92 <_svfprintf_r+0xa9a>
8000ef54:	19 a4 24 10 	ld.w %d4,[%sp]100
8000ef58:	d9 a7 02 10 	lea %a7,[%sp]66
8000ef5c:	c2 24       	add %d4,2
8000ef5e:	59 a4 24 10 	st.w [%sp]100,%d4
8000ef62:	19 a4 20 10 	ld.w %d4,[%sp]96
8000ef66:	82 27       	mov %d7,2
8000ef68:	c2 14       	add %d4,1
8000ef6a:	f4 e7       	st.a [%a14],%a7
8000ef6c:	59 e7 04 00 	st.w [%a14]4,%d7
8000ef70:	59 a4 20 10 	st.w [%sp]96,%d4
8000ef74:	8b 84 80 42 	ge %d4,%d4,8
8000ef78:	d9 ee 08 00 	lea %a14,[%a14]8
8000ef7c:	76 4b       	jz %d4,8000ef92 <_svfprintf_r+0xa9a>
8000ef7e:	60 c4       	mov.a %a4,%d12
8000ef80:	60 b5       	mov.a %a5,%d11
8000ef82:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ef86:	6d 00 f4 0f 	call 80010f6e <__ssprint_r>
8000ef8a:	df 02 82 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000ef8e:	d9 ae 10 20 	lea %a14,[%sp]144
8000ef92:	8b 0f 28 42 	ne %d4,%d15,128
8000ef96:	df 04 48 80 	jne %d4,0,8000f026 <_svfprintf_r+0xb2e>
8000ef9a:	58 07       	ld.w %d15,[%sp]28
8000ef9c:	7b 00 00 28 	movh %d2,32768
8000efa0:	60 23       	mov.a %a3,%d2
8000efa2:	a2 af       	sub %d15,%d10
8000efa4:	d9 3f e8 00 	lea %a15,[%a3]3112
8000efa8:	bf 1f 3f 00 	jlt %d15,1,8000f026 <_svfprintf_r+0xb2e>
8000efac:	19 a7 24 10 	ld.w %d7,[%sp]100
8000efb0:	19 a4 20 10 	ld.w %d4,[%sp]96
8000efb4:	8b 1f 81 82 	ge %d8,%d15,17
8000efb8:	ec e0       	st.a [%a14]0,%a15
8000efba:	df 08 20 00 	jeq %d8,0,8000effa <_svfprintf_r+0xb02>
8000efbe:	1b 14 00 00 	addi %d0,%d4,1
8000efc2:	3b 00 01 20 	mov %d2,16
8000efc6:	1b 07 01 10 	addi %d1,%d7,16
8000efca:	59 e2 04 00 	st.w [%a14]4,%d2
8000efce:	59 a0 20 10 	st.w [%sp]96,%d0
8000efd2:	59 a1 24 10 	st.w [%sp]100,%d1
8000efd6:	8b 80 80 02 	ge %d0,%d0,8
8000efda:	d9 ee 08 00 	lea %a14,[%a14]8
8000efde:	76 0b       	jz %d0,8000eff4 <_svfprintf_r+0xafc>
8000efe0:	60 c4       	mov.a %a4,%d12
8000efe2:	60 b5       	mov.a %a5,%d11
8000efe4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000efe8:	6d 00 c3 0f 	call 80010f6e <__ssprint_r>
8000efec:	df 02 51 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000eff0:	d9 ae 10 20 	lea %a14,[%sp]144
8000eff4:	1b 0f ff ff 	addi %d15,%d15,-16
8000eff8:	3c da       	j 8000efac <_svfprintf_r+0xab4>
8000effa:	c2 14       	add %d4,1
8000effc:	42 f7       	add %d7,%d15
8000effe:	6c e1       	st.w [%a14]4,%d15
8000f000:	59 a4 20 10 	st.w [%sp]96,%d4
8000f004:	59 a7 24 10 	st.w [%sp]100,%d7
8000f008:	8b 84 80 42 	ge %d4,%d4,8
8000f00c:	d9 ee 08 00 	lea %a14,[%a14]8
8000f010:	76 4b       	jz %d4,8000f026 <_svfprintf_r+0xb2e>
8000f012:	60 c4       	mov.a %a4,%d12
8000f014:	60 b5       	mov.a %a5,%d11
8000f016:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f01a:	6d 00 aa 0f 	call 80010f6e <__ssprint_r>
8000f01e:	df 02 38 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f022:	d9 ae 10 20 	lea %a14,[%sp]144
8000f026:	7b 00 00 88 	movh %d8,32768
8000f02a:	a2 9e       	sub %d14,%d9
8000f02c:	1b 88 c2 80 	addi %d8,%d8,3112
8000f030:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000f034:	bf 1e 3c 00 	jlt %d14,1,8000f0ac <_svfprintf_r+0xbb4>
8000f038:	19 a6 24 10 	ld.w %d6,[%sp]100
8000f03c:	19 a4 20 10 	ld.w %d4,[%sp]96
8000f040:	8b 1e 81 02 	ge %d0,%d14,17
8000f044:	74 e8       	st.w [%a14],%d8
8000f046:	df 00 1c 00 	jeq %d0,0,8000f07e <_svfprintf_r+0xb86>
8000f04a:	c2 14       	add %d4,1
8000f04c:	1b 06 01 00 	addi %d0,%d6,16
8000f050:	ec e1       	st.a [%a14]4,%a15
8000f052:	59 a4 20 10 	st.w [%sp]96,%d4
8000f056:	59 a0 24 10 	st.w [%sp]100,%d0
8000f05a:	8b 84 80 42 	ge %d4,%d4,8
8000f05e:	d9 ee 08 00 	lea %a14,[%a14]8
8000f062:	76 4b       	jz %d4,8000f078 <_svfprintf_r+0xb80>
8000f064:	60 c4       	mov.a %a4,%d12
8000f066:	60 b5       	mov.a %a5,%d11
8000f068:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f06c:	6d 00 81 0f 	call 80010f6e <__ssprint_r>
8000f070:	df 02 0f 83 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f074:	d9 ae 10 20 	lea %a14,[%sp]144
8000f078:	1b 0e ff ef 	addi %d14,%d14,-16
8000f07c:	3c de       	j 8000f038 <_svfprintf_r+0xb40>
8000f07e:	c2 14       	add %d4,1
8000f080:	42 e6       	add %d6,%d14
8000f082:	59 ee 04 00 	st.w [%a14]4,%d14
8000f086:	59 a4 20 10 	st.w [%sp]96,%d4
8000f08a:	59 a6 24 10 	st.w [%sp]100,%d6
8000f08e:	8b 84 80 42 	ge %d4,%d4,8
8000f092:	d9 ee 08 00 	lea %a14,[%a14]8
8000f096:	76 4b       	jz %d4,8000f0ac <_svfprintf_r+0xbb4>
8000f098:	60 c4       	mov.a %a4,%d12
8000f09a:	60 b5       	mov.a %a5,%d11
8000f09c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f0a0:	6d 00 67 0f 	call 80010f6e <__ssprint_r>
8000f0a4:	df 02 f5 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f0a8:	d9 ae 10 20 	lea %a14,[%sp]144
8000f0ac:	80 df       	mov.d %d15,%a13
8000f0ae:	19 ae 24 10 	ld.w %d14,[%sp]100
8000f0b2:	19 a8 20 10 	ld.w %d8,[%sp]96
8000f0b6:	6f 8f 1d 80 	jnz.t %d15,8,8000f0f0 <_svfprintf_r+0xbf8>
8000f0ba:	c2 18       	add %d8,1
8000f0bc:	59 e9 04 00 	st.w [%a14]4,%d9
8000f0c0:	42 e9       	add %d9,%d14
8000f0c2:	59 a8 20 10 	st.w [%sp]96,%d8
8000f0c6:	74 ed       	st.w [%a14],%d13
8000f0c8:	59 a9 24 10 	st.w [%sp]100,%d9
8000f0cc:	8b 88 80 82 	ge %d8,%d8,8
8000f0d0:	d9 ef 08 00 	lea %a15,[%a14]8
8000f0d4:	df 08 79 02 	jeq %d8,0,8000f5c6 <_svfprintf_r+0x10ce>
8000f0d8:	60 c4       	mov.a %a4,%d12
8000f0da:	60 b5       	mov.a %a5,%d11
8000f0dc:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f0e0:	6d 00 47 0f 	call 80010f6e <__ssprint_r>
8000f0e4:	df 02 d5 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f0e8:	d9 af 10 20 	lea %a15,[%sp]144
8000f0ec:	1d 00 6d 02 	j 8000f5c6 <_svfprintf_r+0x10ce>
8000f0f0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000f0f4:	8b 62 46 f2 	lt %d15,%d2,102
8000f0f8:	df 0f be 81 	jne %d15,0,8000f474 <_svfprintf_r+0xf7c>
8000f0fc:	d2 06       	mov %e6,0
8000f0fe:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000f102:	19 a5 30 00 	ld.w %d5,[%sp]48
8000f106:	6d 00 c1 16 	call 80011e88 <__eqdf2>
8000f10a:	df 02 78 80 	jne %d2,0,8000f1fa <_svfprintf_r+0xd02>
8000f10e:	7b 00 00 38 	movh %d3,32768
8000f112:	1b 63 c2 30 	addi %d3,%d3,3110
8000f116:	c2 18       	add %d8,1
8000f118:	74 e3       	st.w [%a14],%d3
8000f11a:	1b 1e 00 90 	addi %d9,%d14,1
8000f11e:	82 13       	mov %d3,1
8000f120:	59 a8 20 10 	st.w [%sp]96,%d8
8000f124:	59 e3 04 00 	st.w [%a14]4,%d3
8000f128:	59 a9 24 10 	st.w [%sp]100,%d9
8000f12c:	8b 88 80 82 	ge %d8,%d8,8
8000f130:	d9 ef 08 00 	lea %a15,[%a14]8
8000f134:	76 8b       	jz %d8,8000f14a <_svfprintf_r+0xc52>
8000f136:	60 c4       	mov.a %a4,%d12
8000f138:	60 b5       	mov.a %a5,%d11
8000f13a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f13e:	6d 00 18 0f 	call 80010f6e <__ssprint_r>
8000f142:	df 02 a6 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f146:	d9 af 10 20 	lea %a15,[%sp]144
8000f14a:	58 11       	ld.w %d15,[%sp]68
8000f14c:	19 a2 14 00 	ld.w %d2,[%sp]20
8000f150:	3f 2f 05 00 	jlt %d15,%d2,8000f15a <_svfprintf_r+0xc62>
8000f154:	80 df       	mov.d %d15,%a13
8000f156:	6f 0f 38 02 	jz.t %d15,0,8000f5c6 <_svfprintf_r+0x10ce>
8000f15a:	58 08       	ld.w %d15,[%sp]32
8000f15c:	19 a2 20 00 	ld.w %d2,[%sp]32
8000f160:	68 1f       	st.w [%a15]4,%d15
8000f162:	58 19       	ld.w %d15,[%sp]100
8000f164:	99 a3 34 00 	ld.a %a3,[%sp]52
8000f168:	42 2f       	add %d15,%d2
8000f16a:	78 19       	st.w [%sp]100,%d15
8000f16c:	58 18       	ld.w %d15,[%sp]96
8000f16e:	e8 03       	st.a [%a15]0,%a3
8000f170:	c2 1f       	add %d15,1
8000f172:	78 18       	st.w [%sp]96,%d15
8000f174:	8b 8f 80 f2 	ge %d15,%d15,8
8000f178:	d9 ff 08 00 	lea %a15,[%a15]8
8000f17c:	6e 0b       	jz %d15,8000f192 <_svfprintf_r+0xc9a>
8000f17e:	60 c4       	mov.a %a4,%d12
8000f180:	60 b5       	mov.a %a5,%d11
8000f182:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f186:	6d 00 f4 0e 	call 80010f6e <__ssprint_r>
8000f18a:	df 02 82 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f18e:	d9 af 10 20 	lea %a15,[%sp]144
8000f192:	58 05       	ld.w %d15,[%sp]20
8000f194:	7b 00 00 88 	movh %d8,32768
8000f198:	c2 ff       	add %d15,-1
8000f19a:	1b 88 c2 80 	addi %d8,%d8,3112
8000f19e:	3b 00 01 90 	mov %d9,16
8000f1a2:	bf 1f 12 02 	jlt %d15,1,8000f5c6 <_svfprintf_r+0x10ce>
8000f1a6:	19 a5 24 10 	ld.w %d5,[%sp]100
8000f1aa:	19 a3 20 10 	ld.w %d3,[%sp]96
8000f1ae:	8b 1f 81 42 	ge %d4,%d15,17
8000f1b2:	68 08       	st.w [%a15]0,%d8
8000f1b4:	df 04 1c 00 	jeq %d4,0,8000f1ec <_svfprintf_r+0xcf4>
8000f1b8:	c2 13       	add %d3,1
8000f1ba:	1b 05 01 40 	addi %d4,%d5,16
8000f1be:	68 19       	st.w [%a15]4,%d9
8000f1c0:	59 a3 20 10 	st.w [%sp]96,%d3
8000f1c4:	59 a4 24 10 	st.w [%sp]100,%d4
8000f1c8:	8b 83 80 32 	ge %d3,%d3,8
8000f1cc:	d9 ff 08 00 	lea %a15,[%a15]8
8000f1d0:	76 3b       	jz %d3,8000f1e6 <_svfprintf_r+0xcee>
8000f1d2:	60 c4       	mov.a %a4,%d12
8000f1d4:	60 b5       	mov.a %a5,%d11
8000f1d6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f1da:	6d 00 ca 0e 	call 80010f6e <__ssprint_r>
8000f1de:	df 02 58 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f1e2:	d9 af 10 20 	lea %a15,[%sp]144
8000f1e6:	1b 0f ff ff 	addi %d15,%d15,-16
8000f1ea:	3c de       	j 8000f1a6 <_svfprintf_r+0xcae>
8000f1ec:	12 54       	add %d4,%d15,%d5
8000f1ee:	68 1f       	st.w [%a15]4,%d15
8000f1f0:	59 a4 24 10 	st.w [%sp]100,%d4
8000f1f4:	9a 13       	add %d15,%d3,1
8000f1f6:	1d 00 e1 01 	j 8000f5b8 <_svfprintf_r+0x10c0>
8000f1fa:	19 a3 04 10 	ld.w %d3,[%sp]68
8000f1fe:	ff 13 8e 00 	jge %d3,1,8000f31a <_svfprintf_r+0xe22>
8000f202:	7b 00 00 38 	movh %d3,32768
8000f206:	1b 63 c2 30 	addi %d3,%d3,3110
8000f20a:	c2 18       	add %d8,1
8000f20c:	74 e3       	st.w [%a14],%d3
8000f20e:	1b 1e 00 90 	addi %d9,%d14,1
8000f212:	82 13       	mov %d3,1
8000f214:	59 a8 20 10 	st.w [%sp]96,%d8
8000f218:	59 e3 04 00 	st.w [%a14]4,%d3
8000f21c:	59 a9 24 10 	st.w [%sp]100,%d9
8000f220:	8b 88 80 82 	ge %d8,%d8,8
8000f224:	d9 ef 08 00 	lea %a15,[%a14]8
8000f228:	76 8b       	jz %d8,8000f23e <_svfprintf_r+0xd46>
8000f22a:	60 c4       	mov.a %a4,%d12
8000f22c:	60 b5       	mov.a %a5,%d11
8000f22e:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f232:	6d 00 9e 0e 	call 80010f6e <__ssprint_r>
8000f236:	df 02 2c 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f23a:	d9 af 10 20 	lea %a15,[%sp]144
8000f23e:	58 11       	ld.w %d15,[%sp]68
8000f240:	19 a2 14 00 	ld.w %d2,[%sp]20
8000f244:	a6 2f       	or %d15,%d2
8000f246:	ee 04       	jnz %d15,8000f24e <_svfprintf_r+0xd56>
8000f248:	80 df       	mov.d %d15,%a13
8000f24a:	6f 0f be 01 	jz.t %d15,0,8000f5c6 <_svfprintf_r+0x10ce>
8000f24e:	58 08       	ld.w %d15,[%sp]32
8000f250:	19 a2 20 00 	ld.w %d2,[%sp]32
8000f254:	68 1f       	st.w [%a15]4,%d15
8000f256:	58 19       	ld.w %d15,[%sp]100
8000f258:	99 a3 34 00 	ld.a %a3,[%sp]52
8000f25c:	42 2f       	add %d15,%d2
8000f25e:	78 19       	st.w [%sp]100,%d15
8000f260:	58 18       	ld.w %d15,[%sp]96
8000f262:	e8 03       	st.a [%a15]0,%a3
8000f264:	c2 1f       	add %d15,1
8000f266:	78 18       	st.w [%sp]96,%d15
8000f268:	8b 8f 80 f2 	ge %d15,%d15,8
8000f26c:	d9 ff 08 00 	lea %a15,[%a15]8
8000f270:	6e 0b       	jz %d15,8000f286 <_svfprintf_r+0xd8e>
8000f272:	60 c4       	mov.a %a4,%d12
8000f274:	60 b5       	mov.a %a5,%d11
8000f276:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f27a:	6d 00 7a 0e 	call 80010f6e <__ssprint_r>
8000f27e:	df 02 08 82 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f282:	d9 af 10 20 	lea %a15,[%sp]144
8000f286:	58 11       	ld.w %d15,[%sp]68
8000f288:	7b 00 00 88 	movh %d8,32768
8000f28c:	32 5f       	rsub %d15
8000f28e:	1b 88 c2 80 	addi %d8,%d8,3112
8000f292:	3b 00 01 90 	mov %d9,16
8000f296:	bf 1f 3a 00 	jlt %d15,1,8000f30a <_svfprintf_r+0xe12>
8000f29a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000f29e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000f2a2:	8b 1f 81 42 	ge %d4,%d15,17
8000f2a6:	68 08       	st.w [%a15]0,%d8
8000f2a8:	df 04 1c 00 	jeq %d4,0,8000f2e0 <_svfprintf_r+0xde8>
8000f2ac:	c2 13       	add %d3,1
8000f2ae:	1b 05 01 40 	addi %d4,%d5,16
8000f2b2:	68 19       	st.w [%a15]4,%d9
8000f2b4:	59 a3 20 10 	st.w [%sp]96,%d3
8000f2b8:	59 a4 24 10 	st.w [%sp]100,%d4
8000f2bc:	8b 83 80 32 	ge %d3,%d3,8
8000f2c0:	d9 ff 08 00 	lea %a15,[%a15]8
8000f2c4:	76 3b       	jz %d3,8000f2da <_svfprintf_r+0xde2>
8000f2c6:	60 c4       	mov.a %a4,%d12
8000f2c8:	60 b5       	mov.a %a5,%d11
8000f2ca:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f2ce:	6d 00 50 0e 	call 80010f6e <__ssprint_r>
8000f2d2:	df 02 de 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f2d6:	d9 af 10 20 	lea %a15,[%sp]144
8000f2da:	1b 0f ff ff 	addi %d15,%d15,-16
8000f2de:	3c de       	j 8000f29a <_svfprintf_r+0xda2>
8000f2e0:	68 1f       	st.w [%a15]4,%d15
8000f2e2:	12 54       	add %d4,%d15,%d5
8000f2e4:	9a 13       	add %d15,%d3,1
8000f2e6:	78 18       	st.w [%sp]96,%d15
8000f2e8:	59 a4 24 10 	st.w [%sp]100,%d4
8000f2ec:	8b 8f 80 f2 	ge %d15,%d15,8
8000f2f0:	d9 ff 08 00 	lea %a15,[%a15]8
8000f2f4:	6e 0b       	jz %d15,8000f30a <_svfprintf_r+0xe12>
8000f2f6:	60 c4       	mov.a %a4,%d12
8000f2f8:	60 b5       	mov.a %a5,%d11
8000f2fa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f2fe:	6d 00 38 0e 	call 80010f6e <__ssprint_r>
8000f302:	df 02 c6 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f306:	d9 af 10 20 	lea %a15,[%sp]144
8000f30a:	58 05       	ld.w %d15,[%sp]20
8000f30c:	68 0d       	st.w [%a15]0,%d13
8000f30e:	68 1f       	st.w [%a15]4,%d15
8000f310:	19 a2 14 00 	ld.w %d2,[%sp]20
8000f314:	58 19       	ld.w %d15,[%sp]100
8000f316:	1d 00 4d 01 	j 8000f5b0 <_svfprintf_r+0x10b8>
8000f31a:	58 05       	ld.w %d15,[%sp]20
8000f31c:	74 ed       	st.w [%a14],%d13
8000f31e:	3f f3 6a 00 	jlt %d3,%d15,8000f3f2 <_svfprintf_r+0xefa>
8000f322:	02 f9       	mov %d9,%d15
8000f324:	c2 18       	add %d8,1
8000f326:	42 e9       	add %d9,%d14
8000f328:	59 a8 20 10 	st.w [%sp]96,%d8
8000f32c:	6c e1       	st.w [%a14]4,%d15
8000f32e:	59 a9 24 10 	st.w [%sp]100,%d9
8000f332:	8b 88 80 82 	ge %d8,%d8,8
8000f336:	d9 ef 08 00 	lea %a15,[%a14]8
8000f33a:	76 8b       	jz %d8,8000f350 <_svfprintf_r+0xe58>
8000f33c:	60 c4       	mov.a %a4,%d12
8000f33e:	60 b5       	mov.a %a5,%d11
8000f340:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f344:	6d 00 15 0e 	call 80010f6e <__ssprint_r>
8000f348:	df 02 a3 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f34c:	d9 af 10 20 	lea %a15,[%sp]144
8000f350:	58 11       	ld.w %d15,[%sp]68
8000f352:	19 a2 14 00 	ld.w %d2,[%sp]20
8000f356:	7b 00 00 88 	movh %d8,32768
8000f35a:	a2 2f       	sub %d15,%d2
8000f35c:	1b 88 c2 80 	addi %d8,%d8,3112
8000f360:	3b 00 01 90 	mov %d9,16
8000f364:	bf 1f 3a 00 	jlt %d15,1,8000f3d8 <_svfprintf_r+0xee0>
8000f368:	19 a5 24 10 	ld.w %d5,[%sp]100
8000f36c:	19 a3 20 10 	ld.w %d3,[%sp]96
8000f370:	8b 1f 81 42 	ge %d4,%d15,17
8000f374:	68 08       	st.w [%a15]0,%d8
8000f376:	df 04 1c 00 	jeq %d4,0,8000f3ae <_svfprintf_r+0xeb6>
8000f37a:	c2 13       	add %d3,1
8000f37c:	1b 05 01 40 	addi %d4,%d5,16
8000f380:	68 19       	st.w [%a15]4,%d9
8000f382:	59 a3 20 10 	st.w [%sp]96,%d3
8000f386:	59 a4 24 10 	st.w [%sp]100,%d4
8000f38a:	8b 83 80 32 	ge %d3,%d3,8
8000f38e:	d9 ff 08 00 	lea %a15,[%a15]8
8000f392:	76 3b       	jz %d3,8000f3a8 <_svfprintf_r+0xeb0>
8000f394:	60 c4       	mov.a %a4,%d12
8000f396:	60 b5       	mov.a %a5,%d11
8000f398:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f39c:	6d 00 e9 0d 	call 80010f6e <__ssprint_r>
8000f3a0:	df 02 77 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f3a4:	d9 af 10 20 	lea %a15,[%sp]144
8000f3a8:	1b 0f ff ff 	addi %d15,%d15,-16
8000f3ac:	3c de       	j 8000f368 <_svfprintf_r+0xe70>
8000f3ae:	68 1f       	st.w [%a15]4,%d15
8000f3b0:	12 54       	add %d4,%d15,%d5
8000f3b2:	9a 13       	add %d15,%d3,1
8000f3b4:	78 18       	st.w [%sp]96,%d15
8000f3b6:	59 a4 24 10 	st.w [%sp]100,%d4
8000f3ba:	8b 8f 80 f2 	ge %d15,%d15,8
8000f3be:	d9 ff 08 00 	lea %a15,[%a15]8
8000f3c2:	6e 0b       	jz %d15,8000f3d8 <_svfprintf_r+0xee0>
8000f3c4:	60 c4       	mov.a %a4,%d12
8000f3c6:	60 b5       	mov.a %a5,%d11
8000f3c8:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f3cc:	6d 00 d1 0d 	call 80010f6e <__ssprint_r>
8000f3d0:	df 02 5f 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f3d4:	d9 af 10 20 	lea %a15,[%sp]144
8000f3d8:	80 df       	mov.d %d15,%a13
8000f3da:	6f 0f f6 00 	jz.t %d15,0,8000f5c6 <_svfprintf_r+0x10ce>
8000f3de:	99 a3 34 00 	ld.a %a3,[%sp]52
8000f3e2:	58 08       	ld.w %d15,[%sp]32
8000f3e4:	19 a2 20 00 	ld.w %d2,[%sp]32
8000f3e8:	68 1f       	st.w [%a15]4,%d15
8000f3ea:	e8 03       	st.a [%a15]0,%a3
8000f3ec:	58 19       	ld.w %d15,[%sp]100
8000f3ee:	1d 00 e1 00 	j 8000f5b0 <_svfprintf_r+0x10b8>
8000f3f2:	c2 18       	add %d8,1
8000f3f4:	59 e3 04 00 	st.w [%a14]4,%d3
8000f3f8:	42 e3       	add %d3,%d14
8000f3fa:	59 a8 20 10 	st.w [%sp]96,%d8
8000f3fe:	59 a3 24 10 	st.w [%sp]100,%d3
8000f402:	8b 88 80 82 	ge %d8,%d8,8
8000f406:	d9 ef 08 00 	lea %a15,[%a14]8
8000f40a:	76 8b       	jz %d8,8000f420 <_svfprintf_r+0xf28>
8000f40c:	60 c4       	mov.a %a4,%d12
8000f40e:	60 b5       	mov.a %a5,%d11
8000f410:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f414:	6d 00 ad 0d 	call 80010f6e <__ssprint_r>
8000f418:	df 02 3b 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f41c:	d9 af 10 20 	lea %a15,[%sp]144
8000f420:	58 08       	ld.w %d15,[%sp]32
8000f422:	19 a2 20 00 	ld.w %d2,[%sp]32
8000f426:	68 1f       	st.w [%a15]4,%d15
8000f428:	58 19       	ld.w %d15,[%sp]100
8000f42a:	99 a3 34 00 	ld.a %a3,[%sp]52
8000f42e:	42 2f       	add %d15,%d2
8000f430:	78 19       	st.w [%sp]100,%d15
8000f432:	58 18       	ld.w %d15,[%sp]96
8000f434:	99 ae 04 10 	ld.a %a14,[%sp]68
8000f438:	c2 1f       	add %d15,1
8000f43a:	60 d2       	mov.a %a2,%d13
8000f43c:	e8 03       	st.a [%a15]0,%a3
8000f43e:	78 18       	st.w [%sp]96,%d15
8000f440:	8b 8f 80 f2 	ge %d15,%d15,8
8000f444:	30 2e       	add.a %a14,%a2
8000f446:	d9 ff 08 00 	lea %a15,[%a15]8
8000f44a:	6e 0b       	jz %d15,8000f460 <_svfprintf_r+0xf68>
8000f44c:	60 c4       	mov.a %a4,%d12
8000f44e:	60 b5       	mov.a %a5,%d11
8000f450:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f454:	6d 00 8d 0d 	call 80010f6e <__ssprint_r>
8000f458:	df 02 1b 81 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f45c:	d9 af 10 20 	lea %a15,[%sp]144
8000f460:	19 a2 14 00 	ld.w %d2,[%sp]20
8000f464:	58 11       	ld.w %d15,[%sp]68
8000f466:	e8 0e       	st.a [%a15]0,%a14
8000f468:	5a f2       	sub %d15,%d2,%d15
8000f46a:	68 1f       	st.w [%a15]4,%d15
8000f46c:	19 a2 24 10 	ld.w %d2,[%sp]100
8000f470:	1d 00 a0 00 	j 8000f5b0 <_svfprintf_r+0x10b8>
8000f474:	c2 18       	add %d8,1
8000f476:	82 13       	mov %d3,1
8000f478:	1b 1e 00 90 	addi %d9,%d14,1
8000f47c:	58 05       	ld.w %d15,[%sp]20
8000f47e:	59 a8 20 10 	st.w [%sp]96,%d8
8000f482:	74 ed       	st.w [%a14],%d13
8000f484:	59 e3 04 00 	st.w [%a14]4,%d3
8000f488:	59 a9 24 10 	st.w [%sp]100,%d9
8000f48c:	8b 88 80 82 	ge %d8,%d8,8
8000f490:	ff 2f 05 00 	jge %d15,2,8000f49a <_svfprintf_r+0xfa2>
8000f494:	80 d2       	mov.d %d2,%a13
8000f496:	6f 02 81 00 	jz.t %d2,0,8000f598 <_svfprintf_r+0x10a0>
8000f49a:	d9 ef 08 00 	lea %a15,[%a14]8
8000f49e:	76 8b       	jz %d8,8000f4b4 <_svfprintf_r+0xfbc>
8000f4a0:	60 c4       	mov.a %a4,%d12
8000f4a2:	60 b5       	mov.a %a5,%d11
8000f4a4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f4a8:	6d 00 63 0d 	call 80010f6e <__ssprint_r>
8000f4ac:	df 02 f1 80 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f4b0:	d9 af 10 20 	lea %a15,[%sp]144
8000f4b4:	58 08       	ld.w %d15,[%sp]32
8000f4b6:	19 a2 20 00 	ld.w %d2,[%sp]32
8000f4ba:	68 1f       	st.w [%a15]4,%d15
8000f4bc:	58 19       	ld.w %d15,[%sp]100
8000f4be:	99 a3 34 00 	ld.a %a3,[%sp]52
8000f4c2:	42 2f       	add %d15,%d2
8000f4c4:	78 19       	st.w [%sp]100,%d15
8000f4c6:	58 18       	ld.w %d15,[%sp]96
8000f4c8:	e8 03       	st.a [%a15]0,%a3
8000f4ca:	c2 1f       	add %d15,1
8000f4cc:	78 18       	st.w [%sp]96,%d15
8000f4ce:	8b 8f 80 f2 	ge %d15,%d15,8
8000f4d2:	d9 ff 08 00 	lea %a15,[%a15]8
8000f4d6:	6e 0b       	jz %d15,8000f4ec <_svfprintf_r+0xff4>
8000f4d8:	60 c4       	mov.a %a4,%d12
8000f4da:	60 b5       	mov.a %a5,%d11
8000f4dc:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f4e0:	6d 00 47 0d 	call 80010f6e <__ssprint_r>
8000f4e4:	df 02 d5 80 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f4e8:	d9 af 10 20 	lea %a15,[%sp]144
8000f4ec:	d2 06       	mov %e6,0
8000f4ee:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000f4f2:	19 a5 30 00 	ld.w %d5,[%sp]48
8000f4f6:	6d 00 e9 14 	call 80011ec8 <__nedf2>
8000f4fa:	58 05       	ld.w %d15,[%sp]20
8000f4fc:	c2 ff       	add %d15,-1
8000f4fe:	76 2c       	jz %d2,8000f516 <_svfprintf_r+0x101e>
8000f500:	19 a2 24 10 	ld.w %d2,[%sp]100
8000f504:	60 de       	mov.a %a14,%d13
8000f506:	68 1f       	st.w [%a15]4,%d15
8000f508:	42 2f       	add %d15,%d2
8000f50a:	78 19       	st.w [%sp]100,%d15
8000f50c:	58 18       	ld.w %d15,[%sp]96
8000f50e:	b0 1e       	add.a %a14,1
8000f510:	e8 0e       	st.a [%a15]0,%a14
8000f512:	c2 1f       	add %d15,1
8000f514:	3c 31       	j 8000f576 <_svfprintf_r+0x107e>
8000f516:	7b 00 00 88 	movh %d8,32768
8000f51a:	1b 88 c2 80 	addi %d8,%d8,3112
8000f51e:	3b 00 01 90 	mov %d9,16
8000f522:	bf 1f 3f 00 	jlt %d15,1,8000f5a0 <_svfprintf_r+0x10a8>
8000f526:	19 a5 24 10 	ld.w %d5,[%sp]100
8000f52a:	19 a3 20 10 	ld.w %d3,[%sp]96
8000f52e:	8b 1f 81 42 	ge %d4,%d15,17
8000f532:	68 08       	st.w [%a15]0,%d8
8000f534:	df 04 1c 00 	jeq %d4,0,8000f56c <_svfprintf_r+0x1074>
8000f538:	c2 13       	add %d3,1
8000f53a:	1b 05 01 40 	addi %d4,%d5,16
8000f53e:	68 19       	st.w [%a15]4,%d9
8000f540:	59 a3 20 10 	st.w [%sp]96,%d3
8000f544:	59 a4 24 10 	st.w [%sp]100,%d4
8000f548:	8b 83 80 32 	ge %d3,%d3,8
8000f54c:	d9 ff 08 00 	lea %a15,[%a15]8
8000f550:	76 3b       	jz %d3,8000f566 <_svfprintf_r+0x106e>
8000f552:	60 c4       	mov.a %a4,%d12
8000f554:	60 b5       	mov.a %a5,%d11
8000f556:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f55a:	6d 00 0a 0d 	call 80010f6e <__ssprint_r>
8000f55e:	df 02 98 80 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f562:	d9 af 10 20 	lea %a15,[%sp]144
8000f566:	1b 0f ff ff 	addi %d15,%d15,-16
8000f56a:	3c de       	j 8000f526 <_svfprintf_r+0x102e>
8000f56c:	12 54       	add %d4,%d15,%d5
8000f56e:	68 1f       	st.w [%a15]4,%d15
8000f570:	59 a4 24 10 	st.w [%sp]100,%d4
8000f574:	9a 13       	add %d15,%d3,1
8000f576:	78 18       	st.w [%sp]96,%d15
8000f578:	8b 8f 80 f2 	ge %d15,%d15,8
8000f57c:	d9 ff 08 00 	lea %a15,[%a15]8
8000f580:	6e 10       	jz %d15,8000f5a0 <_svfprintf_r+0x10a8>
8000f582:	60 c4       	mov.a %a4,%d12
8000f584:	60 b5       	mov.a %a5,%d11
8000f586:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f58a:	6d 00 f2 0c 	call 80010f6e <__ssprint_r>
8000f58e:	df 02 80 80 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f592:	d9 af 10 20 	lea %a15,[%sp]144
8000f596:	3c 05       	j 8000f5a0 <_svfprintf_r+0x10a8>
8000f598:	df 08 f5 ff 	jne %d8,0,8000f582 <_svfprintf_r+0x108a>
8000f59c:	d9 ef 08 00 	lea %a15,[%a14]8
8000f5a0:	58 0e       	ld.w %d15,[%sp]56
8000f5a2:	d9 a3 0d 10 	lea %a3,[%sp]77
8000f5a6:	68 1f       	st.w [%a15]4,%d15
8000f5a8:	19 a2 38 00 	ld.w %d2,[%sp]56
8000f5ac:	58 19       	ld.w %d15,[%sp]100
8000f5ae:	e8 03       	st.a [%a15]0,%a3
8000f5b0:	42 2f       	add %d15,%d2
8000f5b2:	78 19       	st.w [%sp]100,%d15
8000f5b4:	58 18       	ld.w %d15,[%sp]96
8000f5b6:	c2 1f       	add %d15,1
8000f5b8:	78 18       	st.w [%sp]96,%d15
8000f5ba:	8b 8f 80 f2 	ge %d15,%d15,8
8000f5be:	df 0f 8d fd 	jne %d15,0,8000f0d8 <_svfprintf_r+0xbe0>
8000f5c2:	d9 ff 08 00 	lea %a15,[%a15]8
8000f5c6:	80 df       	mov.d %d15,%a13
8000f5c8:	ae 2d       	jnz.t %d15,2,8000f5e2 <_svfprintf_r+0x10ea>
8000f5ca:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000f5ce:	0b 2a a0 f1 	max %d15,%d10,%d2
8000f5d2:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f5d6:	42 f2       	add %d2,%d15
8000f5d8:	58 19       	ld.w %d15,[%sp]100
8000f5da:	59 a2 28 00 	st.w [%sp]40,%d2
8000f5de:	6e 49       	jz %d15,8000f670 <_svfprintf_r+0x1178>
8000f5e0:	3c 40       	j 8000f660 <_svfprintf_r+0x1168>
8000f5e2:	58 07       	ld.w %d15,[%sp]28
8000f5e4:	3b 00 01 80 	mov %d8,16
8000f5e8:	a2 af       	sub %d15,%d10
8000f5ea:	bf 1f f0 7f 	jlt %d15,1,8000f5ca <_svfprintf_r+0x10d2>
8000f5ee:	91 00 00 28 	movh.a %a2,32768
8000f5f2:	d9 22 f8 00 	lea %a2,[%a2]3128 <80000c38 <blanks.4035>>
8000f5f6:	19 a5 24 10 	ld.w %d5,[%sp]100 <80000c38 <blanks.4035>>
8000f5fa:	19 a3 20 10 	ld.w %d3,[%sp]96 <80000c38 <blanks.4035>>
8000f5fe:	8b 1f 81 42 	ge %d4,%d15,17
8000f602:	e8 02       	st.a [%a15]0,%a2
8000f604:	df 04 1c 00 	jeq %d4,0,8000f63c <_svfprintf_r+0x1144>
8000f608:	c2 13       	add %d3,1
8000f60a:	1b 05 01 40 	addi %d4,%d5,16
8000f60e:	68 18       	st.w [%a15]4,%d8
8000f610:	59 a3 20 10 	st.w [%sp]96,%d3
8000f614:	59 a4 24 10 	st.w [%sp]100,%d4
8000f618:	8b 83 80 32 	ge %d3,%d3,8
8000f61c:	d9 ff 08 00 	lea %a15,[%a15]8
8000f620:	76 3b       	jz %d3,8000f636 <_svfprintf_r+0x113e>
8000f622:	60 c4       	mov.a %a4,%d12
8000f624:	60 b5       	mov.a %a5,%d11
8000f626:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f62a:	6d 00 a2 0c 	call 80010f6e <__ssprint_r>
8000f62e:	df 02 30 80 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f632:	d9 af 10 20 	lea %a15,[%sp]144
8000f636:	1b 0f ff ff 	addi %d15,%d15,-16
8000f63a:	3c da       	j 8000f5ee <_svfprintf_r+0x10f6>
8000f63c:	12 54       	add %d4,%d15,%d5
8000f63e:	68 1f       	st.w [%a15]4,%d15
8000f640:	9a 13       	add %d15,%d3,1
8000f642:	78 18       	st.w [%sp]96,%d15
8000f644:	59 a4 24 10 	st.w [%sp]100,%d4
8000f648:	8b 8f 40 f2 	lt %d15,%d15,8
8000f64c:	ee bf       	jnz %d15,8000f5ca <_svfprintf_r+0x10d2>
8000f64e:	60 c4       	mov.a %a4,%d12
8000f650:	60 b5       	mov.a %a5,%d11
8000f652:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f656:	6d 00 8c 0c 	call 80010f6e <__ssprint_r>
8000f65a:	df 02 b8 7f 	jeq %d2,0,8000f5ca <_svfprintf_r+0x10d2>
8000f65e:	3c 18       	j 8000f68e <_svfprintf_r+0x1196>
8000f660:	60 c4       	mov.a %a4,%d12
8000f662:	60 b5       	mov.a %a5,%d11
8000f664:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f668:	6d 00 83 0c 	call 80010f6e <__ssprint_r>
8000f66c:	df 02 11 80 	jne %d2,0,8000f68e <_svfprintf_r+0x1196>
8000f670:	82 0f       	mov %d15,0
8000f672:	78 18       	st.w [%sp]96,%d15
8000f674:	40 cf       	mov.aa %a15,%a12
8000f676:	d9 ae 10 20 	lea %a14,[%sp]144
8000f67a:	1d ff 77 f7 	j 8000e568 <_svfprintf_r+0x70>
8000f67e:	58 19       	ld.w %d15,[%sp]100
8000f680:	6e 07       	jz %d15,8000f68e <_svfprintf_r+0x1196>
8000f682:	60 c4       	mov.a %a4,%d12
8000f684:	60 b5       	mov.a %a5,%d11
8000f686:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f68a:	6d 00 72 0c 	call 80010f6e <__ssprint_r>
8000f68e:	60 b3       	mov.a %a3,%d11
8000f690:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f694:	8c 36       	ld.h %d15,[%a3]12
8000f696:	16 40       	and %d15,64
8000f698:	aa f2       	cmov %d2,%d15,-1
8000f69a:	00 90       	ret 

8000f69c <quorem>:
8000f69c:	19 58 10 00 	ld.w %d8,[%a5]16
8000f6a0:	4c 44       	ld.w %d15,[%a4]16
8000f6a2:	82 02       	mov %d2,0
8000f6a4:	3f 8f 88 00 	jlt %d15,%d8,8000f7b4 <quorem+0x118>
8000f6a8:	c2 f8       	add %d8,-1
8000f6aa:	80 4f       	mov.d %d15,%a4
8000f6ac:	8f 28 00 20 	sh %d2,%d8,2
8000f6b0:	60 2f       	mov.a %a15,%d2
8000f6b2:	1b 4f 01 90 	addi %d9,%d15,20
8000f6b6:	d9 5c 14 00 	lea %a12,[%a5]20
8000f6ba:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000f6be:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000f6c2:	54 dc       	ld.w %d12,[%a13]
8000f6c4:	4c f0       	ld.w %d15,[%a15]0
8000f6c6:	c2 1c       	add %d12,1
8000f6c8:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000f6cc:	02 ca       	mov %d10,%d12
8000f6ce:	df 0c 3d 00 	jeq %d12,0,8000f748 <quorem+0xac>
8000f6d2:	60 96       	mov.a %a6,%d9
8000f6d4:	40 c2       	mov.aa %a2,%a12
8000f6d6:	82 05       	mov %d5,0
8000f6d8:	82 06       	mov %d6,0
8000f6da:	54 22       	ld.w %d2,[%a2]
8000f6dc:	40 63       	mov.aa %a3,%a6
8000f6de:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000f6e2:	8f 02 1f 20 	sh %d2,%d2,-16
8000f6e6:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000f6ea:	b0 42       	add.a %a2,4
8000f6ec:	8f 03 1f 40 	sh %d4,%d3,-16
8000f6f0:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000f6f4:	44 34       	ld.w %d4,[%a3+]
8000f6f6:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000f6fa:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000f6fe:	8f 02 1f 50 	sh %d5,%d2,-16
8000f702:	42 f6       	add %d6,%d15
8000f704:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000f708:	0b 36 80 30 	sub %d3,%d6,%d3
8000f70c:	8f 04 1f 40 	sh %d4,%d4,-16
8000f710:	8f 03 3f f0 	sha %d15,%d3,-16
8000f714:	0b 24 80 20 	sub %d2,%d4,%d2
8000f718:	42 f2       	add %d2,%d15
8000f71a:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000f71e:	8f 02 3f 60 	sha %d6,%d2,-16
8000f722:	80 2f       	mov.d %d15,%a2
8000f724:	80 d2       	mov.d %d2,%a13
8000f726:	74 63       	st.w [%a6],%d3
8000f728:	40 36       	mov.aa %a6,%a3
8000f72a:	7f f2 d8 ff 	jge.u %d2,%d15,8000f6da <quorem+0x3e>
8000f72e:	4c f0       	ld.w %d15,[%a15]0
8000f730:	ee 0c       	jnz %d15,8000f748 <quorem+0xac>
8000f732:	b0 cf       	add.a %a15,-4
8000f734:	80 f2       	mov.d %d2,%a15
8000f736:	3f 29 05 80 	jlt.u %d9,%d2,8000f740 <quorem+0xa4>
8000f73a:	59 48 10 00 	st.w [%a4]16,%d8
8000f73e:	3c 05       	j 8000f748 <quorem+0xac>
8000f740:	4c f0       	ld.w %d15,[%a15]0
8000f742:	ee fc       	jnz %d15,8000f73a <quorem+0x9e>
8000f744:	c2 f8       	add %d8,-1
8000f746:	3c f6       	j 8000f732 <quorem+0x96>
8000f748:	40 4e       	mov.aa %a14,%a4
8000f74a:	6d 00 08 0b 	call 80010d5a <__mcmp>
8000f74e:	bf 02 32 00 	jlt %d2,0,8000f7b2 <quorem+0x116>
8000f752:	60 92       	mov.a %a2,%d9
8000f754:	1b 1c 00 a0 	addi %d10,%d12,1
8000f758:	82 04       	mov %d4,0
8000f75a:	40 2f       	mov.aa %a15,%a2
8000f75c:	44 f3       	ld.w %d3,[%a15+]
8000f75e:	54 c5       	ld.w %d5,[%a12]
8000f760:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000f764:	8f 05 1f f0 	sh %d15,%d5,-16
8000f768:	42 42       	add %d2,%d4
8000f76a:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000f76e:	8f 03 1f 30 	sh %d3,%d3,-16
8000f772:	a2 42       	sub %d2,%d4
8000f774:	8f 02 3f 40 	sha %d4,%d2,-16
8000f778:	a2 f3       	sub %d3,%d15
8000f77a:	42 43       	add %d3,%d4
8000f77c:	8f 03 3f 40 	sha %d4,%d3,-16
8000f780:	b0 4c       	add.a %a12,4
8000f782:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000f786:	80 df       	mov.d %d15,%a13
8000f788:	80 c2       	mov.d %d2,%a12
8000f78a:	74 23       	st.w [%a2],%d3
8000f78c:	40 f2       	mov.aa %a2,%a15
8000f78e:	7f 2f e6 ff 	jge.u %d15,%d2,8000f75a <quorem+0xbe>
8000f792:	60 92       	mov.a %a2,%d9
8000f794:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000f798:	4c f0       	ld.w %d15,[%a15]0
8000f79a:	ee 0c       	jnz %d15,8000f7b2 <quorem+0x116>
8000f79c:	b0 cf       	add.a %a15,-4
8000f79e:	80 f2       	mov.d %d2,%a15
8000f7a0:	3f 29 05 80 	jlt.u %d9,%d2,8000f7aa <quorem+0x10e>
8000f7a4:	59 e8 10 00 	st.w [%a14]16,%d8
8000f7a8:	3c 05       	j 8000f7b2 <quorem+0x116>
8000f7aa:	4c f0       	ld.w %d15,[%a15]0
8000f7ac:	ee fc       	jnz %d15,8000f7a4 <quorem+0x108>
8000f7ae:	c2 f8       	add %d8,-1
8000f7b0:	3c f6       	j 8000f79c <quorem+0x100>
8000f7b2:	02 a2       	mov %d2,%d10
8000f7b4:	00 90       	ret 
	...

8000f7b8 <_dtoa_r>:
8000f7b8:	20 58       	sub.a %sp,88
8000f7ba:	b5 a5 08 10 	st.a [%sp]72,%a5
8000f7be:	99 45 00 10 	ld.a %a5,[%a4]64
8000f7c2:	59 a6 1c 00 	st.w [%sp]28,%d6
8000f7c6:	59 a7 28 00 	st.w [%sp]40,%d7
8000f7ca:	b5 a7 38 00 	st.a [%sp]56,%a7
8000f7ce:	40 4d       	mov.aa %a13,%a4
8000f7d0:	0b 45 10 88 	mov %e8,%d5,%d4
8000f7d4:	40 6c       	mov.aa %a12,%a6
8000f7d6:	0b 45 10 c8 	mov %e12,%d5,%d4
8000f7da:	bc 5e       	jz.a %a5,8000f7f6 <_dtoa_r+0x3e>
8000f7dc:	19 4f 04 10 	ld.w %d15,[%a4]68
8000f7e0:	82 12       	mov %d2,1
8000f7e2:	0f f2 00 20 	sh %d2,%d2,%d15
8000f7e6:	6c 51       	st.w [%a5]4,%d15
8000f7e8:	59 52 08 00 	st.w [%a5]8,%d2
8000f7ec:	82 0f       	mov %d15,0
8000f7ee:	6d 00 e8 08 	call 800109be <_Bfree>
8000f7f2:	59 df 00 10 	st.w [%a13]64,%d15
8000f7f6:	ce 96       	jgez %d9,8000f802 <_dtoa_r+0x4a>
8000f7f8:	82 1f       	mov %d15,1
8000f7fa:	6c c0       	st.w [%a12]0,%d15
8000f7fc:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000f800:	3c 03       	j 8000f806 <_dtoa_r+0x4e>
8000f802:	82 0f       	mov %d15,0
8000f804:	6c c0       	st.w [%a12]0,%d15
8000f806:	7b 00 ff 27 	movh %d2,32752
8000f80a:	26 d2       	and %d2,%d13
8000f80c:	7b 00 ff 37 	movh %d3,32752
8000f810:	5f 32 22 80 	jne %d2,%d3,8000f854 <_dtoa_r+0x9c>
8000f814:	99 a3 08 10 	ld.a %a3,[%sp]72
8000f818:	3b f0 70 22 	mov %d2,9999
8000f81c:	91 00 00 f8 	movh.a %a15,32768
8000f820:	74 32       	st.w [%a3],%d2
8000f822:	d9 ff d1 10 	lea %a15,[%a15]3153 <80000c51 <blanks.4035+0x19>>
8000f826:	f6 c8       	jnz %d12,8000f836 <_dtoa_r+0x7e>
8000f828:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000f82c:	ee 05       	jnz %d15,8000f836 <_dtoa_r+0x7e>
8000f82e:	91 00 00 f8 	movh.a %a15,32768
8000f832:	d9 ff c8 10 	lea %a15,[%a15]3144 <80000c48 <blanks.4035+0x10>>
8000f836:	99 a3 38 00 	ld.a %a3,[%sp]56 <80000c48 <blanks.4035+0x10>>
8000f83a:	40 f2       	mov.aa %a2,%a15
8000f83c:	bd 03 26 06 	jz.a %a3,80010488 <_dtoa_r+0xcd0>
8000f840:	80 ff       	mov.d %d15,%a15
8000f842:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000f846:	1b 8f 00 20 	addi %d2,%d15,8
8000f84a:	c2 3f       	add %d15,3
8000f84c:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000f850:	6c 30       	st.w [%a3]0,%d15
8000f852:	00 90       	ret 
8000f854:	0b cd 10 48 	mov %e4,%d13,%d12
8000f858:	d2 06       	mov %e6,0
8000f85a:	0b cd 10 88 	mov %e8,%d13,%d12
8000f85e:	6d 00 15 13 	call 80011e88 <__eqdf2>
8000f862:	df 02 13 80 	jne %d2,0,8000f888 <_dtoa_r+0xd0>
8000f866:	99 a3 08 10 	ld.a %a3,[%sp]72
8000f86a:	d8 0e       	ld.a %a15,[%sp]56
8000f86c:	82 1f       	mov %d15,1
8000f86e:	91 00 00 28 	movh.a %a2,32768
8000f872:	6c 30       	st.w [%a3]0,%d15
8000f874:	d9 22 d5 10 	lea %a2,[%a2]3157 <80000c55 <blanks.4035+0x1d>>
8000f878:	bd 0f 08 06 	jz.a %a15,80010488 <_dtoa_r+0xcd0>
8000f87c:	7b 00 00 f8 	movh %d15,32768
8000f880:	1b 6f c5 f0 	addi %d15,%d15,3158
8000f884:	68 0f       	st.w [%a15]0,%d15
8000f886:	00 90       	ret 
8000f888:	0b cd 10 48 	mov %e4,%d13,%d12
8000f88c:	40 d4       	mov.aa %a4,%a13
8000f88e:	d9 a5 14 10 	lea %a5,[%sp]84
8000f892:	d9 a6 10 10 	lea %a6,[%sp]80
8000f896:	6d 00 e8 0a 	call 80010e66 <__d2b>
8000f89a:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000f89e:	40 2e       	mov.aa %a14,%a2
8000f8a0:	19 aa 10 10 	ld.w %d10,[%sp]80
8000f8a4:	76 bd       	jz %d11,8000f8be <_dtoa_r+0x106>
8000f8a6:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000f8aa:	0b cd 10 48 	mov %e4,%d13,%d12
8000f8ae:	7b 00 ff 23 	movh %d2,16368
8000f8b2:	0f 2f a0 50 	or %d5,%d15,%d2
8000f8b6:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000f8ba:	82 0f       	mov %d15,0
8000f8bc:	3c 22       	j 8000f900 <_dtoa_r+0x148>
8000f8be:	19 ab 14 10 	ld.w %d11,[%sp]84
8000f8c2:	3b e0 be 4f 	mov %d4,-1042
8000f8c6:	42 ab       	add %d11,%d10
8000f8c8:	a2 b4       	sub %d4,%d11
8000f8ca:	3b f0 be 2f 	mov %d2,-1041
8000f8ce:	0f 4c 00 40 	sh %d4,%d12,%d4
8000f8d2:	3f 2b 0f 00 	jlt %d11,%d2,8000f8f0 <_dtoa_r+0x138>
8000f8d6:	1b 2b 41 30 	addi %d3,%d11,1042
8000f8da:	3b e0 c0 4f 	mov %d4,-1010
8000f8de:	a2 b4       	sub %d4,%d11
8000f8e0:	8b 03 00 21 	rsub %d2,%d3,0
8000f8e4:	0f 2c 00 20 	sh %d2,%d12,%d2
8000f8e8:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000f8ec:	0f f2 a0 40 	or %d4,%d2,%d15
8000f8f0:	6d 00 b7 13 	call 8001205e <__floatunsidf>
8000f8f4:	0b 23 10 48 	mov %e4,%d3,%d2
8000f8f8:	9b 03 e1 5f 	addih %d5,%d3,65040
8000f8fc:	c2 fb       	add %d11,-1
8000f8fe:	82 1f       	mov %d15,1
8000f900:	b7 00 ab 69 	imask %e6,0,19,11
8000f904:	78 13       	st.w [%sp]76,%d15
8000f906:	6d 00 43 11 	call 80011b8c <__subdf3>
8000f90a:	7b 30 fd 73 	movh %d7,16339
8000f90e:	0b 23 10 48 	mov %e4,%d3,%d2
8000f912:	7b f0 36 66 	movh %d6,25455
8000f916:	1b 77 7a 78 	addi %d7,%d7,-30809
8000f91a:	1b 16 36 64 	addi %d6,%d6,17249
8000f91e:	6d 00 57 11 	call 80011bcc <__muldf3>
8000f922:	7b 70 fc 73 	movh %d7,16327
8000f926:	0b 23 10 48 	mov %e4,%d3,%d2
8000f92a:	7b 10 b6 68 	movh %d6,35681
8000f92e:	1b 87 a2 78 	addi %d7,%d7,-30168
8000f932:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000f936:	6d 00 0f 11 	call 80011b54 <__adddf3>
8000f93a:	02 b4       	mov %d4,%d11
8000f93c:	0b 23 10 88 	mov %e8,%d3,%d2
8000f940:	6d 00 44 13 	call 80011fc8 <__floatsidf>
8000f944:	7b 30 fd 73 	movh %d7,16339
8000f948:	0b 23 10 48 	mov %e4,%d3,%d2
8000f94c:	7b f0 09 65 	movh %d6,20639
8000f950:	1b 37 41 74 	addi %d7,%d7,17427
8000f954:	1b b6 9f 67 	addi %d6,%d6,31227
8000f958:	6d 00 3a 11 	call 80011bcc <__muldf3>
8000f95c:	0b 89 10 48 	mov %e4,%d9,%d8
8000f960:	0b 23 10 68 	mov %e6,%d3,%d2
8000f964:	6d 00 f8 10 	call 80011b54 <__adddf3>
8000f968:	0b 23 10 48 	mov %e4,%d3,%d2
8000f96c:	0b 23 10 88 	mov %e8,%d3,%d2
8000f970:	6d 00 50 13 	call 80012010 <__fixdfsi>
8000f974:	0b 89 10 48 	mov %e4,%d9,%d8
8000f978:	d2 06       	mov %e6,0
8000f97a:	59 a2 08 00 	st.w [%sp]8,%d2
8000f97e:	6d 00 05 13 	call 80011f88 <__ltdf2>
8000f982:	ff 02 12 00 	jge %d2,0,8000f9a6 <_dtoa_r+0x1ee>
8000f986:	19 a4 08 00 	ld.w %d4,[%sp]8
8000f98a:	6d 00 1f 13 	call 80011fc8 <__floatsidf>
8000f98e:	0b 89 10 48 	mov %e4,%d9,%d8
8000f992:	0b 23 10 68 	mov %e6,%d3,%d2
8000f996:	6d 00 99 12 	call 80011ec8 <__nedf2>
8000f99a:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f99e:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000f9a2:	59 a3 08 00 	st.w [%sp]8,%d3
8000f9a6:	19 a2 08 00 	ld.w %d2,[%sp]8
8000f9aa:	82 13       	mov %d3,1
8000f9ac:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000f9b0:	59 a3 3c 00 	st.w [%sp]60,%d3
8000f9b4:	ee 18       	jnz %d15,8000f9e4 <_dtoa_r+0x22c>
8000f9b6:	91 00 00 f8 	movh.a %a15,32768
8000f9ba:	d9 ff f8 30 	lea %a15,[%a15]3320 <80000cf8 <__mprec_tens>>
8000f9be:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000f9c2:	0b cd 10 68 	mov %e6,%d13,%d12
8000f9c6:	09 f4 40 09 	ld.d %e4,[%a15]
8000f9ca:	6d 00 9f 12 	call 80011f08 <__gtdf2>
8000f9ce:	8e 28       	jlez %d2,8000f9de <_dtoa_r+0x226>
8000f9d0:	58 02       	ld.w %d15,[%sp]8
8000f9d2:	82 02       	mov %d2,0
8000f9d4:	c2 ff       	add %d15,-1
8000f9d6:	78 02       	st.w [%sp]8,%d15
8000f9d8:	59 a2 3c 00 	st.w [%sp]60,%d2
8000f9dc:	3c 04       	j 8000f9e4 <_dtoa_r+0x22c>
8000f9de:	82 03       	mov %d3,0
8000f9e0:	59 a3 3c 00 	st.w [%sp]60,%d3
8000f9e4:	0b ba 80 b0 	sub %d11,%d10,%d11
8000f9e8:	9a fb       	add %d15,%d11,-1
8000f9ea:	82 02       	mov %d2,0
8000f9ec:	78 06       	st.w [%sp]24,%d15
8000f9ee:	59 a2 14 00 	st.w [%sp]20,%d2
8000f9f2:	ce f6       	jgez %d15,8000f9fe <_dtoa_r+0x246>
8000f9f4:	32 5f       	rsub %d15
8000f9f6:	82 03       	mov %d3,0
8000f9f8:	78 05       	st.w [%sp]20,%d15
8000f9fa:	59 a3 18 00 	st.w [%sp]24,%d3
8000f9fe:	58 02       	ld.w %d15,[%sp]8
8000fa00:	0e fa       	jltz %d15,8000fa14 <_dtoa_r+0x25c>
8000fa02:	19 a2 18 00 	ld.w %d2,[%sp]24
8000fa06:	78 0d       	st.w [%sp]52,%d15
8000fa08:	42 f2       	add %d2,%d15
8000fa0a:	82 0f       	mov %d15,0
8000fa0c:	59 a2 18 00 	st.w [%sp]24,%d2
8000fa10:	78 08       	st.w [%sp]32,%d15
8000fa12:	3c 0d       	j 8000fa2c <_dtoa_r+0x274>
8000fa14:	19 a2 14 00 	ld.w %d2,[%sp]20
8000fa18:	19 a3 08 00 	ld.w %d3,[%sp]8
8000fa1c:	82 0f       	mov %d15,0
8000fa1e:	a2 32       	sub %d2,%d3
8000fa20:	32 53       	rsub %d3
8000fa22:	59 a2 14 00 	st.w [%sp]20,%d2
8000fa26:	59 a3 20 00 	st.w [%sp]32,%d3
8000fa2a:	78 0d       	st.w [%sp]52,%d15
8000fa2c:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000fa30:	82 18       	mov %d8,1
8000fa32:	ff a2 46 80 	jge.u %d2,10,8000fabe <_dtoa_r+0x306>
8000fa36:	bf 62 06 00 	jlt %d2,6,8000fa42 <_dtoa_r+0x28a>
8000fa3a:	c2 c2       	add %d2,-4
8000fa3c:	59 a2 1c 00 	st.w [%sp]28,%d2
8000fa40:	82 08       	mov %d8,0
8000fa42:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000fa46:	c2 e3       	add %d3,-2
8000fa48:	ff 43 4b 80 	jge.u %d3,4,8000fade <_dtoa_r+0x326>
8000fa4c:	91 10 00 f8 	movh.a %a15,32769
8000fa50:	d9 ff 9c 9f 	lea %a15,[%a15]-1444 <8000fa5c <_dtoa_r+0x2a4>>
8000fa54:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000fa58:	dc 0f       	ji %a15
8000fa5a:	00 00       	nop 
8000fa5c:	1d 00 08 00 	j 8000fa6c <_dtoa_r+0x2b4>
8000fa60:	1d 00 1c 00 	j 8000fa98 <_dtoa_r+0x2e0>
8000fa64:	1d 00 08 00 	j 8000fa74 <_dtoa_r+0x2bc>
8000fa68:	1d 00 1c 00 	j 8000faa0 <_dtoa_r+0x2e8>
8000fa6c:	82 03       	mov %d3,0
8000fa6e:	59 a3 24 00 	st.w [%sp]36,%d3
8000fa72:	3c 03       	j 8000fa78 <_dtoa_r+0x2c0>
8000fa74:	82 1f       	mov %d15,1
8000fa76:	78 09       	st.w [%sp]36,%d15
8000fa78:	19 a2 28 00 	ld.w %d2,[%sp]40
8000fa7c:	59 a2 2c 00 	st.w [%sp]44,%d2
8000fa80:	59 a2 10 00 	st.w [%sp]16,%d2
8000fa84:	02 23       	mov %d3,%d2
8000fa86:	ff 12 38 00 	jge %d2,1,8000faf6 <_dtoa_r+0x33e>
8000fa8a:	82 13       	mov %d3,1
8000fa8c:	82 1f       	mov %d15,1
8000fa8e:	59 a3 2c 00 	st.w [%sp]44,%d3
8000fa92:	78 04       	st.w [%sp]16,%d15
8000fa94:	82 12       	mov %d2,1
8000fa96:	3c 21       	j 8000fad8 <_dtoa_r+0x320>
8000fa98:	82 03       	mov %d3,0
8000fa9a:	59 a3 24 00 	st.w [%sp]36,%d3
8000fa9e:	3c 03       	j 8000faa4 <_dtoa_r+0x2ec>
8000faa0:	82 1f       	mov %d15,1
8000faa2:	78 09       	st.w [%sp]36,%d15
8000faa4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000faa8:	19 a2 28 00 	ld.w %d2,[%sp]40
8000faac:	42 32       	add %d2,%d3
8000faae:	59 a2 2c 00 	st.w [%sp]44,%d2
8000fab2:	c2 12       	add %d2,1
8000fab4:	59 a2 10 00 	st.w [%sp]16,%d2
8000fab8:	8b 12 40 33 	max %d3,%d2,1
8000fabc:	3c 1d       	j 8000faf6 <_dtoa_r+0x33e>
8000fabe:	82 0f       	mov %d15,0
8000fac0:	82 12       	mov %d2,1
8000fac2:	82 f3       	mov %d3,-1
8000fac4:	78 07       	st.w [%sp]28,%d15
8000fac6:	82 ff       	mov %d15,-1
8000fac8:	59 a2 24 00 	st.w [%sp]36,%d2
8000facc:	59 a3 2c 00 	st.w [%sp]44,%d3
8000fad0:	78 04       	st.w [%sp]16,%d15
8000fad2:	3b 20 01 30 	mov %d3,18
8000fad6:	82 02       	mov %d2,0
8000fad8:	59 a2 28 00 	st.w [%sp]40,%d2
8000fadc:	3c 0d       	j 8000faf6 <_dtoa_r+0x33e>
8000fade:	82 ff       	mov %d15,-1
8000fae0:	82 13       	mov %d3,1
8000fae2:	78 0b       	st.w [%sp]44,%d15
8000fae4:	82 f2       	mov %d2,-1
8000fae6:	82 0f       	mov %d15,0
8000fae8:	59 a3 24 00 	st.w [%sp]36,%d3
8000faec:	59 a2 10 00 	st.w [%sp]16,%d2
8000faf0:	3b 20 01 30 	mov %d3,18
8000faf4:	78 0a       	st.w [%sp]40,%d15
8000faf6:	82 05       	mov %d5,0
8000faf8:	59 d5 04 10 	st.w [%a13]68,%d5
8000fafc:	82 45       	mov %d5,4
8000fafe:	1b 45 01 00 	addi %d0,%d5,20
8000fb02:	3f 03 09 80 	jlt.u %d3,%d0,8000fb14 <_dtoa_r+0x35c>
8000fb06:	19 d0 04 10 	ld.w %d0,[%a13]68
8000fb0a:	06 15       	sh %d5,1
8000fb0c:	c2 10       	add %d0,1
8000fb0e:	59 d0 04 10 	st.w [%a13]68,%d0
8000fb12:	3c f6       	j 8000fafe <_dtoa_r+0x346>
8000fb14:	40 d4       	mov.aa %a4,%a13
8000fb16:	19 d4 04 10 	ld.w %d4,[%a13]68
8000fb1a:	6d 00 27 07 	call 80010968 <_Balloc>
8000fb1e:	19 a2 10 00 	ld.w %d2,[%sp]16
8000fb22:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000fb26:	8b f2 60 32 	lt.u %d3,%d2,15
8000fb2a:	b5 d2 00 10 	st.a [%a13]64,%a2
8000fb2e:	26 38       	and %d8,%d3
8000fb30:	df 08 97 01 	jeq %d8,0,8000fe5e <_dtoa_r+0x6a6>
8000fb34:	19 a3 08 00 	ld.w %d3,[%sp]8
8000fb38:	89 ac 40 19 	st.d [%sp]64,%e12
8000fb3c:	bf 13 3f 00 	jlt %d3,1,8000fbba <_dtoa_r+0x402>
8000fb40:	91 00 00 f8 	movh.a %a15,32768
8000fb44:	8f f3 00 31 	and %d3,%d3,15
8000fb48:	d9 ff f8 30 	lea %a15,[%a15]3320 <80000cf8 <__mprec_tens>>
8000fb4c:	19 ae 08 00 	ld.w %d14,[%sp]8 <80000cf8 <__mprec_tens>>
8000fb50:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000fb54:	86 ce       	sha %d14,-4
8000fb56:	09 f8 40 09 	ld.d %e8,[%a15]
8000fb5a:	82 2a       	mov %d10,2
8000fb5c:	6f 4e 11 00 	jz.t %d14,4,8000fb7e <_dtoa_r+0x3c6>
8000fb60:	91 00 00 f8 	movh.a %a15,32768
8000fb64:	0b cd 10 48 	mov %e4,%d13,%d12
8000fb68:	d9 ff d0 30 	lea %a15,[%a15]3280 <80000cd0 <__mprec_bigtens>>
8000fb6c:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000fb70:	6d 00 00 11 	call 80011d70 <__divdf3>
8000fb74:	0b 23 10 c8 	mov %e12,%d3,%d2
8000fb78:	8f fe 00 e1 	and %d14,%d14,15
8000fb7c:	82 3a       	mov %d10,3
8000fb7e:	7b 00 00 b8 	movh %d11,32768
8000fb82:	82 0f       	mov %d15,0
8000fb84:	1b 0b cd b0 	addi %d11,%d11,3280
8000fb88:	df 0e 12 00 	jeq %d14,0,8000fbac <_dtoa_r+0x3f4>
8000fb8c:	6f 0e 0d 00 	jz.t %d14,0,8000fba6 <_dtoa_r+0x3ee>
8000fb90:	60 b2       	mov.a %a2,%d11
8000fb92:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000fb94:	0b 89 10 48 	mov %e4,%d9,%d8
8000fb98:	09 f6 40 09 	ld.d %e6,[%a15]
8000fb9c:	6d 00 18 10 	call 80011bcc <__muldf3>
8000fba0:	0b 23 10 88 	mov %e8,%d3,%d2
8000fba4:	c2 1a       	add %d10,1
8000fba6:	86 fe       	sha %d14,-1
8000fba8:	c2 1f       	add %d15,1
8000fbaa:	3c ef       	j 8000fb88 <_dtoa_r+0x3d0>
8000fbac:	0b cd 10 48 	mov %e4,%d13,%d12
8000fbb0:	0b 89 10 68 	mov %e6,%d9,%d8
8000fbb4:	6d 00 de 10 	call 80011d70 <__divdf3>
8000fbb8:	3c 2c       	j 8000fc10 <_dtoa_r+0x458>
8000fbba:	19 a8 08 00 	ld.w %d8,[%sp]8
8000fbbe:	82 2a       	mov %d10,2
8000fbc0:	32 58       	rsub %d8
8000fbc2:	df 08 29 00 	jeq %d8,0,8000fc14 <_dtoa_r+0x45c>
8000fbc6:	91 00 00 f8 	movh.a %a15,32768
8000fbca:	8f f8 00 31 	and %d3,%d8,15
8000fbce:	d9 ff f8 30 	lea %a15,[%a15]3320 <80000cf8 <__mprec_tens>>
8000fbd2:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000fbd6:	09 a4 40 19 	ld.d %e4,[%sp]64
8000fbda:	09 f6 40 09 	ld.d %e6,[%a15]
8000fbde:	7b 00 00 c8 	movh %d12,32768
8000fbe2:	6d 00 f5 0f 	call 80011bcc <__muldf3>
8000fbe6:	82 09       	mov %d9,0
8000fbe8:	86 c8       	sha %d8,-4
8000fbea:	1b 0c cd c0 	addi %d12,%d12,3280
8000fbee:	df 08 11 00 	jeq %d8,0,8000fc10 <_dtoa_r+0x458>
8000fbf2:	6f 08 0c 00 	jz.t %d8,0,8000fc0a <_dtoa_r+0x452>
8000fbf6:	60 c3       	mov.a %a3,%d12
8000fbf8:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000fbfc:	0b 23 10 48 	mov %e4,%d3,%d2
8000fc00:	09 f6 40 09 	ld.d %e6,[%a15]
8000fc04:	c2 1a       	add %d10,1
8000fc06:	6d 00 e3 0f 	call 80011bcc <__muldf3>
8000fc0a:	86 f8       	sha %d8,-1
8000fc0c:	c2 19       	add %d9,1
8000fc0e:	3c f0       	j 8000fbee <_dtoa_r+0x436>
8000fc10:	0b 23 10 c8 	mov %e12,%d3,%d2
8000fc14:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000fc18:	df 02 23 00 	jeq %d2,0,8000fc5e <_dtoa_r+0x4a6>
8000fc1c:	0b cd 10 48 	mov %e4,%d13,%d12
8000fc20:	b7 00 2a 6a 	imask %e6,0,20,10
8000fc24:	6d 00 b2 11 	call 80011f88 <__ltdf2>
8000fc28:	ff 02 20 00 	jge %d2,0,8000fc68 <_dtoa_r+0x4b0>
8000fc2c:	19 a3 10 00 	ld.w %d3,[%sp]16
8000fc30:	df 03 21 00 	jeq %d3,0,8000fc72 <_dtoa_r+0x4ba>
8000fc34:	58 0b       	ld.w %d15,[%sp]44
8000fc36:	bf 1f 12 01 	jlt %d15,1,8000fe5a <_dtoa_r+0x6a2>
8000fc3a:	19 a2 08 00 	ld.w %d2,[%sp]8
8000fc3e:	0b cd 10 48 	mov %e4,%d13,%d12
8000fc42:	c2 f2       	add %d2,-1
8000fc44:	82 06       	mov %d6,0
8000fc46:	7b 40 02 74 	movh %d7,16420
8000fc4a:	59 a2 30 00 	st.w [%sp]48,%d2
8000fc4e:	6d 00 bf 0f 	call 80011bcc <__muldf3>
8000fc52:	c2 1a       	add %d10,1
8000fc54:	0b 23 10 c8 	mov %e12,%d3,%d2
8000fc58:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000fc5c:	3c 10       	j 8000fc7c <_dtoa_r+0x4c4>
8000fc5e:	19 a3 08 00 	ld.w %d3,[%sp]8
8000fc62:	59 a3 30 00 	st.w [%sp]48,%d3
8000fc66:	3c 03       	j 8000fc6c <_dtoa_r+0x4b4>
8000fc68:	58 02       	ld.w %d15,[%sp]8
8000fc6a:	78 0c       	st.w [%sp]48,%d15
8000fc6c:	99 ac 10 00 	ld.a %a12,[%sp]16
8000fc70:	3c 06       	j 8000fc7c <_dtoa_r+0x4c4>
8000fc72:	19 a2 08 00 	ld.w %d2,[%sp]8
8000fc76:	a0 0c       	mov.a %a12,0
8000fc78:	59 a2 30 00 	st.w [%sp]48,%d2
8000fc7c:	02 a4       	mov %d4,%d10
8000fc7e:	6d 00 a5 11 	call 80011fc8 <__floatsidf>
8000fc82:	0b cd 10 68 	mov %e6,%d13,%d12
8000fc86:	0b 23 10 48 	mov %e4,%d3,%d2
8000fc8a:	6d 00 a1 0f 	call 80011bcc <__muldf3>
8000fc8e:	0b 23 10 48 	mov %e4,%d3,%d2
8000fc92:	82 06       	mov %d6,0
8000fc94:	7b c0 01 74 	movh %d7,16412
8000fc98:	6d 00 5e 0f 	call 80011b54 <__adddf3>
8000fc9c:	0b 23 10 a8 	mov %e10,%d3,%d2
8000fca0:	0b 23 10 e8 	mov %e14,%d3,%d2
8000fca4:	60 b2       	mov.a %a2,%d11
8000fca6:	11 02 cc ff 	addih.a %a15,%a2,64704
8000fcaa:	80 ff       	mov.d %d15,%a15
8000fcac:	bd 0c 1e 80 	jnz.a %a12,8000fce8 <_dtoa_r+0x530>
8000fcb0:	0b cd 10 48 	mov %e4,%d13,%d12
8000fcb4:	82 06       	mov %d6,0
8000fcb6:	7b 40 01 74 	movh %d7,16404
8000fcba:	6d 00 69 0f 	call 80011b8c <__subdf3>
8000fcbe:	80 f7       	mov.d %d7,%a15
8000fcc0:	0b 23 10 48 	mov %e4,%d3,%d2
8000fcc4:	02 e6       	mov %d6,%d14
8000fcc6:	0b 23 10 88 	mov %e8,%d3,%d2
8000fcca:	6d 00 1f 11 	call 80011f08 <__gtdf2>
8000fcce:	ff 12 8e 02 	jge %d2,1,800101ea <_dtoa_r+0xa32>
8000fcd2:	0b 89 10 48 	mov %e4,%d9,%d8
8000fcd6:	02 e6       	mov %d6,%d14
8000fcd8:	9b 0b cc 77 	addih %d7,%d11,31936
8000fcdc:	6d 00 56 11 	call 80011f88 <__ltdf2>
8000fce0:	bf 02 7d 02 	jlt %d2,0,800101da <_dtoa_r+0xa22>
8000fce4:	1d 00 bb 00 	j 8000fe5a <_dtoa_r+0x6a2>
8000fce8:	80 c5       	mov.d %d5,%a12
8000fcea:	91 00 00 f8 	movh.a %a15,32768
8000fcee:	19 a2 24 00 	ld.w %d2,[%sp]36
8000fcf2:	d9 ff f8 30 	lea %a15,[%a15]3320 <80000cf8 <__mprec_tens>>
8000fcf6:	c2 f5       	add %d5,-1
8000fcf8:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000fcfc:	df 02 57 00 	jeq %d2,0,8000fdaa <_dtoa_r+0x5f2>
8000fd00:	b7 00 a9 4a 	imask %e4,0,21,9
8000fd04:	09 f6 40 09 	ld.d %e6,[%a15]
8000fd08:	6d 00 34 10 	call 80011d70 <__divdf3>
8000fd0c:	0b ef 10 68 	mov %e6,%d15,%d14
8000fd10:	0b 23 10 48 	mov %e4,%d3,%d2
8000fd14:	6d 00 3c 0f 	call 80011b8c <__subdf3>
8000fd18:	d8 03       	ld.a %a15,[%sp]12
8000fd1a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000fd1e:	0b cd 10 48 	mov %e4,%d13,%d12
8000fd22:	80 fe       	mov.d %d14,%a15
8000fd24:	6d 00 76 11 	call 80012010 <__fixdfsi>
8000fd28:	02 24       	mov %d4,%d2
8000fd2a:	02 2f       	mov %d15,%d2
8000fd2c:	6d 00 4e 11 	call 80011fc8 <__floatsidf>
8000fd30:	0b cd 10 48 	mov %e4,%d13,%d12
8000fd34:	0b 23 10 68 	mov %e6,%d3,%d2
8000fd38:	c2 1e       	add %d14,1
8000fd3a:	6d 00 29 0f 	call 80011b8c <__subdf3>
8000fd3e:	1b 0f 03 50 	addi %d5,%d15,48
8000fd42:	28 05       	st.b [%a15]0,%d5
8000fd44:	0b ab 10 68 	mov %e6,%d11,%d10
8000fd48:	0b 23 10 48 	mov %e4,%d3,%d2
8000fd4c:	0b 23 10 88 	mov %e8,%d3,%d2
8000fd50:	6d 00 1c 11 	call 80011f88 <__ltdf2>
8000fd54:	bf 02 86 03 	jlt %d2,0,80010460 <_dtoa_r+0xca8>
8000fd58:	b7 00 2a 4a 	imask %e4,0,20,10
8000fd5c:	0b 89 10 68 	mov %e6,%d9,%d8
8000fd60:	6d 00 16 0f 	call 80011b8c <__subdf3>
8000fd64:	0b ab 10 68 	mov %e6,%d11,%d10
8000fd68:	0b 23 10 48 	mov %e4,%d3,%d2
8000fd6c:	6d 00 0e 11 	call 80011f88 <__ltdf2>
8000fd70:	bf 02 ea 00 	jlt %d2,0,8000ff44 <_dtoa_r+0x78c>
8000fd74:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000fd78:	02 e5       	mov %d5,%d14
8000fd7a:	80 cf       	mov.d %d15,%a12
8000fd7c:	a2 35       	sub %d5,%d3
8000fd7e:	7f f5 6e 00 	jge %d5,%d15,8000fe5a <_dtoa_r+0x6a2>
8000fd82:	0b ab 10 48 	mov %e4,%d11,%d10
8000fd86:	82 06       	mov %d6,0
8000fd88:	7b 40 02 74 	movh %d7,16420
8000fd8c:	6d 00 20 0f 	call 80011bcc <__muldf3>
8000fd90:	0b 89 10 48 	mov %e4,%d9,%d8
8000fd94:	82 06       	mov %d6,0
8000fd96:	7b 40 02 74 	movh %d7,16420
8000fd9a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000fd9e:	6d 00 17 0f 	call 80011bcc <__muldf3>
8000fda2:	60 ef       	mov.a %a15,%d14
8000fda4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000fda8:	3c bb       	j 8000fd1e <_dtoa_r+0x566>
8000fdaa:	0b ef 10 68 	mov %e6,%d15,%d14
8000fdae:	09 f4 40 09 	ld.d %e4,[%a15]
8000fdb2:	6d 00 0d 0f 	call 80011bcc <__muldf3>
8000fdb6:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000fdba:	0b 23 10 a8 	mov %e10,%d3,%d2
8000fdbe:	30 c3       	add.a %a3,%a12
8000fdc0:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000fdc4:	80 3e       	mov.d %d14,%a3
8000fdc6:	0b cd 10 48 	mov %e4,%d13,%d12
8000fdca:	d9 cf 01 00 	lea %a15,[%a12]1
8000fdce:	6d 00 21 11 	call 80012010 <__fixdfsi>
8000fdd2:	02 24       	mov %d4,%d2
8000fdd4:	02 2f       	mov %d15,%d2
8000fdd6:	6d 00 f9 10 	call 80011fc8 <__floatsidf>
8000fdda:	0b cd 10 48 	mov %e4,%d13,%d12
8000fdde:	0b 23 10 68 	mov %e6,%d3,%d2
8000fde2:	6d 00 d5 0e 	call 80011b8c <__subdf3>
8000fde6:	1b 0f 03 50 	addi %d5,%d15,48
8000fdea:	0b 23 10 88 	mov %e8,%d3,%d2
8000fdee:	80 f2       	mov.d %d2,%a15
8000fdf0:	34 c5       	st.b [%a12],%d5
8000fdf2:	5f e2 29 80 	jne %d2,%d14,8000fe44 <_dtoa_r+0x68c>
8000fdf6:	0b ab 10 48 	mov %e4,%d11,%d10
8000fdfa:	b7 00 a9 6a 	imask %e6,0,21,9
8000fdfe:	6d 00 ab 0e 	call 80011b54 <__adddf3>
8000fe02:	0b 89 10 48 	mov %e4,%d9,%d8
8000fe06:	0b 23 10 68 	mov %e6,%d3,%d2
8000fe0a:	6d 00 7f 10 	call 80011f08 <__gtdf2>
8000fe0e:	ff 12 9b 00 	jge %d2,1,8000ff44 <_dtoa_r+0x78c>
8000fe12:	b7 00 a9 4a 	imask %e4,0,21,9
8000fe16:	0b ab 10 68 	mov %e6,%d11,%d10
8000fe1a:	6d 00 b9 0e 	call 80011b8c <__subdf3>
8000fe1e:	0b 89 10 48 	mov %e4,%d9,%d8
8000fe22:	0b 23 10 68 	mov %e6,%d3,%d2
8000fe26:	6d 00 b1 10 	call 80011f88 <__ltdf2>
8000fe2a:	ff 02 18 00 	jge %d2,0,8000fe5a <_dtoa_r+0x6a2>
8000fe2e:	60 e2       	mov.a %a2,%d14
8000fe30:	60 ef       	mov.a %a15,%d14
8000fe32:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000fe36:	b0 ff       	add.a %a15,-1
8000fe38:	8b 0f 03 f2 	eq %d15,%d15,48
8000fe3c:	df 0f 12 03 	jeq %d15,0,80010460 <_dtoa_r+0xca8>
8000fe40:	80 fe       	mov.d %d14,%a15
8000fe42:	3c f6       	j 8000fe2e <_dtoa_r+0x676>
8000fe44:	0b 89 10 48 	mov %e4,%d9,%d8
8000fe48:	82 06       	mov %d6,0
8000fe4a:	7b 40 02 74 	movh %d7,16420
8000fe4e:	6d 00 bf 0e 	call 80011bcc <__muldf3>
8000fe52:	40 fc       	mov.aa %a12,%a15
8000fe54:	0b 23 10 c8 	mov %e12,%d3,%d2
8000fe58:	3c b7       	j 8000fdc6 <_dtoa_r+0x60e>
8000fe5a:	09 ac 40 19 	ld.d %e12,[%sp]64
8000fe5e:	19 a3 14 10 	ld.w %d3,[%sp]84
8000fe62:	19 a2 08 00 	ld.w %d2,[%sp]8
8000fe66:	8b 03 80 52 	ge %d5,%d3,0
8000fe6a:	8b f2 40 54 	and.lt %d5,%d2,15
8000fe6e:	df 05 9e 00 	jeq %d5,0,8000ffaa <_dtoa_r+0x7f2>
8000fe72:	91 00 00 f8 	movh.a %a15,32768
8000fe76:	d9 ff f8 30 	lea %a15,[%a15]3320 <80000cf8 <__mprec_tens>>
8000fe7a:	19 a3 10 00 	ld.w %d3,[%sp]16 <80000cf8 <__mprec_tens>>
8000fe7e:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000fe82:	19 a2 28 00 	ld.w %d2,[%sp]40
8000fe86:	fa 13       	lt %d15,%d3,1
8000fe88:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000fe8c:	09 f8 40 09 	ld.d %e8,[%a15]
8000fe90:	6e 16       	jz %d15,8000febc <_dtoa_r+0x704>
8000fe92:	df 03 a4 81 	jne %d3,0,800101da <_dtoa_r+0xa22>
8000fe96:	0b 89 10 48 	mov %e4,%d9,%d8
8000fe9a:	82 06       	mov %d6,0
8000fe9c:	7b 40 01 74 	movh %d7,16404
8000fea0:	6d 00 96 0e 	call 80011bcc <__muldf3>
8000fea4:	0b cd 10 68 	mov %e6,%d13,%d12
8000fea8:	0b 23 10 48 	mov %e4,%d3,%d2
8000feac:	a0 0c       	mov.a %a12,0
8000feae:	6d 00 4d 10 	call 80011f48 <__gedf2>
8000feb2:	a0 0f       	mov.a %a15,0
8000feb4:	ff 02 95 01 	jge %d2,0,800101de <_dtoa_r+0xa26>
8000feb8:	1d 00 9d 01 	j 800101f2 <_dtoa_r+0xa3a>
8000febc:	d8 03       	ld.a %a15,[%sp]12
8000febe:	0b cd 10 a8 	mov %e10,%d13,%d12
8000fec2:	0b 89 10 68 	mov %e6,%d9,%d8
8000fec6:	0b ab 10 48 	mov %e4,%d11,%d10
8000feca:	80 fe       	mov.d %d14,%a15
8000fecc:	6d 00 52 0f 	call 80011d70 <__divdf3>
8000fed0:	0b 23 10 48 	mov %e4,%d3,%d2
8000fed4:	c2 1e       	add %d14,1
8000fed6:	6d 00 9d 10 	call 80012010 <__fixdfsi>
8000feda:	02 24       	mov %d4,%d2
8000fedc:	02 2f       	mov %d15,%d2
8000fede:	6d 00 75 10 	call 80011fc8 <__floatsidf>
8000fee2:	0b 89 10 68 	mov %e6,%d9,%d8
8000fee6:	0b 23 10 48 	mov %e4,%d3,%d2
8000feea:	6d 00 71 0e 	call 80011bcc <__muldf3>
8000feee:	0b ab 10 48 	mov %e4,%d11,%d10
8000fef2:	0b 23 10 68 	mov %e6,%d3,%d2
8000fef6:	6d 00 4b 0e 	call 80011b8c <__subdf3>
8000fefa:	0b 23 10 48 	mov %e4,%d3,%d2
8000fefe:	1b 0f 03 30 	addi %d3,%d15,48
8000ff02:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000ff06:	28 03       	st.b [%a15]0,%d3
8000ff08:	02 e3       	mov %d3,%d14
8000ff0a:	a2 23       	sub %d3,%d2
8000ff0c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000ff10:	5f 23 3c 80 	jne %d3,%d2,8000ff88 <_dtoa_r+0x7d0>
8000ff14:	0b 45 10 68 	mov %e6,%d5,%d4
8000ff18:	6d 00 1e 0e 	call 80011b54 <__adddf3>
8000ff1c:	0b 89 10 68 	mov %e6,%d9,%d8
8000ff20:	0b 23 10 48 	mov %e4,%d3,%d2
8000ff24:	0b 23 10 a8 	mov %e10,%d3,%d2
8000ff28:	6d 00 f0 0f 	call 80011f08 <__gtdf2>
8000ff2c:	4e 2e       	jgtz %d2,8000ff48 <_dtoa_r+0x790>
8000ff2e:	0b ab 10 48 	mov %e4,%d11,%d10
8000ff32:	0b 89 10 68 	mov %e6,%d9,%d8
8000ff36:	6d 00 a9 0f 	call 80011e88 <__eqdf2>
8000ff3a:	df 02 95 82 	jne %d2,0,80010464 <_dtoa_r+0xcac>
8000ff3e:	ae 05       	jnz.t %d15,0,8000ff48 <_dtoa_r+0x790>
8000ff40:	1d 00 92 02 	j 80010464 <_dtoa_r+0xcac>
8000ff44:	58 0c       	ld.w %d15,[%sp]48
8000ff46:	78 02       	st.w [%sp]8,%d15
8000ff48:	58 03       	ld.w %d15,[%sp]12
8000ff4a:	a2 ef       	sub %d15,%d14
8000ff4c:	46 0f       	not %d15
8000ff4e:	60 e2       	mov.a %a2,%d14
8000ff50:	60 ef       	mov.a %a15,%d14
8000ff52:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000ff56:	b0 ff       	add.a %a15,-1
8000ff58:	8b 93 03 32 	eq %d3,%d3,57
8000ff5c:	df 03 11 00 	jeq %d3,0,8000ff7e <_dtoa_r+0x7c6>
8000ff60:	9f 0f 0d 80 	jned %d15,0,8000ff7a <_dtoa_r+0x7c2>
8000ff64:	19 a3 08 00 	ld.w %d3,[%sp]8
8000ff68:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000ff6c:	c2 13       	add %d3,1
8000ff6e:	da 30       	mov %d15,48
8000ff70:	59 a3 08 00 	st.w [%sp]8,%d3
8000ff74:	2c 30       	st.b [%a3]0,%d15
8000ff76:	40 3f       	mov.aa %a15,%a3
8000ff78:	3c 03       	j 8000ff7e <_dtoa_r+0x7c6>
8000ff7a:	80 fe       	mov.d %d14,%a15
8000ff7c:	3c e9       	j 8000ff4e <_dtoa_r+0x796>
8000ff7e:	0c f0       	ld.bu %d15,[%a15]0
8000ff80:	c2 1f       	add %d15,1
8000ff82:	28 0f       	st.b [%a15]0,%d15
8000ff84:	1d 00 70 02 	j 80010464 <_dtoa_r+0xcac>
8000ff88:	82 06       	mov %d6,0
8000ff8a:	7b 40 02 74 	movh %d7,16420
8000ff8e:	6d 00 1f 0e 	call 80011bcc <__muldf3>
8000ff92:	d2 06       	mov %e6,0
8000ff94:	0b 23 10 48 	mov %e4,%d3,%d2
8000ff98:	0b 23 10 a8 	mov %e10,%d3,%d2
8000ff9c:	60 ef       	mov.a %a15,%d14
8000ff9e:	6d 00 75 0f 	call 80011e88 <__eqdf2>
8000ffa2:	df 02 90 ff 	jne %d2,0,8000fec2 <_dtoa_r+0x70a>
8000ffa6:	1d 00 5f 02 	j 80010464 <_dtoa_r+0xcac>
8000ffaa:	19 a2 24 00 	ld.w %d2,[%sp]36
8000ffae:	58 08       	ld.w %d15,[%sp]32
8000ffb0:	19 a8 14 00 	ld.w %d8,[%sp]20
8000ffb4:	a0 0f       	mov.a %a15,0
8000ffb6:	df 02 3b 00 	jeq %d2,0,8001002c <_dtoa_r+0x874>
8000ffba:	58 07       	ld.w %d15,[%sp]28
8000ffbc:	ff 2f 10 00 	jge %d15,2,8000ffdc <_dtoa_r+0x824>
8000ffc0:	58 13       	ld.w %d15,[%sp]76
8000ffc2:	6e 05       	jz %d15,8000ffcc <_dtoa_r+0x814>
8000ffc4:	1b 33 43 30 	addi %d3,%d3,1075
8000ffc8:	58 08       	ld.w %d15,[%sp]32
8000ffca:	3c 22       	j 8001000e <_dtoa_r+0x856>
8000ffcc:	19 a3 10 10 	ld.w %d3,[%sp]80
8000ffd0:	58 08       	ld.w %d15,[%sp]32
8000ffd2:	8b 63 03 31 	rsub %d3,%d3,54
8000ffd6:	19 a8 14 00 	ld.w %d8,[%sp]20
8000ffda:	3c 1a       	j 8001000e <_dtoa_r+0x856>
8000ffdc:	58 04       	ld.w %d15,[%sp]16
8000ffde:	19 a2 20 00 	ld.w %d2,[%sp]32
8000ffe2:	c2 ff       	add %d15,-1
8000ffe4:	3f f2 04 00 	jlt %d2,%d15,8000ffec <_dtoa_r+0x834>
8000ffe8:	5a f2       	sub %d15,%d2,%d15
8000ffea:	3c 0b       	j 80010000 <_dtoa_r+0x848>
8000ffec:	19 a3 20 00 	ld.w %d3,[%sp]32
8000fff0:	78 08       	st.w [%sp]32,%d15
8000fff2:	52 32       	sub %d2,%d15,%d3
8000fff4:	19 a3 34 00 	ld.w %d3,[%sp]52
8000fff8:	82 0f       	mov %d15,0
8000fffa:	42 23       	add %d3,%d2
8000fffc:	59 a3 34 00 	st.w [%sp]52,%d3
80010000:	19 a3 10 00 	ld.w %d3,[%sp]16
80010004:	19 a8 14 00 	ld.w %d8,[%sp]20
80010008:	ce 33       	jgez %d3,8001000e <_dtoa_r+0x856>
8001000a:	a2 38       	sub %d8,%d3
8001000c:	82 03       	mov %d3,0
8001000e:	19 a2 14 00 	ld.w %d2,[%sp]20
80010012:	40 d4       	mov.aa %a4,%a13
80010014:	42 32       	add %d2,%d3
80010016:	59 a2 14 00 	st.w [%sp]20,%d2
8001001a:	19 a2 18 00 	ld.w %d2,[%sp]24
8001001e:	82 14       	mov %d4,1
80010020:	42 32       	add %d2,%d3
80010022:	59 a2 18 00 	st.w [%sp]24,%d2
80010026:	6d 00 6a 05 	call 80010afa <__i2b>
8001002a:	40 2f       	mov.aa %a15,%a2
8001002c:	19 a2 18 00 	ld.w %d2,[%sp]24
80010030:	8b 18 80 32 	ge %d3,%d8,1
80010034:	8b 12 80 34 	and.ge %d3,%d2,1
80010038:	76 3e       	jz %d3,80010054 <_dtoa_r+0x89c>
8001003a:	0b 82 80 31 	min %d3,%d2,%d8
8001003e:	19 a2 14 00 	ld.w %d2,[%sp]20
80010042:	a2 38       	sub %d8,%d3
80010044:	a2 32       	sub %d2,%d3
80010046:	59 a2 14 00 	st.w [%sp]20,%d2
8001004a:	19 a2 18 00 	ld.w %d2,[%sp]24
8001004e:	a2 32       	sub %d2,%d3
80010050:	59 a2 18 00 	st.w [%sp]24,%d2
80010054:	19 a3 20 00 	ld.w %d3,[%sp]32
80010058:	bf 13 27 00 	jlt %d3,1,800100a6 <_dtoa_r+0x8ee>
8001005c:	19 a2 24 00 	ld.w %d2,[%sp]36
80010060:	df 02 1c 00 	jeq %d2,0,80010098 <_dtoa_r+0x8e0>
80010064:	bf 1f 13 00 	jlt %d15,1,8001008a <_dtoa_r+0x8d2>
80010068:	40 f5       	mov.aa %a5,%a15
8001006a:	02 f4       	mov %d4,%d15
8001006c:	40 d4       	mov.aa %a4,%a13
8001006e:	6d 00 db 05 	call 80010c24 <__pow5mult>
80010072:	40 e6       	mov.aa %a6,%a14
80010074:	40 d4       	mov.aa %a4,%a13
80010076:	40 25       	mov.aa %a5,%a2
80010078:	40 2f       	mov.aa %a15,%a2
8001007a:	6d 00 48 05 	call 80010b0a <__multiply>
8001007e:	40 e5       	mov.aa %a5,%a14
80010080:	40 2c       	mov.aa %a12,%a2
80010082:	40 d4       	mov.aa %a4,%a13
80010084:	6d 00 9d 04 	call 800109be <_Bfree>
80010088:	40 ce       	mov.aa %a14,%a12
8001008a:	19 a4 20 00 	ld.w %d4,[%sp]32
8001008e:	40 d4       	mov.aa %a4,%a13
80010090:	a2 f4       	sub %d4,%d15
80010092:	40 e5       	mov.aa %a5,%a14
80010094:	76 49       	jz %d4,800100a6 <_dtoa_r+0x8ee>
80010096:	3c 05       	j 800100a0 <_dtoa_r+0x8e8>
80010098:	19 a4 20 00 	ld.w %d4,[%sp]32
8001009c:	40 d4       	mov.aa %a4,%a13
8001009e:	40 e5       	mov.aa %a5,%a14
800100a0:	6d 00 c2 05 	call 80010c24 <__pow5mult>
800100a4:	40 2e       	mov.aa %a14,%a2
800100a6:	40 d4       	mov.aa %a4,%a13
800100a8:	82 14       	mov %d4,1
800100aa:	6d 00 28 05 	call 80010afa <__i2b>
800100ae:	19 a3 34 00 	ld.w %d3,[%sp]52
800100b2:	40 2c       	mov.aa %a12,%a2
800100b4:	8e 3c       	jlez %d3,800100cc <_dtoa_r+0x914>
800100b6:	40 d4       	mov.aa %a4,%a13
800100b8:	40 25       	mov.aa %a5,%a2
800100ba:	02 34       	mov %d4,%d3
800100bc:	6d 00 b4 05 	call 80010c24 <__pow5mult>
800100c0:	58 07       	ld.w %d15,[%sp]28
800100c2:	40 2c       	mov.aa %a12,%a2
800100c4:	82 09       	mov %d9,0
800100c6:	ff 2f 1f 00 	jge %d15,2,80010104 <_dtoa_r+0x94c>
800100ca:	3c 06       	j 800100d6 <_dtoa_r+0x91e>
800100cc:	19 a2 1c 00 	ld.w %d2,[%sp]28
800100d0:	82 09       	mov %d9,0
800100d2:	ff 22 15 00 	jge %d2,2,800100fc <_dtoa_r+0x944>
800100d6:	82 09       	mov %d9,0
800100d8:	df 0c 12 80 	jne %d12,0,800100fc <_dtoa_r+0x944>
800100dc:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
800100e0:	ee 0e       	jnz %d15,800100fc <_dtoa_r+0x944>
800100e2:	7b 00 ff f7 	movh %d15,32752
800100e6:	26 df       	and %d15,%d13
800100e8:	6e 0a       	jz %d15,800100fc <_dtoa_r+0x944>
800100ea:	19 a3 14 00 	ld.w %d3,[%sp]20
800100ee:	58 06       	ld.w %d15,[%sp]24
800100f0:	c2 13       	add %d3,1
800100f2:	c2 1f       	add %d15,1
800100f4:	59 a3 14 00 	st.w [%sp]20,%d3
800100f8:	78 06       	st.w [%sp]24,%d15
800100fa:	82 19       	mov %d9,1
800100fc:	19 a3 34 00 	ld.w %d3,[%sp]52
80010100:	82 12       	mov %d2,1
80010102:	76 39       	jz %d3,80010114 <_dtoa_r+0x95c>
80010104:	4c c4       	ld.w %d15,[%a12]16
80010106:	90 c3       	addsc.a %a3,%a12,%d15,2
80010108:	19 34 10 00 	ld.w %d4,[%a3]16
8001010c:	6d 00 a3 04 	call 80010a52 <__hi0bits>
80010110:	8b 02 02 21 	rsub %d2,%d2,32
80010114:	58 06       	ld.w %d15,[%sp]24
80010116:	42 2f       	add %d15,%d2
80010118:	16 1f       	and %d15,31
8001011a:	6e 0a       	jz %d15,8001012e <_dtoa_r+0x976>
8001011c:	8b 0f 02 31 	rsub %d3,%d15,32
80010120:	8b cf 01 f1 	rsub %d15,%d15,28
80010124:	ff 53 07 00 	jge %d3,5,80010132 <_dtoa_r+0x97a>
80010128:	df 43 10 00 	jeq %d3,4,80010148 <_dtoa_r+0x990>
8001012c:	02 3f       	mov %d15,%d3
8001012e:	1b cf 01 f0 	addi %d15,%d15,28
80010132:	19 a2 14 00 	ld.w %d2,[%sp]20
80010136:	19 a3 18 00 	ld.w %d3,[%sp]24
8001013a:	42 f2       	add %d2,%d15
8001013c:	42 f3       	add %d3,%d15
8001013e:	59 a2 14 00 	st.w [%sp]20,%d2
80010142:	42 f8       	add %d8,%d15
80010144:	59 a3 18 00 	st.w [%sp]24,%d3
80010148:	58 05       	ld.w %d15,[%sp]20
8001014a:	8e f7       	jlez %d15,80010158 <_dtoa_r+0x9a0>
8001014c:	40 e5       	mov.aa %a5,%a14
8001014e:	40 d4       	mov.aa %a4,%a13
80010150:	02 f4       	mov %d4,%d15
80010152:	6d 00 a7 05 	call 80010ca0 <__lshift>
80010156:	40 2e       	mov.aa %a14,%a2
80010158:	19 a2 18 00 	ld.w %d2,[%sp]24
8001015c:	8e 27       	jlez %d2,8001016a <_dtoa_r+0x9b2>
8001015e:	40 c5       	mov.aa %a5,%a12
80010160:	40 d4       	mov.aa %a4,%a13
80010162:	02 24       	mov %d4,%d2
80010164:	6d 00 9e 05 	call 80010ca0 <__lshift>
80010168:	40 2c       	mov.aa %a12,%a2
8001016a:	19 a3 3c 00 	ld.w %d3,[%sp]60
8001016e:	df 03 20 00 	jeq %d3,0,800101ae <_dtoa_r+0x9f6>
80010172:	40 e4       	mov.aa %a4,%a14
80010174:	40 c5       	mov.aa %a5,%a12
80010176:	6d 00 f2 05 	call 80010d5a <__mcmp>
8001017a:	ff 02 1a 00 	jge %d2,0,800101ae <_dtoa_r+0x9f6>
8001017e:	58 02       	ld.w %d15,[%sp]8
80010180:	40 e5       	mov.aa %a5,%a14
80010182:	c2 ff       	add %d15,-1
80010184:	40 d4       	mov.aa %a4,%a13
80010186:	fb a0 00 40 	mov %e4,10
8001018a:	78 02       	st.w [%sp]8,%d15
8001018c:	6d 00 22 04 	call 800109d0 <__multadd>
80010190:	19 a2 2c 00 	ld.w %d2,[%sp]44
80010194:	19 a3 24 00 	ld.w %d3,[%sp]36
80010198:	59 a2 10 00 	st.w [%sp]16,%d2
8001019c:	40 2e       	mov.aa %a14,%a2
8001019e:	76 38       	jz %d3,800101ae <_dtoa_r+0x9f6>
800101a0:	40 f5       	mov.aa %a5,%a15
800101a2:	40 d4       	mov.aa %a4,%a13
800101a4:	fb a0 00 40 	mov %e4,10
800101a8:	6d 00 14 04 	call 800109d0 <__multadd>
800101ac:	40 2f       	mov.aa %a15,%a2
800101ae:	19 a2 1c 00 	ld.w %d2,[%sp]28
800101b2:	19 a3 10 00 	ld.w %d3,[%sp]16
800101b6:	8b 32 80 f2 	ge %d15,%d2,3
800101ba:	8b 13 40 f4 	and.lt %d15,%d3,1
800101be:	6e 2a       	jz %d15,80010212 <_dtoa_r+0xa5a>
800101c0:	f6 3f       	jnz %d3,800101de <_dtoa_r+0xa26>
800101c2:	40 c5       	mov.aa %a5,%a12
800101c4:	40 d4       	mov.aa %a4,%a13
800101c6:	d2 54       	mov %e4,5
800101c8:	6d 00 04 04 	call 800109d0 <__multadd>
800101cc:	40 e4       	mov.aa %a4,%a14
800101ce:	40 25       	mov.aa %a5,%a2
800101d0:	40 2c       	mov.aa %a12,%a2
800101d2:	6d 00 c4 05 	call 80010d5a <__mcmp>
800101d6:	4e 2e       	jgtz %d2,800101f2 <_dtoa_r+0xa3a>
800101d8:	3c 03       	j 800101de <_dtoa_r+0xa26>
800101da:	a0 0c       	mov.a %a12,0
800101dc:	a0 0f       	mov.a %a15,0
800101de:	58 0a       	ld.w %d15,[%sp]40
800101e0:	19 ae 0c 00 	ld.w %d14,[%sp]12
800101e4:	46 0f       	not %d15
800101e6:	78 02       	st.w [%sp]8,%d15
800101e8:	3c 11       	j 8001020a <_dtoa_r+0xa52>
800101ea:	58 0c       	ld.w %d15,[%sp]48
800101ec:	a0 0c       	mov.a %a12,0
800101ee:	78 02       	st.w [%sp]8,%d15
800101f0:	a0 0f       	mov.a %a15,0
800101f2:	19 a2 08 00 	ld.w %d2,[%sp]8
800101f6:	99 a3 0c 00 	ld.a %a3,[%sp]12
800101fa:	19 ae 0c 00 	ld.w %d14,[%sp]12
800101fe:	da 31       	mov %d15,49
80010200:	c2 12       	add %d2,1
80010202:	c2 1e       	add %d14,1
80010204:	2c 30       	st.b [%a3]0,%d15
80010206:	59 a2 08 00 	st.w [%sp]8,%d2
8001020a:	80 f8       	mov.d %d8,%a15
8001020c:	a0 0f       	mov.a %a15,0
8001020e:	1d 00 14 01 	j 80010436 <_dtoa_r+0xc7e>
80010212:	19 a3 24 00 	ld.w %d3,[%sp]36
80010216:	f6 35       	jnz %d3,80010220 <_dtoa_r+0xa68>
80010218:	19 a8 0c 00 	ld.w %d8,[%sp]12
8001021c:	1d 00 c2 00 	j 800103a0 <_dtoa_r+0xbe8>
80010220:	8e 87       	jlez %d8,8001022e <_dtoa_r+0xa76>
80010222:	40 f5       	mov.aa %a5,%a15
80010224:	40 d4       	mov.aa %a4,%a13
80010226:	02 84       	mov %d4,%d8
80010228:	6d 00 3c 05 	call 80010ca0 <__lshift>
8001022c:	40 2f       	mov.aa %a15,%a2
8001022e:	80 f8       	mov.d %d8,%a15
80010230:	df 09 16 00 	jeq %d9,0,8001025c <_dtoa_r+0xaa4>
80010234:	40 d4       	mov.aa %a4,%a13
80010236:	48 14       	ld.w %d4,[%a15]4
80010238:	6d 00 98 03 	call 80010968 <_Balloc>
8001023c:	48 44       	ld.w %d4,[%a15]16
8001023e:	d9 24 0c 00 	lea %a4,[%a2]12
80010242:	c2 24       	add %d4,2
80010244:	d9 f5 0c 00 	lea %a5,[%a15]12
80010248:	06 24       	sh %d4,2
8001024a:	80 2f       	mov.d %d15,%a2
8001024c:	6d 00 7e 03 	call 80010948 <memcpy>
80010250:	60 f5       	mov.a %a5,%d15
80010252:	40 d4       	mov.aa %a4,%a13
80010254:	82 14       	mov %d4,1
80010256:	6d 00 25 05 	call 80010ca0 <__lshift>
8001025a:	80 28       	mov.d %d8,%a2
8001025c:	19 a9 0c 00 	ld.w %d9,[%sp]12
80010260:	8f 1c 00 a1 	and %d10,%d12,1
80010264:	40 e4       	mov.aa %a4,%a14
80010266:	40 c5       	mov.aa %a5,%a12
80010268:	6d ff 1a fa 	call 8000f69c <quorem>
8001026c:	40 e4       	mov.aa %a4,%a14
8001026e:	40 f5       	mov.aa %a5,%a15
80010270:	02 2e       	mov %d14,%d2
80010272:	1b 02 03 f0 	addi %d15,%d2,48
80010276:	6d 00 72 05 	call 80010d5a <__mcmp>
8001027a:	60 86       	mov.a %a6,%d8
8001027c:	40 d4       	mov.aa %a4,%a13
8001027e:	40 c5       	mov.aa %a5,%a12
80010280:	02 2b       	mov %d11,%d2
80010282:	6d 00 8d 05 	call 80010d9c <__mdiff>
80010286:	19 22 0c 00 	ld.w %d2,[%a2]12
8001028a:	80 2d       	mov.d %d13,%a2
8001028c:	82 1c       	mov %d12,1
8001028e:	f6 26       	jnz %d2,8001029a <_dtoa_r+0xae2>
80010290:	40 e4       	mov.aa %a4,%a14
80010292:	40 25       	mov.aa %a5,%a2
80010294:	6d 00 63 05 	call 80010d5a <__mcmp>
80010298:	02 2c       	mov %d12,%d2
8001029a:	60 d5       	mov.a %a5,%d13
8001029c:	40 d4       	mov.aa %a4,%a13
8001029e:	6d 00 90 03 	call 800109be <_Bfree>
800102a2:	19 a3 1c 00 	ld.w %d3,[%sp]28
800102a6:	1b 19 00 d0 	addi %d13,%d9,1
800102aa:	a6 c3       	or %d3,%d12
800102ac:	f6 3f       	jnz %d3,800102ca <_dtoa_r+0xb12>
800102ae:	f6 ae       	jnz %d10,800102ca <_dtoa_r+0xb12>
800102b0:	8b 9f 03 32 	eq %d3,%d15,57
800102b4:	40 e2       	mov.aa %a2,%a14
800102b6:	df 03 3a 80 	jne %d3,0,8001032a <_dtoa_r+0xb72>
800102ba:	1b 1e 03 20 	addi %d2,%d14,49
800102be:	8b 1b 80 b2 	ge %d11,%d11,1
800102c2:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
800102c6:	02 de       	mov %d14,%d13
800102c8:	3c 37       	j 80010336 <_dtoa_r+0xb7e>
800102ca:	ce b5       	jgez %d11,800102d4 <_dtoa_r+0xb1c>
800102cc:	02 fa       	mov %d10,%d15
800102ce:	40 e2       	mov.aa %a2,%a14
800102d0:	4e ca       	jgtz %d12,800102e4 <_dtoa_r+0xb2c>
800102d2:	3c 1e       	j 8001030e <_dtoa_r+0xb56>
800102d4:	19 a2 1c 00 	ld.w %d2,[%sp]28
800102d8:	a6 2b       	or %d11,%d2
800102da:	df 0b 20 80 	jne %d11,0,8001031a <_dtoa_r+0xb62>
800102de:	df 0a 1e 80 	jne %d10,0,8001031a <_dtoa_r+0xb62>
800102e2:	3c f5       	j 800102cc <_dtoa_r+0xb14>
800102e4:	40 d4       	mov.aa %a4,%a13
800102e6:	40 e5       	mov.aa %a5,%a14
800102e8:	82 14       	mov %d4,1
800102ea:	6d 00 db 04 	call 80010ca0 <__lshift>
800102ee:	40 c5       	mov.aa %a5,%a12
800102f0:	40 24       	mov.aa %a4,%a2
800102f2:	b5 a2 04 00 	st.a [%sp]4,%a2
800102f6:	6d 00 32 05 	call 80010d5a <__mcmp>
800102fa:	99 a2 04 00 	ld.a %a2,[%sp]4
800102fe:	4e 23       	jgtz %d2,80010304 <_dtoa_r+0xb4c>
80010300:	f6 27       	jnz %d2,8001030e <_dtoa_r+0xb56>
80010302:	2e 06       	jz.t %d15,0,8001030e <_dtoa_r+0xb56>
80010304:	8b 9f 03 32 	eq %d3,%d15,57
80010308:	df 03 11 80 	jne %d3,0,8001032a <_dtoa_r+0xb72>
8001030c:	92 1a       	add %d10,%d15,1
8001030e:	60 93       	mov.a %a3,%d9
80010310:	02 de       	mov %d14,%d13
80010312:	34 3a       	st.b [%a3],%d10
80010314:	40 2e       	mov.aa %a14,%a2
80010316:	1d 00 90 00 	j 80010436 <_dtoa_r+0xc7e>
8001031a:	bf 1c 11 00 	jlt %d12,1,8001033c <_dtoa_r+0xb84>
8001031e:	8b 9f 23 32 	ne %d3,%d15,57
80010322:	40 e2       	mov.aa %a2,%a14
80010324:	02 de       	mov %d14,%d13
80010326:	c2 1f       	add %d15,1
80010328:	f6 37       	jnz %d3,80010336 <_dtoa_r+0xb7e>
8001032a:	60 93       	mov.a %a3,%d9
8001032c:	da 39       	mov %d15,57
8001032e:	02 de       	mov %d14,%d13
80010330:	2c 30       	st.b [%a3]0,%d15
80010332:	40 2e       	mov.aa %a14,%a2
80010334:	3c 5d       	j 800103ee <_dtoa_r+0xc36>
80010336:	60 92       	mov.a %a2,%d9
80010338:	2c 20       	st.b [%a2]0,%d15
8001033a:	3c 7e       	j 80010436 <_dtoa_r+0xc7e>
8001033c:	60 93       	mov.a %a3,%d9
8001033e:	19 a2 0c 00 	ld.w %d2,[%sp]12
80010342:	02 d5       	mov %d5,%d13
80010344:	19 a3 10 00 	ld.w %d3,[%sp]16
80010348:	2c 30       	st.b [%a3]0,%d15
8001034a:	a2 25       	sub %d5,%d2
8001034c:	02 de       	mov %d14,%d13
8001034e:	5f 35 41 00 	jeq %d5,%d3,800103d0 <_dtoa_r+0xc18>
80010352:	40 e5       	mov.aa %a5,%a14
80010354:	40 d4       	mov.aa %a4,%a13
80010356:	fb a0 00 40 	mov %e4,10
8001035a:	6d 00 3b 03 	call 800109d0 <__multadd>
8001035e:	80 ff       	mov.d %d15,%a15
80010360:	40 2e       	mov.aa %a14,%a2
80010362:	40 d4       	mov.aa %a4,%a13
80010364:	40 f5       	mov.aa %a5,%a15
80010366:	fb a0 00 40 	mov %e4,10
8001036a:	7e 86       	jne %d15,%d8,80010376 <_dtoa_r+0xbbe>
8001036c:	6d 00 32 03 	call 800109d0 <__multadd>
80010370:	40 2f       	mov.aa %a15,%a2
80010372:	80 28       	mov.d %d8,%a2
80010374:	3c 0b       	j 8001038a <_dtoa_r+0xbd2>
80010376:	6d 00 2d 03 	call 800109d0 <__multadd>
8001037a:	60 85       	mov.a %a5,%d8
8001037c:	40 d4       	mov.aa %a4,%a13
8001037e:	fb a0 00 40 	mov %e4,10
80010382:	40 2f       	mov.aa %a15,%a2
80010384:	6d 00 26 03 	call 800109d0 <__multadd>
80010388:	80 28       	mov.d %d8,%a2
8001038a:	02 d9       	mov %d9,%d13
8001038c:	1d ff 6c ff 	j 80010264 <_dtoa_r+0xaac>
80010390:	40 e5       	mov.aa %a5,%a14
80010392:	40 d4       	mov.aa %a4,%a13
80010394:	fb a0 00 40 	mov %e4,10
80010398:	6d 00 1c 03 	call 800109d0 <__multadd>
8001039c:	02 98       	mov %d8,%d9
8001039e:	40 2e       	mov.aa %a14,%a2
800103a0:	40 e4       	mov.aa %a4,%a14
800103a2:	40 c5       	mov.aa %a5,%a12
800103a4:	6d ff 7c f9 	call 8000f69c <quorem>
800103a8:	1b 18 00 90 	addi %d9,%d8,1
800103ac:	1b 02 03 f0 	addi %d15,%d2,48
800103b0:	60 82       	mov.a %a2,%d8
800103b2:	19 a2 0c 00 	ld.w %d2,[%sp]12
800103b6:	02 95       	mov %d5,%d9
800103b8:	19 a3 10 00 	ld.w %d3,[%sp]16
800103bc:	2c 20       	st.b [%a2]0,%d15
800103be:	a2 25       	sub %d5,%d2
800103c0:	3f 35 e8 7f 	jlt %d5,%d3,80010390 <_dtoa_r+0xbd8>
800103c4:	8b 13 40 33 	max %d3,%d3,1
800103c8:	02 2e       	mov %d14,%d2
800103ca:	80 f8       	mov.d %d8,%a15
800103cc:	42 3e       	add %d14,%d3
800103ce:	a0 0f       	mov.a %a15,0
800103d0:	40 e5       	mov.aa %a5,%a14
800103d2:	40 d4       	mov.aa %a4,%a13
800103d4:	82 14       	mov %d4,1
800103d6:	6d 00 65 04 	call 80010ca0 <__lshift>
800103da:	40 c5       	mov.aa %a5,%a12
800103dc:	40 2e       	mov.aa %a14,%a2
800103de:	40 24       	mov.aa %a4,%a2
800103e0:	6d 00 bd 04 	call 80010d5a <__mcmp>
800103e4:	4e 25       	jgtz %d2,800103ee <_dtoa_r+0xc36>
800103e6:	df 02 1e 80 	jne %d2,0,80010422 <_dtoa_r+0xc6a>
800103ea:	6f 0f 1c 00 	jz.t %d15,0,80010422 <_dtoa_r+0xc6a>
800103ee:	58 03       	ld.w %d15,[%sp]12
800103f0:	a2 ef       	sub %d15,%d14
800103f2:	46 0f       	not %d15
800103f4:	60 e2       	mov.a %a2,%d14
800103f6:	60 e3       	mov.a %a3,%d14
800103f8:	79 23 ff ff 	ld.b %d3,[%a2]-1
800103fc:	b0 f3       	add.a %a3,-1
800103fe:	8b 93 03 52 	eq %d5,%d3,57
80010402:	76 5d       	jz %d5,8001041c <_dtoa_r+0xc64>
80010404:	9f 0f 0a 80 	jned %d15,0,80010418 <_dtoa_r+0xc60>
80010408:	58 02       	ld.w %d15,[%sp]8
8001040a:	99 a3 0c 00 	ld.a %a3,[%sp]12
8001040e:	c2 1f       	add %d15,1
80010410:	78 02       	st.w [%sp]8,%d15
80010412:	da 31       	mov %d15,49
80010414:	2c 30       	st.b [%a3]0,%d15
80010416:	3c 10       	j 80010436 <_dtoa_r+0xc7e>
80010418:	80 3e       	mov.d %d14,%a3
8001041a:	3c ed       	j 800103f4 <_dtoa_r+0xc3c>
8001041c:	c2 13       	add %d3,1
8001041e:	34 33       	st.b [%a3],%d3
80010420:	3c 0b       	j 80010436 <_dtoa_r+0xc7e>
80010422:	60 e2       	mov.a %a2,%d14
80010424:	60 e3       	mov.a %a3,%d14
80010426:	79 2f ff ff 	ld.b %d15,[%a2]-1
8001042a:	b0 f3       	add.a %a3,-1
8001042c:	8b 0f 03 f2 	eq %d15,%d15,48
80010430:	6e 03       	jz %d15,80010436 <_dtoa_r+0xc7e>
80010432:	80 3e       	mov.d %d14,%a3
80010434:	3c f7       	j 80010422 <_dtoa_r+0xc6a>
80010436:	40 d4       	mov.aa %a4,%a13
80010438:	40 c5       	mov.aa %a5,%a12
8001043a:	6d 00 c2 02 	call 800109be <_Bfree>
8001043e:	df 08 13 00 	jeq %d8,0,80010464 <_dtoa_r+0xcac>
80010442:	80 f2       	mov.d %d2,%a15
80010444:	8b 02 20 f2 	ne %d15,%d2,0
80010448:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8001044c:	6e 05       	jz %d15,80010456 <_dtoa_r+0xc9e>
8001044e:	40 d4       	mov.aa %a4,%a13
80010450:	40 f5       	mov.aa %a5,%a15
80010452:	6d 00 b6 02 	call 800109be <_Bfree>
80010456:	60 85       	mov.a %a5,%d8
80010458:	40 d4       	mov.aa %a4,%a13
8001045a:	6d 00 b2 02 	call 800109be <_Bfree>
8001045e:	3c 03       	j 80010464 <_dtoa_r+0xcac>
80010460:	58 0c       	ld.w %d15,[%sp]48
80010462:	78 02       	st.w [%sp]8,%d15
80010464:	40 d4       	mov.aa %a4,%a13
80010466:	40 e5       	mov.aa %a5,%a14
80010468:	6d 00 ab 02 	call 800109be <_Bfree>
8001046c:	60 e2       	mov.a %a2,%d14
8001046e:	19 a2 08 00 	ld.w %d2,[%sp]8
80010472:	99 a3 08 10 	ld.a %a3,[%sp]72
80010476:	82 0f       	mov %d15,0
80010478:	d8 0e       	ld.a %a15,[%sp]56
8001047a:	2c 20       	st.b [%a2]0,%d15
8001047c:	c2 12       	add %d2,1
8001047e:	74 32       	st.w [%a3],%d2
80010480:	99 a2 0c 00 	ld.a %a2,[%sp]12
80010484:	bc f2       	jz.a %a15,80010488 <_dtoa_r+0xcd0>
80010486:	68 0e       	st.w [%a15]0,%d14
80010488:	00 90       	ret 
	...

8001048c <_localeconv_r>:
8001048c:	91 00 00 28 	movh.a %a2,32768
80010490:	d9 22 e4 10 	lea %a2,[%a2]3172 <80000c64 <lconv>>
80010494:	00 90       	ret 

80010496 <_malloc_r>:
80010496:	1b b4 00 f0 	addi %d15,%d4,11
8001049a:	8b 7f 61 82 	lt.u %d8,%d15,23
8001049e:	8f 7f c0 f1 	andn %d15,%d15,7
800104a2:	ab 0f a1 88 	seln %d8,%d8,%d15,16
800104a6:	0b 48 30 41 	lt.u %d4,%d8,%d4
800104aa:	8b 08 20 45 	or.lt %d4,%d8,0
800104ae:	40 4d       	mov.aa %a13,%a4
800104b0:	76 45       	jz %d4,800104ba <_malloc_r+0x24>
800104b2:	da 0c       	mov %d15,12
800104b4:	6c 40       	st.w [%a4]0,%d15
800104b6:	1d 00 2a 02 	j 8001090a <_malloc_r+0x474>
800104ba:	91 00 00 f7 	movh.a %a15,28672
800104be:	8b 88 bf f2 	ge.u %d15,%d8,504
800104c2:	6d 00 51 02 	call 80010964 <__malloc_lock>
800104c6:	d9 ff 48 61 	lea %a15,[%a15]5512 <70001588 <__malloc_av_>>
800104ca:	ee 19       	jnz %d15,800104fc <_malloc_r+0x66>
800104cc:	8f d8 1f 20 	sh %d2,%d8,-3
800104d0:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
800104d4:	99 2c 0c 00 	ld.a %a12,[%a2]12
800104d8:	7d 2c 09 80 	jne.a %a12,%a2,800104ea <_malloc_r+0x54>
800104dc:	d9 c2 08 00 	lea %a2,[%a12]8
800104e0:	99 cc 14 00 	ld.a %a12,[%a12]20
800104e4:	c2 22       	add %d2,2
800104e6:	7d 2c 58 00 	jeq.a %a12,%a2,80010596 <_malloc_r+0x100>
800104ea:	cc c3       	ld.a %a15,[%a12]12
800104ec:	99 c2 08 00 	ld.a %a2,[%a12]8
800104f0:	4c c1       	ld.w %d15,[%a12]4
800104f2:	ec 23       	st.a [%a2]12,%a15
800104f4:	8f 3f c0 f1 	andn %d15,%d15,3
800104f8:	e8 22       	st.a [%a15]8,%a2
800104fa:	3c 74       	j 800105e2 <_malloc_r+0x14c>
800104fc:	8f 78 1f f0 	sh %d15,%d8,-9
80010500:	3b f0 03 20 	mov %d2,63
80010504:	6e 27       	jz %d15,80010552 <_malloc_r+0xbc>
80010506:	8f a8 1f 20 	sh %d2,%d8,-6
8001050a:	1b 82 03 20 	addi %d2,%d2,56
8001050e:	bf 5f 22 80 	jlt.u %d15,5,80010552 <_malloc_r+0xbc>
80010512:	8b 5f a1 22 	ge.u %d2,%d15,21
80010516:	f6 24       	jnz %d2,8001051e <_malloc_r+0x88>
80010518:	1b bf 05 20 	addi %d2,%d15,91
8001051c:	3c 1b       	j 80010552 <_malloc_r+0xbc>
8001051e:	8b 5f a5 22 	ge.u %d2,%d15,85
80010522:	f6 26       	jnz %d2,8001052e <_malloc_r+0x98>
80010524:	8f 48 1f 20 	sh %d2,%d8,-12
80010528:	1b e2 06 20 	addi %d2,%d2,110
8001052c:	3c 13       	j 80010552 <_malloc_r+0xbc>
8001052e:	8b 5f b5 22 	ge.u %d2,%d15,341
80010532:	f6 26       	jnz %d2,8001053e <_malloc_r+0xa8>
80010534:	8f 18 1f 20 	sh %d2,%d8,-15
80010538:	1b 72 07 20 	addi %d2,%d2,119
8001053c:	3c 0b       	j 80010552 <_malloc_r+0xbc>
8001053e:	3b 50 55 30 	mov %d3,1365
80010542:	3b e0 07 20 	mov %d2,126
80010546:	7f 3f 06 80 	jge.u %d15,%d3,80010552 <_malloc_r+0xbc>
8001054a:	8f e8 1e 20 	sh %d2,%d8,-18
8001054e:	1b c2 07 20 	addi %d2,%d2,124
80010552:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
80010556:	99 2c 0c 00 	ld.a %a12,[%a2]12
8001055a:	7d 2c 1d 00 	jeq.a %a12,%a2,80010594 <_malloc_r+0xfe>
8001055e:	19 c4 04 00 	ld.w %d4,[%a12]4
80010562:	8f 34 c0 41 	andn %d4,%d4,3
80010566:	5a 84       	sub %d15,%d4,%d8
80010568:	8b 0f 41 32 	lt %d3,%d15,16
8001056c:	f6 33       	jnz %d3,80010572 <_malloc_r+0xdc>
8001056e:	c2 f2       	add %d2,-1
80010570:	3c 12       	j 80010594 <_malloc_r+0xfe>
80010572:	0e fe       	jltz %d15,8001058e <_malloc_r+0xf8>
80010574:	cc c3       	ld.a %a15,[%a12]12
80010576:	99 c2 08 00 	ld.a %a2,[%a12]8
8001057a:	ec 23       	st.a [%a2]12,%a15
8001057c:	e8 22       	st.a [%a15]8,%a2
8001057e:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
80010582:	b7 10 21 20 	imask %e2,1,0,1
80010586:	49 f2 44 08 	ldmst [%a15]4,%e2
8001058a:	1d 00 cc 01 	j 80010922 <_malloc_r+0x48c>
8001058e:	99 cc 0c 00 	ld.a %a12,[%a12]12
80010592:	3c e4       	j 8001055a <_malloc_r+0xc4>
80010594:	c2 12       	add %d2,1
80010596:	c8 4c       	ld.a %a12,[%a15]16
80010598:	91 00 00 37 	movh.a %a3,28672
8001059c:	d9 33 50 61 	lea %a3,[%a3]5520 <70001590 <__malloc_av_+0x8>>
800105a0:	7d 3c 83 00 	jeq.a %a12,%a3,800106a6 <_malloc_r+0x210>
800105a4:	4c c1       	ld.w %d15,[%a12]4
800105a6:	8f 3f c0 f1 	andn %d15,%d15,3
800105aa:	52 83       	sub %d3,%d15,%d8
800105ac:	8b 03 41 42 	lt %d4,%d3,16
800105b0:	df 04 16 80 	jne %d4,0,800105dc <_malloc_r+0x146>
800105b4:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
800105b8:	8f 18 40 81 	or %d8,%d8,1
800105bc:	59 c8 04 00 	st.w [%a12]4,%d8
800105c0:	e8 52       	st.a [%a15]20,%a2
800105c2:	e8 42       	st.a [%a15]16,%a2
800105c4:	8f 13 40 f1 	or %d15,%d3,1
800105c8:	b5 23 0c 00 	st.a [%a2]12,%a3
800105cc:	b5 23 08 00 	st.a [%a2]8,%a3
800105d0:	6c 21       	st.w [%a2]4,%d15
800105d2:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
800105d6:	74 23       	st.w [%a2],%d3
800105d8:	1d 00 a5 01 	j 80010922 <_malloc_r+0x48c>
800105dc:	e8 53       	st.a [%a15]20,%a3
800105de:	e8 43       	st.a [%a15]16,%a3
800105e0:	0e 33       	jltz %d3,800105e6 <_malloc_r+0x150>
800105e2:	10 cf       	addsc.a %a15,%a12,%d15,0
800105e4:	3c cf       	j 80010582 <_malloc_r+0xec>
800105e6:	3b 00 20 30 	mov %d3,512
800105ea:	7f 3f 15 80 	jge.u %d15,%d3,80010614 <_malloc_r+0x17e>
800105ee:	06 df       	sh %d15,-3
800105f0:	d0 f2       	addsc.a %a2,%a15,%d15,3
800105f2:	48 14       	ld.w %d4,[%a15]4
800105f4:	99 24 08 00 	ld.a %a4,[%a2]8
800105f8:	8f ef 3f 30 	sha %d3,%d15,-2
800105fc:	b5 c2 0c 00 	st.a [%a12]12,%a2
80010600:	b5 c4 08 00 	st.a [%a12]8,%a4
80010604:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
80010608:	b5 2c 08 00 	st.a [%a2]8,%a12
8001060c:	68 13       	st.w [%a15]4,%d3
8001060e:	b5 4c 0c 00 	st.a [%a4]12,%a12
80010612:	3c 4a       	j 800106a6 <_malloc_r+0x210>
80010614:	8f af 1f 40 	sh %d4,%d15,-6
80010618:	8f 7f 1f 30 	sh %d3,%d15,-9
8001061c:	1b 84 03 40 	addi %d4,%d4,56
80010620:	bf 53 22 80 	jlt.u %d3,5,80010664 <_malloc_r+0x1ce>
80010624:	8b 53 a1 42 	ge.u %d4,%d3,21
80010628:	f6 44       	jnz %d4,80010630 <_malloc_r+0x19a>
8001062a:	1b b3 05 40 	addi %d4,%d3,91
8001062e:	3c 1b       	j 80010664 <_malloc_r+0x1ce>
80010630:	8b 53 a5 42 	ge.u %d4,%d3,85
80010634:	f6 46       	jnz %d4,80010640 <_malloc_r+0x1aa>
80010636:	8f 4f 1f 40 	sh %d4,%d15,-12
8001063a:	1b e4 06 40 	addi %d4,%d4,110
8001063e:	3c 13       	j 80010664 <_malloc_r+0x1ce>
80010640:	8b 53 b5 42 	ge.u %d4,%d3,341
80010644:	f6 46       	jnz %d4,80010650 <_malloc_r+0x1ba>
80010646:	8f 1f 1f 40 	sh %d4,%d15,-15
8001064a:	1b 74 07 40 	addi %d4,%d4,119
8001064e:	3c 0b       	j 80010664 <_malloc_r+0x1ce>
80010650:	3b 50 55 50 	mov %d5,1365
80010654:	3b e0 07 40 	mov %d4,126
80010658:	7f 53 06 80 	jge.u %d3,%d5,80010664 <_malloc_r+0x1ce>
8001065c:	8f ef 1e 40 	sh %d4,%d15,-18
80010660:	1b c4 07 40 	addi %d4,%d4,124
80010664:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
80010668:	99 42 08 00 	ld.a %a2,[%a4]8
8001066c:	7d 42 0d 80 	jne.a %a2,%a4,80010686 <_malloc_r+0x1f0>
80010670:	4c f1       	ld.w %d15,[%a15]4
80010672:	86 e4       	sha %d4,-2
80010674:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
80010678:	40 24       	mov.aa %a4,%a2
8001067a:	68 14       	st.w [%a15]4,%d4
8001067c:	3c 0d       	j 80010696 <_malloc_r+0x200>
8001067e:	99 22 08 00 	ld.a %a2,[%a2]8
80010682:	7d 42 08 00 	jeq.a %a2,%a4,80010692 <_malloc_r+0x1fc>
80010686:	19 23 04 00 	ld.w %d3,[%a2]4
8001068a:	8f 33 c0 31 	andn %d3,%d3,3
8001068e:	3f 3f f8 ff 	jlt.u %d15,%d3,8001067e <_malloc_r+0x1e8>
80010692:	99 24 0c 00 	ld.a %a4,[%a2]12
80010696:	b5 c4 0c 00 	st.a [%a12]12,%a4
8001069a:	b5 c2 08 00 	st.a [%a12]8,%a2
8001069e:	b5 4c 08 00 	st.a [%a4]8,%a12
800106a2:	b5 2c 0c 00 	st.a [%a2]12,%a12
800106a6:	8f e2 3f 30 	sha %d3,%d2,-2
800106aa:	82 1f       	mov %d15,1
800106ac:	0f 3f 00 f0 	sh %d15,%d15,%d3
800106b0:	48 13       	ld.w %d3,[%a15]4
800106b2:	3f f3 73 80 	jlt.u %d3,%d15,80010798 <_malloc_r+0x302>
800106b6:	0f 3f 80 40 	and %d4,%d15,%d3
800106ba:	f6 49       	jnz %d4,800106cc <_malloc_r+0x236>
800106bc:	8f 32 c0 21 	andn %d2,%d2,3
800106c0:	06 1f       	sh %d15,1
800106c2:	0f 3f 80 40 	and %d4,%d15,%d3
800106c6:	c2 42       	add %d2,4
800106c8:	df 04 fc 7f 	jeq %d4,0,800106c0 <_malloc_r+0x22a>
800106cc:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
800106d0:	02 24       	mov %d4,%d2
800106d2:	40 24       	mov.aa %a4,%a2
800106d4:	99 4c 0c 00 	ld.a %a12,[%a4]12
800106d8:	7d 4c 3c 00 	jeq.a %a12,%a4,80010750 <_malloc_r+0x2ba>
800106dc:	19 c6 04 00 	ld.w %d6,[%a12]4
800106e0:	8f 36 c0 61 	andn %d6,%d6,3
800106e4:	0b 86 80 30 	sub %d3,%d6,%d8
800106e8:	8b 03 41 52 	lt %d5,%d3,16
800106ec:	df 05 1d 80 	jne %d5,0,80010726 <_malloc_r+0x290>
800106f0:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
800106f4:	8f 18 40 81 	or %d8,%d8,1
800106f8:	59 c8 04 00 	st.w [%a12]4,%d8
800106fc:	99 c4 0c 00 	ld.a %a4,[%a12]12
80010700:	09 c5 88 05 	ld.a %a5,[+%a12]8
80010704:	8f 13 40 f1 	or %d15,%d3,1
80010708:	b5 54 0c 00 	st.a [%a5]12,%a4
8001070c:	b5 45 08 00 	st.a [%a4]8,%a5
80010710:	e8 52       	st.a [%a15]20,%a2
80010712:	e8 42       	st.a [%a15]16,%a2
80010714:	b5 23 0c 00 	st.a [%a2]12,%a3
80010718:	b5 23 08 00 	st.a [%a2]8,%a3
8001071c:	6c 21       	st.w [%a2]4,%d15
8001071e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80010722:	74 23       	st.w [%a2],%d3
80010724:	3c 0e       	j 80010740 <_malloc_r+0x2aa>
80010726:	bf 03 12 00 	jlt %d3,0,8001074a <_malloc_r+0x2b4>
8001072a:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
8001072e:	b7 10 21 20 	imask %e2,1,0,1
80010732:	49 f2 44 08 	ldmst [%a15]4,%e2
80010736:	cc c3       	ld.a %a15,[%a12]12
80010738:	09 c2 88 05 	ld.a %a2,[+%a12]8
8001073c:	ec 23       	st.a [%a2]12,%a15
8001073e:	e8 22       	st.a [%a15]8,%a2
80010740:	40 d4       	mov.aa %a4,%a13
80010742:	6d 00 12 01 	call 80010966 <__malloc_unlock>
80010746:	1d 00 f3 00 	j 8001092c <_malloc_r+0x496>
8001074a:	99 cc 0c 00 	ld.a %a12,[%a12]12
8001074e:	3c c5       	j 800106d8 <_malloc_r+0x242>
80010750:	c2 14       	add %d4,1
80010752:	8f 34 00 31 	and %d3,%d4,3
80010756:	d9 44 08 00 	lea %a4,[%a4]8
8001075a:	df 03 bd ff 	jne %d3,0,800106d4 <_malloc_r+0x23e>
8001075e:	8f 32 00 31 	and %d3,%d2,3
80010762:	f6 36       	jnz %d3,8001076e <_malloc_r+0x2d8>
80010764:	48 12       	ld.w %d2,[%a15]4
80010766:	0f f2 e0 20 	andn %d2,%d2,%d15
8001076a:	68 12       	st.w [%a15]4,%d2
8001076c:	3c 07       	j 8001077a <_malloc_r+0x2e4>
8001076e:	d9 24 f8 ff 	lea %a4,[%a2]-8
80010772:	d4 22       	ld.a %a2,[%a2]
80010774:	c2 f2       	add %d2,-1
80010776:	7d 42 f4 7f 	jeq.a %a2,%a4,8001075e <_malloc_r+0x2c8>
8001077a:	06 1f       	sh %d15,1
8001077c:	48 12       	ld.w %d2,[%a15]4
8001077e:	8b 0f 20 32 	ne %d3,%d15,0
80010782:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
80010786:	76 39       	jz %d3,80010798 <_malloc_r+0x302>
80010788:	0f 2f 80 30 	and %d3,%d15,%d2
8001078c:	f6 34       	jnz %d3,80010794 <_malloc_r+0x2fe>
8001078e:	c2 44       	add %d4,4
80010790:	06 1f       	sh %d15,1
80010792:	3c fb       	j 80010788 <_malloc_r+0x2f2>
80010794:	02 42       	mov %d2,%d4
80010796:	3c 9b       	j 800106cc <_malloc_r+0x236>
80010798:	c8 2c       	ld.a %a12,[%a15]8
8001079a:	19 ca 04 00 	ld.w %d10,[%a12]4
8001079e:	8f 3a c0 a1 	andn %d10,%d10,3
800107a2:	5a 8a       	sub %d15,%d10,%d8
800107a4:	8b 0f 41 22 	lt %d2,%d15,16
800107a8:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
800107ac:	df 02 b1 00 	jeq %d2,0,8001090e <_malloc_r+0x478>
800107b0:	91 00 00 27 	movh.a %a2,28672
800107b4:	19 2b 58 34 	ld.w %d11,[%a2]17624 <700044d8 <__malloc_top_pad>>
800107b8:	91 00 00 27 	movh.a %a2,28672
800107bc:	42 8b       	add %d11,%d8
800107be:	19 23 40 61 	ld.w %d3,[%a2]5504 <70001580 <__malloc_sbrk_base>>
800107c2:	1b fb 00 f1 	addi %d15,%d11,4111
800107c6:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
800107ca:	1b 0b 01 20 	addi %d2,%d11,16
800107ce:	8b f3 3f b2 	ne %d11,%d3,-1
800107d2:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
800107d6:	40 d4       	mov.aa %a4,%a13
800107d8:	02 b4       	mov %d4,%d11
800107da:	80 2c       	mov.d %d12,%a2
800107dc:	6d 00 ba 03 	call 80010f50 <_sbrk_r>
800107e0:	80 29       	mov.d %d9,%a2
800107e2:	df f9 86 00 	jeq %d9,-1,800108ee <_malloc_r+0x458>
800107e6:	80 c2       	mov.d %d2,%a12
800107e8:	80 c3       	mov.d %d3,%a12
800107ea:	42 a2       	add %d2,%d10
800107ec:	80 f4       	mov.d %d4,%a15
800107ee:	0b 29 30 f1 	lt.u %d15,%d9,%d2
800107f2:	0b 43 10 f2 	and.ne %d15,%d3,%d4
800107f6:	01 fc 10 d4 	ne.a %d13,%a12,%a15
800107fa:	ee 7a       	jnz %d15,800108ee <_malloc_r+0x458>
800107fc:	91 00 00 e7 	movh.a %a14,28672
80010800:	19 e3 68 24 	ld.w %d3,[%a14]17576 <700044a8 <__malloc_current_mallinfo>>
80010804:	42 b3       	add %d3,%d11
80010806:	59 e3 68 24 	st.w [%a14]17576 <700044a8 <__malloc_current_mallinfo>>,%d3
8001080a:	5f 29 0c 80 	jne %d9,%d2,80010822 <_malloc_r+0x38c>
8001080e:	b7 09 14 f6 	insert %d15,%d9,0,12,20
80010812:	ee 08       	jnz %d15,80010822 <_malloc_r+0x38c>
80010814:	c8 22       	ld.a %a2,[%a15]8
80010816:	42 ba       	add %d10,%d11
80010818:	8f 1a 40 a1 	or %d10,%d10,1
8001081c:	59 2a 04 00 	st.w [%a2]4,%d10
80010820:	3c 55       	j 800108ca <_malloc_r+0x434>
80010822:	60 c2       	mov.a %a2,%d12
80010824:	19 2f 40 61 	ld.w %d15,[%a2]5504
80010828:	5e f6       	jne %d15,-1,80010834 <_malloc_r+0x39e>
8001082a:	91 00 00 27 	movh.a %a2,28672
8001082e:	59 29 40 61 	st.w [%a2]5504 <70001580 <__malloc_sbrk_base>>,%d9
80010832:	3c 06       	j 8001083e <_malloc_r+0x3a8>
80010834:	0b 29 80 20 	sub %d2,%d9,%d2
80010838:	42 23       	add %d3,%d2
8001083a:	59 e3 68 24 	st.w [%a14]17576 <700044a8 <__malloc_current_mallinfo>>,%d3
8001083e:	8f 79 00 21 	and %d2,%d9,7
80010842:	82 0f       	mov %d15,0
80010844:	76 24       	jz %d2,8001084c <_malloc_r+0x3b6>
80010846:	8b 82 00 f1 	rsub %d15,%d2,8
8001084a:	42 f9       	add %d9,%d15
8001084c:	42 9b       	add %d11,%d9
8001084e:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
80010852:	1b 0f 00 21 	addi %d2,%d15,4096
80010856:	5a b2       	sub %d15,%d2,%d11
80010858:	40 d4       	mov.aa %a4,%a13
8001085a:	02 f4       	mov %d4,%d15
8001085c:	6d 00 7a 03 	call 80010f50 <_sbrk_r>
80010860:	80 22       	mov.d %d2,%a2
80010862:	df f2 04 80 	jne %d2,-1,8001086a <_malloc_r+0x3d4>
80010866:	60 92       	mov.a %a2,%d9
80010868:	82 0f       	mov %d15,0
8001086a:	80 2b       	mov.d %d11,%a2
8001086c:	19 e2 68 24 	ld.w %d2,[%a14]17576 <700044a8 <__malloc_current_mallinfo>>
80010870:	a2 9b       	sub %d11,%d9
80010872:	42 f2       	add %d2,%d15
80010874:	60 92       	mov.a %a2,%d9
80010876:	42 bf       	add %d15,%d11
80010878:	68 29       	st.w [%a15]8,%d9
8001087a:	8f 1f 40 31 	or %d3,%d15,1
8001087e:	59 e2 68 24 	st.w [%a14]17576 <700044a8 <__malloc_current_mallinfo>>,%d2
80010882:	59 23 04 00 	st.w [%a2]4 <700044a8 <__malloc_current_mallinfo>>,%d3
80010886:	df 0d 22 00 	jeq %d13,0,800108ca <_malloc_r+0x434>
8001088a:	8b 0a a1 f2 	ge.u %d15,%d10,16
8001088e:	ee 05       	jnz %d15,80010898 <_malloc_r+0x402>
80010890:	82 12       	mov %d2,1
80010892:	59 22 04 00 	st.w [%a2]4,%d2
80010896:	3c 2c       	j 800108ee <_malloc_r+0x458>
80010898:	1b 4a ff af 	addi %d10,%d10,-12
8001089c:	8f 7a c0 f1 	andn %d15,%d10,7
800108a0:	10 c2       	addsc.a %a2,%a12,%d15,0
800108a2:	82 52       	mov %d2,5
800108a4:	59 22 04 00 	st.w [%a2]4,%d2
800108a8:	59 22 08 00 	st.w [%a2]8,%d2
800108ac:	19 c2 04 00 	ld.w %d2,[%a12]4
800108b0:	8f 12 00 21 	and %d2,%d2,1
800108b4:	a6 f2       	or %d2,%d15
800108b6:	59 c2 04 00 	st.w [%a12]4,%d2
800108ba:	8b 0f 61 f2 	lt.u %d15,%d15,16
800108be:	ee 06       	jnz %d15,800108ca <_malloc_r+0x434>
800108c0:	40 d4       	mov.aa %a4,%a13
800108c2:	d9 c5 08 00 	lea %a5,[%a12]8
800108c6:	6d 00 5a 04 	call 8001117a <_free_r>
800108ca:	91 00 00 27 	movh.a %a2,28672
800108ce:	19 ef 68 24 	ld.w %d15,[%a14]17576 <700044a8 <__malloc_current_mallinfo>>
800108d2:	19 22 54 34 	ld.w %d2,[%a2]17620 <700044d4 <__malloc_max_sbrked_mem>>
800108d6:	7f f2 04 80 	jge.u %d2,%d15,800108de <_malloc_r+0x448>
800108da:	59 2f 54 34 	st.w [%a2]17620 <700044d4 <__malloc_max_sbrked_mem>>,%d15
800108de:	91 00 00 27 	movh.a %a2,28672
800108e2:	19 22 50 34 	ld.w %d2,[%a2]17616 <700044d0 <__malloc_max_total_mem>>
800108e6:	7f f2 04 80 	jge.u %d2,%d15,800108ee <_malloc_r+0x458>
800108ea:	59 2f 50 34 	st.w [%a2]17616 <700044d0 <__malloc_max_total_mem>>,%d15
800108ee:	c8 22       	ld.a %a2,[%a15]8
800108f0:	19 22 04 00 	ld.w %d2,[%a2]4 <700044d0 <__malloc_max_total_mem>>
800108f4:	8f 32 c0 21 	andn %d2,%d2,3
800108f8:	5a 82       	sub %d15,%d2,%d8
800108fa:	8b 0f 41 32 	lt %d3,%d15,16
800108fe:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
80010902:	76 36       	jz %d3,8001090e <_malloc_r+0x478>
80010904:	40 d4       	mov.aa %a4,%a13
80010906:	6d 00 30 00 	call 80010966 <__malloc_unlock>
8001090a:	a0 0c       	mov.a %a12,0
8001090c:	3c 10       	j 8001092c <_malloc_r+0x496>
8001090e:	c8 2c       	ld.a %a12,[%a15]8
80010910:	8f 18 40 21 	or %d2,%d8,1
80010914:	96 01       	or %d15,1
80010916:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8001091a:	59 c2 04 00 	st.w [%a12]4,%d2
8001091e:	e8 22       	st.a [%a15]8,%a2
80010920:	6c 21       	st.w [%a2]4,%d15
80010922:	40 d4       	mov.aa %a4,%a13
80010924:	6d 00 21 00 	call 80010966 <__malloc_unlock>
80010928:	d9 cc 08 00 	lea %a12,[%a12]8
8001092c:	40 c2       	mov.aa %a2,%a12
8001092e:	00 90       	ret 

80010930 <memchr>:
80010930:	8f f4 0f 41 	and %d4,%d4,255
80010934:	9f 05 04 80 	jned %d5,0,8001093c <memchr+0xc>
80010938:	a0 02       	mov.a %a2,0
8001093a:	00 90       	ret 
8001093c:	0c 40       	ld.bu %d15,[%a4]0
8001093e:	3e 43       	jeq %d15,%d4,80010944 <memchr+0x14>
80010940:	b0 14       	add.a %a4,1
80010942:	3c f9       	j 80010934 <memchr+0x4>
80010944:	40 42       	mov.aa %a2,%a4
80010946:	00 90       	ret 

80010948 <memcpy>:
80010948:	40 42       	mov.aa %a2,%a4
8001094a:	a0 0f       	mov.a %a15,0
8001094c:	01 f2 10 40 	add.a %a4,%a2,%a15
80010950:	01 f5 10 30 	add.a %a3,%a5,%a15
80010954:	9f 04 03 80 	jned %d4,0,8001095a <memcpy+0x12>
80010958:	00 90       	ret 
8001095a:	79 3f 00 00 	ld.b %d15,[%a3]0
8001095e:	b0 1f       	add.a %a15,1
80010960:	2c 40       	st.b [%a4]0,%d15
80010962:	3c f5       	j 8001094c <memcpy+0x4>

80010964 <__malloc_lock>:
80010964:	00 90       	ret 

80010966 <__malloc_unlock>:
80010966:	00 90       	ret 

80010968 <_Balloc>:
80010968:	19 42 0c 10 	ld.w %d2,[%a4]76
8001096c:	40 4f       	mov.aa %a15,%a4
8001096e:	02 4f       	mov %d15,%d4
80010970:	76 29       	jz %d2,80010982 <_Balloc+0x1a>
80010972:	99 f3 0c 10 	ld.a %a3,[%a15]76
80010976:	90 33       	addsc.a %a3,%a3,%d15,2
80010978:	d4 32       	ld.a %a2,[%a3]
8001097a:	bc 2f       	jz.a %a2,80010998 <_Balloc+0x30>
8001097c:	4c 20       	ld.w %d15,[%a2]0
8001097e:	6c 30       	st.w [%a3]0,%d15
80010980:	3c 1b       	j 800109b6 <_Balloc+0x4e>
80010982:	82 44       	mov %d4,4
80010984:	3b 10 02 50 	mov %d5,33
80010988:	6d 00 6b 03 	call 8001105e <_calloc_r>
8001098c:	b5 f2 0c 10 	st.a [%a15]76,%a2
80010990:	bd 02 f1 ff 	jnz.a %a2,80010972 <_Balloc+0xa>
80010994:	a0 02       	mov.a %a2,0
80010996:	00 90       	ret 
80010998:	82 18       	mov %d8,1
8001099a:	0f f8 00 80 	sh %d8,%d8,%d15
8001099e:	1b 58 00 50 	addi %d5,%d8,5
800109a2:	40 f4       	mov.aa %a4,%a15
800109a4:	82 14       	mov %d4,1
800109a6:	06 25       	sh %d5,2
800109a8:	6d 00 5b 03 	call 8001105e <_calloc_r>
800109ac:	bd 02 f4 7f 	jz.a %a2,80010994 <_Balloc+0x2c>
800109b0:	6c 21       	st.w [%a2]4,%d15
800109b2:	59 28 08 00 	st.w [%a2]8,%d8
800109b6:	82 0f       	mov %d15,0
800109b8:	6c 24       	st.w [%a2]16,%d15
800109ba:	6c 23       	st.w [%a2]12,%d15
800109bc:	00 90       	ret 

800109be <_Bfree>:
800109be:	bc 58       	jz.a %a5,800109ce <_Bfree+0x10>
800109c0:	99 4f 0c 10 	ld.a %a15,[%a4]76
800109c4:	4c 51       	ld.w %d15,[%a5]4
800109c6:	90 ff       	addsc.a %a15,%a15,%d15,2
800109c8:	4c f0       	ld.w %d15,[%a15]0
800109ca:	6c 50       	st.w [%a5]0,%d15
800109cc:	e8 05       	st.a [%a15]0,%a5
800109ce:	00 90       	ret 

800109d0 <__multadd>:
800109d0:	19 59 10 00 	ld.w %d9,[%a5]16
800109d4:	40 4c       	mov.aa %a12,%a4
800109d6:	9a f9       	add %d15,%d9,-1
800109d8:	8b 19 80 22 	ge %d2,%d9,1
800109dc:	40 5f       	mov.aa %a15,%a5
800109de:	02 58       	mov %d8,%d5
800109e0:	d9 53 14 00 	lea %a3,[%a5]20
800109e4:	ab 0f 80 22 	sel %d2,%d2,%d15,0
800109e8:	40 32       	mov.aa %a2,%a3
800109ea:	44 25       	ld.w %d5,[%a2+]
800109ec:	b7 05 10 38 	insert %d3,%d5,0,16,16
800109f0:	8f 05 1f f0 	sh %d15,%d5,-16
800109f4:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
800109f8:	8f 03 1f 60 	sh %d6,%d3,-16
800109fc:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
80010a00:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
80010a04:	8f 0f 1f 80 	sh %d8,%d15,-16
80010a08:	74 33       	st.w [%a3],%d3
80010a0a:	40 23       	mov.aa %a3,%a2
80010a0c:	9f 02 ee ff 	jned %d2,0,800109e8 <__multadd+0x18>
80010a10:	df 08 1f 00 	jeq %d8,0,80010a4e <__multadd+0x7e>
80010a14:	4c f2       	ld.w %d15,[%a15]8
80010a16:	3f f9 16 00 	jlt %d9,%d15,80010a42 <__multadd+0x72>
80010a1a:	48 14       	ld.w %d4,[%a15]4
80010a1c:	40 c4       	mov.aa %a4,%a12
80010a1e:	c2 14       	add %d4,1
80010a20:	6d ff a4 ff 	call 80010968 <_Balloc>
80010a24:	48 44       	ld.w %d4,[%a15]16
80010a26:	d9 f5 0c 00 	lea %a5,[%a15]12
80010a2a:	c2 24       	add %d4,2
80010a2c:	d9 24 0c 00 	lea %a4,[%a2]12
80010a30:	06 24       	sh %d4,2
80010a32:	40 2d       	mov.aa %a13,%a2
80010a34:	6d ff 8a ff 	call 80010948 <memcpy>
80010a38:	40 f5       	mov.aa %a5,%a15
80010a3a:	40 c4       	mov.aa %a4,%a12
80010a3c:	6d ff c1 ff 	call 800109be <_Bfree>
80010a40:	40 df       	mov.aa %a15,%a13
80010a42:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
80010a46:	c2 19       	add %d9,1
80010a48:	59 28 14 00 	st.w [%a2]20,%d8
80010a4c:	68 49       	st.w [%a15]16,%d9
80010a4e:	40 f2       	mov.aa %a2,%a15
80010a50:	00 90       	ret 

80010a52 <__hi0bits>:
80010a52:	b7 04 10 f0 	insert %d15,%d4,0,0,16
80010a56:	82 02       	mov %d2,0
80010a58:	ee 05       	jnz %d15,80010a62 <__hi0bits+0x10>
80010a5a:	8f 04 01 40 	sh %d4,%d4,16
80010a5e:	3b 00 01 20 	mov %d2,16
80010a62:	b7 04 18 f0 	insert %d15,%d4,0,0,24
80010a66:	ee 05       	jnz %d15,80010a70 <__hi0bits+0x1e>
80010a68:	1b 82 00 20 	addi %d2,%d2,8
80010a6c:	8f 84 00 40 	sh %d4,%d4,8
80010a70:	b7 04 1c f0 	insert %d15,%d4,0,0,28
80010a74:	ee 03       	jnz %d15,80010a7a <__hi0bits+0x28>
80010a76:	c2 42       	add %d2,4
80010a78:	06 44       	sh %d4,4
80010a7a:	b7 04 1e f0 	insert %d15,%d4,0,0,30
80010a7e:	ee 03       	jnz %d15,80010a84 <__hi0bits+0x32>
80010a80:	c2 22       	add %d2,2
80010a82:	06 24       	sh %d4,2
80010a84:	0e 47       	jltz %d4,80010a92 <__hi0bits+0x40>
80010a86:	7b 00 00 f4 	movh %d15,16384
80010a8a:	26 f4       	and %d4,%d15
80010a8c:	c2 12       	add %d2,1
80010a8e:	ab 02 82 24 	sel %d2,%d4,%d2,32
80010a92:	00 90       	ret 

80010a94 <__lo0bits>:
80010a94:	54 43       	ld.w %d3,[%a4]
80010a96:	8f 73 00 f1 	and %d15,%d3,7
80010a9a:	6e 0e       	jz %d15,80010ab6 <__lo0bits+0x22>
80010a9c:	82 02       	mov %d2,0
80010a9e:	6f 03 2d 80 	jnz.t %d3,0,80010af8 <__lo0bits+0x64>
80010aa2:	6f 13 06 00 	jz.t %d3,1,80010aae <__lo0bits+0x1a>
80010aa6:	06 f3       	sh %d3,-1
80010aa8:	74 43       	st.w [%a4],%d3
80010aaa:	82 12       	mov %d2,1
80010aac:	00 90       	ret 
80010aae:	06 e3       	sh %d3,-2
80010ab0:	74 43       	st.w [%a4],%d3
80010ab2:	82 22       	mov %d2,2
80010ab4:	00 90       	ret 
80010ab6:	b7 03 10 f8 	insert %d15,%d3,0,16,16
80010aba:	82 04       	mov %d4,0
80010abc:	ee 05       	jnz %d15,80010ac6 <__lo0bits+0x32>
80010abe:	8f 03 1f 30 	sh %d3,%d3,-16
80010ac2:	3b 00 01 40 	mov %d4,16
80010ac6:	02 3f       	mov %d15,%d3
80010ac8:	16 ff       	and %d15,255
80010aca:	ee 04       	jnz %d15,80010ad2 <__lo0bits+0x3e>
80010acc:	1b 84 00 40 	addi %d4,%d4,8
80010ad0:	06 83       	sh %d3,-8
80010ad2:	8f f3 00 f1 	and %d15,%d3,15
80010ad6:	ee 03       	jnz %d15,80010adc <__lo0bits+0x48>
80010ad8:	c2 44       	add %d4,4
80010ada:	06 c3       	sh %d3,-4
80010adc:	8f 33 00 f1 	and %d15,%d3,3
80010ae0:	ee 03       	jnz %d15,80010ae6 <__lo0bits+0x52>
80010ae2:	c2 24       	add %d4,2
80010ae4:	06 e3       	sh %d3,-2
80010ae6:	6f 03 07 80 	jnz.t %d3,0,80010af4 <__lo0bits+0x60>
80010aea:	06 f3       	sh %d3,-1
80010aec:	3b 00 02 20 	mov %d2,32
80010af0:	76 34       	jz %d3,80010af8 <__lo0bits+0x64>
80010af2:	c2 14       	add %d4,1
80010af4:	74 43       	st.w [%a4],%d3
80010af6:	02 42       	mov %d2,%d4
80010af8:	00 90       	ret 

80010afa <__i2b>:
80010afa:	02 4f       	mov %d15,%d4
80010afc:	82 14       	mov %d4,1
80010afe:	6d ff 35 ff 	call 80010968 <_Balloc>
80010b02:	6c 25       	st.w [%a2]20,%d15
80010b04:	82 1f       	mov %d15,1
80010b06:	6c 24       	st.w [%a2]16,%d15
80010b08:	00 90       	ret 

80010b0a <__multiply>:
80010b0a:	19 52 10 00 	ld.w %d2,[%a5]16
80010b0e:	4c 64       	ld.w %d15,[%a6]16
80010b10:	40 5f       	mov.aa %a15,%a5
80010b12:	40 6c       	mov.aa %a12,%a6
80010b14:	7f f2 04 00 	jge %d2,%d15,80010b1c <__multiply+0x12>
80010b18:	40 6f       	mov.aa %a15,%a6
80010b1a:	40 5c       	mov.aa %a12,%a5
80010b1c:	48 4a       	ld.w %d10,[%a15]16
80010b1e:	19 c9 10 00 	ld.w %d9,[%a12]16
80010b22:	4c f2       	ld.w %d15,[%a15]8
80010b24:	0b 9a 00 80 	add %d8,%d10,%d9
80010b28:	48 12       	ld.w %d2,[%a15]4
80010b2a:	0b 8f 20 41 	lt %d4,%d15,%d8
80010b2e:	42 24       	add %d4,%d2
80010b30:	6d ff 1c ff 	call 80010968 <_Balloc>
80010b34:	d9 23 14 00 	lea %a3,[%a2]20
80010b38:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
80010b3c:	40 34       	mov.aa %a4,%a3
80010b3e:	82 0f       	mov %d15,0
80010b40:	80 43       	mov.d %d3,%a4
80010b42:	80 d2       	mov.d %d2,%a13
80010b44:	7f 23 04 80 	jge.u %d3,%d2,80010b4c <__multiply+0x42>
80010b48:	64 4f       	st.w [%a4+],%d15
80010b4a:	3c fb       	j 80010b40 <__multiply+0x36>
80010b4c:	d9 ff 14 00 	lea %a15,[%a15]20
80010b50:	d9 cc 14 00 	lea %a12,[%a12]20
80010b54:	80 f3       	mov.d %d3,%a15
80010b56:	80 cf       	mov.d %d15,%a12
80010b58:	13 4a 20 43 	madd %d4,%d3,%d10,4
80010b5c:	13 49 20 0f 	madd %d0,%d15,%d9,4
80010b60:	80 c2       	mov.d %d2,%a12
80010b62:	7f 02 54 80 	jge.u %d2,%d0,80010c0a <__multiply+0x100>
80010b66:	b9 c2 00 00 	ld.hu %d2,[%a12]0
80010b6a:	40 34       	mov.aa %a4,%a3
80010b6c:	40 f6       	mov.aa %a6,%a15
80010b6e:	82 03       	mov %d3,0
80010b70:	df 02 21 00 	jeq %d2,0,80010bb2 <__multiply+0xa8>
80010b74:	40 45       	mov.aa %a5,%a4
80010b76:	44 67       	ld.w %d7,[%a6+]
80010b78:	44 56       	ld.w %d6,[%a5+]
80010b7a:	b7 07 10 18 	insert %d1,%d7,0,16,16
80010b7e:	b7 06 10 58 	insert %d5,%d6,0,16,16
80010b82:	8f 07 1f 70 	sh %d7,%d7,-16
80010b86:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
80010b8a:	8f 06 1f 60 	sh %d6,%d6,-16
80010b8e:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
80010b92:	42 35       	add %d5,%d3
80010b94:	8f 05 1f 30 	sh %d3,%d5,-16
80010b98:	1a 36       	add %d15,%d6,%d3
80010b9a:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
80010b9e:	8f 0f 1f 30 	sh %d3,%d15,-16
80010ba2:	80 6f       	mov.d %d15,%a6
80010ba4:	74 45       	st.w [%a4],%d5
80010ba6:	7f 4f 04 80 	jge.u %d15,%d4,80010bae <__multiply+0xa4>
80010baa:	40 54       	mov.aa %a4,%a5
80010bac:	3c e4       	j 80010b74 <__multiply+0x6a>
80010bae:	59 43 04 00 	st.w [%a4]4,%d3
80010bb2:	b9 c2 02 00 	ld.hu %d2,[%a12]2
80010bb6:	df 02 27 00 	jeq %d2,0,80010c04 <__multiply+0xfa>
80010bba:	54 33       	ld.w %d3,[%a3]
80010bbc:	40 34       	mov.aa %a4,%a3
80010bbe:	40 f5       	mov.aa %a5,%a15
80010bc0:	82 07       	mov %d7,0
80010bc2:	40 56       	mov.aa %a6,%a5
80010bc4:	44 66       	ld.w %d6,[%a6+]
80010bc6:	40 47       	mov.aa %a7,%a4
80010bc8:	44 75       	ld.w %d5,[%a7+]
80010bca:	b7 06 10 68 	insert %d6,%d6,0,16,16
80010bce:	8f 05 1f 50 	sh %d5,%d5,-16
80010bd2:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
80010bd6:	42 7f       	add %d15,%d7
80010bd8:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
80010bdc:	8f 0f 1f f0 	sh %d15,%d15,-16
80010be0:	74 43       	st.w [%a4],%d3
80010be2:	b9 55 02 00 	ld.hu %d5,[%a5]2
80010be6:	b9 43 04 00 	ld.hu %d3,[%a4]4
80010bea:	40 65       	mov.aa %a5,%a6
80010bec:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
80010bf0:	42 f3       	add %d3,%d15
80010bf2:	80 6f       	mov.d %d15,%a6
80010bf4:	8f 03 1f 70 	sh %d7,%d3,-16
80010bf8:	7f 4f 04 80 	jge.u %d15,%d4,80010c00 <__multiply+0xf6>
80010bfc:	40 74       	mov.aa %a4,%a7
80010bfe:	3c e2       	j 80010bc2 <__multiply+0xb8>
80010c00:	59 43 04 00 	st.w [%a4]4,%d3
80010c04:	b0 4c       	add.a %a12,4
80010c06:	b0 43       	add.a %a3,4
80010c08:	3c ac       	j 80010b60 <__multiply+0x56>
80010c0a:	8b 08 40 f3 	max %d15,%d8,0
80010c0e:	9f 0f 05 80 	jned %d15,0,80010c18 <__multiply+0x10e>
80010c12:	59 28 10 00 	st.w [%a2]16,%d8
80010c16:	00 90       	ret 
80010c18:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
80010c1c:	df 02 fb ff 	jne %d2,0,80010c12 <__multiply+0x108>
80010c20:	c2 f8       	add %d8,-1
80010c22:	3c f6       	j 80010c0e <__multiply+0x104>

80010c24 <__pow5mult>:
80010c24:	8f 34 00 21 	and %d2,%d4,3
80010c28:	40 4c       	mov.aa %a12,%a4
80010c2a:	40 5d       	mov.aa %a13,%a5
80010c2c:	02 4f       	mov %d15,%d4
80010c2e:	76 2d       	jz %d2,80010c48 <__pow5mult+0x24>
80010c30:	91 00 00 f8 	movh.a %a15,32768
80010c34:	d9 ff dc 20 	lea %a15,[%a15]3228 <80000c9c <p05.2553>>
80010c38:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
80010c3c:	82 05       	mov %d5,0
80010c3e:	19 f4 fc ff 	ld.w %d4,[%a15]-4
80010c42:	6d ff c7 fe 	call 800109d0 <__multadd>
80010c46:	40 2d       	mov.aa %a13,%a2
80010c48:	86 ef       	sha %d15,-2
80010c4a:	6e 29       	jz %d15,80010c9c <__pow5mult+0x78>
80010c4c:	99 cf 08 10 	ld.a %a15,[%a12]72
80010c50:	7c fb       	jnz.a %a15,80010c66 <__pow5mult+0x42>
80010c52:	40 c4       	mov.aa %a4,%a12
80010c54:	3b 10 27 40 	mov %d4,625
80010c58:	6d ff 51 ff 	call 80010afa <__i2b>
80010c5c:	82 02       	mov %d2,0
80010c5e:	b5 c2 08 10 	st.a [%a12]72,%a2
80010c62:	40 2f       	mov.aa %a15,%a2
80010c64:	74 22       	st.w [%a2],%d2
80010c66:	82 08       	mov %d8,0
80010c68:	2e 0c       	jz.t %d15,0,80010c80 <__pow5mult+0x5c>
80010c6a:	40 d5       	mov.aa %a5,%a13
80010c6c:	40 c4       	mov.aa %a4,%a12
80010c6e:	40 f6       	mov.aa %a6,%a15
80010c70:	6d ff 4d ff 	call 80010b0a <__multiply>
80010c74:	40 d5       	mov.aa %a5,%a13
80010c76:	40 2e       	mov.aa %a14,%a2
80010c78:	40 c4       	mov.aa %a4,%a12
80010c7a:	6d ff a2 fe 	call 800109be <_Bfree>
80010c7e:	40 ed       	mov.aa %a13,%a14
80010c80:	86 ff       	sha %d15,-1
80010c82:	6e 0d       	jz %d15,80010c9c <__pow5mult+0x78>
80010c84:	c8 02       	ld.a %a2,[%a15]0
80010c86:	bc 23       	jz.a %a2,80010c8c <__pow5mult+0x68>
80010c88:	40 2f       	mov.aa %a15,%a2
80010c8a:	3c ef       	j 80010c68 <__pow5mult+0x44>
80010c8c:	40 c4       	mov.aa %a4,%a12
80010c8e:	40 f5       	mov.aa %a5,%a15
80010c90:	40 f6       	mov.aa %a6,%a15
80010c92:	6d ff 3c ff 	call 80010b0a <__multiply>
80010c96:	e8 02       	st.a [%a15]0,%a2
80010c98:	74 28       	st.w [%a2],%d8
80010c9a:	3c f7       	j 80010c88 <__pow5mult+0x64>
80010c9c:	40 d2       	mov.aa %a2,%a13
80010c9e:	00 90       	ret 

80010ca0 <__lshift>:
80010ca0:	19 5b 10 00 	ld.w %d11,[%a5]16
80010ca4:	8f b4 3f 80 	sha %d8,%d4,-5
80010ca8:	02 4a       	mov %d10,%d4
80010caa:	42 8b       	add %d11,%d8
80010cac:	19 54 04 00 	ld.w %d4,[%a5]4
80010cb0:	4c 52       	ld.w %d15,[%a5]8
80010cb2:	40 4e       	mov.aa %a14,%a4
80010cb4:	40 5c       	mov.aa %a12,%a5
80010cb6:	1b 1b 00 90 	addi %d9,%d11,1
80010cba:	7f 9f 05 00 	jge %d15,%d9,80010cc4 <__lshift+0x24>
80010cbe:	c2 14       	add %d4,1
80010cc0:	06 1f       	sh %d15,1
80010cc2:	3c fc       	j 80010cba <__lshift+0x1a>
80010cc4:	40 e4       	mov.aa %a4,%a14
80010cc6:	6d ff 51 fe 	call 80010968 <_Balloc>
80010cca:	8b 08 40 f3 	max %d15,%d8,0
80010cce:	40 2d       	mov.aa %a13,%a2
80010cd0:	d9 2f 14 00 	lea %a15,[%a2]20
80010cd4:	d2 02       	mov %e2,0
80010cd6:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
80010cda:	9f 0f 03 80 	jned %d15,0,80010ce0 <__lshift+0x40>
80010cde:	3c 04       	j 80010ce6 <__lshift+0x46>
80010ce0:	74 23       	st.w [%a2],%d3
80010ce2:	c2 12       	add %d2,1
80010ce4:	3c f9       	j 80010cd6 <__lshift+0x36>
80010ce6:	8b 08 40 83 	max %d8,%d8,0
80010cea:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
80010cee:	d9 cf 14 00 	lea %a15,[%a12]20
80010cf2:	19 c2 10 00 	ld.w %d2,[%a12]16
80010cf6:	80 f3       	mov.d %d3,%a15
80010cf8:	8f fa 01 41 	and %d4,%d10,31
80010cfc:	13 42 20 23 	madd %d2,%d3,%d2,4
80010d00:	8b 04 02 51 	rsub %d5,%d4,32
80010d04:	82 0f       	mov %d15,0
80010d06:	df 04 1a 00 	jeq %d4,0,80010d3a <__lshift+0x9a>
80010d0a:	40 f5       	mov.aa %a5,%a15
80010d0c:	44 53       	ld.w %d3,[%a5+]
80010d0e:	d9 32 04 00 	lea %a2,[%a3]4
80010d12:	0f 43 00 30 	sh %d3,%d3,%d4
80010d16:	a6 3f       	or %d15,%d3
80010d18:	6c 30       	st.w [%a3]0,%d15
80010d1a:	4c f0       	ld.w %d15,[%a15]0
80010d1c:	8b 05 00 31 	rsub %d3,%d5,0
80010d20:	0f 3f 00 30 	sh %d3,%d15,%d3
80010d24:	02 3f       	mov %d15,%d3
80010d26:	80 53       	mov.d %d3,%a5
80010d28:	40 5f       	mov.aa %a15,%a5
80010d2a:	7f 23 04 80 	jge.u %d3,%d2,80010d32 <__lshift+0x92>
80010d2e:	40 23       	mov.aa %a3,%a2
80010d30:	3c ed       	j 80010d0a <__lshift+0x6a>
80010d32:	c2 2b       	add %d11,2
80010d34:	6c 31       	st.w [%a3]4,%d15
80010d36:	2a b9       	cmov %d9,%d15,%d11
80010d38:	3c 08       	j 80010d48 <__lshift+0xa8>
80010d3a:	4c f0       	ld.w %d15,[%a15]0
80010d3c:	b0 4f       	add.a %a15,4
80010d3e:	80 f3       	mov.d %d3,%a15
80010d40:	6c 30       	st.w [%a3]0,%d15
80010d42:	b0 43       	add.a %a3,4
80010d44:	3f 23 fb ff 	jlt.u %d3,%d2,80010d3a <__lshift+0x9a>
80010d48:	c2 f9       	add %d9,-1
80010d4a:	59 d9 10 00 	st.w [%a13]16,%d9
80010d4e:	40 e4       	mov.aa %a4,%a14
80010d50:	40 c5       	mov.aa %a5,%a12
80010d52:	6d ff 36 fe 	call 800109be <_Bfree>
80010d56:	40 d2       	mov.aa %a2,%a13
80010d58:	00 90       	ret 

80010d5a <__mcmp>:
80010d5a:	4c 54       	ld.w %d15,[%a5]16
80010d5c:	19 42 10 00 	ld.w %d2,[%a4]16
80010d60:	a2 f2       	sub %d2,%d15
80010d62:	df 02 1c 80 	jne %d2,0,80010d9a <__mcmp+0x40>
80010d66:	80 42       	mov.d %d2,%a4
80010d68:	06 2f       	sh %d15,2
80010d6a:	60 f2       	mov.a %a2,%d15
80010d6c:	1b 42 01 30 	addi %d3,%d2,20
80010d70:	d9 55 14 00 	lea %a5,[%a5]20
80010d74:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
80010d78:	30 25       	add.a %a5,%a2
80010d7a:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
80010d7e:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
80010d82:	5f f2 08 00 	jeq %d2,%d15,80010d92 <__mcmp+0x38>
80010d86:	0b f2 30 21 	lt.u %d2,%d2,%d15
80010d8a:	82 f3       	mov %d3,-1
80010d8c:	ab 13 80 22 	sel %d2,%d2,%d3,1
80010d90:	00 90       	ret 
80010d92:	80 ff       	mov.d %d15,%a15
80010d94:	3f f3 f3 ff 	jlt.u %d3,%d15,80010d7a <__mcmp+0x20>
80010d98:	82 02       	mov %d2,0
80010d9a:	00 90       	ret 

80010d9c <__mdiff>:
80010d9c:	40 4d       	mov.aa %a13,%a4
80010d9e:	40 5f       	mov.aa %a15,%a5
80010da0:	40 54       	mov.aa %a4,%a5
80010da2:	40 65       	mov.aa %a5,%a6
80010da4:	40 6c       	mov.aa %a12,%a6
80010da6:	6d ff da ff 	call 80010d5a <__mcmp>
80010daa:	02 2f       	mov %d15,%d2
80010dac:	f6 2a       	jnz %d2,80010dc0 <__mdiff+0x24>
80010dae:	40 d4       	mov.aa %a4,%a13
80010db0:	82 04       	mov %d4,0
80010db2:	6d ff db fd 	call 80010968 <_Balloc>
80010db6:	82 12       	mov %d2,1
80010db8:	59 22 10 00 	st.w [%a2]16,%d2
80010dbc:	6c 25       	st.w [%a2]20,%d15
80010dbe:	00 90       	ret 
80010dc0:	82 08       	mov %d8,0
80010dc2:	ce 25       	jgez %d2,80010dcc <__mdiff+0x30>
80010dc4:	40 f2       	mov.aa %a2,%a15
80010dc6:	82 18       	mov %d8,1
80010dc8:	40 cf       	mov.aa %a15,%a12
80010dca:	40 2c       	mov.aa %a12,%a2
80010dcc:	40 d4       	mov.aa %a4,%a13
80010dce:	48 14       	ld.w %d4,[%a15]4
80010dd0:	6d ff cc fd 	call 80010968 <_Balloc>
80010dd4:	48 42       	ld.w %d2,[%a15]16
80010dd6:	d9 ff 14 00 	lea %a15,[%a15]20
80010dda:	80 ff       	mov.d %d15,%a15
80010ddc:	d9 c4 14 00 	lea %a4,[%a12]20
80010de0:	13 42 20 7f 	madd %d7,%d15,%d2,4
80010de4:	19 c0 10 00 	ld.w %d0,[%a12]16
80010de8:	80 4f       	mov.d %d15,%a4
80010dea:	59 28 0c 00 	st.w [%a2]12,%d8
80010dee:	13 40 20 0f 	madd %d0,%d15,%d0,4
80010df2:	d9 25 14 00 	lea %a5,[%a2]20
80010df6:	82 03       	mov %d3,0
80010df8:	44 f6       	ld.w %d6,[%a15+]
80010dfa:	44 45       	ld.w %d5,[%a4+]
80010dfc:	b7 06 10 48 	insert %d4,%d6,0,16,16
80010e00:	b7 05 10 18 	insert %d1,%d5,0,16,16
80010e04:	42 34       	add %d4,%d3
80010e06:	a2 14       	sub %d4,%d1
80010e08:	8f 06 1f 60 	sh %d6,%d6,-16
80010e0c:	8f 05 1f 50 	sh %d5,%d5,-16
80010e10:	8f 04 3f 30 	sha %d3,%d4,-16
80010e14:	0b 56 80 50 	sub %d5,%d6,%d5
80010e18:	1a 35       	add %d15,%d5,%d3
80010e1a:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
80010e1e:	8f 0f 3f 30 	sha %d3,%d15,-16
80010e22:	80 4f       	mov.d %d15,%a4
80010e24:	d9 53 04 00 	lea %a3,[%a5]4
80010e28:	74 54       	st.w [%a5],%d4
80010e2a:	40 35       	mov.aa %a5,%a3
80010e2c:	3f 0f e6 ff 	jlt.u %d15,%d0,80010df8 <__mdiff+0x5c>
80010e30:	80 ff       	mov.d %d15,%a15
80010e32:	7f 7f 12 80 	jge.u %d15,%d7,80010e56 <__mdiff+0xba>
80010e36:	44 f5       	ld.w %d5,[%a15+]
80010e38:	b7 05 10 48 	insert %d4,%d5,0,16,16
80010e3c:	8f 05 1f 50 	sh %d5,%d5,-16
80010e40:	42 34       	add %d4,%d3
80010e42:	8f 04 3f f0 	sha %d15,%d4,-16
80010e46:	42 5f       	add %d15,%d5
80010e48:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
80010e4c:	8f 0f 3f 30 	sha %d3,%d15,-16
80010e50:	74 34       	st.w [%a3],%d4
80010e52:	b0 43       	add.a %a3,4
80010e54:	3c ee       	j 80010e30 <__mdiff+0x94>
80010e56:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
80010e5a:	ee 03       	jnz %d15,80010e60 <__mdiff+0xc4>
80010e5c:	c2 f2       	add %d2,-1
80010e5e:	3c fc       	j 80010e56 <__mdiff+0xba>
80010e60:	59 22 10 00 	st.w [%a2]16,%d2
80010e64:	00 90       	ret 

80010e66 <__d2b>:
80010e66:	20 08       	sub.a %sp,8
80010e68:	02 48       	mov %d8,%d4
80010e6a:	82 14       	mov %d4,1
80010e6c:	02 59       	mov %d9,%d5
80010e6e:	40 5d       	mov.aa %a13,%a5
80010e70:	40 6c       	mov.aa %a12,%a6
80010e72:	6d ff 7b fd 	call 80010968 <_Balloc>
80010e76:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
80010e7a:	37 09 6b 9a 	extr.u %d9,%d9,20,11
80010e7e:	40 2f       	mov.aa %a15,%a2
80010e80:	76 93       	jz %d9,80010e86 <__d2b+0x20>
80010e82:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
80010e86:	59 a2 04 00 	st.w [%sp]4,%d2
80010e8a:	df 08 20 00 	jeq %d8,0,80010eca <__d2b+0x64>
80010e8e:	d9 a4 08 00 	lea %a4,[%sp]8
80010e92:	89 48 38 f5 	st.w [+%a4]-8,%d8
80010e96:	40 a4       	mov.aa %a4,%sp
80010e98:	6d ff fe fd 	call 80010a94 <__lo0bits>
80010e9c:	58 00       	ld.w %d15,[%sp]0
80010e9e:	76 2f       	jz %d2,80010ebc <__d2b+0x56>
80010ea0:	19 a4 04 00 	ld.w %d4,[%sp]4
80010ea4:	8b 02 02 31 	rsub %d3,%d2,32
80010ea8:	0f 34 00 30 	sh %d3,%d4,%d3
80010eac:	a6 3f       	or %d15,%d3
80010eae:	68 5f       	st.w [%a15]20,%d15
80010eb0:	8b 02 00 f1 	rsub %d15,%d2,0
80010eb4:	0f f4 00 f0 	sh %d15,%d4,%d15
80010eb8:	78 01       	st.w [%sp]4,%d15
80010eba:	3c 02       	j 80010ebe <__d2b+0x58>
80010ebc:	68 5f       	st.w [%a15]20,%d15
80010ebe:	58 01       	ld.w %d15,[%sp]4
80010ec0:	82 28       	mov %d8,2
80010ec2:	ea 18       	cmovn %d8,%d15,1
80010ec4:	68 6f       	st.w [%a15]24,%d15
80010ec6:	68 48       	st.w [%a15]16,%d8
80010ec8:	3c 0c       	j 80010ee0 <__d2b+0x7a>
80010eca:	d9 a4 04 00 	lea %a4,[%sp]4
80010ece:	6d ff e3 fd 	call 80010a94 <__lo0bits>
80010ed2:	58 01       	ld.w %d15,[%sp]4
80010ed4:	1b 02 02 20 	addi %d2,%d2,32
80010ed8:	68 5f       	st.w [%a15]20,%d15
80010eda:	82 1f       	mov %d15,1
80010edc:	68 4f       	st.w [%a15]16,%d15
80010ede:	82 18       	mov %d8,1
80010ee0:	76 98       	jz %d9,80010ef0 <__d2b+0x8a>
80010ee2:	1b d9 bc 9f 	addi %d9,%d9,-1075
80010ee6:	42 29       	add %d9,%d2
80010ee8:	74 d9       	st.w [%a13],%d9
80010eea:	8b 52 03 21 	rsub %d2,%d2,53
80010eee:	3c 0d       	j 80010f08 <__d2b+0xa2>
80010ef0:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
80010ef4:	1b e2 bc 2f 	addi %d2,%d2,-1074
80010ef8:	74 d2       	st.w [%a13],%d2
80010efa:	19 24 10 00 	ld.w %d4,[%a2]16
80010efe:	6d ff aa fd 	call 80010a52 <__hi0bits>
80010f02:	06 58       	sh %d8,5
80010f04:	0b 28 80 20 	sub %d2,%d8,%d2
80010f08:	74 c2       	st.w [%a12],%d2
80010f0a:	40 f2       	mov.aa %a2,%a15
80010f0c:	00 90       	ret 

80010f0e <__fpclassifyd>:
80010f0e:	0f 45 a0 f0 	or %d15,%d5,%d4
80010f12:	82 22       	mov %d2,2
80010f14:	6e 1d       	jz %d15,80010f4e <__fpclassifyd+0x40>
80010f16:	7b 00 00 38 	movh %d3,32768
80010f1a:	3a 53       	eq %d15,%d3,%d5
80010f1c:	8b 04 00 f4 	and.eq %d15,%d4,0
80010f20:	8b 04 00 62 	eq %d6,%d4,0
80010f24:	ee 15       	jnz %d15,80010f4e <__fpclassifyd+0x40>
80010f26:	b7 05 81 5f 	insert %d5,%d5,0,31,1
80010f2a:	7b 00 fe f7 	movh %d15,32736
80010f2e:	9b 05 ff 3f 	addih %d3,%d5,65520
80010f32:	82 42       	mov %d2,4
80010f34:	3f f3 0d 80 	jlt.u %d3,%d15,80010f4e <__fpclassifyd+0x40>
80010f38:	7b 00 01 f0 	movh %d15,16
80010f3c:	82 32       	mov %d2,3
80010f3e:	3f f5 08 80 	jlt.u %d5,%d15,80010f4e <__fpclassifyd+0x40>
80010f42:	7b 00 ff 27 	movh %d2,32752
80010f46:	0b 25 00 51 	eq %d5,%d5,%d2
80010f4a:	0f 56 80 20 	and %d2,%d6,%d5
80010f4e:	00 90       	ret 

80010f50 <_sbrk_r>:
80010f50:	82 0f       	mov %d15,0
80010f52:	91 00 00 c7 	movh.a %a12,28672
80010f56:	59 cf 60 34 	st.w [%a12]17632 <700044e0 <errno>>,%d15
80010f5a:	40 4f       	mov.aa %a15,%a4
80010f5c:	6d 00 02 05 	call 80011960 <sbrk>
80010f60:	80 2f       	mov.d %d15,%a2
80010f62:	5e f5       	jne %d15,-1,80010f6c <_sbrk_r+0x1c>
80010f64:	19 cf 60 34 	ld.w %d15,[%a12]17632 <700044e0 <errno>>
80010f68:	6e 02       	jz %d15,80010f6c <_sbrk_r+0x1c>
80010f6a:	68 0f       	st.w [%a15]0,%d15
80010f6c:	00 90       	ret 

80010f6e <__ssprint_r>:
80010f6e:	4c 62       	ld.w %d15,[%a6]8
80010f70:	20 08       	sub.a %sp,8
80010f72:	40 4e       	mov.aa %a14,%a4
80010f74:	40 5f       	mov.aa %a15,%a5
80010f76:	40 6c       	mov.aa %a12,%a6
80010f78:	54 6c       	ld.w %d12,[%a6]
80010f7a:	6e 30       	jz %d15,80010fda <__ssprint_r+0x6c>
80010f7c:	a0 02       	mov.a %a2,0
80010f7e:	b5 a2 04 00 	st.a [%sp]4,%a2
80010f82:	82 09       	mov %d9,0
80010f84:	3b 00 48 e0 	mov %d14,1152
80010f88:	3b f0 b7 df 	mov %d13,-1153
80010f8c:	3c 0a       	j 80010fa0 <__ssprint_r+0x32>
80010f8e:	60 c2       	mov.a %a2,%d12
80010f90:	d4 22       	ld.a %a2,[%a2]
80010f92:	b5 a2 04 00 	st.a [%sp]4,%a2
80010f96:	60 c2       	mov.a %a2,%d12
80010f98:	1b 8c 00 c0 	addi %d12,%d12,8
80010f9c:	19 29 04 00 	ld.w %d9,[%a2]4
80010fa0:	df 09 f7 7f 	jeq %d9,0,80010f8e <__ssprint_r+0x20>
80010fa4:	48 28       	ld.w %d8,[%a15]8
80010fa6:	3f 89 5a 80 	jlt.u %d9,%d8,8001105a <__ssprint_r+0xec>
80010faa:	88 62       	ld.h %d2,[%a15]12
80010fac:	0f e2 80 f0 	and %d15,%d2,%d14
80010fb0:	ee 19       	jnz %d15,80010fe2 <__ssprint_r+0x74>
80010fb2:	3f 89 54 80 	jlt.u %d9,%d8,8001105a <__ssprint_r+0xec>
80010fb6:	c8 04       	ld.a %a4,[%a15]0
80010fb8:	99 a5 04 00 	ld.a %a5,[%sp]4 <0 <NULL>>
80010fbc:	02 84       	mov %d4,%d8
80010fbe:	6d 00 b4 01 	call 80011326 <memmove>
80010fc2:	4c f2       	ld.w %d15,[%a15]8
80010fc4:	a2 8f       	sub %d15,%d8
80010fc6:	68 2f       	st.w [%a15]8,%d15
80010fc8:	4c f0       	ld.w %d15,[%a15]0
80010fca:	42 f8       	add %d8,%d15
80010fcc:	4c c2       	ld.w %d15,[%a12]8
80010fce:	68 08       	st.w [%a15]0,%d8
80010fd0:	52 99       	sub %d9,%d15,%d9
80010fd2:	59 c9 08 00 	st.w [%a12]8,%d9
80010fd6:	df 09 dc ff 	jne %d9,0,80010f8e <__ssprint_r+0x20>
80010fda:	82 0f       	mov %d15,0
80010fdc:	6c c1       	st.w [%a12]4,%d15
80010fde:	82 02       	mov %d2,0
80010fe0:	00 90       	ret 
80010fe2:	c8 45       	ld.a %a5,[%a15]16
80010fe4:	48 5a       	ld.w %d10,[%a15]20
80010fe6:	4c f0       	ld.w %d15,[%a15]0
80010fe8:	80 53       	mov.d %d3,%a5
80010fea:	53 3a 20 a0 	mul %d10,%d10,3
80010fee:	a2 3f       	sub %d15,%d3
80010ff0:	82 23       	mov %d3,2
80010ff2:	4b 3a 01 a2 	div %e10,%d10,%d3
80010ff6:	92 13       	add %d3,%d15,1
80010ff8:	42 93       	add %d3,%d9
80010ffa:	0b 3a b0 a1 	max.u %d10,%d10,%d3
80010ffe:	40 e4       	mov.aa %a4,%a14
80011000:	02 a4       	mov %d4,%d10
80011002:	6f a2 12 00 	jz.t %d2,10,80011026 <__ssprint_r+0xb8>
80011006:	6d ff 48 fa 	call 80010496 <_malloc_r>
8001100a:	40 2d       	mov.aa %a13,%a2
8001100c:	bd 02 15 00 	jz.a %a2,80011036 <__ssprint_r+0xc8>
80011010:	c8 45       	ld.a %a5,[%a15]16
80011012:	40 24       	mov.aa %a4,%a2
80011014:	02 f4       	mov %d4,%d15
80011016:	6d ff 99 fc 	call 80010948 <memcpy>
8001101a:	88 62       	ld.h %d2,[%a15]12
8001101c:	26 d2       	and %d2,%d13
8001101e:	8f 02 48 21 	or %d2,%d2,128
80011022:	a8 62       	st.h [%a15]12,%d2
80011024:	3c 13       	j 8001104a <__ssprint_r+0xdc>
80011026:	6d 00 b0 01 	call 80011386 <_realloc_r>
8001102a:	40 2d       	mov.aa %a13,%a2
8001102c:	7c 2f       	jnz.a %a2,8001104a <__ssprint_r+0xdc>
8001102e:	c8 45       	ld.a %a5,[%a15]16
80011030:	40 e4       	mov.aa %a4,%a14
80011032:	6d 00 a4 00 	call 8001117a <_free_r>
80011036:	da 0c       	mov %d15,12
80011038:	6c e0       	st.w [%a14]0,%d15
8001103a:	8c f6       	ld.h %d15,[%a15]12
8001103c:	82 f2       	mov %d2,-1
8001103e:	96 40       	or %d15,64
80011040:	a8 6f       	st.h [%a15]12,%d15
80011042:	82 0f       	mov %d15,0
80011044:	6c c2       	st.w [%a12]8,%d15
80011046:	6c c1       	st.w [%a12]4,%d15
80011048:	00 90       	ret 
8001104a:	e8 4d       	st.a [%a15]16,%a13
8001104c:	10 dd       	addsc.a %a13,%a13,%d15,0
8001104e:	68 5a       	st.w [%a15]20,%d10
80011050:	a2 fa       	sub %d10,%d15
80011052:	e8 0d       	st.a [%a15]0,%a13
80011054:	02 98       	mov %d8,%d9
80011056:	68 2a       	st.w [%a15]8,%d10
80011058:	3c ad       	j 80010fb2 <__ssprint_r+0x44>
8001105a:	02 98       	mov %d8,%d9
8001105c:	3c ad       	j 80010fb6 <__ssprint_r+0x48>

8001105e <_calloc_r>:
8001105e:	e2 54       	mul %d4,%d5
80011060:	6d ff 1b fa 	call 80010496 <_malloc_r>
80011064:	40 2f       	mov.aa %a15,%a2
80011066:	a0 02       	mov.a %a2,0
80011068:	bd 0f 2b 00 	jz.a %a15,800110be <_calloc_r+0x60>
8001106c:	19 f5 fc ff 	ld.w %d5,[%a15]-4
80011070:	8f 35 c0 51 	andn %d5,%d5,3
80011074:	c2 c5       	add %d5,-4
80011076:	8b 55 a2 f2 	ge.u %d15,%d5,37
8001107a:	ee 1d       	jnz %d15,800110b4 <_calloc_r+0x56>
8001107c:	8b 45 61 f2 	lt.u %d15,%d5,20
80011080:	40 f2       	mov.aa %a2,%a15
80011082:	ee 14       	jnz %d15,800110aa <_calloc_r+0x4c>
80011084:	82 0f       	mov %d15,0
80011086:	68 0f       	st.w [%a15]0,%d15
80011088:	68 1f       	st.w [%a15]4,%d15
8001108a:	8b c5 a1 22 	ge.u %d2,%d5,28
8001108e:	d9 f2 08 00 	lea %a2,[%a15]8
80011092:	76 2c       	jz %d2,800110aa <_calloc_r+0x4c>
80011094:	68 2f       	st.w [%a15]8,%d15
80011096:	68 3f       	st.w [%a15]12,%d15
80011098:	8b 45 02 52 	eq %d5,%d5,36
8001109c:	d9 f2 10 00 	lea %a2,[%a15]16
800110a0:	76 55       	jz %d5,800110aa <_calloc_r+0x4c>
800110a2:	68 4f       	st.w [%a15]16,%d15
800110a4:	d9 f2 18 00 	lea %a2,[%a15]24
800110a8:	68 5f       	st.w [%a15]20,%d15
800110aa:	82 0f       	mov %d15,0
800110ac:	6c 20       	st.w [%a2]0,%d15
800110ae:	6c 21       	st.w [%a2]4,%d15
800110b0:	6c 22       	st.w [%a2]8,%d15
800110b2:	3c 05       	j 800110bc <_calloc_r+0x5e>
800110b4:	40 f4       	mov.aa %a4,%a15
800110b6:	82 04       	mov %d4,0
800110b8:	6d 00 5f 01 	call 80011376 <memset>
800110bc:	40 f2       	mov.aa %a2,%a15
800110be:	00 90       	ret 

800110c0 <_malloc_trim_r>:
800110c0:	02 4f       	mov %d15,%d4
800110c2:	40 4f       	mov.aa %a15,%a4
800110c4:	6d ff 50 fc 	call 80010964 <__malloc_lock>
800110c8:	91 00 00 c7 	movh.a %a12,28672
800110cc:	d9 cc 48 61 	lea %a12,[%a12]5512 <70001588 <__malloc_av_>>
800110d0:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <__DSPR0_START+0x8>>
800110d4:	3b 00 00 21 	mov %d2,4096
800110d8:	19 28 04 00 	ld.w %d8,[%a2]4
800110dc:	8f 38 c0 81 	andn %d8,%d8,3
800110e0:	5a f8       	sub %d15,%d8,%d15
800110e2:	1b ff fe f0 	addi %d15,%d15,4079
800110e6:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
800110ea:	1b 0f 00 ff 	addi %d15,%d15,-4096
800110ee:	7f 2f 07 00 	jge %d15,%d2,800110fc <_malloc_trim_r+0x3c>
800110f2:	40 f4       	mov.aa %a4,%a15
800110f4:	6d ff 39 fc 	call 80010966 <__malloc_unlock>
800110f8:	82 02       	mov %d2,0
800110fa:	00 90       	ret 
800110fc:	40 f4       	mov.aa %a4,%a15
800110fe:	82 04       	mov %d4,0
80011100:	6d ff 28 ff 	call 80010f50 <_sbrk_r>
80011104:	99 c3 08 00 	ld.a %a3,[%a12]8
80011108:	60 84       	mov.a %a4,%d8
8001110a:	30 43       	add.a %a3,%a4
8001110c:	7d 32 f3 ff 	jne.a %a2,%a3,800110f2 <_malloc_trim_r+0x32>
80011110:	40 f4       	mov.aa %a4,%a15
80011112:	8b 0f 00 41 	rsub %d4,%d15,0
80011116:	6d ff 1d ff 	call 80010f50 <_sbrk_r>
8001111a:	80 22       	mov.d %d2,%a2
8001111c:	df f2 1c 80 	jne %d2,-1,80011154 <_malloc_trim_r+0x94>
80011120:	40 f4       	mov.aa %a4,%a15
80011122:	82 04       	mov %d4,0
80011124:	6d ff 16 ff 	call 80010f50 <_sbrk_r>
80011128:	99 c3 08 00 	ld.a %a3,[%a12]8
8001112c:	01 32 20 40 	sub.a %a4,%a2,%a3
80011130:	80 4f       	mov.d %d15,%a4
80011132:	8b 0f 41 22 	lt %d2,%d15,16
80011136:	df 02 de ff 	jne %d2,0,800110f2 <_malloc_trim_r+0x32>
8001113a:	91 00 00 47 	movh.a %a4,28672
8001113e:	99 44 40 61 	ld.a %a4,[%a4]5504 <70001580 <__malloc_sbrk_base>>
80011142:	96 01       	or %d15,1
80011144:	6c 31       	st.w [%a3]4,%d15
80011146:	01 42 20 20 	sub.a %a2,%a2,%a4
8001114a:	91 00 00 47 	movh.a %a4,28672
8001114e:	b5 42 68 24 	st.a [%a4]17576 <700044a8 <__malloc_current_mallinfo>>,%a2
80011152:	3c d0       	j 800110f2 <_malloc_trim_r+0x32>
80011154:	99 c2 08 00 	ld.a %a2,[%a12]8
80011158:	a2 f8       	sub %d8,%d15
8001115a:	8f 18 40 81 	or %d8,%d8,1
8001115e:	59 28 04 00 	st.w [%a2]4,%d8
80011162:	91 00 00 27 	movh.a %a2,28672
80011166:	19 22 68 24 	ld.w %d2,[%a2]17576 <700044a8 <__malloc_current_mallinfo>>
8001116a:	40 f4       	mov.aa %a4,%a15
8001116c:	5a f2       	sub %d15,%d2,%d15
8001116e:	59 2f 68 24 	st.w [%a2]17576 <700044a8 <__malloc_current_mallinfo>>,%d15
80011172:	6d ff fa fb 	call 80010966 <__malloc_unlock>
80011176:	82 12       	mov %d2,1
80011178:	00 90       	ret 

8001117a <_free_r>:
8001117a:	40 4d       	mov.aa %a13,%a4
8001117c:	bd 05 d4 00 	jz.a %a5,80011324 <_free_r+0x1aa>
80011180:	40 5c       	mov.aa %a12,%a5
80011182:	6d ff f1 fb 	call 80010964 <__malloc_lock>
80011186:	19 c4 fc ff 	ld.w %d4,[%a12]-4
8001118a:	d9 cf f8 ff 	lea %a15,[%a12]-8
8001118e:	8f 14 c0 f1 	andn %d15,%d4,1
80011192:	91 00 00 27 	movh.a %a2,28672
80011196:	10 f3       	addsc.a %a3,%a15,%d15,0
80011198:	d9 22 48 61 	lea %a2,[%a2]5512 <70001588 <__malloc_av_>>
8001119c:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <__DSPR0_START+0x8>>
800111a0:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <__DSPR0_START+0x8>>
800111a4:	8f 14 00 41 	and %d4,%d4,1
800111a8:	8f 33 c0 31 	andn %d3,%d3,3
800111ac:	7d 43 24 80 	jne.a %a3,%a4,800111f4 <_free_r+0x7a>
800111b0:	42 3f       	add %d15,%d3
800111b2:	f6 4d       	jnz %d4,800111cc <_free_r+0x52>
800111b4:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
800111b8:	60 23       	mov.a %a3,%d2
800111ba:	42 2f       	add %d15,%d2
800111bc:	01 3f 20 f0 	sub.a %a15,%a15,%a3
800111c0:	c8 33       	ld.a %a3,[%a15]12
800111c2:	c8 24       	ld.a %a4,[%a15]8
800111c4:	b5 43 0c 00 	st.a [%a4]12,%a3
800111c8:	b5 34 08 00 	st.a [%a3]8,%a4
800111cc:	8f 1f 40 21 	or %d2,%d15,1
800111d0:	68 12       	st.w [%a15]4,%d2
800111d2:	ec 22       	st.a [%a2]8,%a15
800111d4:	91 00 00 f7 	movh.a %a15,28672
800111d8:	19 f2 44 61 	ld.w %d2,[%a15]5508 <70001584 <__malloc_trim_threshold>>
800111dc:	3f 2f 09 80 	jlt.u %d15,%d2,800111ee <_free_r+0x74>
800111e0:	91 00 00 f7 	movh.a %a15,28672
800111e4:	40 d4       	mov.aa %a4,%a13
800111e6:	19 f4 58 34 	ld.w %d4,[%a15]17624 <700044d8 <__malloc_top_pad>>
800111ea:	6d ff 6b ff 	call 800110c0 <_malloc_trim_r>
800111ee:	40 d4       	mov.aa %a4,%a13
800111f0:	1d ff bb fb 	j 80010966 <__malloc_unlock>
800111f4:	59 33 04 00 	st.w [%a3]4,%d3
800111f8:	82 02       	mov %d2,0
800111fa:	df 04 16 80 	jne %d4,0,80011226 <_free_r+0xac>
800111fe:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
80011202:	60 24       	mov.a %a4,%d2
80011204:	42 2f       	add %d15,%d2
80011206:	01 4f 20 f0 	sub.a %a15,%a15,%a4
8001120a:	c8 25       	ld.a %a5,[%a15]8
8001120c:	91 00 00 47 	movh.a %a4,28672
80011210:	d9 44 50 61 	lea %a4,[%a4]5520 <70001590 <__malloc_av_+0x8>>
80011214:	82 12       	mov %d2,1
80011216:	7d 45 08 00 	jeq.a %a5,%a4,80011226 <_free_r+0xac>
8001121a:	c8 34       	ld.a %a4,[%a15]12
8001121c:	82 02       	mov %d2,0
8001121e:	b5 54 0c 00 	st.a [%a5]12,%a4
80011222:	b5 45 08 00 	st.a [%a4]8,%a5
80011226:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
8001122a:	19 44 04 00 	ld.w %d4,[%a4]4
8001122e:	6f 04 18 80 	jnz.t %d4,0,8001125e <_free_r+0xe4>
80011232:	42 3f       	add %d15,%d3
80011234:	99 35 08 00 	ld.a %a5,[%a3]8
80011238:	f6 2d       	jnz %d2,80011252 <_free_r+0xd8>
8001123a:	91 00 00 47 	movh.a %a4,28672
8001123e:	d9 44 50 61 	lea %a4,[%a4]5520 <70001590 <__malloc_av_+0x8>>
80011242:	7d 45 08 80 	jne.a %a5,%a4,80011252 <_free_r+0xd8>
80011246:	ec 25       	st.a [%a2]20,%a15
80011248:	ec 24       	st.a [%a2]16,%a15
8001124a:	e8 35       	st.a [%a15]12,%a5
8001124c:	e8 25       	st.a [%a15]8,%a5
8001124e:	82 12       	mov %d2,1
80011250:	3c 07       	j 8001125e <_free_r+0xe4>
80011252:	99 33 0c 00 	ld.a %a3,[%a3]12
80011256:	b5 53 0c 00 	st.a [%a5]12,%a3
8001125a:	b5 35 08 00 	st.a [%a3]8,%a5
8001125e:	8f 1f 40 31 	or %d3,%d15,1
80011262:	10 f3       	addsc.a %a3,%a15,%d15,0
80011264:	68 13       	st.w [%a15]4,%d3
80011266:	6c 30       	st.w [%a3]0,%d15
80011268:	df 02 c3 ff 	jne %d2,0,800111ee <_free_r+0x74>
8001126c:	3b 00 20 20 	mov %d2,512
80011270:	7f 2f 12 80 	jge.u %d15,%d2,80011294 <_free_r+0x11a>
80011274:	19 23 04 00 	ld.w %d3,[%a2]4
80011278:	06 df       	sh %d15,-3
8001127a:	8f ef 3f 20 	sha %d2,%d15,-2
8001127e:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80011282:	59 22 04 00 	st.w [%a2]4,%d2
80011286:	d0 22       	addsc.a %a2,%a2,%d15,3
80011288:	99 23 08 00 	ld.a %a3,[%a2]8
8001128c:	e8 32       	st.a [%a15]12,%a2
8001128e:	e8 23       	st.a [%a15]8,%a3
80011290:	ec 22       	st.a [%a2]8,%a15
80011292:	3c 46       	j 8001131e <_free_r+0x1a4>
80011294:	8f af 1f 30 	sh %d3,%d15,-6
80011298:	8f 7f 1f 20 	sh %d2,%d15,-9
8001129c:	1b 83 03 30 	addi %d3,%d3,56
800112a0:	bf 52 22 80 	jlt.u %d2,5,800112e4 <_free_r+0x16a>
800112a4:	8b 52 a1 32 	ge.u %d3,%d2,21
800112a8:	f6 34       	jnz %d3,800112b0 <_free_r+0x136>
800112aa:	1b b2 05 30 	addi %d3,%d2,91
800112ae:	3c 1b       	j 800112e4 <_free_r+0x16a>
800112b0:	8b 52 a5 32 	ge.u %d3,%d2,85
800112b4:	f6 36       	jnz %d3,800112c0 <_free_r+0x146>
800112b6:	8f 4f 1f 30 	sh %d3,%d15,-12
800112ba:	1b e3 06 30 	addi %d3,%d3,110
800112be:	3c 13       	j 800112e4 <_free_r+0x16a>
800112c0:	8b 52 b5 32 	ge.u %d3,%d2,341
800112c4:	f6 36       	jnz %d3,800112d0 <_free_r+0x156>
800112c6:	8f 1f 1f 30 	sh %d3,%d15,-15
800112ca:	1b 73 07 30 	addi %d3,%d3,119
800112ce:	3c 0b       	j 800112e4 <_free_r+0x16a>
800112d0:	3b 50 55 40 	mov %d4,1365
800112d4:	3b e0 07 30 	mov %d3,126
800112d8:	7f 42 06 80 	jge.u %d2,%d4,800112e4 <_free_r+0x16a>
800112dc:	8f ef 1e 30 	sh %d3,%d15,-18
800112e0:	1b c3 07 30 	addi %d3,%d3,124
800112e4:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
800112e8:	99 65 08 00 	ld.a %a5,[%a6]8
800112ec:	40 53       	mov.aa %a3,%a5
800112ee:	7d 65 0d 80 	jne.a %a5,%a6,80011308 <_free_r+0x18e>
800112f2:	4c 21       	ld.w %d15,[%a2]4
800112f4:	86 e3       	sha %d3,-2
800112f6:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
800112fa:	59 23 04 00 	st.w [%a2]4,%d3
800112fe:	3c 0d       	j 80011318 <_free_r+0x19e>
80011300:	99 33 08 00 	ld.a %a3,[%a3]8
80011304:	7d 63 08 00 	jeq.a %a3,%a6,80011314 <_free_r+0x19a>
80011308:	19 32 04 00 	ld.w %d2,[%a3]4
8001130c:	8f 32 c0 21 	andn %d2,%d2,3
80011310:	3f 2f f8 ff 	jlt.u %d15,%d2,80011300 <_free_r+0x186>
80011314:	99 35 0c 00 	ld.a %a5,[%a3]12
80011318:	e8 35       	st.a [%a15]12,%a5
8001131a:	e8 23       	st.a [%a15]8,%a3
8001131c:	ec 52       	st.a [%a5]8,%a15
8001131e:	ec 33       	st.a [%a3]12,%a15
80011320:	1d ff 67 ff 	j 800111ee <_free_r+0x74>
80011324:	00 90       	ret 

80011326 <memmove>:
80011326:	80 46       	mov.d %d6,%a4
80011328:	80 52       	mov.d %d2,%a5
8001132a:	7f 62 16 80 	jge.u %d2,%d6,80011356 <memmove+0x30>
8001132e:	0b 42 00 50 	add %d5,%d2,%d4
80011332:	7f 56 12 80 	jge.u %d6,%d5,80011356 <memmove+0x30>
80011336:	60 4f       	mov.a %a15,%d4
80011338:	02 42       	mov %d2,%d4
8001133a:	c2 f2       	add %d2,-1
8001133c:	fd f0 03 00 	loop %a15,80011342 <memmove+0x1c>
80011340:	3c 19       	j 80011372 <memmove+0x4c>
80011342:	5a 42       	sub %d15,%d2,%d4
80011344:	60 f2       	mov.a %a2,%d15
80011346:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
8001134a:	1a 62       	add %d15,%d2,%d6
8001134c:	79 23 00 00 	ld.b %d3,[%a2]0
80011350:	60 f2       	mov.a %a2,%d15
80011352:	34 23       	st.b [%a2],%d3
80011354:	3c f3       	j 8001133a <memmove+0x14>
80011356:	60 4f       	mov.a %a15,%d4
80011358:	a0 02       	mov.a %a2,0
8001135a:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
8001135e:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
80011362:	fd f0 03 00 	loop %a15,80011368 <memmove+0x42>
80011366:	3c 06       	j 80011372 <memmove+0x4c>
80011368:	79 33 00 00 	ld.b %d3,[%a3]0
8001136c:	b0 12       	add.a %a2,1
8001136e:	34 43       	st.b [%a4],%d3
80011370:	3c f5       	j 8001135a <memmove+0x34>
80011372:	60 62       	mov.a %a2,%d6
80011374:	00 90       	ret 

80011376 <memset>:
80011376:	40 42       	mov.aa %a2,%a4
80011378:	40 4f       	mov.aa %a15,%a4
8001137a:	9f 05 03 80 	jned %d5,0,80011380 <memset+0xa>
8001137e:	00 90       	ret 
80011380:	28 04       	st.b [%a15]0,%d4
80011382:	b0 1f       	add.a %a15,1
80011384:	3c fb       	j 8001137a <memset+0x4>

80011386 <_realloc_r>:
80011386:	40 4d       	mov.aa %a13,%a4
80011388:	40 5f       	mov.aa %a15,%a5
8001138a:	02 49       	mov %d9,%d4
8001138c:	7c 53       	jnz.a %a5,80011392 <_realloc_r+0xc>
8001138e:	1d ff 84 f8 	j 80010496 <_malloc_r>
80011392:	6d ff e9 fa 	call 80010964 <__malloc_lock>
80011396:	1b b9 00 20 	addi %d2,%d9,11
8001139a:	8b 72 61 f2 	lt.u %d15,%d2,23
8001139e:	8f 72 c0 21 	andn %d2,%d2,7
800113a2:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
800113a6:	19 f3 fc ff 	ld.w %d3,[%a15]-4
800113aa:	0b 9f 30 21 	lt.u %d2,%d15,%d9
800113ae:	8b 0f 20 25 	or.lt %d2,%d15,0
800113b2:	d9 fe f8 ff 	lea %a14,[%a15]-8
800113b6:	8f 33 c0 81 	andn %d8,%d3,3
800113ba:	76 25       	jz %d2,800113c4 <_realloc_r+0x3e>
800113bc:	da 0c       	mov %d15,12
800113be:	6c d0       	st.w [%a13]0,%d15
800113c0:	1d 00 56 01 	j 8001166c <_realloc_r+0x2e6>
800113c4:	7f f8 ac 01 	jge %d8,%d15,8001171c <_realloc_r+0x396>
800113c8:	7b 00 00 c7 	movh %d12,28672
800113cc:	60 c3       	mov.a %a3,%d12
800113ce:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
800113d2:	d9 34 48 61 	lea %a4,[%a3]5512
800113d6:	99 43 08 00 	ld.a %a3,[%a4]8
800113da:	80 4c       	mov.d %d12,%a4
800113dc:	19 2b 04 00 	ld.w %d11,[%a2]4
800113e0:	7d 32 0a 00 	jeq.a %a2,%a3,800113f4 <_realloc_r+0x6e>
800113e4:	8f 1b c0 21 	andn %d2,%d11,1
800113e8:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
800113ec:	19 42 04 00 	ld.w %d2,[%a4]4
800113f0:	6f 02 2b 80 	jnz.t %d2,0,80011446 <_realloc_r+0xc0>
800113f4:	8f 3b c0 b1 	andn %d11,%d11,3
800113f8:	0b 8b 00 20 	add %d2,%d11,%d8
800113fc:	7d 32 1b 80 	jne.a %a2,%a3,80011432 <_realloc_r+0xac>
80011400:	1b 0f 01 40 	addi %d4,%d15,16
80011404:	3f 42 23 00 	jlt %d2,%d4,8001144a <_realloc_r+0xc4>
80011408:	10 ee       	addsc.a %a14,%a14,%d15,0
8001140a:	60 c2       	mov.a %a2,%d12
8001140c:	a2 f2       	sub %d2,%d15
8001140e:	b5 2e 08 00 	st.a [%a2]8,%a14
80011412:	8f 12 40 21 	or %d2,%d2,1
80011416:	59 e2 04 00 	st.w [%a14]4,%d2
8001141a:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8001141e:	40 d4       	mov.aa %a4,%a13
80011420:	8f 12 00 21 	and %d2,%d2,1
80011424:	a6 2f       	or %d15,%d2
80011426:	59 ff fc ff 	st.w [%a15]-4,%d15
8001142a:	6d ff 9e fa 	call 80010966 <__malloc_unlock>
8001142e:	40 f2       	mov.aa %a2,%a15
80011430:	00 90       	ret 
80011432:	3f f2 0c 00 	jlt %d2,%d15,8001144a <_realloc_r+0xc4>
80011436:	cc 23       	ld.a %a15,[%a2]12
80011438:	99 22 08 00 	ld.a %a2,[%a2]8
8001143c:	02 28       	mov %d8,%d2
8001143e:	ec 23       	st.a [%a2]12,%a15
80011440:	e8 22       	st.a [%a15]8,%a2
80011442:	1d 00 6d 01 	j 8001171c <_realloc_r+0x396>
80011446:	82 0b       	mov %d11,0
80011448:	a0 02       	mov.a %a2,0
8001144a:	6f 03 08 81 	jnz.t %d3,0,8001165a <_realloc_r+0x2d4>
8001144e:	99 fc f8 ff 	ld.a %a12,[%a15]-8
80011452:	01 ce 20 c0 	sub.a %a12,%a14,%a12
80011456:	19 ca 04 00 	ld.w %d10,[%a12]4
8001145a:	8f 3a c0 a1 	andn %d10,%d10,3
8001145e:	42 8a       	add %d10,%d8
80011460:	bd 02 b3 00 	jz.a %a2,800115c6 <_realloc_r+0x240>
80011464:	42 ab       	add %d11,%d10
80011466:	7d 32 5f 80 	jne.a %a2,%a3,80011524 <_realloc_r+0x19e>
8001146a:	1b 0f 01 20 	addi %d2,%d15,16
8001146e:	3f 2b ac 00 	jlt %d11,%d2,800115c6 <_realloc_r+0x240>
80011472:	40 ce       	mov.aa %a14,%a12
80011474:	99 c2 0c 00 	ld.a %a2,[%a12]12
80011478:	09 e3 88 05 	ld.a %a3,[+%a14]8
8001147c:	1b c8 ff 4f 	addi %d4,%d8,-4
80011480:	8b 54 a2 22 	ge.u %d2,%d4,37
80011484:	b5 32 0c 00 	st.a [%a3]12,%a2
80011488:	b5 23 08 00 	st.a [%a2]8,%a3
8001148c:	df 02 36 80 	jne %d2,0,800114f8 <_realloc_r+0x172>
80011490:	8b 44 61 22 	lt.u %d2,%d4,20
80011494:	40 e3       	mov.aa %a3,%a14
80011496:	df 02 28 80 	jne %d2,0,800114e6 <_realloc_r+0x160>
8001149a:	48 02       	ld.w %d2,[%a15]0
8001149c:	59 c2 08 00 	st.w [%a12]8,%d2
800114a0:	48 13       	ld.w %d3,[%a15]4
800114a2:	8b c4 a1 22 	ge.u %d2,%d4,28
800114a6:	59 c3 0c 00 	st.w [%a12]12,%d3
800114aa:	f6 26       	jnz %d2,800114b6 <_realloc_r+0x130>
800114ac:	d9 c3 10 00 	lea %a3,[%a12]16
800114b0:	d9 ff 08 00 	lea %a15,[%a15]8
800114b4:	3c 19       	j 800114e6 <_realloc_r+0x160>
800114b6:	48 22       	ld.w %d2,[%a15]8
800114b8:	8b 44 02 82 	eq %d8,%d4,36
800114bc:	59 c2 10 00 	st.w [%a12]16,%d2
800114c0:	48 33       	ld.w %d3,[%a15]12
800114c2:	59 c3 14 00 	st.w [%a12]20,%d3
800114c6:	f6 86       	jnz %d8,800114d2 <_realloc_r+0x14c>
800114c8:	d9 c3 18 00 	lea %a3,[%a12]24
800114cc:	d9 ff 10 00 	lea %a15,[%a15]16
800114d0:	3c 0b       	j 800114e6 <_realloc_r+0x160>
800114d2:	48 42       	ld.w %d2,[%a15]16
800114d4:	d9 c3 20 00 	lea %a3,[%a12]32
800114d8:	59 c2 18 00 	st.w [%a12]24,%d2
800114dc:	48 53       	ld.w %d3,[%a15]20
800114de:	d9 ff 18 00 	lea %a15,[%a15]24
800114e2:	59 c3 1c 00 	st.w [%a12]28,%d3
800114e6:	48 02       	ld.w %d2,[%a15]0
800114e8:	74 32       	st.w [%a3],%d2
800114ea:	48 13       	ld.w %d3,[%a15]4
800114ec:	59 33 04 00 	st.w [%a3]4,%d3
800114f0:	48 22       	ld.w %d2,[%a15]8
800114f2:	59 32 08 00 	st.w [%a3]8,%d2
800114f6:	3c 05       	j 80011500 <_realloc_r+0x17a>
800114f8:	40 e4       	mov.aa %a4,%a14
800114fa:	40 f5       	mov.aa %a5,%a15
800114fc:	6d ff 15 ff 	call 80011326 <memmove>
80011500:	10 cf       	addsc.a %a15,%a12,%d15,0
80011502:	60 c2       	mov.a %a2,%d12
80011504:	a2 fb       	sub %d11,%d15
80011506:	ec 22       	st.a [%a2]8,%a15
80011508:	8f 1b 40 b1 	or %d11,%d11,1
8001150c:	68 1b       	st.w [%a15]4,%d11
8001150e:	19 c2 04 00 	ld.w %d2,[%a12]4
80011512:	40 d4       	mov.aa %a4,%a13
80011514:	8f 12 00 21 	and %d2,%d2,1
80011518:	a6 2f       	or %d15,%d2
8001151a:	6c c1       	st.w [%a12]4,%d15
8001151c:	6d ff 25 fa 	call 80010966 <__malloc_unlock>
80011520:	40 e2       	mov.aa %a2,%a14
80011522:	00 90       	ret 
80011524:	3f fb 51 00 	jlt %d11,%d15,800115c6 <_realloc_r+0x240>
80011528:	99 23 0c 00 	ld.a %a3,[%a2]12
8001152c:	99 22 08 00 	ld.a %a2,[%a2]8
80011530:	40 c4       	mov.aa %a4,%a12
80011532:	1b c8 ff 4f 	addi %d4,%d8,-4
80011536:	b5 23 0c 00 	st.a [%a2]12,%a3
8001153a:	b5 32 08 00 	st.a [%a3]8,%a2
8001153e:	09 43 88 05 	ld.a %a3,[+%a4]8
80011542:	99 c2 0c 00 	ld.a %a2,[%a12]12
80011546:	8b 54 a2 22 	ge.u %d2,%d4,37
8001154a:	b5 32 0c 00 	st.a [%a3]12,%a2
8001154e:	b5 23 08 00 	st.a [%a2]8,%a3
80011552:	df 02 35 80 	jne %d2,0,800115bc <_realloc_r+0x236>
80011556:	8b 44 61 22 	lt.u %d2,%d4,20
8001155a:	df 02 28 80 	jne %d2,0,800115aa <_realloc_r+0x224>
8001155e:	48 02       	ld.w %d2,[%a15]0
80011560:	59 c2 08 00 	st.w [%a12]8,%d2
80011564:	48 13       	ld.w %d3,[%a15]4
80011566:	8b c4 a1 22 	ge.u %d2,%d4,28
8001156a:	59 c3 0c 00 	st.w [%a12]12,%d3
8001156e:	f6 26       	jnz %d2,8001157a <_realloc_r+0x1f4>
80011570:	d9 c4 10 00 	lea %a4,[%a12]16
80011574:	d9 ff 08 00 	lea %a15,[%a15]8
80011578:	3c 19       	j 800115aa <_realloc_r+0x224>
8001157a:	48 22       	ld.w %d2,[%a15]8
8001157c:	8b 44 02 82 	eq %d8,%d4,36
80011580:	59 c2 10 00 	st.w [%a12]16,%d2
80011584:	48 33       	ld.w %d3,[%a15]12
80011586:	59 c3 14 00 	st.w [%a12]20,%d3
8001158a:	f6 86       	jnz %d8,80011596 <_realloc_r+0x210>
8001158c:	d9 c4 18 00 	lea %a4,[%a12]24
80011590:	d9 ff 10 00 	lea %a15,[%a15]16
80011594:	3c 0b       	j 800115aa <_realloc_r+0x224>
80011596:	48 42       	ld.w %d2,[%a15]16
80011598:	d9 c4 20 00 	lea %a4,[%a12]32
8001159c:	59 c2 18 00 	st.w [%a12]24,%d2
800115a0:	48 53       	ld.w %d3,[%a15]20
800115a2:	d9 ff 18 00 	lea %a15,[%a15]24
800115a6:	59 c3 1c 00 	st.w [%a12]28,%d3
800115aa:	48 02       	ld.w %d2,[%a15]0
800115ac:	74 42       	st.w [%a4],%d2
800115ae:	48 13       	ld.w %d3,[%a15]4
800115b0:	59 43 04 00 	st.w [%a4]4,%d3
800115b4:	48 22       	ld.w %d2,[%a15]8
800115b6:	59 42 08 00 	st.w [%a4]8,%d2
800115ba:	3c 04       	j 800115c2 <_realloc_r+0x23c>
800115bc:	40 f5       	mov.aa %a5,%a15
800115be:	6d ff b4 fe 	call 80011326 <memmove>
800115c2:	02 b8       	mov %d8,%d11
800115c4:	3c 45       	j 8001164e <_realloc_r+0x2c8>
800115c6:	3f fa 4a 00 	jlt %d10,%d15,8001165a <_realloc_r+0x2d4>
800115ca:	40 c4       	mov.aa %a4,%a12
800115cc:	99 c2 0c 00 	ld.a %a2,[%a12]12
800115d0:	09 43 88 05 	ld.a %a3,[+%a4]8
800115d4:	1b c8 ff 4f 	addi %d4,%d8,-4
800115d8:	8b 54 a2 22 	ge.u %d2,%d4,37
800115dc:	b5 32 0c 00 	st.a [%a3]12,%a2
800115e0:	b5 23 08 00 	st.a [%a2]8,%a3
800115e4:	df 02 37 80 	jne %d2,0,80011652 <_realloc_r+0x2cc>
800115e8:	8b 44 61 22 	lt.u %d2,%d4,20
800115ec:	df 02 28 80 	jne %d2,0,8001163c <_realloc_r+0x2b6>
800115f0:	48 03       	ld.w %d3,[%a15]0
800115f2:	59 c3 08 00 	st.w [%a12]8,%d3
800115f6:	48 12       	ld.w %d2,[%a15]4
800115f8:	59 c2 0c 00 	st.w [%a12]12,%d2
800115fc:	8b c4 a1 22 	ge.u %d2,%d4,28
80011600:	f6 26       	jnz %d2,8001160c <_realloc_r+0x286>
80011602:	d9 c4 10 00 	lea %a4,[%a12]16
80011606:	d9 ff 08 00 	lea %a15,[%a15]8
8001160a:	3c 19       	j 8001163c <_realloc_r+0x2b6>
8001160c:	48 23       	ld.w %d3,[%a15]8
8001160e:	8b 44 02 82 	eq %d8,%d4,36
80011612:	59 c3 10 00 	st.w [%a12]16,%d3
80011616:	48 32       	ld.w %d2,[%a15]12
80011618:	59 c2 14 00 	st.w [%a12]20,%d2
8001161c:	f6 86       	jnz %d8,80011628 <_realloc_r+0x2a2>
8001161e:	d9 c4 18 00 	lea %a4,[%a12]24
80011622:	d9 ff 10 00 	lea %a15,[%a15]16
80011626:	3c 0b       	j 8001163c <_realloc_r+0x2b6>
80011628:	48 43       	ld.w %d3,[%a15]16
8001162a:	d9 c4 20 00 	lea %a4,[%a12]32
8001162e:	59 c3 18 00 	st.w [%a12]24,%d3
80011632:	48 52       	ld.w %d2,[%a15]20
80011634:	d9 ff 18 00 	lea %a15,[%a15]24
80011638:	59 c2 1c 00 	st.w [%a12]28,%d2
8001163c:	48 03       	ld.w %d3,[%a15]0
8001163e:	74 43       	st.w [%a4],%d3
80011640:	48 12       	ld.w %d2,[%a15]4
80011642:	59 42 04 00 	st.w [%a4]4,%d2
80011646:	48 23       	ld.w %d3,[%a15]8
80011648:	59 43 08 00 	st.w [%a4]8,%d3
8001164c:	02 a8       	mov %d8,%d10
8001164e:	40 ce       	mov.aa %a14,%a12
80011650:	3c 66       	j 8001171c <_realloc_r+0x396>
80011652:	40 f5       	mov.aa %a5,%a15
80011654:	6d ff 69 fe 	call 80011326 <memmove>
80011658:	3c fa       	j 8001164c <_realloc_r+0x2c6>
8001165a:	40 d4       	mov.aa %a4,%a13
8001165c:	02 94       	mov %d4,%d9
8001165e:	6d ff 1c f7 	call 80010496 <_malloc_r>
80011662:	40 2c       	mov.aa %a12,%a2
80011664:	7c 26       	jnz.a %a2,80011670 <_realloc_r+0x2ea>
80011666:	40 d4       	mov.aa %a4,%a13
80011668:	6d ff 7f f9 	call 80010966 <__malloc_unlock>
8001166c:	a0 02       	mov.a %a2,0
8001166e:	00 90       	ret 
80011670:	19 f2 fc ff 	ld.w %d2,[%a15]-4
80011674:	d9 23 f8 ff 	lea %a3,[%a2]-8
80011678:	8f 12 c0 21 	andn %d2,%d2,1
8001167c:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
80011680:	80 32       	mov.d %d2,%a3
80011682:	80 23       	mov.d %d3,%a2
80011684:	5f 32 08 80 	jne %d2,%d3,80011694 <_realloc_r+0x30e>
80011688:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8001168c:	8f 32 c0 21 	andn %d2,%d2,3
80011690:	42 28       	add %d8,%d2
80011692:	3c 45       	j 8001171c <_realloc_r+0x396>
80011694:	1b c8 ff 4f 	addi %d4,%d8,-4
80011698:	8b 54 a2 f2 	ge.u %d15,%d4,37
8001169c:	ee 33       	jnz %d15,80011702 <_realloc_r+0x37c>
8001169e:	8b 44 61 f2 	lt.u %d15,%d4,20
800116a2:	40 c3       	mov.aa %a3,%a12
800116a4:	40 f2       	mov.aa %a2,%a15
800116a6:	ee 23       	jnz %d15,800116ec <_realloc_r+0x366>
800116a8:	4c f0       	ld.w %d15,[%a15]0
800116aa:	d9 c3 08 00 	lea %a3,[%a12]8
800116ae:	6c c0       	st.w [%a12]0,%d15
800116b0:	48 12       	ld.w %d2,[%a15]4
800116b2:	8b c4 a1 f2 	ge.u %d15,%d4,28
800116b6:	59 c2 04 00 	st.w [%a12]4,%d2
800116ba:	d9 f2 08 00 	lea %a2,[%a15]8
800116be:	6e 17       	jz %d15,800116ec <_realloc_r+0x366>
800116c0:	48 23       	ld.w %d3,[%a15]8
800116c2:	8b 44 02 82 	eq %d8,%d4,36
800116c6:	59 c3 08 00 	st.w [%a12]8,%d3
800116ca:	4c f3       	ld.w %d15,[%a15]12
800116cc:	d9 c3 10 00 	lea %a3,[%a12]16
800116d0:	6c c3       	st.w [%a12]12,%d15
800116d2:	d9 f2 10 00 	lea %a2,[%a15]16
800116d6:	76 8b       	jz %d8,800116ec <_realloc_r+0x366>
800116d8:	48 42       	ld.w %d2,[%a15]16
800116da:	d9 c3 18 00 	lea %a3,[%a12]24
800116de:	59 c2 10 00 	st.w [%a12]16,%d2
800116e2:	48 53       	ld.w %d3,[%a15]20
800116e4:	d9 f2 18 00 	lea %a2,[%a15]24
800116e8:	59 c3 14 00 	st.w [%a12]20,%d3
800116ec:	4c 20       	ld.w %d15,[%a2]0
800116ee:	6c 30       	st.w [%a3]0,%d15
800116f0:	19 22 04 00 	ld.w %d2,[%a2]4
800116f4:	59 32 04 00 	st.w [%a3]4,%d2
800116f8:	19 23 08 00 	ld.w %d3,[%a2]8
800116fc:	59 33 08 00 	st.w [%a3]8,%d3
80011700:	3c 05       	j 8001170a <_realloc_r+0x384>
80011702:	40 c4       	mov.aa %a4,%a12
80011704:	40 f5       	mov.aa %a5,%a15
80011706:	6d ff 10 fe 	call 80011326 <memmove>
8001170a:	40 d4       	mov.aa %a4,%a13
8001170c:	40 f5       	mov.aa %a5,%a15
8001170e:	6d ff 36 fd 	call 8001117a <_free_r>
80011712:	40 d4       	mov.aa %a4,%a13
80011714:	6d ff 29 f9 	call 80010966 <__malloc_unlock>
80011718:	40 c2       	mov.aa %a2,%a12
8001171a:	00 90       	ret 
8001171c:	0b f8 80 20 	sub %d2,%d8,%d15
80011720:	8b 02 61 42 	lt.u %d4,%d2,16
80011724:	19 e3 04 00 	ld.w %d3,[%a14]4
80011728:	df 04 16 80 	jne %d4,0,80011754 <_realloc_r+0x3ce>
8001172c:	8f 13 00 31 	and %d3,%d3,1
80011730:	10 e5       	addsc.a %a5,%a14,%d15,0
80011732:	a6 3f       	or %d15,%d3
80011734:	6c e1       	st.w [%a14]4,%d15
80011736:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
8001173a:	8f 12 40 f1 	or %d15,%d2,1
8001173e:	b7 10 21 20 	imask %e2,1,0,1
80011742:	6c 51       	st.w [%a5]4,%d15
80011744:	49 f2 44 08 	ldmst [%a15]4,%e2
80011748:	40 d4       	mov.aa %a4,%a13
8001174a:	d9 55 08 00 	lea %a5,[%a5]8
8001174e:	6d ff 16 fd 	call 8001117a <_free_r>
80011752:	3c 0c       	j 8001176a <_realloc_r+0x3e4>
80011754:	8f 13 00 31 	and %d3,%d3,1
80011758:	a6 83       	or %d3,%d8
8001175a:	59 e3 04 00 	st.w [%a14]4,%d3
8001175e:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
80011762:	b7 10 21 20 	imask %e2,1,0,1
80011766:	49 f2 44 08 	ldmst [%a15]4,%e2
8001176a:	40 d4       	mov.aa %a4,%a13
8001176c:	6d ff fd f8 	call 80010966 <__malloc_unlock>
80011770:	d9 e2 08 00 	lea %a2,[%a14]8
80011774:	00 90       	ret 

80011776 <__int_handler>:
80011776:	00 90       	ret 

80011778 <__class_0_trap_handler>:
80011778:	00 a0       	debug 
8001177a:	7b d0 ea fd 	movh %d15,57005
8001177e:	60 fe       	mov.a %a14,%d15
80011780:	1d 00 e8 00 	j 80011950 <_exit>
80011784:	00 90       	ret 

80011786 <tsim_abort>:
80011786:	8f 84 00 40 	sh %d4,%d4,8
8001178a:	8f f5 0f 51 	and %d5,%d5,255
8001178e:	b7 04 10 48 	insert %d4,%d4,0,16,16
80011792:	9b d5 ea 5d 	addih %d5,%d5,57005
80011796:	42 54       	add %d4,%d5
80011798:	60 4e       	mov.a %a14,%d4
8001179a:	1d 00 db 00 	j 80011950 <_exit>
8001179e:	00 90       	ret 

800117a0 <__class_7_trap_handler>:
800117a0:	02 45       	mov %d5,%d4
800117a2:	00 a0       	debug 
800117a4:	82 74       	mov %d4,7
800117a6:	1d ff f0 ff 	j 80011786 <tsim_abort>

800117aa <__class_6_trap_handler>:
800117aa:	02 45       	mov %d5,%d4
800117ac:	00 a0       	debug 
800117ae:	82 64       	mov %d4,6
800117b0:	1d ff eb ff 	j 80011786 <tsim_abort>

800117b4 <__class_5_trap_handler>:
800117b4:	02 45       	mov %d5,%d4
800117b6:	00 a0       	debug 
800117b8:	82 54       	mov %d4,5
800117ba:	1d ff e6 ff 	j 80011786 <tsim_abort>

800117be <__class_4_trap_handler>:
800117be:	02 45       	mov %d5,%d4
800117c0:	00 a0       	debug 
800117c2:	82 44       	mov %d4,4
800117c4:	1d ff e1 ff 	j 80011786 <tsim_abort>

800117c8 <__class_3_trap_handler>:
800117c8:	02 45       	mov %d5,%d4
800117ca:	00 a0       	debug 
800117cc:	82 34       	mov %d4,3
800117ce:	1d ff dc ff 	j 80011786 <tsim_abort>

800117d2 <__class_2_trap_handler>:
800117d2:	02 45       	mov %d5,%d4
800117d4:	00 a0       	debug 
800117d6:	82 24       	mov %d4,2
800117d8:	1d ff d7 ff 	j 80011786 <tsim_abort>

800117dc <__class_1_trap_handler>:
800117dc:	02 45       	mov %d5,%d4
800117de:	00 a0       	debug 
800117e0:	82 14       	mov %d4,1
800117e2:	1d ff d2 ff 	j 80011786 <tsim_abort>

800117e6 <_install_int_handler>:
800117e6:	8b 04 b0 f2 	ge.u %d15,%d4,256
800117ea:	82 02       	mov %d2,0
800117ec:	ee 0f       	jnz %d15,8001180a <_install_int_handler+0x24>
800117ee:	91 00 00 f7 	movh.a %a15,28672
800117f2:	19 f2 c8 44 	ld.w %d2,[%a15]19720 <70004d08 <_init_vectab_initialized>>
800117f6:	76 2a       	jz %d2,8001180a <_install_int_handler+0x24>
800117f8:	91 00 00 f7 	movh.a %a15,28672
800117fc:	d9 ff 68 34 	lea %a15,[%a15]17640 <700044e8 <Cdisptab>>
80011800:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80011804:	82 12       	mov %d2,1
80011806:	e8 04       	st.a [%a15]0,%a4
80011808:	68 15       	st.w [%a15]4,%d5
8001180a:	00 90       	ret 

8001180c <_init_vectab>:
8001180c:	91 00 00 c7 	movh.a %a12,28672
80011810:	19 cf c8 44 	ld.w %d15,[%a12]19720 <70004d08 <_init_vectab_initialized>>
80011814:	ee 51       	jnz %d15,800118b6 <_init_vectab+0xaa>
80011816:	7b 00 00 f8 	movh %d15,32768
8001181a:	6d 00 4f 00 	call 800118b8 <unlock_wdtcon>
8001181e:	1b 0f f0 f0 	addi %d15,%d15,3840
80011822:	cd 4f e2 0f 	mtcr $btv,%d15
80011826:	7b 00 01 f5 	movh %d15,20496
8001182a:	1b 0f 00 f0 	addi %d15,%d15,0
8001182e:	cd 0f e2 0f 	mtcr $biv,%d15
80011832:	6d 00 59 00 	call 800118e4 <lock_wdtcon>
80011836:	7b 10 00 f8 	movh %d15,32769
8001183a:	91 00 00 27 	movh.a %a2,28672
8001183e:	1b 8f 77 f1 	addi %d15,%d15,6008
80011842:	59 2f e8 34 	st.w [%a2]19688 <70004ce8 <Tdisptab>>,%d15
80011846:	7b 10 00 f8 	movh %d15,32769
8001184a:	d9 2f e8 34 	lea %a15,[%a2]19688 <70004ce8 <Tdisptab>>
8001184e:	1b cf 7d f1 	addi %d15,%d15,6108
80011852:	68 1f       	st.w [%a15]4,%d15
80011854:	7b 10 00 f8 	movh %d15,32769
80011858:	1b 2f 7d f1 	addi %d15,%d15,6098
8001185c:	68 2f       	st.w [%a15]8,%d15
8001185e:	7b 10 00 f8 	movh %d15,32769
80011862:	1b 8f 7c f1 	addi %d15,%d15,6088
80011866:	68 3f       	st.w [%a15]12,%d15
80011868:	7b 10 00 f8 	movh %d15,32769
8001186c:	1b ef 7b f1 	addi %d15,%d15,6078
80011870:	68 4f       	st.w [%a15]16,%d15
80011872:	7b 10 00 f8 	movh %d15,32769
80011876:	1b 4f 7b f1 	addi %d15,%d15,6068
8001187a:	68 5f       	st.w [%a15]20,%d15
8001187c:	7b 10 00 f8 	movh %d15,32769
80011880:	1b af 7a f1 	addi %d15,%d15,6058
80011884:	68 6f       	st.w [%a15]24,%d15
80011886:	7b 10 00 f8 	movh %d15,32769
8001188a:	1b 0f 7a f1 	addi %d15,%d15,6048
8001188e:	91 00 00 37 	movh.a %a3,28672
80011892:	7b 10 00 28 	movh %d2,32769
80011896:	68 7f       	st.w [%a15]28,%d15
80011898:	d9 33 68 34 	lea %a3,[%a3]17640 <700044e8 <Cdisptab>>
8001189c:	82 0f       	mov %d15,0
8001189e:	1b 62 77 21 	addi %d2,%d2,6006
800118a2:	c5 0f 3f 30 	lea %a15,ff <_.+0xfe>
800118a6:	d0 32       	addsc.a %a2,%a3,%d15,3
800118a8:	6c 21       	st.w [%a2]4,%d15
800118aa:	74 22       	st.w [%a2],%d2
800118ac:	c2 1f       	add %d15,1
800118ae:	fc fc       	loop %a15,800118a6 <_init_vectab+0x9a>
800118b0:	82 1f       	mov %d15,1
800118b2:	59 cf c8 44 	st.w [%a12]19720 <70004d08 <_init_vectab_initialized>>,%d15
800118b6:	00 90       	ret 

800118b8 <unlock_wdtcon>:
800118b8:	4d c0 e1 ff 	mfcr %d15,$core_id
800118bc:	16 07       	and %d15,7
800118be:	53 cf 20 f0 	mul %d15,%d15,12
800118c2:	60 f2       	mov.a %a2,%d15
800118c4:	d9 2f 00 46 	lea %a15,[%a2]24832
800118c8:	11 3f 00 ff 	addih.a %a15,%a15,61443
800118cc:	4c f0       	ld.w %d15,[%a15]0
800118ce:	8f ff cf f1 	andn %d15,%d15,255
800118d2:	8f 1f 4f 21 	or %d2,%d15,241
800118d6:	68 02       	st.w [%a15]0,%d2
800118d8:	0d 00 80 04 	dsync 
800118dc:	96 f2       	or %d15,242
800118de:	68 0f       	st.w [%a15]0,%d15
800118e0:	4c f0       	ld.w %d15,[%a15]0
800118e2:	00 90       	ret 

800118e4 <lock_wdtcon>:
800118e4:	4d c0 e1 ff 	mfcr %d15,$core_id
800118e8:	16 07       	and %d15,7
800118ea:	53 cf 20 f0 	mul %d15,%d15,12
800118ee:	60 f2       	mov.a %a2,%d15
800118f0:	d9 2f 00 46 	lea %a15,[%a2]24832
800118f4:	11 3f 00 ff 	addih.a %a15,%a15,61443
800118f8:	4c f0       	ld.w %d15,[%a15]0
800118fa:	8f ff cf f1 	andn %d15,%d15,255
800118fe:	8f 1f 4f 21 	or %d2,%d15,241
80011902:	68 02       	st.w [%a15]0,%d2
80011904:	0d 00 80 04 	dsync 
80011908:	96 f3       	or %d15,243
8001190a:	68 0f       	st.w [%a15]0,%d15
8001190c:	4c f0       	ld.w %d15,[%a15]0
8001190e:	00 90       	ret 

80011910 <unlock_safety_wdtcon>:
80011910:	91 30 00 ff 	movh.a %a15,61443
80011914:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80011918:	4c f0       	ld.w %d15,[%a15]0
8001191a:	8f ff cf f1 	andn %d15,%d15,255
8001191e:	8f 1f 4f 21 	or %d2,%d15,241
80011922:	68 02       	st.w [%a15]0,%d2
80011924:	0d 00 80 04 	dsync 
80011928:	96 f2       	or %d15,242
8001192a:	68 0f       	st.w [%a15]0,%d15
8001192c:	4c f0       	ld.w %d15,[%a15]0
8001192e:	00 90       	ret 

80011930 <lock_safety_wdtcon>:
80011930:	91 30 00 ff 	movh.a %a15,61443
80011934:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80011938:	4c f0       	ld.w %d15,[%a15]0
8001193a:	8f ff cf f1 	andn %d15,%d15,255
8001193e:	8f 1f 4f 21 	or %d2,%d15,241
80011942:	68 02       	st.w [%a15]0,%d2
80011944:	0d 00 80 04 	dsync 
80011948:	96 f3       	or %d15,243
8001194a:	68 0f       	st.w [%a15]0,%d15
8001194c:	4c f0       	ld.w %d15,[%a15]0
8001194e:	00 90       	ret 

80011950 <_exit>:
80011950:	76 43       	jz %d4,80011956 <_exit+0x6>
80011952:	60 4e       	mov.a %a14,%d4
80011954:	3c 04       	j 8001195c <_exit+0xc>
80011956:	bb d0 00 f9 	mov.u %d15,36877
8001195a:	60 fe       	mov.a %a14,%d15
8001195c:	00 a0       	debug 
8001195e:	3c 00       	j 8001195e <_exit+0xe>

80011960 <sbrk>:
80011960:	91 00 00 f7 	movh.a %a15,28672
80011964:	19 ff 90 61 	ld.w %d15,[%a15]6544 <70001990 <heap_top.2289>>
80011968:	7b 00 00 27 	movh %d2,28672
8001196c:	42 f4       	add %d4,%d15
8001196e:	1b 82 d1 24 	addi %d2,%d2,19736
80011972:	7f 42 09 80 	jge.u %d2,%d4,80011984 <sbrk+0x24>
80011976:	6d 00 13 00 	call 8001199c <__errno>
8001197a:	da 0c       	mov %d15,12
8001197c:	6c 20       	st.w [%a2]0,%d15
8001197e:	a0 02       	mov.a %a2,0
80011980:	b0 f2       	add.a %a2,-1
80011982:	00 90       	ret 
80011984:	7b 00 00 27 	movh %d2,28672
80011988:	1b 82 d1 24 	addi %d2,%d2,19736
8001198c:	7f 24 04 80 	jge.u %d4,%d2,80011994 <sbrk+0x34>
80011990:	6d 00 0b 00 	call 800119a6 <abort>
80011994:	59 f4 90 61 	st.w [%a15]6544,%d4
80011998:	60 f2       	mov.a %a2,%d15
8001199a:	00 90       	ret 

8001199c <__errno>:
8001199c:	91 00 00 27 	movh.a %a2,28672
800119a0:	d9 22 d0 44 	lea %a2,[%a2]19728 <70004d10 <_my_errno>>
800119a4:	00 90       	ret 

800119a6 <abort>:
800119a6:	00 a0       	debug 
800119a8:	7b e0 ea fd 	movh %d15,57006
800119ac:	1b ff ee fb 	addi %d15,%d15,-16657
800119b0:	60 fe       	mov.a %a14,%d15
800119b2:	1d ff cf ff 	j 80011950 <_exit>
800119b6:	3c 00       	j 800119b6 <abort+0x10>

800119b8 <_fpadd_parts>:
800119b8:	0c 40       	ld.bu %d15,[%a4]0
800119ba:	40 42       	mov.aa %a2,%a4
800119bc:	bf 2f cb 80 	jlt.u %d15,2,80011b52 <_fpadd_parts+0x19a>
800119c0:	14 52       	ld.bu %d2,[%a5]
800119c2:	40 52       	mov.aa %a2,%a5
800119c4:	bf 22 c7 80 	jlt.u %d2,2,80011b52 <_fpadd_parts+0x19a>
800119c8:	5e 4e       	jne %d15,4,800119e4 <_fpadd_parts+0x2c>
800119ca:	40 42       	mov.aa %a2,%a4
800119cc:	df 42 c3 80 	jne %d2,4,80011b52 <_fpadd_parts+0x19a>
800119d0:	19 42 04 00 	ld.w %d2,[%a4]4
800119d4:	4c 51       	ld.w %d15,[%a5]4
800119d6:	5f f2 be 00 	jeq %d2,%d15,80011b52 <_fpadd_parts+0x19a>
800119da:	91 00 00 f8 	movh.a %a15,32768
800119de:	d9 f2 c0 70 	lea %a2,[%a15]3520 <80000dc0 <__thenan_df>>
800119e2:	00 90       	ret 
800119e4:	40 52       	mov.aa %a2,%a5
800119e6:	df 42 b6 00 	jeq %d2,4,80011b52 <_fpadd_parts+0x19a>
800119ea:	df 22 11 80 	jne %d2,2,80011a0c <_fpadd_parts+0x54>
800119ee:	40 42       	mov.aa %a2,%a4
800119f0:	df 2f b1 80 	jne %d15,2,80011b52 <_fpadd_parts+0x19a>
800119f4:	40 63       	mov.aa %a3,%a6
800119f6:	a0 4f       	mov.a %a15,4
800119f8:	44 4f       	ld.w %d15,[%a4+]
800119fa:	64 3f       	st.w [%a3+],%d15
800119fc:	fc fe       	loop %a15,800119f8 <_fpadd_parts+0x40>
800119fe:	4c 21       	ld.w %d15,[%a2]4
80011a00:	19 52 04 00 	ld.w %d2,[%a5]4
80011a04:	40 62       	mov.aa %a2,%a6
80011a06:	26 2f       	and %d15,%d2
80011a08:	6c 61       	st.w [%a6]4,%d15
80011a0a:	00 90       	ret 
80011a0c:	40 52       	mov.aa %a2,%a5
80011a0e:	df 2f a2 00 	jeq %d15,2,80011b52 <_fpadd_parts+0x19a>
80011a12:	4c 42       	ld.w %d15,[%a4]8
80011a14:	19 52 08 00 	ld.w %d2,[%a5]8
80011a18:	40 6f       	mov.aa %a15,%a6
80011a1a:	52 23       	sub %d3,%d15,%d2
80011a1c:	0b 30 c0 c1 	abs %d12,%d3
80011a20:	8b 0c 84 42 	ge %d4,%d12,64
80011a24:	40 5c       	mov.aa %a12,%a5
80011a26:	40 4d       	mov.aa %a13,%a4
80011a28:	09 4a 4c 09 	ld.d %e10,[%a4]12
80011a2c:	09 58 4c 09 	ld.d %e8,[%a5]12
80011a30:	df 04 35 80 	jne %d4,0,80011a9a <_fpadd_parts+0xe2>
80011a34:	bf 13 19 00 	jlt %d3,1,80011a66 <_fpadd_parts+0xae>
80011a38:	0b 89 10 48 	mov %e4,%d9,%d8
80011a3c:	02 c6       	mov %d6,%d12
80011a3e:	6d 00 99 03 	call 80012170 <__lshrdi3>
80011a42:	d2 14       	mov %e4,1
80011a44:	02 c6       	mov %d6,%d12
80011a46:	02 2e       	mov %d14,%d2
80011a48:	02 3d       	mov %d13,%d3
80011a4a:	6d 00 86 03 	call 80012156 <__ashldi3>
80011a4e:	8b f2 9f 20 	addx %d2,%d2,-1
80011a52:	8b f3 bf 30 	addc %d3,%d3,-1
80011a56:	26 82       	and %d2,%d8
80011a58:	26 93       	and %d3,%d9
80011a5a:	a6 23       	or %d3,%d2
80011a5c:	02 e8       	mov %d8,%d14
80011a5e:	8b 03 00 85 	or.ne %d8,%d3,0
80011a62:	02 d9       	mov %d9,%d13
80011a64:	3c 21       	j 80011aa6 <_fpadd_parts+0xee>
80011a66:	df 03 20 00 	jeq %d3,0,80011aa6 <_fpadd_parts+0xee>
80011a6a:	0b ab 10 48 	mov %e4,%d11,%d10
80011a6e:	02 c6       	mov %d6,%d12
80011a70:	6d 00 80 03 	call 80012170 <__lshrdi3>
80011a74:	d2 14       	mov %e4,1
80011a76:	02 c6       	mov %d6,%d12
80011a78:	02 2e       	mov %d14,%d2
80011a7a:	02 3d       	mov %d13,%d3
80011a7c:	6d 00 6d 03 	call 80012156 <__ashldi3>
80011a80:	8b f2 9f 20 	addx %d2,%d2,-1
80011a84:	8b f3 bf 30 	addc %d3,%d3,-1
80011a88:	26 a2       	and %d2,%d10
80011a8a:	26 b3       	and %d3,%d11
80011a8c:	a6 23       	or %d3,%d2
80011a8e:	02 ea       	mov %d10,%d14
80011a90:	42 cf       	add %d15,%d12
80011a92:	8b 03 00 a5 	or.ne %d10,%d3,0
80011a96:	02 db       	mov %d11,%d13
80011a98:	3c 07       	j 80011aa6 <_fpadd_parts+0xee>
80011a9a:	3f f2 05 00 	jlt %d2,%d15,80011aa4 <_fpadd_parts+0xec>
80011a9e:	02 2f       	mov %d15,%d2
80011aa0:	d2 0a       	mov %e10,0
80011aa2:	3c 02       	j 80011aa6 <_fpadd_parts+0xee>
80011aa4:	d2 08       	mov %e8,0
80011aa6:	19 d4 04 00 	ld.w %d4,[%a13]4
80011aaa:	19 c2 04 00 	ld.w %d2,[%a12]4
80011aae:	5f 24 34 00 	jeq %d4,%d2,80011b16 <_fpadd_parts+0x15e>
80011ab2:	0b 8a c0 20 	subx %d2,%d10,%d8
80011ab6:	0b 9b d0 30 	subc %d3,%d11,%d9
80011aba:	76 45       	jz %d4,80011ac4 <_fpadd_parts+0x10c>
80011abc:	0b a8 c0 20 	subx %d2,%d8,%d10
80011ac0:	0b b9 d0 30 	subc %d3,%d9,%d11
80011ac4:	0e 37       	jltz %d3,80011ad2 <_fpadd_parts+0x11a>
80011ac6:	82 04       	mov %d4,0
80011ac8:	68 14       	st.w [%a15]4,%d4
80011aca:	68 2f       	st.w [%a15]8,%d15
80011acc:	89 f2 4c 09 	st.d [%a15]12,%e2
80011ad0:	3c 0c       	j 80011ae8 <_fpadd_parts+0x130>
80011ad2:	68 2f       	st.w [%a15]8,%d15
80011ad4:	8b 03 00 f1 	rsub %d15,%d3,0
80011ad8:	82 14       	mov %d4,1
80011ada:	8b 02 00 31 	rsub %d3,%d2,0
80011ade:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
80011ae2:	68 14       	st.w [%a15]4,%d4
80011ae4:	68 33       	st.w [%a15]12,%d3
80011ae6:	68 4f       	st.w [%a15]16,%d15
80011ae8:	82 f5       	mov %d5,-1
80011aea:	06 c5       	sh %d5,-4
80011aec:	48 32       	ld.w %d2,[%a15]12
80011aee:	48 43       	ld.w %d3,[%a15]16
80011af0:	8b f2 9f 60 	addx %d6,%d2,-1
80011af4:	8b f3 bf 40 	addc %d4,%d3,-1
80011af8:	3a 54       	eq %d15,%d4,%d5
80011afa:	8b f6 3f f4 	and.ne %d15,%d6,-1
80011afe:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
80011b02:	6e 12       	jz %d15,80011b26 <_fpadd_parts+0x16e>
80011b04:	4c f2       	ld.w %d15,[%a15]8
80011b06:	77 23 80 30 	dextr %d3,%d3,%d2,1
80011b0a:	c2 ff       	add %d15,-1
80011b0c:	06 12       	sh %d2,1
80011b0e:	68 32       	st.w [%a15]12,%d2
80011b10:	68 43       	st.w [%a15]16,%d3
80011b12:	68 2f       	st.w [%a15]8,%d15
80011b14:	3c ec       	j 80011aec <_fpadd_parts+0x134>
80011b16:	0b a8 40 20 	addx %d2,%d8,%d10
80011b1a:	68 2f       	st.w [%a15]8,%d15
80011b1c:	0b b9 50 f0 	addc %d15,%d9,%d11
80011b20:	68 14       	st.w [%a15]4,%d4
80011b22:	68 32       	st.w [%a15]12,%d2
80011b24:	68 4f       	st.w [%a15]16,%d15
80011b26:	82 3f       	mov %d15,3
80011b28:	28 0f       	st.b [%a15]0,%d15
80011b2a:	4c f4       	ld.w %d15,[%a15]16
80011b2c:	7b 00 00 42 	movh %d4,8192
80011b30:	0b 4f 30 31 	lt.u %d3,%d15,%d4
80011b34:	48 32       	ld.w %d2,[%a15]12
80011b36:	40 f2       	mov.aa %a2,%a15
80011b38:	f6 3d       	jnz %d3,80011b52 <_fpadd_parts+0x19a>
80011b3a:	8f 12 00 31 	and %d3,%d2,1
80011b3e:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
80011b42:	06 ff       	sh %d15,-1
80011b44:	96 00       	or %d15,0
80011b46:	68 4f       	st.w [%a15]16,%d15
80011b48:	4c f2       	ld.w %d15,[%a15]8
80011b4a:	a6 32       	or %d2,%d3
80011b4c:	c2 1f       	add %d15,1
80011b4e:	68 32       	st.w [%a15]12,%d2
80011b50:	68 2f       	st.w [%a15]8,%d15
80011b52:	00 90       	ret 

80011b54 <__adddf3>:
80011b54:	20 50       	sub.a %sp,80
80011b56:	d9 a4 04 00 	lea %a4,[%sp]4
80011b5a:	d9 a5 14 00 	lea %a5,[%sp]20
80011b5e:	89 a4 44 09 	st.d [%sp]4,%e4
80011b62:	89 a6 4c 09 	st.d [%sp]12,%e6
80011b66:	6d 00 a1 03 	call 800122a8 <__unpack_d>
80011b6a:	d9 a4 0c 00 	lea %a4,[%sp]12
80011b6e:	d9 a5 28 00 	lea %a5,[%sp]40
80011b72:	6d 00 9b 03 	call 800122a8 <__unpack_d>
80011b76:	d9 a4 14 00 	lea %a4,[%sp]20
80011b7a:	d9 a5 28 00 	lea %a5,[%sp]40
80011b7e:	d9 a6 3c 00 	lea %a6,[%sp]60
80011b82:	6d ff 1b ff 	call 800119b8 <_fpadd_parts>
80011b86:	40 24       	mov.aa %a4,%a2
80011b88:	1d 00 07 03 	j 80012196 <__pack_d>

80011b8c <__subdf3>:
80011b8c:	20 50       	sub.a %sp,80
80011b8e:	d9 a4 04 00 	lea %a4,[%sp]4
80011b92:	d9 a5 14 00 	lea %a5,[%sp]20
80011b96:	89 a4 44 09 	st.d [%sp]4,%e4
80011b9a:	89 a6 4c 09 	st.d [%sp]12,%e6
80011b9e:	6d 00 85 03 	call 800122a8 <__unpack_d>
80011ba2:	d9 a4 0c 00 	lea %a4,[%sp]12
80011ba6:	d9 a5 28 00 	lea %a5,[%sp]40
80011baa:	6d 00 7f 03 	call 800122a8 <__unpack_d>
80011bae:	58 0b       	ld.w %d15,[%sp]44
80011bb0:	d9 a4 14 00 	lea %a4,[%sp]20
80011bb4:	8f 1f 80 f1 	xor %d15,%d15,1
80011bb8:	d9 a5 28 00 	lea %a5,[%sp]40
80011bbc:	d9 a6 3c 00 	lea %a6,[%sp]60
80011bc0:	78 0b       	st.w [%sp]44,%d15
80011bc2:	6d ff fb fe 	call 800119b8 <_fpadd_parts>
80011bc6:	40 24       	mov.aa %a4,%a2
80011bc8:	1d 00 e7 02 	j 80012196 <__pack_d>

80011bcc <__muldf3>:
80011bcc:	20 50       	sub.a %sp,80
80011bce:	d9 a4 04 00 	lea %a4,[%sp]4
80011bd2:	d9 a5 14 00 	lea %a5,[%sp]20
80011bd6:	89 a4 44 09 	st.d [%sp]4,%e4
80011bda:	89 a6 4c 09 	st.d [%sp]12,%e6
80011bde:	6d 00 65 03 	call 800122a8 <__unpack_d>
80011be2:	d9 a4 0c 00 	lea %a4,[%sp]12
80011be6:	d9 a5 28 00 	lea %a5,[%sp]40
80011bea:	6d 00 5f 03 	call 800122a8 <__unpack_d>
80011bee:	39 a3 14 00 	ld.bu %d3,[%sp]20
80011bf2:	ff 23 0c 80 	jge.u %d3,2,80011c0a <__muldf3+0x3e>
80011bf6:	19 a2 18 00 	ld.w %d2,[%sp]24
80011bfa:	58 0b       	ld.w %d15,[%sp]44
80011bfc:	d9 a4 14 00 	lea %a4,[%sp]20
80011c00:	0b f2 10 f1 	ne %d15,%d2,%d15
80011c04:	78 06       	st.w [%sp]24,%d15
80011c06:	1d 00 b3 00 	j 80011d6c <__muldf3+0x1a0>
80011c0a:	39 af 28 00 	ld.bu %d15,[%sp]40
80011c0e:	ff 2f 0c 80 	jge.u %d15,2,80011c26 <__muldf3+0x5a>
80011c12:	58 0b       	ld.w %d15,[%sp]44
80011c14:	19 a2 18 00 	ld.w %d2,[%sp]24
80011c18:	d9 a4 28 00 	lea %a4,[%sp]40
80011c1c:	0b f2 10 f1 	ne %d15,%d2,%d15
80011c20:	78 0b       	st.w [%sp]44,%d15
80011c22:	1d 00 a5 00 	j 80011d6c <__muldf3+0x1a0>
80011c26:	df 43 09 80 	jne %d3,4,80011c38 <__muldf3+0x6c>
80011c2a:	91 00 00 48 	movh.a %a4,32768
80011c2e:	d9 44 c0 70 	lea %a4,[%a4]3520 <80000dc0 <__thenan_df>>
80011c32:	df 2f 9d 00 	jeq %d15,2,80011d6c <__muldf3+0x1a0>
80011c36:	3c e0       	j 80011bf6 <__muldf3+0x2a>
80011c38:	5e 48       	jne %d15,4,80011c48 <__muldf3+0x7c>
80011c3a:	91 00 00 48 	movh.a %a4,32768
80011c3e:	d9 44 c0 70 	lea %a4,[%a4]3520 <80000dc0 <__thenan_df>>
80011c42:	df 23 95 00 	jeq %d3,2,80011d6c <__muldf3+0x1a0>
80011c46:	3c e6       	j 80011c12 <__muldf3+0x46>
80011c48:	df 23 d7 7f 	jeq %d3,2,80011bf6 <__muldf3+0x2a>
80011c4c:	df 2f e3 7f 	jeq %d15,2,80011c12 <__muldf3+0x46>
80011c50:	58 08       	ld.w %d15,[%sp]32
80011c52:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
80011c56:	d2 00       	mov %e0,0
80011c58:	19 a0 34 00 	ld.w %d0,[%sp]52
80011c5c:	73 bf 68 60 	mul.u %e6,%d15,%d11
80011c60:	82 0c       	mov %d12,0
80011c62:	73 0f 68 40 	mul.u %e4,%d15,%d0
80011c66:	19 aa 24 00 	ld.w %d10,[%sp]36
80011c6a:	82 02       	mov %d2,0
80011c6c:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
80011c70:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
80011c74:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
80011c78:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
80011c7c:	82 0d       	mov %d13,0
80011c7e:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
80011c82:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
80011c86:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
80011c8a:	0b 54 10 08 	mov %e0,%d4,%d5
80011c8e:	42 20       	add %d0,%d2
80011c90:	3a 73       	eq %d15,%d3,%d7
80011c92:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
80011c96:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
80011c9a:	8b 0f 00 62 	eq %d6,%d15,0
80011c9e:	3a 50       	eq %d15,%d0,%d5
80011ca0:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
80011ca4:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
80011ca8:	ba 0f       	eq %d15,%d15,0
80011caa:	53 1f 40 40 	mul.u %e4,%d15,1
80011cae:	02 38       	mov %d8,%d3
80011cb0:	82 09       	mov %d9,0
80011cb2:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
80011cb6:	02 5f       	mov %d15,%d5
80011cb8:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
80011cbc:	42 6f       	add %d15,%d6
80011cbe:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
80011cc2:	0b 4f 10 68 	mov %e6,%d15,%d4
80011cc6:	0b 62 40 40 	addx %d4,%d2,%d6
80011cca:	0b 73 50 20 	addc %d2,%d3,%d7
80011cce:	58 07       	ld.w %d15,[%sp]28
80011cd0:	19 a3 30 00 	ld.w %d3,[%sp]48
80011cd4:	19 a5 18 00 	ld.w %d5,[%sp]24
80011cd8:	42 3f       	add %d15,%d3
80011cda:	19 a3 2c 00 	ld.w %d3,[%sp]44
80011cde:	c2 4f       	add %d15,4
80011ce0:	0b 35 10 31 	ne %d3,%d5,%d3
80011ce4:	59 a3 00 10 	st.w [%sp]64,%d3
80011ce8:	7b 00 00 52 	movh %d5,8192
80011cec:	0b 52 50 31 	ge.u %d3,%d2,%d5
80011cf0:	df 03 1b 00 	jeq %d3,0,80011d26 <__muldf3+0x15a>
80011cf4:	8f 14 00 31 	and %d3,%d4,1
80011cf8:	76 37       	jz %d3,80011d06 <__muldf3+0x13a>
80011cfa:	8f f0 1f 30 	sh %d3,%d0,-1
80011cfe:	77 10 80 1f 	dextr %d1,%d0,%d1,31
80011d02:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
80011d06:	77 42 80 4f 	dextr %d4,%d2,%d4,31
80011d0a:	c2 1f       	add %d15,1
80011d0c:	06 f2       	sh %d2,-1
80011d0e:	3c ed       	j 80011ce8 <__muldf3+0x11c>
80011d10:	77 42 80 20 	dextr %d2,%d2,%d4,1
80011d14:	06 14       	sh %d4,1
80011d16:	ce 04       	jgez %d0,80011d1e <__muldf3+0x152>
80011d18:	8f 14 40 51 	or %d5,%d4,1
80011d1c:	02 54       	mov %d4,%d5
80011d1e:	77 10 80 00 	dextr %d0,%d0,%d1,1
80011d22:	c2 ff       	add %d15,-1
80011d24:	06 11       	sh %d1,1
80011d26:	7b 00 00 51 	movh %d5,4096
80011d2a:	0b 52 30 31 	lt.u %d3,%d2,%d5
80011d2e:	df 03 f1 ff 	jne %d3,0,80011d10 <__muldf3+0x144>
80011d32:	78 11       	st.w [%sp]68,%d15
80011d34:	02 4f       	mov %d15,%d4
80011d36:	16 ff       	and %d15,255
80011d38:	8b 0f 28 f2 	ne %d15,%d15,128
80011d3c:	ee 0f       	jnz %d15,80011d5a <__muldf3+0x18e>
80011d3e:	a6 10       	or %d0,%d1
80011d40:	77 42 00 fc 	dextr %d15,%d2,%d4,24
80011d44:	8b 00 20 02 	ne %d0,%d0,0
80011d48:	0f f0 e0 00 	andn %d0,%d0,%d15
80011d4c:	76 07       	jz %d0,80011d5a <__muldf3+0x18e>
80011d4e:	8b 04 88 40 	addx %d4,%d4,128
80011d52:	8b 02 a0 20 	addc %d2,%d2,0
80011d56:	8f f4 cf 41 	andn %d4,%d4,255
80011d5a:	d9 a4 10 10 	lea %a4,[%sp]80
80011d5e:	82 3f       	mov %d15,3
80011d60:	59 a4 08 10 	st.w [%sp]72,%d4
80011d64:	59 a2 0c 10 	st.w [%sp]76,%d2
80011d68:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <IfxPort_cfg_indexMap+0x74>>,%d15
80011d6c:	1d 00 15 02 	j 80012196 <__pack_d>

80011d70 <__divdf3>:
80011d70:	20 38       	sub.a %sp,56
80011d72:	40 a4       	mov.aa %a4,%sp
80011d74:	d9 a5 10 00 	lea %a5,[%sp]16
80011d78:	89 a4 40 09 	st.d [%sp],%e4
80011d7c:	89 a6 48 09 	st.d [%sp]8,%e6
80011d80:	6d 00 94 02 	call 800122a8 <__unpack_d>
80011d84:	d9 a4 08 00 	lea %a4,[%sp]8
80011d88:	d9 a5 24 00 	lea %a5,[%sp]36
80011d8c:	6d 00 8e 02 	call 800122a8 <__unpack_d>
80011d90:	39 a2 10 00 	ld.bu %d2,[%sp]16
80011d94:	bf 22 76 80 	jlt.u %d2,2,80011e80 <__divdf3+0x110>
80011d98:	39 af 24 00 	ld.bu %d15,[%sp]36
80011d9c:	d9 a4 24 00 	lea %a4,[%sp]36
80011da0:	bf 2f 72 80 	jlt.u %d15,2,80011e84 <__divdf3+0x114>
80011da4:	19 a4 14 00 	ld.w %d4,[%sp]20
80011da8:	19 a3 28 00 	ld.w %d3,[%sp]40
80011dac:	c6 43       	xor %d3,%d4
80011dae:	59 a3 14 00 	st.w [%sp]20,%d3
80011db2:	1b e2 ff 3f 	addi %d3,%d2,-2
80011db6:	8f d3 0f 31 	and %d3,%d3,253
80011dba:	f6 38       	jnz %d3,80011dca <__divdf3+0x5a>
80011dbc:	91 00 00 48 	movh.a %a4,32768
80011dc0:	d9 44 c0 70 	lea %a4,[%a4]3520 <80000dc0 <__thenan_df>>
80011dc4:	5f f2 5e 80 	jne %d2,%d15,80011e80 <__divdf3+0x110>
80011dc8:	3c 5e       	j 80011e84 <__divdf3+0x114>
80011dca:	5e 47       	jne %d15,4,80011dd8 <__divdf3+0x68>
80011dcc:	d2 02       	mov %e2,0
80011dce:	82 0f       	mov %d15,0
80011dd0:	89 a2 5c 09 	st.d [%sp]28,%e2
80011dd4:	78 06       	st.w [%sp]24,%d15
80011dd6:	3c 55       	j 80011e80 <__divdf3+0x110>
80011dd8:	5e 25       	jne %d15,2,80011de2 <__divdf3+0x72>
80011dda:	82 4f       	mov %d15,4
80011ddc:	e9 af 10 00 	st.b [%sp]16,%d15
80011de0:	3c 50       	j 80011e80 <__divdf3+0x110>
80011de2:	58 06       	ld.w %d15,[%sp]24
80011de4:	09 a2 5c 09 	ld.d %e2,[%sp]28
80011de8:	09 a4 70 09 	ld.d %e4,[%sp]48
80011dec:	19 a6 2c 00 	ld.w %d6,[%sp]44
80011df0:	52 66       	sub %d6,%d15,%d6
80011df2:	3a 53       	eq %d15,%d3,%d5
80011df4:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
80011df8:	59 a6 18 00 	st.w [%sp]24,%d6
80011dfc:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
80011e00:	ee 07       	jnz %d15,80011e0e <__divdf3+0x9e>
80011e02:	c2 f6       	add %d6,-1
80011e04:	77 23 80 30 	dextr %d3,%d3,%d2,1
80011e08:	59 a6 18 00 	st.w [%sp]24,%d6
80011e0c:	06 12       	sh %d2,1
80011e0e:	82 01       	mov %d1,0
80011e10:	7b 00 00 f1 	movh %d15,4096
80011e14:	82 00       	mov %d0,0
80011e16:	82 07       	mov %d7,0
80011e18:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
80011e1c:	0b 53 00 61 	eq %d6,%d3,%d5
80011e20:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
80011e24:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
80011e28:	f6 6b       	jnz %d6,80011e3e <__divdf3+0xce>
80011e2a:	0f 10 a0 80 	or %d8,%d0,%d1
80011e2e:	0f f7 a0 60 	or %d6,%d7,%d15
80011e32:	0b 42 c0 20 	subx %d2,%d2,%d4
80011e36:	02 80       	mov %d0,%d8
80011e38:	02 67       	mov %d7,%d6
80011e3a:	0b 53 d0 30 	subc %d3,%d3,%d5
80011e3e:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
80011e42:	77 23 80 30 	dextr %d3,%d3,%d2,1
80011e46:	06 ff       	sh %d15,-1
80011e48:	06 12       	sh %d2,1
80011e4a:	fd f0 e9 7f 	loop %a15,80011e1c <__divdf3+0xac>
80011e4e:	02 0f       	mov %d15,%d0
80011e50:	16 ff       	and %d15,255
80011e52:	8b 0f 28 f2 	ne %d15,%d15,128
80011e56:	0b 70 10 48 	mov %e4,%d0,%d7
80011e5a:	ee 0f       	jnz %d15,80011e78 <__divdf3+0x108>
80011e5c:	a6 32       	or %d2,%d3
80011e5e:	77 07 00 fc 	dextr %d15,%d7,%d0,24
80011e62:	8b 02 20 22 	ne %d2,%d2,0
80011e66:	0f f2 e0 20 	andn %d2,%d2,%d15
80011e6a:	76 27       	jz %d2,80011e78 <__divdf3+0x108>
80011e6c:	8b 00 88 00 	addx %d0,%d0,128
80011e70:	8b 07 a0 40 	addc %d4,%d7,0
80011e74:	8f f0 cf 51 	andn %d5,%d0,255
80011e78:	59 a5 1c 00 	st.w [%sp]28,%d5
80011e7c:	59 a4 20 00 	st.w [%sp]32,%d4
80011e80:	d9 a4 10 00 	lea %a4,[%sp]16
80011e84:	1d 00 89 01 	j 80012196 <__pack_d>

80011e88 <__eqdf2>:
80011e88:	20 38       	sub.a %sp,56
80011e8a:	40 a4       	mov.aa %a4,%sp
80011e8c:	d9 a5 10 00 	lea %a5,[%sp]16
80011e90:	89 a4 40 09 	st.d [%sp],%e4
80011e94:	89 a6 48 09 	st.d [%sp]8,%e6
80011e98:	6d 00 08 02 	call 800122a8 <__unpack_d>
80011e9c:	d9 a4 08 00 	lea %a4,[%sp]8
80011ea0:	d9 a5 24 00 	lea %a5,[%sp]36
80011ea4:	6d 00 02 02 	call 800122a8 <__unpack_d>
80011ea8:	39 af 10 00 	ld.bu %d15,[%sp]16
80011eac:	82 12       	mov %d2,1
80011eae:	bf 2f 0c 80 	jlt.u %d15,2,80011ec6 <__eqdf2+0x3e>
80011eb2:	39 af 24 00 	ld.bu %d15,[%sp]36
80011eb6:	bf 2f 08 80 	jlt.u %d15,2,80011ec6 <__eqdf2+0x3e>
80011eba:	d9 a4 10 00 	lea %a4,[%sp]16
80011ebe:	d9 a5 24 00 	lea %a5,[%sp]36
80011ec2:	6d 00 49 02 	call 80012354 <__fpcmp_parts_d>
80011ec6:	00 90       	ret 

80011ec8 <__nedf2>:
80011ec8:	20 38       	sub.a %sp,56
80011eca:	40 a4       	mov.aa %a4,%sp
80011ecc:	d9 a5 10 00 	lea %a5,[%sp]16
80011ed0:	89 a4 40 09 	st.d [%sp],%e4
80011ed4:	89 a6 48 09 	st.d [%sp]8,%e6
80011ed8:	6d 00 e8 01 	call 800122a8 <__unpack_d>
80011edc:	d9 a4 08 00 	lea %a4,[%sp]8
80011ee0:	d9 a5 24 00 	lea %a5,[%sp]36
80011ee4:	6d 00 e2 01 	call 800122a8 <__unpack_d>
80011ee8:	39 af 10 00 	ld.bu %d15,[%sp]16
80011eec:	82 12       	mov %d2,1
80011eee:	bf 2f 0c 80 	jlt.u %d15,2,80011f06 <__nedf2+0x3e>
80011ef2:	39 af 24 00 	ld.bu %d15,[%sp]36
80011ef6:	bf 2f 08 80 	jlt.u %d15,2,80011f06 <__nedf2+0x3e>
80011efa:	d9 a4 10 00 	lea %a4,[%sp]16
80011efe:	d9 a5 24 00 	lea %a5,[%sp]36
80011f02:	6d 00 29 02 	call 80012354 <__fpcmp_parts_d>
80011f06:	00 90       	ret 

80011f08 <__gtdf2>:
80011f08:	20 38       	sub.a %sp,56
80011f0a:	40 a4       	mov.aa %a4,%sp
80011f0c:	d9 a5 10 00 	lea %a5,[%sp]16
80011f10:	89 a4 40 09 	st.d [%sp],%e4
80011f14:	89 a6 48 09 	st.d [%sp]8,%e6
80011f18:	6d 00 c8 01 	call 800122a8 <__unpack_d>
80011f1c:	d9 a4 08 00 	lea %a4,[%sp]8
80011f20:	d9 a5 24 00 	lea %a5,[%sp]36
80011f24:	6d 00 c2 01 	call 800122a8 <__unpack_d>
80011f28:	39 af 10 00 	ld.bu %d15,[%sp]16
80011f2c:	82 f2       	mov %d2,-1
80011f2e:	bf 2f 0c 80 	jlt.u %d15,2,80011f46 <__gtdf2+0x3e>
80011f32:	39 af 24 00 	ld.bu %d15,[%sp]36
80011f36:	bf 2f 08 80 	jlt.u %d15,2,80011f46 <__gtdf2+0x3e>
80011f3a:	d9 a4 10 00 	lea %a4,[%sp]16
80011f3e:	d9 a5 24 00 	lea %a5,[%sp]36
80011f42:	6d 00 09 02 	call 80012354 <__fpcmp_parts_d>
80011f46:	00 90       	ret 

80011f48 <__gedf2>:
80011f48:	20 38       	sub.a %sp,56
80011f4a:	40 a4       	mov.aa %a4,%sp
80011f4c:	d9 a5 10 00 	lea %a5,[%sp]16
80011f50:	89 a4 40 09 	st.d [%sp],%e4
80011f54:	89 a6 48 09 	st.d [%sp]8,%e6
80011f58:	6d 00 a8 01 	call 800122a8 <__unpack_d>
80011f5c:	d9 a4 08 00 	lea %a4,[%sp]8
80011f60:	d9 a5 24 00 	lea %a5,[%sp]36
80011f64:	6d 00 a2 01 	call 800122a8 <__unpack_d>
80011f68:	39 af 10 00 	ld.bu %d15,[%sp]16
80011f6c:	82 f2       	mov %d2,-1
80011f6e:	bf 2f 0c 80 	jlt.u %d15,2,80011f86 <__gedf2+0x3e>
80011f72:	39 af 24 00 	ld.bu %d15,[%sp]36
80011f76:	bf 2f 08 80 	jlt.u %d15,2,80011f86 <__gedf2+0x3e>
80011f7a:	d9 a4 10 00 	lea %a4,[%sp]16
80011f7e:	d9 a5 24 00 	lea %a5,[%sp]36
80011f82:	6d 00 e9 01 	call 80012354 <__fpcmp_parts_d>
80011f86:	00 90       	ret 

80011f88 <__ltdf2>:
80011f88:	20 38       	sub.a %sp,56
80011f8a:	40 a4       	mov.aa %a4,%sp
80011f8c:	d9 a5 10 00 	lea %a5,[%sp]16
80011f90:	89 a4 40 09 	st.d [%sp],%e4
80011f94:	89 a6 48 09 	st.d [%sp]8,%e6
80011f98:	6d 00 88 01 	call 800122a8 <__unpack_d>
80011f9c:	d9 a4 08 00 	lea %a4,[%sp]8
80011fa0:	d9 a5 24 00 	lea %a5,[%sp]36
80011fa4:	6d 00 82 01 	call 800122a8 <__unpack_d>
80011fa8:	39 af 10 00 	ld.bu %d15,[%sp]16
80011fac:	82 12       	mov %d2,1
80011fae:	bf 2f 0c 80 	jlt.u %d15,2,80011fc6 <__ltdf2+0x3e>
80011fb2:	39 af 24 00 	ld.bu %d15,[%sp]36
80011fb6:	bf 2f 08 80 	jlt.u %d15,2,80011fc6 <__ltdf2+0x3e>
80011fba:	d9 a4 10 00 	lea %a4,[%sp]16
80011fbe:	d9 a5 24 00 	lea %a5,[%sp]36
80011fc2:	6d 00 c9 01 	call 80012354 <__fpcmp_parts_d>
80011fc6:	00 90       	ret 

80011fc8 <__floatsidf>:
80011fc8:	20 18       	sub.a %sp,24
80011fca:	82 3f       	mov %d15,3
80011fcc:	2c a4       	st.b [%sp]4,%d15
80011fce:	8f 14 1e f0 	sh %d15,%d4,-31
80011fd2:	78 02       	st.w [%sp]8,%d15
80011fd4:	f6 44       	jnz %d4,80011fdc <__floatsidf+0x14>
80011fd6:	82 2f       	mov %d15,2
80011fd8:	2c a4       	st.b [%sp]4,%d15
80011fda:	3c 16       	j 80012006 <__floatsidf+0x3e>
80011fdc:	6e 09       	jz %d15,80011fee <__floatsidf+0x26>
80011fde:	7b 00 00 f8 	movh %d15,32768
80011fe2:	82 02       	mov %d2,0
80011fe4:	7b 00 1e 3c 	movh %d3,49632
80011fe8:	5f f4 13 00 	jeq %d4,%d15,8001200e <__floatsidf+0x46>
80011fec:	32 54       	rsub %d4
80011fee:	0f 04 b0 f1 	clz %d15,%d4
80011ff2:	1b df 01 60 	addi %d6,%d15,29
80011ff6:	82 05       	mov %d5,0
80011ff8:	6d 00 af 00 	call 80012156 <__ashldi3>
80011ffc:	8b ff 01 f1 	rsub %d15,%d15,31
80012000:	89 a2 50 09 	st.d [%sp]16,%e2
80012004:	78 03       	st.w [%sp]12,%d15
80012006:	d9 a4 04 00 	lea %a4,[%sp]4
8001200a:	6d 00 c6 00 	call 80012196 <__pack_d>
8001200e:	00 90       	ret 

80012010 <__fixdfsi>:
80012010:	20 20       	sub.a %sp,32
80012012:	d9 a4 20 00 	lea %a4,[%sp]32
80012016:	89 44 64 f5 	st.d [+%a4]-28,%e4
8001201a:	d9 a5 0c 00 	lea %a5,[%sp]12
8001201e:	6d 00 45 01 	call 800122a8 <__unpack_d>
80012022:	0c ac       	ld.bu %d15,[%sp]12
80012024:	82 02       	mov %d2,0
80012026:	bf 3f 1b 80 	jlt.u %d15,3,8001205c <__fixdfsi+0x4c>
8001202a:	5e 48       	jne %d15,4,8001203a <__fixdfsi+0x2a>
8001202c:	7b 00 00 28 	movh %d2,32768
80012030:	58 04       	ld.w %d15,[%sp]16
80012032:	1b f2 ff 3f 	addi %d3,%d2,-1
80012036:	6a 32       	cmovn %d2,%d15,%d3
80012038:	00 90       	ret 
8001203a:	19 a6 14 00 	ld.w %d6,[%sp]20
8001203e:	82 02       	mov %d2,0
80012040:	0e 6e       	jltz %d6,8001205c <__fixdfsi+0x4c>
80012042:	8b f6 81 f2 	ge %d15,%d6,31
80012046:	ee f3       	jnz %d15,8001202c <__fixdfsi+0x1c>
80012048:	09 a4 58 09 	ld.d %e4,[%sp]24
8001204c:	8b c6 03 61 	rsub %d6,%d6,60
80012050:	6d 00 90 00 	call 80012170 <__lshrdi3>
80012054:	58 04       	ld.w %d15,[%sp]16
80012056:	8b 02 00 41 	rsub %d4,%d2,0
8001205a:	2a 42       	cmov %d2,%d15,%d4
8001205c:	00 90       	ret 

8001205e <__floatunsidf>:
8001205e:	20 18       	sub.a %sp,24
80012060:	82 0f       	mov %d15,0
80012062:	78 02       	st.w [%sp]8,%d15
80012064:	f6 44       	jnz %d4,8001206c <__floatunsidf+0xe>
80012066:	82 2f       	mov %d15,2
80012068:	2c a4       	st.b [%sp]4,%d15
8001206a:	3c 0f       	j 80012088 <__floatunsidf+0x2a>
8001206c:	82 3f       	mov %d15,3
8001206e:	2c a4       	st.b [%sp]4,%d15
80012070:	0f 04 b0 f1 	clz %d15,%d4
80012074:	1b df 01 60 	addi %d6,%d15,29
80012078:	82 05       	mov %d5,0
8001207a:	6d 00 6e 00 	call 80012156 <__ashldi3>
8001207e:	8b ff 01 f1 	rsub %d15,%d15,31
80012082:	89 a2 50 09 	st.d [%sp]16,%e2
80012086:	78 03       	st.w [%sp]12,%d15
80012088:	d9 a4 04 00 	lea %a4,[%sp]4
8001208c:	1d 00 85 00 	j 80012196 <__pack_d>

80012090 <__udivdi3>:
80012090:	0f 67 a0 20 	or %d2,%d7,%d6
80012094:	0b 45 10 a8 	mov %e10,%d5,%d4
80012098:	02 6f       	mov %d15,%d6
8001209a:	02 7c       	mov %d12,%d7
8001209c:	d2 f8       	mov %e8,-1
8001209e:	df 02 46 00 	jeq %d2,0,8001212a <__udivdi3+0x9a>
800120a2:	8f 07 40 21 	or %d2,%d7,0
800120a6:	f6 2d       	jnz %d2,800120c0 <__udivdi3+0x30>
800120a8:	4b 6b 11 82 	div.u %e8,%d11,%d6
800120ac:	d2 04       	mov %e4,0
800120ae:	02 a4       	mov %d4,%d10
800120b0:	42 95       	add %d5,%d9
800120b2:	6d 00 a4 01 	call 800123fa <__udiv6432>
800120b6:	82 04       	mov %d4,0
800120b8:	02 85       	mov %d5,%d8
800120ba:	13 12 40 84 	madd.u %e8,%e4,%d2,1
800120be:	3c 36       	j 8001212a <__udivdi3+0x9a>
800120c0:	0b 7b 00 21 	eq %d2,%d11,%d7
800120c4:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
800120c8:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
800120cc:	d2 08       	mov %e8,0
800120ce:	df 02 2e 80 	jne %d2,0,8001212a <__udivdi3+0x9a>
800120d2:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
800120d6:	0f 07 b0 d1 	clz %d13,%d7
800120da:	60 5f       	mov.a %a15,%d5
800120dc:	0b 67 10 48 	mov %e4,%d7,%d6
800120e0:	02 d6       	mov %d6,%d13
800120e2:	6d 00 3a 00 	call 80012156 <__ashldi3>
800120e6:	8f fb 1f e0 	sh %d14,%d11,-1
800120ea:	80 f4       	mov.d %d4,%a15
800120ec:	02 36       	mov %d6,%d3
800120ee:	02 e5       	mov %d5,%d14
800120f0:	6d 00 85 01 	call 800123fa <__udiv6432>
800120f4:	8b fd 01 d1 	rsub %d13,%d13,31
800120f8:	8b 0d 00 31 	rsub %d3,%d13,0
800120fc:	0f 32 00 30 	sh %d3,%d2,%d3
80012100:	02 32       	mov %d2,%d3
80012102:	8b f2 9f 80 	addx %d8,%d2,-1
80012106:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
8001210a:	82 03       	mov %d3,0
8001210c:	8b f3 bf 90 	addc %d9,%d3,-1
80012110:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
80012114:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
80012118:	0b cb 00 41 	eq %d4,%d11,%d12
8001211c:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
80012120:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
80012124:	f6 43       	jnz %d4,8001212a <__udivdi3+0x9a>
80012126:	0b 23 10 88 	mov %e8,%d3,%d2
8001212a:	0b 89 10 28 	mov %e2,%d9,%d8
8001212e:	00 90       	ret 

80012130 <__umoddi3>:
80012130:	0f 67 a0 90 	or %d9,%d7,%d6
80012134:	02 6f       	mov %d15,%d6
80012136:	d2 00       	mov %e0,0
80012138:	76 9c       	jz %d9,80012150 <__umoddi3+0x20>
8001213a:	02 7a       	mov %d10,%d7
8001213c:	0b 45 10 88 	mov %e8,%d5,%d4
80012140:	6d ff a8 ff 	call 80012090 <__udivdi3>
80012144:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
80012148:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
8001214c:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
80012150:	0b 01 10 28 	mov %e2,%d1,%d0
80012154:	00 90       	ret 

80012156 <__ashldi3>:
80012156:	6f 56 07 80 	jnz.t %d6,5,80012164 <__ashldi3+0xe>
8001215a:	0f 64 00 20 	sh %d2,%d4,%d6
8001215e:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
80012162:	00 90       	ret 
80012164:	8b 06 1e 60 	add %d6,%d6,-32
80012168:	82 02       	mov %d2,0
8001216a:	0f 64 00 30 	sh %d3,%d4,%d6
8001216e:	00 90       	ret 

80012170 <__lshrdi3>:
80012170:	6f 56 0c 80 	jnz.t %d6,5,80012188 <__lshrdi3+0x18>
80012174:	8b 06 02 71 	rsub %d7,%d6,32
80012178:	32 56       	rsub %d6
8001217a:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
8001217e:	0f 65 00 30 	sh %d3,%d5,%d6
80012182:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
80012186:	00 90       	ret 
80012188:	8b 06 02 60 	add %d6,%d6,32
8001218c:	32 56       	rsub %d6
8001218e:	0f 65 00 20 	sh %d2,%d5,%d6
80012192:	82 03       	mov %d3,0
80012194:	00 90       	ret 

80012196 <__pack_d>:
80012196:	14 42       	ld.bu %d2,[%a4]
80012198:	19 49 0c 00 	ld.w %d9,[%a4]12
8001219c:	19 48 10 00 	ld.w %d8,[%a4]16
800121a0:	19 4c 04 00 	ld.w %d12,[%a4]4
800121a4:	ff 22 0b 80 	jge.u %d2,2,800121ba <__pack_d+0x24>
800121a8:	77 98 00 9c 	dextr %d9,%d8,%d9,24
800121ac:	06 88       	sh %d8,-8
800121ae:	02 95       	mov %d5,%d9
800121b0:	b7 18 8d 49 	insert %d4,%d8,1,19,13
800121b4:	3b f0 7f f0 	mov %d15,2047
800121b8:	3c 6f       	j 80012296 <__pack_d+0x100>
800121ba:	3b f0 7f f0 	mov %d15,2047
800121be:	d2 04       	mov %e4,0
800121c0:	df 42 6b 00 	jeq %d2,4,80012296 <__pack_d+0x100>
800121c4:	0f 89 a0 f0 	or %d15,%d9,%d8
800121c8:	8b 22 00 32 	eq %d3,%d2,2
800121cc:	8b 0f e0 34 	or.eq %d3,%d15,0
800121d0:	82 0f       	mov %d15,0
800121d2:	df 03 62 80 	jne %d3,0,80012296 <__pack_d+0x100>
800121d6:	19 42 08 00 	ld.w %d2,[%a4]8
800121da:	3b 20 c0 ff 	mov %d15,-1022
800121de:	7f f2 36 00 	jge %d2,%d15,8001224a <__pack_d+0xb4>
800121e2:	a2 2f       	sub %d15,%d2
800121e4:	8b 9f 83 42 	ge %d4,%d15,57
800121e8:	82 02       	mov %d2,0
800121ea:	df 04 18 80 	jne %d4,0,8001221a <__pack_d+0x84>
800121ee:	0b 98 10 48 	mov %e4,%d8,%d9
800121f2:	02 f6       	mov %d6,%d15
800121f4:	6d ff be ff 	call 80012170 <__lshrdi3>
800121f8:	d2 14       	mov %e4,1
800121fa:	02 f6       	mov %d6,%d15
800121fc:	0b 32 10 a8 	mov %e10,%d2,%d3
80012200:	6d ff ab ff 	call 80012156 <__ashldi3>
80012204:	8b f2 9f 20 	addx %d2,%d2,-1
80012208:	8b f3 bf 30 	addc %d3,%d3,-1
8001220c:	26 29       	and %d9,%d2
8001220e:	26 38       	and %d8,%d3
80012210:	a6 98       	or %d8,%d9
80012212:	02 b2       	mov %d2,%d11
80012214:	8b 08 00 25 	or.ne %d2,%d8,0
80012218:	02 a3       	mov %d3,%d10
8001221a:	02 2f       	mov %d15,%d2
8001221c:	16 ff       	and %d15,255
8001221e:	8b 0f 28 f2 	ne %d15,%d15,128
80012222:	ee 07       	jnz %d15,80012230 <__pack_d+0x9a>
80012224:	8f 02 10 f1 	and %d15,%d2,256
80012228:	6e 08       	jz %d15,80012238 <__pack_d+0xa2>
8001222a:	8b 02 88 20 	addx %d2,%d2,128
8001222e:	3c 03       	j 80012234 <__pack_d+0x9e>
80012230:	8b f2 87 20 	addx %d2,%d2,127
80012234:	8b 03 a0 30 	addc %d3,%d3,0
80012238:	7b 00 00 41 	movh %d4,4096
8001223c:	0b 43 50 f1 	ge.u %d15,%d3,%d4
80012240:	77 23 00 5c 	dextr %d5,%d3,%d2,24
80012244:	8f 83 1f 40 	sh %d4,%d3,-8
80012248:	3c 27       	j 80012296 <__pack_d+0x100>
8001224a:	3b 00 40 30 	mov %d3,1024
8001224e:	3b f0 7f f0 	mov %d15,2047
80012252:	7f 32 22 00 	jge %d2,%d3,80012296 <__pack_d+0x100>
80012256:	02 9f       	mov %d15,%d9
80012258:	16 ff       	and %d15,255
8001225a:	8b 0f 28 f2 	ne %d15,%d15,128
8001225e:	ee 07       	jnz %d15,8001226c <__pack_d+0xd6>
80012260:	8f 09 10 f1 	and %d15,%d9,256
80012264:	6e 08       	jz %d15,80012274 <__pack_d+0xde>
80012266:	8b 09 88 90 	addx %d9,%d9,128
8001226a:	3c 03       	j 80012270 <__pack_d+0xda>
8001226c:	8b f9 87 90 	addx %d9,%d9,127
80012270:	8b 08 a0 80 	addc %d8,%d8,0
80012274:	7b 00 00 32 	movh %d3,8192
80012278:	0b 38 50 f1 	ge.u %d15,%d8,%d3
8001227c:	ee 04       	jnz %d15,80012284 <__pack_d+0xee>
8001227e:	1b f2 3f f0 	addi %d15,%d2,1023
80012282:	3c 06       	j 8001228e <__pack_d+0xf8>
80012284:	77 98 80 9f 	dextr %d9,%d8,%d9,31
80012288:	1b 02 40 f0 	addi %d15,%d2,1024
8001228c:	06 f8       	sh %d8,-1
8001228e:	77 98 00 5c 	dextr %d5,%d8,%d9,24
80012292:	8f 88 1f 40 	sh %d4,%d8,-8
80012296:	d2 02       	mov %e2,0
80012298:	37 43 14 40 	insert %d4,%d3,%d4,0,20
8001229c:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
800122a0:	02 52       	mov %d2,%d5
800122a2:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
800122a6:	00 90       	ret 

800122a8 <__unpack_d>:
800122a8:	19 44 04 00 	ld.w %d4,[%a4]4
800122ac:	54 42       	ld.w %d2,[%a4]
800122ae:	37 04 74 50 	extr.u %d5,%d4,0,20
800122b2:	37 04 6b fa 	extr.u %d15,%d4,20,11
800122b6:	8f 14 1e 40 	sh %d4,%d4,-31
800122ba:	59 54 04 00 	st.w [%a5]4,%d4
800122be:	02 53       	mov %d3,%d5
800122c0:	ee 21       	jnz %d15,80012302 <__unpack_d+0x5a>
800122c2:	0f 25 a0 f0 	or %d15,%d5,%d2
800122c6:	ee 03       	jnz %d15,800122cc <__unpack_d+0x24>
800122c8:	82 2f       	mov %d15,2
800122ca:	3c 23       	j 80012310 <__unpack_d+0x68>
800122cc:	3b 20 c0 ff 	mov %d15,-1022
800122d0:	6c 52       	st.w [%a5]8,%d15
800122d2:	82 3f       	mov %d15,3
800122d4:	77 25 00 34 	dextr %d3,%d5,%d2,8
800122d8:	2c 50       	st.b [%a5]0,%d15
800122da:	8f 82 00 20 	sh %d2,%d2,8
800122de:	3b 10 c0 ff 	mov %d15,-1023
800122e2:	77 23 80 30 	dextr %d3,%d3,%d2,1
800122e6:	7b 00 00 61 	movh %d6,4096
800122ea:	0b 63 30 51 	lt.u %d5,%d3,%d6
800122ee:	02 f4       	mov %d4,%d15
800122f0:	06 12       	sh %d2,1
800122f2:	c2 ff       	add %d15,-1
800122f4:	df 05 f7 ff 	jne %d5,0,800122e2 <__unpack_d+0x3a>
800122f8:	59 54 08 00 	st.w [%a5]8,%d4
800122fc:	59 52 0c 00 	st.w [%a5]12,%d2
80012300:	3c 27       	j 8001234e <__unpack_d+0xa6>
80012302:	3b f0 7f 40 	mov %d4,2047
80012306:	fe 47       	jne %d15,%d4,80012334 <__unpack_d+0x8c>
80012308:	0f 25 a0 f0 	or %d15,%d5,%d2
8001230c:	ee 04       	jnz %d15,80012314 <__unpack_d+0x6c>
8001230e:	82 4f       	mov %d15,4
80012310:	2c 50       	st.b [%a5]0,%d15
80012312:	00 90       	ret 
80012314:	7b 80 00 f0 	movh %d15,8
80012318:	26 5f       	and %d15,%d5
8001231a:	6e 02       	jz %d15,8001231e <__unpack_d+0x76>
8001231c:	82 1f       	mov %d15,1
8001231e:	2c 50       	st.b [%a5]0,%d15
80012320:	b7 03 81 f9 	insert %d15,%d3,0,19,1
80012324:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
80012328:	8f 82 00 40 	sh %d4,%d2,8
8001232c:	59 54 0c 00 	st.w [%a5]12,%d4
80012330:	6c 54       	st.w [%a5]16,%d15
80012332:	00 90       	ret 
80012334:	1b 1f c0 ff 	addi %d15,%d15,-1023
80012338:	77 25 00 34 	dextr %d3,%d5,%d2,8
8001233c:	6c 52       	st.w [%a5]8,%d15
8001233e:	8f 82 00 20 	sh %d2,%d2,8
80012342:	82 3f       	mov %d15,3
80012344:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
80012348:	2c 50       	st.b [%a5]0,%d15
8001234a:	59 52 0c 00 	st.w [%a5]12,%d2
8001234e:	59 53 10 00 	st.w [%a5]16,%d3
80012352:	00 90       	ret 

80012354 <__fpcmp_parts_d>:
80012354:	14 43       	ld.bu %d3,[%a4]
80012356:	82 12       	mov %d2,1
80012358:	bf 23 50 80 	jlt.u %d3,2,800123f8 <__fpcmp_parts_d+0xa4>
8001235c:	0c 50       	ld.bu %d15,[%a5]0
8001235e:	bf 2f 4d 80 	jlt.u %d15,2,800123f8 <__fpcmp_parts_d+0xa4>
80012362:	8b 43 00 42 	eq %d4,%d3,4
80012366:	8b 4f 00 22 	eq %d2,%d15,4
8001236a:	0f 24 80 50 	and %d5,%d4,%d2
8001236e:	76 56       	jz %d5,8001237a <__fpcmp_parts_d+0x26>
80012370:	19 52 04 00 	ld.w %d2,[%a5]4
80012374:	4c 41       	ld.w %d15,[%a4]4
80012376:	a2 f2       	sub %d2,%d15
80012378:	00 90       	ret 
8001237a:	76 47       	jz %d4,80012388 <__fpcmp_parts_d+0x34>
8001237c:	19 42 04 00 	ld.w %d2,[%a4]4
80012380:	82 1f       	mov %d15,1
80012382:	ab ff bf 22 	seln %d2,%d2,%d15,-1
80012386:	00 90       	ret 
80012388:	76 27       	jz %d2,80012396 <__fpcmp_parts_d+0x42>
8001238a:	19 52 04 00 	ld.w %d2,[%a5]4
8001238e:	82 ff       	mov %d15,-1
80012390:	ab 1f a0 22 	seln %d2,%d2,%d15,1
80012394:	00 90       	ret 
80012396:	df 23 06 80 	jne %d3,2,800123a2 <__fpcmp_parts_d+0x4e>
8001239a:	82 02       	mov %d2,0
8001239c:	df 2f f7 ff 	jne %d15,2,8001238a <__fpcmp_parts_d+0x36>
800123a0:	00 90       	ret 
800123a2:	df 2f ed 7f 	jeq %d15,2,8001237c <__fpcmp_parts_d+0x28>
800123a6:	19 45 04 00 	ld.w %d5,[%a4]4
800123aa:	4c 51       	ld.w %d15,[%a5]4
800123ac:	5f f5 19 80 	jne %d5,%d15,800123de <__fpcmp_parts_d+0x8a>
800123b0:	19 42 08 00 	ld.w %d2,[%a4]8
800123b4:	4c 52       	ld.w %d15,[%a5]8
800123b6:	3f 2f 14 00 	jlt %d15,%d2,800123de <__fpcmp_parts_d+0x8a>
800123ba:	3f f2 1c 00 	jlt %d2,%d15,800123f2 <__fpcmp_parts_d+0x9e>
800123be:	19 43 10 00 	ld.w %d3,[%a4]16
800123c2:	19 54 10 00 	ld.w %d4,[%a5]16
800123c6:	19 47 0c 00 	ld.w %d7,[%a4]12
800123ca:	19 56 0c 00 	ld.w %d6,[%a5]12
800123ce:	0b 43 00 21 	eq %d2,%d3,%d4
800123d2:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
800123d6:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
800123da:	3a 43       	eq %d15,%d3,%d4
800123dc:	f6 25       	jnz %d2,800123e6 <__fpcmp_parts_d+0x92>
800123de:	82 12       	mov %d2,1
800123e0:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
800123e4:	00 90       	ret 
800123e6:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
800123ea:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
800123ee:	82 02       	mov %d2,0
800123f0:	ee 04       	jnz %d15,800123f8 <__fpcmp_parts_d+0xa4>
800123f2:	82 f2       	mov %d2,-1
800123f4:	ab 12 a0 25 	seln %d2,%d5,%d2,1
800123f8:	00 90       	ret 

800123fa <__udiv6432>:
800123fa:	02 53       	mov %d3,%d5
800123fc:	82 f2       	mov %d2,-1
800123fe:	7f 65 4b 80 	jge.u %d5,%d6,80012494 <__udiv6432+0x9a>
80012402:	0f 06 b0 21 	clz %d2,%d6
80012406:	0f 26 00 60 	sh %d6,%d6,%d2
8001240a:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
8001240e:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
80012412:	8f 06 1f 70 	sh %d7,%d6,-16
80012416:	4b 73 11 02 	div.u %e0,%d3,%d7
8001241a:	b7 06 10 88 	insert %d8,%d6,0,16,16
8001241e:	0f 24 00 20 	sh %d2,%d4,%d2
80012422:	02 05       	mov %d5,%d0
80012424:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
80012428:	e2 80       	mul %d0,%d8
8001242a:	8f 02 1f b0 	sh %d11,%d2,-16
8001242e:	b7 02 10 28 	insert %d2,%d2,0,16,16
80012432:	82 0c       	mov %d12,0
80012434:	7b 10 00 90 	movh %d9,1
80012438:	7f 95 09 80 	jge.u %d5,%d9,8001244a <__udiv6432+0x50>
8001243c:	8f 01 01 f0 	sh %d15,%d1,16
80012440:	0b 0c 00 a0 	add %d10,%d12,%d0
80012444:	42 bf       	add %d15,%d11
80012446:	7f af 07 80 	jge.u %d15,%d10,80012454 <__udiv6432+0x5a>
8001244a:	42 71       	add %d1,%d7
8001244c:	c2 f5       	add %d5,-1
8001244e:	a2 8c       	sub %d12,%d8
80012450:	3f 91 f4 ff 	jlt.u %d1,%d9,80012438 <__udiv6432+0x3e>
80012454:	8f 03 01 30 	sh %d3,%d3,16
80012458:	42 3b       	add %d11,%d3
8001245a:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
8001245e:	82 0a       	mov %d10,0
80012460:	4b 76 11 02 	div.u %e0,%d6,%d7
80012464:	7b 10 00 10 	movh %d1,1
80012468:	02 03       	mov %d3,%d0
8001246a:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
8001246e:	e2 80       	mul %d0,%d8
80012470:	7f 13 09 80 	jge.u %d3,%d1,80012482 <__udiv6432+0x88>
80012474:	8f 06 01 f0 	sh %d15,%d6,16
80012478:	0b 0a 00 90 	add %d9,%d10,%d0
8001247c:	42 2f       	add %d15,%d2
8001247e:	7f 9f 07 80 	jge.u %d15,%d9,8001248c <__udiv6432+0x92>
80012482:	42 76       	add %d6,%d7
80012484:	c2 f3       	add %d3,-1
80012486:	a2 8a       	sub %d10,%d8
80012488:	3f 16 f4 ff 	jlt.u %d6,%d1,80012470 <__udiv6432+0x76>
8001248c:	8f 05 01 50 	sh %d5,%d5,16
80012490:	0b 53 00 20 	add %d2,%d3,%d5
80012494:	00 90       	ret 
	...

Disassembly of section .inttab:

50100000 <TriCore_int_table>:
50100000:	00 a0       	debug 
	...

50100020 <___interrupt_1>:
50100020:	9d 80 90 71 	ja 8000e320 <__interrupt_1>
	...

50100040 <__interrupt_2>:
50100040:	e0 02       	bisr 2
50100042:	91 00 00 f7 	movh.a %a15,28672
50100046:	d9 ff 78 34 	lea %a15,[%a15]17656 <700044f8 <Cdisptab+0x10>>
5010004a:	c4 fe       	ld.a %a14,[%a15+]
5010004c:	54 f4       	ld.w %d4,[%a15]
5010004e:	2d 0e 00 00 	calli %a14
50100052:	0d 00 40 02 	rslcx 
50100056:	00 80       	rfe 
	...

50100060 <__interrupt_3>:
50100060:	e0 03       	bisr 3
50100062:	91 00 00 f7 	movh.a %a15,28672
50100066:	d9 ff 40 44 	lea %a15,[%a15]17664 <70004500 <Cdisptab+0x18>>
5010006a:	c4 fe       	ld.a %a14,[%a15+]
5010006c:	54 f4       	ld.w %d4,[%a15]
5010006e:	2d 0e 00 00 	calli %a14
50100072:	0d 00 40 02 	rslcx 
50100076:	00 80       	rfe 
	...

50100080 <__interrupt_4>:
50100080:	e0 04       	bisr 4
50100082:	91 00 00 f7 	movh.a %a15,28672
50100086:	d9 ff 48 44 	lea %a15,[%a15]17672 <70004508 <Cdisptab+0x20>>
5010008a:	c4 fe       	ld.a %a14,[%a15+]
5010008c:	54 f4       	ld.w %d4,[%a15]
5010008e:	2d 0e 00 00 	calli %a14
50100092:	0d 00 40 02 	rslcx 
50100096:	00 80       	rfe 
	...

501000a0 <__interrupt_5>:
501000a0:	e0 05       	bisr 5
501000a2:	91 00 00 f7 	movh.a %a15,28672
501000a6:	d9 ff 50 44 	lea %a15,[%a15]17680 <70004510 <Cdisptab+0x28>>
501000aa:	c4 fe       	ld.a %a14,[%a15+]
501000ac:	54 f4       	ld.w %d4,[%a15]
501000ae:	2d 0e 00 00 	calli %a14
501000b2:	0d 00 40 02 	rslcx 
501000b6:	00 80       	rfe 
	...

501000c0 <__interrupt_6>:
501000c0:	e0 06       	bisr 6
501000c2:	91 00 00 f7 	movh.a %a15,28672
501000c6:	d9 ff 58 44 	lea %a15,[%a15]17688 <70004518 <Cdisptab+0x30>>
501000ca:	c4 fe       	ld.a %a14,[%a15+]
501000cc:	54 f4       	ld.w %d4,[%a15]
501000ce:	2d 0e 00 00 	calli %a14
501000d2:	0d 00 40 02 	rslcx 
501000d6:	00 80       	rfe 
	...

501000e0 <__interrupt_7>:
501000e0:	e0 07       	bisr 7
501000e2:	91 00 00 f7 	movh.a %a15,28672
501000e6:	d9 ff 60 44 	lea %a15,[%a15]17696 <70004520 <Cdisptab+0x38>>
501000ea:	c4 fe       	ld.a %a14,[%a15+]
501000ec:	54 f4       	ld.w %d4,[%a15]
501000ee:	2d 0e 00 00 	calli %a14
501000f2:	0d 00 40 02 	rslcx 
501000f6:	00 80       	rfe 
	...

50100100 <__interrupt_8>:
50100100:	e0 08       	bisr 8
50100102:	91 00 00 f7 	movh.a %a15,28672
50100106:	d9 ff 68 44 	lea %a15,[%a15]17704 <70004528 <Cdisptab+0x40>>
5010010a:	c4 fe       	ld.a %a14,[%a15+]
5010010c:	54 f4       	ld.w %d4,[%a15]
5010010e:	2d 0e 00 00 	calli %a14
50100112:	0d 00 40 02 	rslcx 
50100116:	00 80       	rfe 
	...

50100120 <__interrupt_9>:
50100120:	e0 09       	bisr 9
50100122:	91 00 00 f7 	movh.a %a15,28672
50100126:	d9 ff 70 44 	lea %a15,[%a15]17712 <70004530 <Cdisptab+0x48>>
5010012a:	c4 fe       	ld.a %a14,[%a15+]
5010012c:	54 f4       	ld.w %d4,[%a15]
5010012e:	2d 0e 00 00 	calli %a14
50100132:	0d 00 40 02 	rslcx 
50100136:	00 80       	rfe 
	...

50100140 <__interrupt_10>:
50100140:	e0 0a       	bisr 10
50100142:	91 00 00 f7 	movh.a %a15,28672
50100146:	d9 ff 78 44 	lea %a15,[%a15]17720 <70004538 <Cdisptab+0x50>>
5010014a:	c4 fe       	ld.a %a14,[%a15+]
5010014c:	54 f4       	ld.w %d4,[%a15]
5010014e:	2d 0e 00 00 	calli %a14
50100152:	0d 00 40 02 	rslcx 
50100156:	00 80       	rfe 
	...

50100160 <__interrupt_11>:
50100160:	e0 0b       	bisr 11
50100162:	91 00 00 f7 	movh.a %a15,28672
50100166:	d9 ff 40 54 	lea %a15,[%a15]17728 <70004540 <Cdisptab+0x58>>
5010016a:	c4 fe       	ld.a %a14,[%a15+]
5010016c:	54 f4       	ld.w %d4,[%a15]
5010016e:	2d 0e 00 00 	calli %a14
50100172:	0d 00 40 02 	rslcx 
50100176:	00 80       	rfe 
	...

50100180 <__interrupt_12>:
50100180:	e0 0c       	bisr 12
50100182:	91 00 00 f7 	movh.a %a15,28672
50100186:	d9 ff 48 54 	lea %a15,[%a15]17736 <70004548 <Cdisptab+0x60>>
5010018a:	c4 fe       	ld.a %a14,[%a15+]
5010018c:	54 f4       	ld.w %d4,[%a15]
5010018e:	2d 0e 00 00 	calli %a14
50100192:	0d 00 40 02 	rslcx 
50100196:	00 80       	rfe 
	...

501001a0 <__interrupt_13>:
501001a0:	e0 0d       	bisr 13
501001a2:	91 00 00 f7 	movh.a %a15,28672
501001a6:	d9 ff 50 54 	lea %a15,[%a15]17744 <70004550 <Cdisptab+0x68>>
501001aa:	c4 fe       	ld.a %a14,[%a15+]
501001ac:	54 f4       	ld.w %d4,[%a15]
501001ae:	2d 0e 00 00 	calli %a14
501001b2:	0d 00 40 02 	rslcx 
501001b6:	00 80       	rfe 
	...

501001c0 <__interrupt_14>:
501001c0:	e0 0e       	bisr 14
501001c2:	91 00 00 f7 	movh.a %a15,28672
501001c6:	d9 ff 58 54 	lea %a15,[%a15]17752 <70004558 <Cdisptab+0x70>>
501001ca:	c4 fe       	ld.a %a14,[%a15+]
501001cc:	54 f4       	ld.w %d4,[%a15]
501001ce:	2d 0e 00 00 	calli %a14
501001d2:	0d 00 40 02 	rslcx 
501001d6:	00 80       	rfe 
	...

501001e0 <__interrupt_15>:
501001e0:	e0 0f       	bisr 15
501001e2:	91 00 00 f7 	movh.a %a15,28672
501001e6:	d9 ff 60 54 	lea %a15,[%a15]17760 <70004560 <Cdisptab+0x78>>
501001ea:	c4 fe       	ld.a %a14,[%a15+]
501001ec:	54 f4       	ld.w %d4,[%a15]
501001ee:	2d 0e 00 00 	calli %a14
501001f2:	0d 00 40 02 	rslcx 
501001f6:	00 80       	rfe 
	...

50100200 <__interrupt_16>:
50100200:	e0 10       	bisr 16
50100202:	91 00 00 f7 	movh.a %a15,28672
50100206:	d9 ff 68 54 	lea %a15,[%a15]17768 <70004568 <Cdisptab+0x80>>
5010020a:	c4 fe       	ld.a %a14,[%a15+]
5010020c:	54 f4       	ld.w %d4,[%a15]
5010020e:	2d 0e 00 00 	calli %a14
50100212:	0d 00 40 02 	rslcx 
50100216:	00 80       	rfe 
	...

50100220 <__interrupt_17>:
50100220:	e0 11       	bisr 17
50100222:	91 00 00 f7 	movh.a %a15,28672
50100226:	d9 ff 70 54 	lea %a15,[%a15]17776 <70004570 <Cdisptab+0x88>>
5010022a:	c4 fe       	ld.a %a14,[%a15+]
5010022c:	54 f4       	ld.w %d4,[%a15]
5010022e:	2d 0e 00 00 	calli %a14
50100232:	0d 00 40 02 	rslcx 
50100236:	00 80       	rfe 
	...

50100240 <__interrupt_18>:
50100240:	e0 12       	bisr 18
50100242:	91 00 00 f7 	movh.a %a15,28672
50100246:	d9 ff 78 54 	lea %a15,[%a15]17784 <70004578 <Cdisptab+0x90>>
5010024a:	c4 fe       	ld.a %a14,[%a15+]
5010024c:	54 f4       	ld.w %d4,[%a15]
5010024e:	2d 0e 00 00 	calli %a14
50100252:	0d 00 40 02 	rslcx 
50100256:	00 80       	rfe 
	...

50100260 <__interrupt_19>:
50100260:	e0 13       	bisr 19
50100262:	91 00 00 f7 	movh.a %a15,28672
50100266:	d9 ff 40 64 	lea %a15,[%a15]17792 <70004580 <Cdisptab+0x98>>
5010026a:	c4 fe       	ld.a %a14,[%a15+]
5010026c:	54 f4       	ld.w %d4,[%a15]
5010026e:	2d 0e 00 00 	calli %a14
50100272:	0d 00 40 02 	rslcx 
50100276:	00 80       	rfe 
	...

50100280 <__interrupt_20>:
50100280:	e0 14       	bisr 20
50100282:	91 00 00 f7 	movh.a %a15,28672
50100286:	d9 ff 48 64 	lea %a15,[%a15]17800 <70004588 <Cdisptab+0xa0>>
5010028a:	c4 fe       	ld.a %a14,[%a15+]
5010028c:	54 f4       	ld.w %d4,[%a15]
5010028e:	2d 0e 00 00 	calli %a14
50100292:	0d 00 40 02 	rslcx 
50100296:	00 80       	rfe 
	...

501002a0 <__interrupt_21>:
501002a0:	e0 15       	bisr 21
501002a2:	91 00 00 f7 	movh.a %a15,28672
501002a6:	d9 ff 50 64 	lea %a15,[%a15]17808 <70004590 <Cdisptab+0xa8>>
501002aa:	c4 fe       	ld.a %a14,[%a15+]
501002ac:	54 f4       	ld.w %d4,[%a15]
501002ae:	2d 0e 00 00 	calli %a14
501002b2:	0d 00 40 02 	rslcx 
501002b6:	00 80       	rfe 
	...

501002c0 <__interrupt_22>:
501002c0:	e0 16       	bisr 22
501002c2:	91 00 00 f7 	movh.a %a15,28672
501002c6:	d9 ff 58 64 	lea %a15,[%a15]17816 <70004598 <Cdisptab+0xb0>>
501002ca:	c4 fe       	ld.a %a14,[%a15+]
501002cc:	54 f4       	ld.w %d4,[%a15]
501002ce:	2d 0e 00 00 	calli %a14
501002d2:	0d 00 40 02 	rslcx 
501002d6:	00 80       	rfe 
	...

501002e0 <__interrupt_23>:
501002e0:	e0 17       	bisr 23
501002e2:	91 00 00 f7 	movh.a %a15,28672
501002e6:	d9 ff 60 64 	lea %a15,[%a15]17824 <700045a0 <Cdisptab+0xb8>>
501002ea:	c4 fe       	ld.a %a14,[%a15+]
501002ec:	54 f4       	ld.w %d4,[%a15]
501002ee:	2d 0e 00 00 	calli %a14
501002f2:	0d 00 40 02 	rslcx 
501002f6:	00 80       	rfe 
	...

50100300 <__interrupt_24>:
50100300:	e0 18       	bisr 24
50100302:	91 00 00 f7 	movh.a %a15,28672
50100306:	d9 ff 68 64 	lea %a15,[%a15]17832 <700045a8 <Cdisptab+0xc0>>
5010030a:	c4 fe       	ld.a %a14,[%a15+]
5010030c:	54 f4       	ld.w %d4,[%a15]
5010030e:	2d 0e 00 00 	calli %a14
50100312:	0d 00 40 02 	rslcx 
50100316:	00 80       	rfe 
	...

50100320 <__interrupt_25>:
50100320:	e0 19       	bisr 25
50100322:	91 00 00 f7 	movh.a %a15,28672
50100326:	d9 ff 70 64 	lea %a15,[%a15]17840 <700045b0 <Cdisptab+0xc8>>
5010032a:	c4 fe       	ld.a %a14,[%a15+]
5010032c:	54 f4       	ld.w %d4,[%a15]
5010032e:	2d 0e 00 00 	calli %a14
50100332:	0d 00 40 02 	rslcx 
50100336:	00 80       	rfe 
	...

50100340 <__interrupt_26>:
50100340:	e0 1a       	bisr 26
50100342:	91 00 00 f7 	movh.a %a15,28672
50100346:	d9 ff 78 64 	lea %a15,[%a15]17848 <700045b8 <Cdisptab+0xd0>>
5010034a:	c4 fe       	ld.a %a14,[%a15+]
5010034c:	54 f4       	ld.w %d4,[%a15]
5010034e:	2d 0e 00 00 	calli %a14
50100352:	0d 00 40 02 	rslcx 
50100356:	00 80       	rfe 
	...

50100360 <__interrupt_27>:
50100360:	e0 1b       	bisr 27
50100362:	91 00 00 f7 	movh.a %a15,28672
50100366:	d9 ff 40 74 	lea %a15,[%a15]17856 <700045c0 <Cdisptab+0xd8>>
5010036a:	c4 fe       	ld.a %a14,[%a15+]
5010036c:	54 f4       	ld.w %d4,[%a15]
5010036e:	2d 0e 00 00 	calli %a14
50100372:	0d 00 40 02 	rslcx 
50100376:	00 80       	rfe 
	...

50100380 <__interrupt_28>:
50100380:	e0 1c       	bisr 28
50100382:	91 00 00 f7 	movh.a %a15,28672
50100386:	d9 ff 48 74 	lea %a15,[%a15]17864 <700045c8 <Cdisptab+0xe0>>
5010038a:	c4 fe       	ld.a %a14,[%a15+]
5010038c:	54 f4       	ld.w %d4,[%a15]
5010038e:	2d 0e 00 00 	calli %a14
50100392:	0d 00 40 02 	rslcx 
50100396:	00 80       	rfe 
	...

501003a0 <__interrupt_29>:
501003a0:	e0 1d       	bisr 29
501003a2:	91 00 00 f7 	movh.a %a15,28672
501003a6:	d9 ff 50 74 	lea %a15,[%a15]17872 <700045d0 <Cdisptab+0xe8>>
501003aa:	c4 fe       	ld.a %a14,[%a15+]
501003ac:	54 f4       	ld.w %d4,[%a15]
501003ae:	2d 0e 00 00 	calli %a14
501003b2:	0d 00 40 02 	rslcx 
501003b6:	00 80       	rfe 
	...

501003c0 <__interrupt_30>:
501003c0:	e0 1e       	bisr 30
501003c2:	91 00 00 f7 	movh.a %a15,28672
501003c6:	d9 ff 58 74 	lea %a15,[%a15]17880 <700045d8 <Cdisptab+0xf0>>
501003ca:	c4 fe       	ld.a %a14,[%a15+]
501003cc:	54 f4       	ld.w %d4,[%a15]
501003ce:	2d 0e 00 00 	calli %a14
501003d2:	0d 00 40 02 	rslcx 
501003d6:	00 80       	rfe 
	...

501003e0 <__interrupt_31>:
501003e0:	e0 1f       	bisr 31
501003e2:	91 00 00 f7 	movh.a %a15,28672
501003e6:	d9 ff 60 74 	lea %a15,[%a15]17888 <700045e0 <Cdisptab+0xf8>>
501003ea:	c4 fe       	ld.a %a14,[%a15+]
501003ec:	54 f4       	ld.w %d4,[%a15]
501003ee:	2d 0e 00 00 	calli %a14
501003f2:	0d 00 40 02 	rslcx 
501003f6:	00 80       	rfe 
	...

50100400 <__interrupt_32>:
50100400:	e0 20       	bisr 32
50100402:	91 00 00 f7 	movh.a %a15,28672
50100406:	d9 ff 68 74 	lea %a15,[%a15]17896 <700045e8 <Cdisptab+0x100>>
5010040a:	c4 fe       	ld.a %a14,[%a15+]
5010040c:	54 f4       	ld.w %d4,[%a15]
5010040e:	2d 0e 00 00 	calli %a14
50100412:	0d 00 40 02 	rslcx 
50100416:	00 80       	rfe 
	...

50100420 <__interrupt_33>:
50100420:	e0 21       	bisr 33
50100422:	91 00 00 f7 	movh.a %a15,28672
50100426:	d9 ff 70 74 	lea %a15,[%a15]17904 <700045f0 <Cdisptab+0x108>>
5010042a:	c4 fe       	ld.a %a14,[%a15+]
5010042c:	54 f4       	ld.w %d4,[%a15]
5010042e:	2d 0e 00 00 	calli %a14
50100432:	0d 00 40 02 	rslcx 
50100436:	00 80       	rfe 
	...

50100440 <__interrupt_34>:
50100440:	e0 22       	bisr 34
50100442:	91 00 00 f7 	movh.a %a15,28672
50100446:	d9 ff 78 74 	lea %a15,[%a15]17912 <700045f8 <Cdisptab+0x110>>
5010044a:	c4 fe       	ld.a %a14,[%a15+]
5010044c:	54 f4       	ld.w %d4,[%a15]
5010044e:	2d 0e 00 00 	calli %a14
50100452:	0d 00 40 02 	rslcx 
50100456:	00 80       	rfe 
	...

50100460 <__interrupt_35>:
50100460:	e0 23       	bisr 35
50100462:	91 00 00 f7 	movh.a %a15,28672
50100466:	d9 ff 40 84 	lea %a15,[%a15]17920 <70004600 <Cdisptab+0x118>>
5010046a:	c4 fe       	ld.a %a14,[%a15+]
5010046c:	54 f4       	ld.w %d4,[%a15]
5010046e:	2d 0e 00 00 	calli %a14
50100472:	0d 00 40 02 	rslcx 
50100476:	00 80       	rfe 
	...

50100480 <__interrupt_36>:
50100480:	e0 24       	bisr 36
50100482:	91 00 00 f7 	movh.a %a15,28672
50100486:	d9 ff 48 84 	lea %a15,[%a15]17928 <70004608 <Cdisptab+0x120>>
5010048a:	c4 fe       	ld.a %a14,[%a15+]
5010048c:	54 f4       	ld.w %d4,[%a15]
5010048e:	2d 0e 00 00 	calli %a14
50100492:	0d 00 40 02 	rslcx 
50100496:	00 80       	rfe 
	...

501004a0 <__interrupt_37>:
501004a0:	e0 25       	bisr 37
501004a2:	91 00 00 f7 	movh.a %a15,28672
501004a6:	d9 ff 50 84 	lea %a15,[%a15]17936 <70004610 <Cdisptab+0x128>>
501004aa:	c4 fe       	ld.a %a14,[%a15+]
501004ac:	54 f4       	ld.w %d4,[%a15]
501004ae:	2d 0e 00 00 	calli %a14
501004b2:	0d 00 40 02 	rslcx 
501004b6:	00 80       	rfe 
	...

501004c0 <__interrupt_38>:
501004c0:	e0 26       	bisr 38
501004c2:	91 00 00 f7 	movh.a %a15,28672
501004c6:	d9 ff 58 84 	lea %a15,[%a15]17944 <70004618 <Cdisptab+0x130>>
501004ca:	c4 fe       	ld.a %a14,[%a15+]
501004cc:	54 f4       	ld.w %d4,[%a15]
501004ce:	2d 0e 00 00 	calli %a14
501004d2:	0d 00 40 02 	rslcx 
501004d6:	00 80       	rfe 
	...

501004e0 <__interrupt_39>:
501004e0:	e0 27       	bisr 39
501004e2:	91 00 00 f7 	movh.a %a15,28672
501004e6:	d9 ff 60 84 	lea %a15,[%a15]17952 <70004620 <Cdisptab+0x138>>
501004ea:	c4 fe       	ld.a %a14,[%a15+]
501004ec:	54 f4       	ld.w %d4,[%a15]
501004ee:	2d 0e 00 00 	calli %a14
501004f2:	0d 00 40 02 	rslcx 
501004f6:	00 80       	rfe 
	...

50100500 <__interrupt_40>:
50100500:	e0 28       	bisr 40
50100502:	91 00 00 f7 	movh.a %a15,28672
50100506:	d9 ff 68 84 	lea %a15,[%a15]17960 <70004628 <Cdisptab+0x140>>
5010050a:	c4 fe       	ld.a %a14,[%a15+]
5010050c:	54 f4       	ld.w %d4,[%a15]
5010050e:	2d 0e 00 00 	calli %a14
50100512:	0d 00 40 02 	rslcx 
50100516:	00 80       	rfe 
	...

50100520 <__interrupt_41>:
50100520:	e0 29       	bisr 41
50100522:	91 00 00 f7 	movh.a %a15,28672
50100526:	d9 ff 70 84 	lea %a15,[%a15]17968 <70004630 <Cdisptab+0x148>>
5010052a:	c4 fe       	ld.a %a14,[%a15+]
5010052c:	54 f4       	ld.w %d4,[%a15]
5010052e:	2d 0e 00 00 	calli %a14
50100532:	0d 00 40 02 	rslcx 
50100536:	00 80       	rfe 
	...

50100540 <__interrupt_42>:
50100540:	e0 2a       	bisr 42
50100542:	91 00 00 f7 	movh.a %a15,28672
50100546:	d9 ff 78 84 	lea %a15,[%a15]17976 <70004638 <Cdisptab+0x150>>
5010054a:	c4 fe       	ld.a %a14,[%a15+]
5010054c:	54 f4       	ld.w %d4,[%a15]
5010054e:	2d 0e 00 00 	calli %a14
50100552:	0d 00 40 02 	rslcx 
50100556:	00 80       	rfe 
	...

50100560 <__interrupt_43>:
50100560:	e0 2b       	bisr 43
50100562:	91 00 00 f7 	movh.a %a15,28672
50100566:	d9 ff 40 94 	lea %a15,[%a15]17984 <70004640 <Cdisptab+0x158>>
5010056a:	c4 fe       	ld.a %a14,[%a15+]
5010056c:	54 f4       	ld.w %d4,[%a15]
5010056e:	2d 0e 00 00 	calli %a14
50100572:	0d 00 40 02 	rslcx 
50100576:	00 80       	rfe 
	...

50100580 <__interrupt_44>:
50100580:	e0 2c       	bisr 44
50100582:	91 00 00 f7 	movh.a %a15,28672
50100586:	d9 ff 48 94 	lea %a15,[%a15]17992 <70004648 <Cdisptab+0x160>>
5010058a:	c4 fe       	ld.a %a14,[%a15+]
5010058c:	54 f4       	ld.w %d4,[%a15]
5010058e:	2d 0e 00 00 	calli %a14
50100592:	0d 00 40 02 	rslcx 
50100596:	00 80       	rfe 
	...

501005a0 <__interrupt_45>:
501005a0:	e0 2d       	bisr 45
501005a2:	91 00 00 f7 	movh.a %a15,28672
501005a6:	d9 ff 50 94 	lea %a15,[%a15]18000 <70004650 <Cdisptab+0x168>>
501005aa:	c4 fe       	ld.a %a14,[%a15+]
501005ac:	54 f4       	ld.w %d4,[%a15]
501005ae:	2d 0e 00 00 	calli %a14
501005b2:	0d 00 40 02 	rslcx 
501005b6:	00 80       	rfe 
	...

501005c0 <__interrupt_46>:
501005c0:	e0 2e       	bisr 46
501005c2:	91 00 00 f7 	movh.a %a15,28672
501005c6:	d9 ff 58 94 	lea %a15,[%a15]18008 <70004658 <Cdisptab+0x170>>
501005ca:	c4 fe       	ld.a %a14,[%a15+]
501005cc:	54 f4       	ld.w %d4,[%a15]
501005ce:	2d 0e 00 00 	calli %a14
501005d2:	0d 00 40 02 	rslcx 
501005d6:	00 80       	rfe 
	...

501005e0 <__interrupt_47>:
501005e0:	e0 2f       	bisr 47
501005e2:	91 00 00 f7 	movh.a %a15,28672
501005e6:	d9 ff 60 94 	lea %a15,[%a15]18016 <70004660 <Cdisptab+0x178>>
501005ea:	c4 fe       	ld.a %a14,[%a15+]
501005ec:	54 f4       	ld.w %d4,[%a15]
501005ee:	2d 0e 00 00 	calli %a14
501005f2:	0d 00 40 02 	rslcx 
501005f6:	00 80       	rfe 
	...

50100600 <__interrupt_48>:
50100600:	e0 30       	bisr 48
50100602:	91 00 00 f7 	movh.a %a15,28672
50100606:	d9 ff 68 94 	lea %a15,[%a15]18024 <70004668 <Cdisptab+0x180>>
5010060a:	c4 fe       	ld.a %a14,[%a15+]
5010060c:	54 f4       	ld.w %d4,[%a15]
5010060e:	2d 0e 00 00 	calli %a14
50100612:	0d 00 40 02 	rslcx 
50100616:	00 80       	rfe 
	...

50100620 <__interrupt_49>:
50100620:	e0 31       	bisr 49
50100622:	91 00 00 f7 	movh.a %a15,28672
50100626:	d9 ff 70 94 	lea %a15,[%a15]18032 <70004670 <Cdisptab+0x188>>
5010062a:	c4 fe       	ld.a %a14,[%a15+]
5010062c:	54 f4       	ld.w %d4,[%a15]
5010062e:	2d 0e 00 00 	calli %a14
50100632:	0d 00 40 02 	rslcx 
50100636:	00 80       	rfe 
	...

50100640 <__interrupt_50>:
50100640:	e0 32       	bisr 50
50100642:	91 00 00 f7 	movh.a %a15,28672
50100646:	d9 ff 78 94 	lea %a15,[%a15]18040 <70004678 <Cdisptab+0x190>>
5010064a:	c4 fe       	ld.a %a14,[%a15+]
5010064c:	54 f4       	ld.w %d4,[%a15]
5010064e:	2d 0e 00 00 	calli %a14
50100652:	0d 00 40 02 	rslcx 
50100656:	00 80       	rfe 
	...

50100660 <__interrupt_51>:
50100660:	e0 33       	bisr 51
50100662:	91 00 00 f7 	movh.a %a15,28672
50100666:	d9 ff 40 a4 	lea %a15,[%a15]18048 <70004680 <Cdisptab+0x198>>
5010066a:	c4 fe       	ld.a %a14,[%a15+]
5010066c:	54 f4       	ld.w %d4,[%a15]
5010066e:	2d 0e 00 00 	calli %a14
50100672:	0d 00 40 02 	rslcx 
50100676:	00 80       	rfe 
	...

50100680 <__interrupt_52>:
50100680:	e0 34       	bisr 52
50100682:	91 00 00 f7 	movh.a %a15,28672
50100686:	d9 ff 48 a4 	lea %a15,[%a15]18056 <70004688 <Cdisptab+0x1a0>>
5010068a:	c4 fe       	ld.a %a14,[%a15+]
5010068c:	54 f4       	ld.w %d4,[%a15]
5010068e:	2d 0e 00 00 	calli %a14
50100692:	0d 00 40 02 	rslcx 
50100696:	00 80       	rfe 
	...

501006a0 <__interrupt_53>:
501006a0:	e0 35       	bisr 53
501006a2:	91 00 00 f7 	movh.a %a15,28672
501006a6:	d9 ff 50 a4 	lea %a15,[%a15]18064 <70004690 <Cdisptab+0x1a8>>
501006aa:	c4 fe       	ld.a %a14,[%a15+]
501006ac:	54 f4       	ld.w %d4,[%a15]
501006ae:	2d 0e 00 00 	calli %a14
501006b2:	0d 00 40 02 	rslcx 
501006b6:	00 80       	rfe 
	...

501006c0 <__interrupt_54>:
501006c0:	e0 36       	bisr 54
501006c2:	91 00 00 f7 	movh.a %a15,28672
501006c6:	d9 ff 58 a4 	lea %a15,[%a15]18072 <70004698 <Cdisptab+0x1b0>>
501006ca:	c4 fe       	ld.a %a14,[%a15+]
501006cc:	54 f4       	ld.w %d4,[%a15]
501006ce:	2d 0e 00 00 	calli %a14
501006d2:	0d 00 40 02 	rslcx 
501006d6:	00 80       	rfe 
	...

501006e0 <__interrupt_55>:
501006e0:	e0 37       	bisr 55
501006e2:	91 00 00 f7 	movh.a %a15,28672
501006e6:	d9 ff 60 a4 	lea %a15,[%a15]18080 <700046a0 <Cdisptab+0x1b8>>
501006ea:	c4 fe       	ld.a %a14,[%a15+]
501006ec:	54 f4       	ld.w %d4,[%a15]
501006ee:	2d 0e 00 00 	calli %a14
501006f2:	0d 00 40 02 	rslcx 
501006f6:	00 80       	rfe 
	...

50100700 <__interrupt_56>:
50100700:	e0 38       	bisr 56
50100702:	91 00 00 f7 	movh.a %a15,28672
50100706:	d9 ff 68 a4 	lea %a15,[%a15]18088 <700046a8 <Cdisptab+0x1c0>>
5010070a:	c4 fe       	ld.a %a14,[%a15+]
5010070c:	54 f4       	ld.w %d4,[%a15]
5010070e:	2d 0e 00 00 	calli %a14
50100712:	0d 00 40 02 	rslcx 
50100716:	00 80       	rfe 
	...

50100720 <__interrupt_57>:
50100720:	e0 39       	bisr 57
50100722:	91 00 00 f7 	movh.a %a15,28672
50100726:	d9 ff 70 a4 	lea %a15,[%a15]18096 <700046b0 <Cdisptab+0x1c8>>
5010072a:	c4 fe       	ld.a %a14,[%a15+]
5010072c:	54 f4       	ld.w %d4,[%a15]
5010072e:	2d 0e 00 00 	calli %a14
50100732:	0d 00 40 02 	rslcx 
50100736:	00 80       	rfe 
	...

50100740 <__interrupt_58>:
50100740:	e0 3a       	bisr 58
50100742:	91 00 00 f7 	movh.a %a15,28672
50100746:	d9 ff 78 a4 	lea %a15,[%a15]18104 <700046b8 <Cdisptab+0x1d0>>
5010074a:	c4 fe       	ld.a %a14,[%a15+]
5010074c:	54 f4       	ld.w %d4,[%a15]
5010074e:	2d 0e 00 00 	calli %a14
50100752:	0d 00 40 02 	rslcx 
50100756:	00 80       	rfe 
	...

50100760 <__interrupt_59>:
50100760:	e0 3b       	bisr 59
50100762:	91 00 00 f7 	movh.a %a15,28672
50100766:	d9 ff 40 b4 	lea %a15,[%a15]18112 <700046c0 <Cdisptab+0x1d8>>
5010076a:	c4 fe       	ld.a %a14,[%a15+]
5010076c:	54 f4       	ld.w %d4,[%a15]
5010076e:	2d 0e 00 00 	calli %a14
50100772:	0d 00 40 02 	rslcx 
50100776:	00 80       	rfe 
	...

50100780 <__interrupt_60>:
50100780:	e0 3c       	bisr 60
50100782:	91 00 00 f7 	movh.a %a15,28672
50100786:	d9 ff 48 b4 	lea %a15,[%a15]18120 <700046c8 <Cdisptab+0x1e0>>
5010078a:	c4 fe       	ld.a %a14,[%a15+]
5010078c:	54 f4       	ld.w %d4,[%a15]
5010078e:	2d 0e 00 00 	calli %a14
50100792:	0d 00 40 02 	rslcx 
50100796:	00 80       	rfe 
	...

501007a0 <__interrupt_61>:
501007a0:	e0 3d       	bisr 61
501007a2:	91 00 00 f7 	movh.a %a15,28672
501007a6:	d9 ff 50 b4 	lea %a15,[%a15]18128 <700046d0 <Cdisptab+0x1e8>>
501007aa:	c4 fe       	ld.a %a14,[%a15+]
501007ac:	54 f4       	ld.w %d4,[%a15]
501007ae:	2d 0e 00 00 	calli %a14
501007b2:	0d 00 40 02 	rslcx 
501007b6:	00 80       	rfe 
	...

501007c0 <__interrupt_62>:
501007c0:	e0 3e       	bisr 62
501007c2:	91 00 00 f7 	movh.a %a15,28672
501007c6:	d9 ff 58 b4 	lea %a15,[%a15]18136 <700046d8 <Cdisptab+0x1f0>>
501007ca:	c4 fe       	ld.a %a14,[%a15+]
501007cc:	54 f4       	ld.w %d4,[%a15]
501007ce:	2d 0e 00 00 	calli %a14
501007d2:	0d 00 40 02 	rslcx 
501007d6:	00 80       	rfe 
	...

501007e0 <__interrupt_63>:
501007e0:	e0 3f       	bisr 63
501007e2:	91 00 00 f7 	movh.a %a15,28672
501007e6:	d9 ff 60 b4 	lea %a15,[%a15]18144 <700046e0 <Cdisptab+0x1f8>>
501007ea:	c4 fe       	ld.a %a14,[%a15+]
501007ec:	54 f4       	ld.w %d4,[%a15]
501007ee:	2d 0e 00 00 	calli %a14
501007f2:	0d 00 40 02 	rslcx 
501007f6:	00 80       	rfe 
	...

50100800 <__interrupt_64>:
50100800:	e0 40       	bisr 64
50100802:	91 00 00 f7 	movh.a %a15,28672
50100806:	d9 ff 68 b4 	lea %a15,[%a15]18152 <700046e8 <Cdisptab+0x200>>
5010080a:	c4 fe       	ld.a %a14,[%a15+]
5010080c:	54 f4       	ld.w %d4,[%a15]
5010080e:	2d 0e 00 00 	calli %a14
50100812:	0d 00 40 02 	rslcx 
50100816:	00 80       	rfe 
	...

50100820 <__interrupt_65>:
50100820:	e0 41       	bisr 65
50100822:	91 00 00 f7 	movh.a %a15,28672
50100826:	d9 ff 70 b4 	lea %a15,[%a15]18160 <700046f0 <Cdisptab+0x208>>
5010082a:	c4 fe       	ld.a %a14,[%a15+]
5010082c:	54 f4       	ld.w %d4,[%a15]
5010082e:	2d 0e 00 00 	calli %a14
50100832:	0d 00 40 02 	rslcx 
50100836:	00 80       	rfe 
	...

50100840 <__interrupt_66>:
50100840:	e0 42       	bisr 66
50100842:	91 00 00 f7 	movh.a %a15,28672
50100846:	d9 ff 78 b4 	lea %a15,[%a15]18168 <700046f8 <Cdisptab+0x210>>
5010084a:	c4 fe       	ld.a %a14,[%a15+]
5010084c:	54 f4       	ld.w %d4,[%a15]
5010084e:	2d 0e 00 00 	calli %a14
50100852:	0d 00 40 02 	rslcx 
50100856:	00 80       	rfe 
	...

50100860 <__interrupt_67>:
50100860:	e0 43       	bisr 67
50100862:	91 00 00 f7 	movh.a %a15,28672
50100866:	d9 ff 40 c4 	lea %a15,[%a15]18176 <70004700 <Cdisptab+0x218>>
5010086a:	c4 fe       	ld.a %a14,[%a15+]
5010086c:	54 f4       	ld.w %d4,[%a15]
5010086e:	2d 0e 00 00 	calli %a14
50100872:	0d 00 40 02 	rslcx 
50100876:	00 80       	rfe 
	...

50100880 <__interrupt_68>:
50100880:	e0 44       	bisr 68
50100882:	91 00 00 f7 	movh.a %a15,28672
50100886:	d9 ff 48 c4 	lea %a15,[%a15]18184 <70004708 <Cdisptab+0x220>>
5010088a:	c4 fe       	ld.a %a14,[%a15+]
5010088c:	54 f4       	ld.w %d4,[%a15]
5010088e:	2d 0e 00 00 	calli %a14
50100892:	0d 00 40 02 	rslcx 
50100896:	00 80       	rfe 
	...

501008a0 <__interrupt_69>:
501008a0:	e0 45       	bisr 69
501008a2:	91 00 00 f7 	movh.a %a15,28672
501008a6:	d9 ff 50 c4 	lea %a15,[%a15]18192 <70004710 <Cdisptab+0x228>>
501008aa:	c4 fe       	ld.a %a14,[%a15+]
501008ac:	54 f4       	ld.w %d4,[%a15]
501008ae:	2d 0e 00 00 	calli %a14
501008b2:	0d 00 40 02 	rslcx 
501008b6:	00 80       	rfe 
	...

501008c0 <__interrupt_70>:
501008c0:	e0 46       	bisr 70
501008c2:	91 00 00 f7 	movh.a %a15,28672
501008c6:	d9 ff 58 c4 	lea %a15,[%a15]18200 <70004718 <Cdisptab+0x230>>
501008ca:	c4 fe       	ld.a %a14,[%a15+]
501008cc:	54 f4       	ld.w %d4,[%a15]
501008ce:	2d 0e 00 00 	calli %a14
501008d2:	0d 00 40 02 	rslcx 
501008d6:	00 80       	rfe 
	...

501008e0 <__interrupt_71>:
501008e0:	e0 47       	bisr 71
501008e2:	91 00 00 f7 	movh.a %a15,28672
501008e6:	d9 ff 60 c4 	lea %a15,[%a15]18208 <70004720 <Cdisptab+0x238>>
501008ea:	c4 fe       	ld.a %a14,[%a15+]
501008ec:	54 f4       	ld.w %d4,[%a15]
501008ee:	2d 0e 00 00 	calli %a14
501008f2:	0d 00 40 02 	rslcx 
501008f6:	00 80       	rfe 
	...

50100900 <__interrupt_72>:
50100900:	e0 48       	bisr 72
50100902:	91 00 00 f7 	movh.a %a15,28672
50100906:	d9 ff 68 c4 	lea %a15,[%a15]18216 <70004728 <Cdisptab+0x240>>
5010090a:	c4 fe       	ld.a %a14,[%a15+]
5010090c:	54 f4       	ld.w %d4,[%a15]
5010090e:	2d 0e 00 00 	calli %a14
50100912:	0d 00 40 02 	rslcx 
50100916:	00 80       	rfe 
	...

50100920 <__interrupt_73>:
50100920:	e0 49       	bisr 73
50100922:	91 00 00 f7 	movh.a %a15,28672
50100926:	d9 ff 70 c4 	lea %a15,[%a15]18224 <70004730 <Cdisptab+0x248>>
5010092a:	c4 fe       	ld.a %a14,[%a15+]
5010092c:	54 f4       	ld.w %d4,[%a15]
5010092e:	2d 0e 00 00 	calli %a14
50100932:	0d 00 40 02 	rslcx 
50100936:	00 80       	rfe 
	...

50100940 <__interrupt_74>:
50100940:	e0 4a       	bisr 74
50100942:	91 00 00 f7 	movh.a %a15,28672
50100946:	d9 ff 78 c4 	lea %a15,[%a15]18232 <70004738 <Cdisptab+0x250>>
5010094a:	c4 fe       	ld.a %a14,[%a15+]
5010094c:	54 f4       	ld.w %d4,[%a15]
5010094e:	2d 0e 00 00 	calli %a14
50100952:	0d 00 40 02 	rslcx 
50100956:	00 80       	rfe 
	...

50100960 <__interrupt_75>:
50100960:	e0 4b       	bisr 75
50100962:	91 00 00 f7 	movh.a %a15,28672
50100966:	d9 ff 40 d4 	lea %a15,[%a15]18240 <70004740 <Cdisptab+0x258>>
5010096a:	c4 fe       	ld.a %a14,[%a15+]
5010096c:	54 f4       	ld.w %d4,[%a15]
5010096e:	2d 0e 00 00 	calli %a14
50100972:	0d 00 40 02 	rslcx 
50100976:	00 80       	rfe 
	...

50100980 <__interrupt_76>:
50100980:	e0 4c       	bisr 76
50100982:	91 00 00 f7 	movh.a %a15,28672
50100986:	d9 ff 48 d4 	lea %a15,[%a15]18248 <70004748 <Cdisptab+0x260>>
5010098a:	c4 fe       	ld.a %a14,[%a15+]
5010098c:	54 f4       	ld.w %d4,[%a15]
5010098e:	2d 0e 00 00 	calli %a14
50100992:	0d 00 40 02 	rslcx 
50100996:	00 80       	rfe 
	...

501009a0 <__interrupt_77>:
501009a0:	e0 4d       	bisr 77
501009a2:	91 00 00 f7 	movh.a %a15,28672
501009a6:	d9 ff 50 d4 	lea %a15,[%a15]18256 <70004750 <Cdisptab+0x268>>
501009aa:	c4 fe       	ld.a %a14,[%a15+]
501009ac:	54 f4       	ld.w %d4,[%a15]
501009ae:	2d 0e 00 00 	calli %a14
501009b2:	0d 00 40 02 	rslcx 
501009b6:	00 80       	rfe 
	...

501009c0 <__interrupt_78>:
501009c0:	e0 4e       	bisr 78
501009c2:	91 00 00 f7 	movh.a %a15,28672
501009c6:	d9 ff 58 d4 	lea %a15,[%a15]18264 <70004758 <Cdisptab+0x270>>
501009ca:	c4 fe       	ld.a %a14,[%a15+]
501009cc:	54 f4       	ld.w %d4,[%a15]
501009ce:	2d 0e 00 00 	calli %a14
501009d2:	0d 00 40 02 	rslcx 
501009d6:	00 80       	rfe 
	...

501009e0 <__interrupt_79>:
501009e0:	e0 4f       	bisr 79
501009e2:	91 00 00 f7 	movh.a %a15,28672
501009e6:	d9 ff 60 d4 	lea %a15,[%a15]18272 <70004760 <Cdisptab+0x278>>
501009ea:	c4 fe       	ld.a %a14,[%a15+]
501009ec:	54 f4       	ld.w %d4,[%a15]
501009ee:	2d 0e 00 00 	calli %a14
501009f2:	0d 00 40 02 	rslcx 
501009f6:	00 80       	rfe 
	...

50100a00 <__interrupt_80>:
50100a00:	e0 50       	bisr 80
50100a02:	91 00 00 f7 	movh.a %a15,28672
50100a06:	d9 ff 68 d4 	lea %a15,[%a15]18280 <70004768 <Cdisptab+0x280>>
50100a0a:	c4 fe       	ld.a %a14,[%a15+]
50100a0c:	54 f4       	ld.w %d4,[%a15]
50100a0e:	2d 0e 00 00 	calli %a14
50100a12:	0d 00 40 02 	rslcx 
50100a16:	00 80       	rfe 
	...

50100a20 <__interrupt_81>:
50100a20:	e0 51       	bisr 81
50100a22:	91 00 00 f7 	movh.a %a15,28672
50100a26:	d9 ff 70 d4 	lea %a15,[%a15]18288 <70004770 <Cdisptab+0x288>>
50100a2a:	c4 fe       	ld.a %a14,[%a15+]
50100a2c:	54 f4       	ld.w %d4,[%a15]
50100a2e:	2d 0e 00 00 	calli %a14
50100a32:	0d 00 40 02 	rslcx 
50100a36:	00 80       	rfe 
	...

50100a40 <__interrupt_82>:
50100a40:	e0 52       	bisr 82
50100a42:	91 00 00 f7 	movh.a %a15,28672
50100a46:	d9 ff 78 d4 	lea %a15,[%a15]18296 <70004778 <Cdisptab+0x290>>
50100a4a:	c4 fe       	ld.a %a14,[%a15+]
50100a4c:	54 f4       	ld.w %d4,[%a15]
50100a4e:	2d 0e 00 00 	calli %a14
50100a52:	0d 00 40 02 	rslcx 
50100a56:	00 80       	rfe 
	...

50100a60 <__interrupt_83>:
50100a60:	e0 53       	bisr 83
50100a62:	91 00 00 f7 	movh.a %a15,28672
50100a66:	d9 ff 40 e4 	lea %a15,[%a15]18304 <70004780 <Cdisptab+0x298>>
50100a6a:	c4 fe       	ld.a %a14,[%a15+]
50100a6c:	54 f4       	ld.w %d4,[%a15]
50100a6e:	2d 0e 00 00 	calli %a14
50100a72:	0d 00 40 02 	rslcx 
50100a76:	00 80       	rfe 
	...

50100a80 <__interrupt_84>:
50100a80:	e0 54       	bisr 84
50100a82:	91 00 00 f7 	movh.a %a15,28672
50100a86:	d9 ff 48 e4 	lea %a15,[%a15]18312 <70004788 <Cdisptab+0x2a0>>
50100a8a:	c4 fe       	ld.a %a14,[%a15+]
50100a8c:	54 f4       	ld.w %d4,[%a15]
50100a8e:	2d 0e 00 00 	calli %a14
50100a92:	0d 00 40 02 	rslcx 
50100a96:	00 80       	rfe 
	...

50100aa0 <__interrupt_85>:
50100aa0:	e0 55       	bisr 85
50100aa2:	91 00 00 f7 	movh.a %a15,28672
50100aa6:	d9 ff 50 e4 	lea %a15,[%a15]18320 <70004790 <Cdisptab+0x2a8>>
50100aaa:	c4 fe       	ld.a %a14,[%a15+]
50100aac:	54 f4       	ld.w %d4,[%a15]
50100aae:	2d 0e 00 00 	calli %a14
50100ab2:	0d 00 40 02 	rslcx 
50100ab6:	00 80       	rfe 
	...

50100ac0 <__interrupt_86>:
50100ac0:	e0 56       	bisr 86
50100ac2:	91 00 00 f7 	movh.a %a15,28672
50100ac6:	d9 ff 58 e4 	lea %a15,[%a15]18328 <70004798 <Cdisptab+0x2b0>>
50100aca:	c4 fe       	ld.a %a14,[%a15+]
50100acc:	54 f4       	ld.w %d4,[%a15]
50100ace:	2d 0e 00 00 	calli %a14
50100ad2:	0d 00 40 02 	rslcx 
50100ad6:	00 80       	rfe 
	...

50100ae0 <__interrupt_87>:
50100ae0:	e0 57       	bisr 87
50100ae2:	91 00 00 f7 	movh.a %a15,28672
50100ae6:	d9 ff 60 e4 	lea %a15,[%a15]18336 <700047a0 <Cdisptab+0x2b8>>
50100aea:	c4 fe       	ld.a %a14,[%a15+]
50100aec:	54 f4       	ld.w %d4,[%a15]
50100aee:	2d 0e 00 00 	calli %a14
50100af2:	0d 00 40 02 	rslcx 
50100af6:	00 80       	rfe 
	...

50100b00 <__interrupt_88>:
50100b00:	e0 58       	bisr 88
50100b02:	91 00 00 f7 	movh.a %a15,28672
50100b06:	d9 ff 68 e4 	lea %a15,[%a15]18344 <700047a8 <Cdisptab+0x2c0>>
50100b0a:	c4 fe       	ld.a %a14,[%a15+]
50100b0c:	54 f4       	ld.w %d4,[%a15]
50100b0e:	2d 0e 00 00 	calli %a14
50100b12:	0d 00 40 02 	rslcx 
50100b16:	00 80       	rfe 
	...

50100b20 <__interrupt_89>:
50100b20:	e0 59       	bisr 89
50100b22:	91 00 00 f7 	movh.a %a15,28672
50100b26:	d9 ff 70 e4 	lea %a15,[%a15]18352 <700047b0 <Cdisptab+0x2c8>>
50100b2a:	c4 fe       	ld.a %a14,[%a15+]
50100b2c:	54 f4       	ld.w %d4,[%a15]
50100b2e:	2d 0e 00 00 	calli %a14
50100b32:	0d 00 40 02 	rslcx 
50100b36:	00 80       	rfe 
	...

50100b40 <__interrupt_90>:
50100b40:	e0 5a       	bisr 90
50100b42:	91 00 00 f7 	movh.a %a15,28672
50100b46:	d9 ff 78 e4 	lea %a15,[%a15]18360 <700047b8 <Cdisptab+0x2d0>>
50100b4a:	c4 fe       	ld.a %a14,[%a15+]
50100b4c:	54 f4       	ld.w %d4,[%a15]
50100b4e:	2d 0e 00 00 	calli %a14
50100b52:	0d 00 40 02 	rslcx 
50100b56:	00 80       	rfe 
	...

50100b60 <__interrupt_91>:
50100b60:	e0 5b       	bisr 91
50100b62:	91 00 00 f7 	movh.a %a15,28672
50100b66:	d9 ff 40 f4 	lea %a15,[%a15]18368 <700047c0 <Cdisptab+0x2d8>>
50100b6a:	c4 fe       	ld.a %a14,[%a15+]
50100b6c:	54 f4       	ld.w %d4,[%a15]
50100b6e:	2d 0e 00 00 	calli %a14
50100b72:	0d 00 40 02 	rslcx 
50100b76:	00 80       	rfe 
	...

50100b80 <__interrupt_92>:
50100b80:	e0 5c       	bisr 92
50100b82:	91 00 00 f7 	movh.a %a15,28672
50100b86:	d9 ff 48 f4 	lea %a15,[%a15]18376 <700047c8 <Cdisptab+0x2e0>>
50100b8a:	c4 fe       	ld.a %a14,[%a15+]
50100b8c:	54 f4       	ld.w %d4,[%a15]
50100b8e:	2d 0e 00 00 	calli %a14
50100b92:	0d 00 40 02 	rslcx 
50100b96:	00 80       	rfe 
	...

50100ba0 <__interrupt_93>:
50100ba0:	e0 5d       	bisr 93
50100ba2:	91 00 00 f7 	movh.a %a15,28672
50100ba6:	d9 ff 50 f4 	lea %a15,[%a15]18384 <700047d0 <Cdisptab+0x2e8>>
50100baa:	c4 fe       	ld.a %a14,[%a15+]
50100bac:	54 f4       	ld.w %d4,[%a15]
50100bae:	2d 0e 00 00 	calli %a14
50100bb2:	0d 00 40 02 	rslcx 
50100bb6:	00 80       	rfe 
	...

50100bc0 <__interrupt_94>:
50100bc0:	e0 5e       	bisr 94
50100bc2:	91 00 00 f7 	movh.a %a15,28672
50100bc6:	d9 ff 58 f4 	lea %a15,[%a15]18392 <700047d8 <Cdisptab+0x2f0>>
50100bca:	c4 fe       	ld.a %a14,[%a15+]
50100bcc:	54 f4       	ld.w %d4,[%a15]
50100bce:	2d 0e 00 00 	calli %a14
50100bd2:	0d 00 40 02 	rslcx 
50100bd6:	00 80       	rfe 
	...

50100be0 <__interrupt_95>:
50100be0:	e0 5f       	bisr 95
50100be2:	91 00 00 f7 	movh.a %a15,28672
50100be6:	d9 ff 60 f4 	lea %a15,[%a15]18400 <700047e0 <Cdisptab+0x2f8>>
50100bea:	c4 fe       	ld.a %a14,[%a15+]
50100bec:	54 f4       	ld.w %d4,[%a15]
50100bee:	2d 0e 00 00 	calli %a14
50100bf2:	0d 00 40 02 	rslcx 
50100bf6:	00 80       	rfe 
	...

50100c00 <__interrupt_96>:
50100c00:	e0 60       	bisr 96
50100c02:	91 00 00 f7 	movh.a %a15,28672
50100c06:	d9 ff 68 f4 	lea %a15,[%a15]18408 <700047e8 <Cdisptab+0x300>>
50100c0a:	c4 fe       	ld.a %a14,[%a15+]
50100c0c:	54 f4       	ld.w %d4,[%a15]
50100c0e:	2d 0e 00 00 	calli %a14
50100c12:	0d 00 40 02 	rslcx 
50100c16:	00 80       	rfe 
	...

50100c20 <__interrupt_97>:
50100c20:	e0 61       	bisr 97
50100c22:	91 00 00 f7 	movh.a %a15,28672
50100c26:	d9 ff 70 f4 	lea %a15,[%a15]18416 <700047f0 <Cdisptab+0x308>>
50100c2a:	c4 fe       	ld.a %a14,[%a15+]
50100c2c:	54 f4       	ld.w %d4,[%a15]
50100c2e:	2d 0e 00 00 	calli %a14
50100c32:	0d 00 40 02 	rslcx 
50100c36:	00 80       	rfe 
	...

50100c40 <__interrupt_98>:
50100c40:	e0 62       	bisr 98
50100c42:	91 00 00 f7 	movh.a %a15,28672
50100c46:	d9 ff 78 f4 	lea %a15,[%a15]18424 <700047f8 <Cdisptab+0x310>>
50100c4a:	c4 fe       	ld.a %a14,[%a15+]
50100c4c:	54 f4       	ld.w %d4,[%a15]
50100c4e:	2d 0e 00 00 	calli %a14
50100c52:	0d 00 40 02 	rslcx 
50100c56:	00 80       	rfe 
	...

50100c60 <__interrupt_99>:
50100c60:	e0 63       	bisr 99
50100c62:	91 00 00 f7 	movh.a %a15,28672
50100c66:	d9 ff 80 04 	lea %a15,[%a15]18432 <70004800 <Cdisptab+0x318>>
50100c6a:	c4 fe       	ld.a %a14,[%a15+]
50100c6c:	54 f4       	ld.w %d4,[%a15]
50100c6e:	2d 0e 00 00 	calli %a14
50100c72:	0d 00 40 02 	rslcx 
50100c76:	00 80       	rfe 
	...

50100c80 <__interrupt_100>:
50100c80:	e0 64       	bisr 100
50100c82:	91 00 00 f7 	movh.a %a15,28672
50100c86:	d9 ff 88 04 	lea %a15,[%a15]18440 <70004808 <Cdisptab+0x320>>
50100c8a:	c4 fe       	ld.a %a14,[%a15+]
50100c8c:	54 f4       	ld.w %d4,[%a15]
50100c8e:	2d 0e 00 00 	calli %a14
50100c92:	0d 00 40 02 	rslcx 
50100c96:	00 80       	rfe 
	...

50100ca0 <__interrupt_101>:
50100ca0:	e0 65       	bisr 101
50100ca2:	91 00 00 f7 	movh.a %a15,28672
50100ca6:	d9 ff 90 04 	lea %a15,[%a15]18448 <70004810 <Cdisptab+0x328>>
50100caa:	c4 fe       	ld.a %a14,[%a15+]
50100cac:	54 f4       	ld.w %d4,[%a15]
50100cae:	2d 0e 00 00 	calli %a14
50100cb2:	0d 00 40 02 	rslcx 
50100cb6:	00 80       	rfe 
	...

50100cc0 <__interrupt_102>:
50100cc0:	e0 66       	bisr 102
50100cc2:	91 00 00 f7 	movh.a %a15,28672
50100cc6:	d9 ff 98 04 	lea %a15,[%a15]18456 <70004818 <Cdisptab+0x330>>
50100cca:	c4 fe       	ld.a %a14,[%a15+]
50100ccc:	54 f4       	ld.w %d4,[%a15]
50100cce:	2d 0e 00 00 	calli %a14
50100cd2:	0d 00 40 02 	rslcx 
50100cd6:	00 80       	rfe 
	...

50100ce0 <__interrupt_103>:
50100ce0:	e0 67       	bisr 103
50100ce2:	91 00 00 f7 	movh.a %a15,28672
50100ce6:	d9 ff a0 04 	lea %a15,[%a15]18464 <70004820 <Cdisptab+0x338>>
50100cea:	c4 fe       	ld.a %a14,[%a15+]
50100cec:	54 f4       	ld.w %d4,[%a15]
50100cee:	2d 0e 00 00 	calli %a14
50100cf2:	0d 00 40 02 	rslcx 
50100cf6:	00 80       	rfe 
	...

50100d00 <__interrupt_104>:
50100d00:	e0 68       	bisr 104
50100d02:	91 00 00 f7 	movh.a %a15,28672
50100d06:	d9 ff a8 04 	lea %a15,[%a15]18472 <70004828 <Cdisptab+0x340>>
50100d0a:	c4 fe       	ld.a %a14,[%a15+]
50100d0c:	54 f4       	ld.w %d4,[%a15]
50100d0e:	2d 0e 00 00 	calli %a14
50100d12:	0d 00 40 02 	rslcx 
50100d16:	00 80       	rfe 
	...

50100d20 <__interrupt_105>:
50100d20:	e0 69       	bisr 105
50100d22:	91 00 00 f7 	movh.a %a15,28672
50100d26:	d9 ff b0 04 	lea %a15,[%a15]18480 <70004830 <Cdisptab+0x348>>
50100d2a:	c4 fe       	ld.a %a14,[%a15+]
50100d2c:	54 f4       	ld.w %d4,[%a15]
50100d2e:	2d 0e 00 00 	calli %a14
50100d32:	0d 00 40 02 	rslcx 
50100d36:	00 80       	rfe 
	...

50100d40 <__interrupt_106>:
50100d40:	e0 6a       	bisr 106
50100d42:	91 00 00 f7 	movh.a %a15,28672
50100d46:	d9 ff b8 04 	lea %a15,[%a15]18488 <70004838 <Cdisptab+0x350>>
50100d4a:	c4 fe       	ld.a %a14,[%a15+]
50100d4c:	54 f4       	ld.w %d4,[%a15]
50100d4e:	2d 0e 00 00 	calli %a14
50100d52:	0d 00 40 02 	rslcx 
50100d56:	00 80       	rfe 
	...

50100d60 <__interrupt_107>:
50100d60:	e0 6b       	bisr 107
50100d62:	91 00 00 f7 	movh.a %a15,28672
50100d66:	d9 ff 80 14 	lea %a15,[%a15]18496 <70004840 <Cdisptab+0x358>>
50100d6a:	c4 fe       	ld.a %a14,[%a15+]
50100d6c:	54 f4       	ld.w %d4,[%a15]
50100d6e:	2d 0e 00 00 	calli %a14
50100d72:	0d 00 40 02 	rslcx 
50100d76:	00 80       	rfe 
	...

50100d80 <__interrupt_108>:
50100d80:	e0 6c       	bisr 108
50100d82:	91 00 00 f7 	movh.a %a15,28672
50100d86:	d9 ff 88 14 	lea %a15,[%a15]18504 <70004848 <Cdisptab+0x360>>
50100d8a:	c4 fe       	ld.a %a14,[%a15+]
50100d8c:	54 f4       	ld.w %d4,[%a15]
50100d8e:	2d 0e 00 00 	calli %a14
50100d92:	0d 00 40 02 	rslcx 
50100d96:	00 80       	rfe 
	...

50100da0 <__interrupt_109>:
50100da0:	e0 6d       	bisr 109
50100da2:	91 00 00 f7 	movh.a %a15,28672
50100da6:	d9 ff 90 14 	lea %a15,[%a15]18512 <70004850 <Cdisptab+0x368>>
50100daa:	c4 fe       	ld.a %a14,[%a15+]
50100dac:	54 f4       	ld.w %d4,[%a15]
50100dae:	2d 0e 00 00 	calli %a14
50100db2:	0d 00 40 02 	rslcx 
50100db6:	00 80       	rfe 
	...

50100dc0 <__interrupt_110>:
50100dc0:	e0 6e       	bisr 110
50100dc2:	91 00 00 f7 	movh.a %a15,28672
50100dc6:	d9 ff 98 14 	lea %a15,[%a15]18520 <70004858 <Cdisptab+0x370>>
50100dca:	c4 fe       	ld.a %a14,[%a15+]
50100dcc:	54 f4       	ld.w %d4,[%a15]
50100dce:	2d 0e 00 00 	calli %a14
50100dd2:	0d 00 40 02 	rslcx 
50100dd6:	00 80       	rfe 
	...

50100de0 <__interrupt_111>:
50100de0:	e0 6f       	bisr 111
50100de2:	91 00 00 f7 	movh.a %a15,28672
50100de6:	d9 ff a0 14 	lea %a15,[%a15]18528 <70004860 <Cdisptab+0x378>>
50100dea:	c4 fe       	ld.a %a14,[%a15+]
50100dec:	54 f4       	ld.w %d4,[%a15]
50100dee:	2d 0e 00 00 	calli %a14
50100df2:	0d 00 40 02 	rslcx 
50100df6:	00 80       	rfe 
	...

50100e00 <__interrupt_112>:
50100e00:	e0 70       	bisr 112
50100e02:	91 00 00 f7 	movh.a %a15,28672
50100e06:	d9 ff a8 14 	lea %a15,[%a15]18536 <70004868 <Cdisptab+0x380>>
50100e0a:	c4 fe       	ld.a %a14,[%a15+]
50100e0c:	54 f4       	ld.w %d4,[%a15]
50100e0e:	2d 0e 00 00 	calli %a14
50100e12:	0d 00 40 02 	rslcx 
50100e16:	00 80       	rfe 
	...

50100e20 <__interrupt_113>:
50100e20:	e0 71       	bisr 113
50100e22:	91 00 00 f7 	movh.a %a15,28672
50100e26:	d9 ff b0 14 	lea %a15,[%a15]18544 <70004870 <Cdisptab+0x388>>
50100e2a:	c4 fe       	ld.a %a14,[%a15+]
50100e2c:	54 f4       	ld.w %d4,[%a15]
50100e2e:	2d 0e 00 00 	calli %a14
50100e32:	0d 00 40 02 	rslcx 
50100e36:	00 80       	rfe 
	...

50100e40 <__interrupt_114>:
50100e40:	e0 72       	bisr 114
50100e42:	91 00 00 f7 	movh.a %a15,28672
50100e46:	d9 ff b8 14 	lea %a15,[%a15]18552 <70004878 <Cdisptab+0x390>>
50100e4a:	c4 fe       	ld.a %a14,[%a15+]
50100e4c:	54 f4       	ld.w %d4,[%a15]
50100e4e:	2d 0e 00 00 	calli %a14
50100e52:	0d 00 40 02 	rslcx 
50100e56:	00 80       	rfe 
	...

50100e60 <__interrupt_115>:
50100e60:	e0 73       	bisr 115
50100e62:	91 00 00 f7 	movh.a %a15,28672
50100e66:	d9 ff 80 24 	lea %a15,[%a15]18560 <70004880 <Cdisptab+0x398>>
50100e6a:	c4 fe       	ld.a %a14,[%a15+]
50100e6c:	54 f4       	ld.w %d4,[%a15]
50100e6e:	2d 0e 00 00 	calli %a14
50100e72:	0d 00 40 02 	rslcx 
50100e76:	00 80       	rfe 
	...

50100e80 <__interrupt_116>:
50100e80:	e0 74       	bisr 116
50100e82:	91 00 00 f7 	movh.a %a15,28672
50100e86:	d9 ff 88 24 	lea %a15,[%a15]18568 <70004888 <Cdisptab+0x3a0>>
50100e8a:	c4 fe       	ld.a %a14,[%a15+]
50100e8c:	54 f4       	ld.w %d4,[%a15]
50100e8e:	2d 0e 00 00 	calli %a14
50100e92:	0d 00 40 02 	rslcx 
50100e96:	00 80       	rfe 
	...

50100ea0 <__interrupt_117>:
50100ea0:	e0 75       	bisr 117
50100ea2:	91 00 00 f7 	movh.a %a15,28672
50100ea6:	d9 ff 90 24 	lea %a15,[%a15]18576 <70004890 <Cdisptab+0x3a8>>
50100eaa:	c4 fe       	ld.a %a14,[%a15+]
50100eac:	54 f4       	ld.w %d4,[%a15]
50100eae:	2d 0e 00 00 	calli %a14
50100eb2:	0d 00 40 02 	rslcx 
50100eb6:	00 80       	rfe 
	...

50100ec0 <__interrupt_118>:
50100ec0:	e0 76       	bisr 118
50100ec2:	91 00 00 f7 	movh.a %a15,28672
50100ec6:	d9 ff 98 24 	lea %a15,[%a15]18584 <70004898 <Cdisptab+0x3b0>>
50100eca:	c4 fe       	ld.a %a14,[%a15+]
50100ecc:	54 f4       	ld.w %d4,[%a15]
50100ece:	2d 0e 00 00 	calli %a14
50100ed2:	0d 00 40 02 	rslcx 
50100ed6:	00 80       	rfe 
	...

50100ee0 <__interrupt_119>:
50100ee0:	e0 77       	bisr 119
50100ee2:	91 00 00 f7 	movh.a %a15,28672
50100ee6:	d9 ff a0 24 	lea %a15,[%a15]18592 <700048a0 <Cdisptab+0x3b8>>
50100eea:	c4 fe       	ld.a %a14,[%a15+]
50100eec:	54 f4       	ld.w %d4,[%a15]
50100eee:	2d 0e 00 00 	calli %a14
50100ef2:	0d 00 40 02 	rslcx 
50100ef6:	00 80       	rfe 
	...

50100f00 <__interrupt_120>:
50100f00:	e0 78       	bisr 120
50100f02:	91 00 00 f7 	movh.a %a15,28672
50100f06:	d9 ff a8 24 	lea %a15,[%a15]18600 <700048a8 <Cdisptab+0x3c0>>
50100f0a:	c4 fe       	ld.a %a14,[%a15+]
50100f0c:	54 f4       	ld.w %d4,[%a15]
50100f0e:	2d 0e 00 00 	calli %a14
50100f12:	0d 00 40 02 	rslcx 
50100f16:	00 80       	rfe 
	...

50100f20 <__interrupt_121>:
50100f20:	e0 79       	bisr 121
50100f22:	91 00 00 f7 	movh.a %a15,28672
50100f26:	d9 ff b0 24 	lea %a15,[%a15]18608 <700048b0 <Cdisptab+0x3c8>>
50100f2a:	c4 fe       	ld.a %a14,[%a15+]
50100f2c:	54 f4       	ld.w %d4,[%a15]
50100f2e:	2d 0e 00 00 	calli %a14
50100f32:	0d 00 40 02 	rslcx 
50100f36:	00 80       	rfe 
	...

50100f40 <__interrupt_122>:
50100f40:	e0 7a       	bisr 122
50100f42:	91 00 00 f7 	movh.a %a15,28672
50100f46:	d9 ff b8 24 	lea %a15,[%a15]18616 <700048b8 <Cdisptab+0x3d0>>
50100f4a:	c4 fe       	ld.a %a14,[%a15+]
50100f4c:	54 f4       	ld.w %d4,[%a15]
50100f4e:	2d 0e 00 00 	calli %a14
50100f52:	0d 00 40 02 	rslcx 
50100f56:	00 80       	rfe 
	...

50100f60 <__interrupt_123>:
50100f60:	e0 7b       	bisr 123
50100f62:	91 00 00 f7 	movh.a %a15,28672
50100f66:	d9 ff 80 34 	lea %a15,[%a15]18624 <700048c0 <Cdisptab+0x3d8>>
50100f6a:	c4 fe       	ld.a %a14,[%a15+]
50100f6c:	54 f4       	ld.w %d4,[%a15]
50100f6e:	2d 0e 00 00 	calli %a14
50100f72:	0d 00 40 02 	rslcx 
50100f76:	00 80       	rfe 
	...

50100f80 <__interrupt_124>:
50100f80:	e0 7c       	bisr 124
50100f82:	91 00 00 f7 	movh.a %a15,28672
50100f86:	d9 ff 88 34 	lea %a15,[%a15]18632 <700048c8 <Cdisptab+0x3e0>>
50100f8a:	c4 fe       	ld.a %a14,[%a15+]
50100f8c:	54 f4       	ld.w %d4,[%a15]
50100f8e:	2d 0e 00 00 	calli %a14
50100f92:	0d 00 40 02 	rslcx 
50100f96:	00 80       	rfe 
	...

50100fa0 <__interrupt_125>:
50100fa0:	e0 7d       	bisr 125
50100fa2:	91 00 00 f7 	movh.a %a15,28672
50100fa6:	d9 ff 90 34 	lea %a15,[%a15]18640 <700048d0 <Cdisptab+0x3e8>>
50100faa:	c4 fe       	ld.a %a14,[%a15+]
50100fac:	54 f4       	ld.w %d4,[%a15]
50100fae:	2d 0e 00 00 	calli %a14
50100fb2:	0d 00 40 02 	rslcx 
50100fb6:	00 80       	rfe 
	...

50100fc0 <__interrupt_126>:
50100fc0:	e0 7e       	bisr 126
50100fc2:	91 00 00 f7 	movh.a %a15,28672
50100fc6:	d9 ff 98 34 	lea %a15,[%a15]18648 <700048d8 <Cdisptab+0x3f0>>
50100fca:	c4 fe       	ld.a %a14,[%a15+]
50100fcc:	54 f4       	ld.w %d4,[%a15]
50100fce:	2d 0e 00 00 	calli %a14
50100fd2:	0d 00 40 02 	rslcx 
50100fd6:	00 80       	rfe 
	...

50100fe0 <__interrupt_127>:
50100fe0:	e0 7f       	bisr 127
50100fe2:	91 00 00 f7 	movh.a %a15,28672
50100fe6:	d9 ff a0 34 	lea %a15,[%a15]18656 <700048e0 <Cdisptab+0x3f8>>
50100fea:	c4 fe       	ld.a %a14,[%a15+]
50100fec:	54 f4       	ld.w %d4,[%a15]
50100fee:	2d 0e 00 00 	calli %a14
50100ff2:	0d 00 40 02 	rslcx 
50100ff6:	00 80       	rfe 
	...

50101000 <__interrupt_128>:
50101000:	e0 80       	bisr 128
50101002:	91 00 00 f7 	movh.a %a15,28672
50101006:	d9 ff a8 34 	lea %a15,[%a15]18664 <700048e8 <Cdisptab+0x400>>
5010100a:	c4 fe       	ld.a %a14,[%a15+]
5010100c:	54 f4       	ld.w %d4,[%a15]
5010100e:	2d 0e 00 00 	calli %a14
50101012:	0d 00 40 02 	rslcx 
50101016:	00 80       	rfe 
	...

50101020 <__interrupt_129>:
50101020:	e0 81       	bisr 129
50101022:	91 00 00 f7 	movh.a %a15,28672
50101026:	d9 ff b0 34 	lea %a15,[%a15]18672 <700048f0 <Cdisptab+0x408>>
5010102a:	c4 fe       	ld.a %a14,[%a15+]
5010102c:	54 f4       	ld.w %d4,[%a15]
5010102e:	2d 0e 00 00 	calli %a14
50101032:	0d 00 40 02 	rslcx 
50101036:	00 80       	rfe 
	...

50101040 <__interrupt_130>:
50101040:	e0 82       	bisr 130
50101042:	91 00 00 f7 	movh.a %a15,28672
50101046:	d9 ff b8 34 	lea %a15,[%a15]18680 <700048f8 <Cdisptab+0x410>>
5010104a:	c4 fe       	ld.a %a14,[%a15+]
5010104c:	54 f4       	ld.w %d4,[%a15]
5010104e:	2d 0e 00 00 	calli %a14
50101052:	0d 00 40 02 	rslcx 
50101056:	00 80       	rfe 
	...

50101060 <__interrupt_131>:
50101060:	e0 83       	bisr 131
50101062:	91 00 00 f7 	movh.a %a15,28672
50101066:	d9 ff 80 44 	lea %a15,[%a15]18688 <70004900 <Cdisptab+0x418>>
5010106a:	c4 fe       	ld.a %a14,[%a15+]
5010106c:	54 f4       	ld.w %d4,[%a15]
5010106e:	2d 0e 00 00 	calli %a14
50101072:	0d 00 40 02 	rslcx 
50101076:	00 80       	rfe 
	...

50101080 <__interrupt_132>:
50101080:	e0 84       	bisr 132
50101082:	91 00 00 f7 	movh.a %a15,28672
50101086:	d9 ff 88 44 	lea %a15,[%a15]18696 <70004908 <Cdisptab+0x420>>
5010108a:	c4 fe       	ld.a %a14,[%a15+]
5010108c:	54 f4       	ld.w %d4,[%a15]
5010108e:	2d 0e 00 00 	calli %a14
50101092:	0d 00 40 02 	rslcx 
50101096:	00 80       	rfe 
	...

501010a0 <__interrupt_133>:
501010a0:	e0 85       	bisr 133
501010a2:	91 00 00 f7 	movh.a %a15,28672
501010a6:	d9 ff 90 44 	lea %a15,[%a15]18704 <70004910 <Cdisptab+0x428>>
501010aa:	c4 fe       	ld.a %a14,[%a15+]
501010ac:	54 f4       	ld.w %d4,[%a15]
501010ae:	2d 0e 00 00 	calli %a14
501010b2:	0d 00 40 02 	rslcx 
501010b6:	00 80       	rfe 
	...

501010c0 <__interrupt_134>:
501010c0:	e0 86       	bisr 134
501010c2:	91 00 00 f7 	movh.a %a15,28672
501010c6:	d9 ff 98 44 	lea %a15,[%a15]18712 <70004918 <Cdisptab+0x430>>
501010ca:	c4 fe       	ld.a %a14,[%a15+]
501010cc:	54 f4       	ld.w %d4,[%a15]
501010ce:	2d 0e 00 00 	calli %a14
501010d2:	0d 00 40 02 	rslcx 
501010d6:	00 80       	rfe 
	...

501010e0 <__interrupt_135>:
501010e0:	e0 87       	bisr 135
501010e2:	91 00 00 f7 	movh.a %a15,28672
501010e6:	d9 ff a0 44 	lea %a15,[%a15]18720 <70004920 <Cdisptab+0x438>>
501010ea:	c4 fe       	ld.a %a14,[%a15+]
501010ec:	54 f4       	ld.w %d4,[%a15]
501010ee:	2d 0e 00 00 	calli %a14
501010f2:	0d 00 40 02 	rslcx 
501010f6:	00 80       	rfe 
	...

50101100 <__interrupt_136>:
50101100:	e0 88       	bisr 136
50101102:	91 00 00 f7 	movh.a %a15,28672
50101106:	d9 ff a8 44 	lea %a15,[%a15]18728 <70004928 <Cdisptab+0x440>>
5010110a:	c4 fe       	ld.a %a14,[%a15+]
5010110c:	54 f4       	ld.w %d4,[%a15]
5010110e:	2d 0e 00 00 	calli %a14
50101112:	0d 00 40 02 	rslcx 
50101116:	00 80       	rfe 
	...

50101120 <__interrupt_137>:
50101120:	e0 89       	bisr 137
50101122:	91 00 00 f7 	movh.a %a15,28672
50101126:	d9 ff b0 44 	lea %a15,[%a15]18736 <70004930 <Cdisptab+0x448>>
5010112a:	c4 fe       	ld.a %a14,[%a15+]
5010112c:	54 f4       	ld.w %d4,[%a15]
5010112e:	2d 0e 00 00 	calli %a14
50101132:	0d 00 40 02 	rslcx 
50101136:	00 80       	rfe 
	...

50101140 <__interrupt_138>:
50101140:	e0 8a       	bisr 138
50101142:	91 00 00 f7 	movh.a %a15,28672
50101146:	d9 ff b8 44 	lea %a15,[%a15]18744 <70004938 <Cdisptab+0x450>>
5010114a:	c4 fe       	ld.a %a14,[%a15+]
5010114c:	54 f4       	ld.w %d4,[%a15]
5010114e:	2d 0e 00 00 	calli %a14
50101152:	0d 00 40 02 	rslcx 
50101156:	00 80       	rfe 
	...

50101160 <__interrupt_139>:
50101160:	e0 8b       	bisr 139
50101162:	91 00 00 f7 	movh.a %a15,28672
50101166:	d9 ff 80 54 	lea %a15,[%a15]18752 <70004940 <Cdisptab+0x458>>
5010116a:	c4 fe       	ld.a %a14,[%a15+]
5010116c:	54 f4       	ld.w %d4,[%a15]
5010116e:	2d 0e 00 00 	calli %a14
50101172:	0d 00 40 02 	rslcx 
50101176:	00 80       	rfe 
	...

50101180 <__interrupt_140>:
50101180:	e0 8c       	bisr 140
50101182:	91 00 00 f7 	movh.a %a15,28672
50101186:	d9 ff 88 54 	lea %a15,[%a15]18760 <70004948 <Cdisptab+0x460>>
5010118a:	c4 fe       	ld.a %a14,[%a15+]
5010118c:	54 f4       	ld.w %d4,[%a15]
5010118e:	2d 0e 00 00 	calli %a14
50101192:	0d 00 40 02 	rslcx 
50101196:	00 80       	rfe 
	...

501011a0 <__interrupt_141>:
501011a0:	e0 8d       	bisr 141
501011a2:	91 00 00 f7 	movh.a %a15,28672
501011a6:	d9 ff 90 54 	lea %a15,[%a15]18768 <70004950 <Cdisptab+0x468>>
501011aa:	c4 fe       	ld.a %a14,[%a15+]
501011ac:	54 f4       	ld.w %d4,[%a15]
501011ae:	2d 0e 00 00 	calli %a14
501011b2:	0d 00 40 02 	rslcx 
501011b6:	00 80       	rfe 
	...

501011c0 <__interrupt_142>:
501011c0:	e0 8e       	bisr 142
501011c2:	91 00 00 f7 	movh.a %a15,28672
501011c6:	d9 ff 98 54 	lea %a15,[%a15]18776 <70004958 <Cdisptab+0x470>>
501011ca:	c4 fe       	ld.a %a14,[%a15+]
501011cc:	54 f4       	ld.w %d4,[%a15]
501011ce:	2d 0e 00 00 	calli %a14
501011d2:	0d 00 40 02 	rslcx 
501011d6:	00 80       	rfe 
	...

501011e0 <__interrupt_143>:
501011e0:	e0 8f       	bisr 143
501011e2:	91 00 00 f7 	movh.a %a15,28672
501011e6:	d9 ff a0 54 	lea %a15,[%a15]18784 <70004960 <Cdisptab+0x478>>
501011ea:	c4 fe       	ld.a %a14,[%a15+]
501011ec:	54 f4       	ld.w %d4,[%a15]
501011ee:	2d 0e 00 00 	calli %a14
501011f2:	0d 00 40 02 	rslcx 
501011f6:	00 80       	rfe 
	...

50101200 <__interrupt_144>:
50101200:	e0 90       	bisr 144
50101202:	91 00 00 f7 	movh.a %a15,28672
50101206:	d9 ff a8 54 	lea %a15,[%a15]18792 <70004968 <Cdisptab+0x480>>
5010120a:	c4 fe       	ld.a %a14,[%a15+]
5010120c:	54 f4       	ld.w %d4,[%a15]
5010120e:	2d 0e 00 00 	calli %a14
50101212:	0d 00 40 02 	rslcx 
50101216:	00 80       	rfe 
	...

50101220 <__interrupt_145>:
50101220:	e0 91       	bisr 145
50101222:	91 00 00 f7 	movh.a %a15,28672
50101226:	d9 ff b0 54 	lea %a15,[%a15]18800 <70004970 <Cdisptab+0x488>>
5010122a:	c4 fe       	ld.a %a14,[%a15+]
5010122c:	54 f4       	ld.w %d4,[%a15]
5010122e:	2d 0e 00 00 	calli %a14
50101232:	0d 00 40 02 	rslcx 
50101236:	00 80       	rfe 
	...

50101240 <__interrupt_146>:
50101240:	e0 92       	bisr 146
50101242:	91 00 00 f7 	movh.a %a15,28672
50101246:	d9 ff b8 54 	lea %a15,[%a15]18808 <70004978 <Cdisptab+0x490>>
5010124a:	c4 fe       	ld.a %a14,[%a15+]
5010124c:	54 f4       	ld.w %d4,[%a15]
5010124e:	2d 0e 00 00 	calli %a14
50101252:	0d 00 40 02 	rslcx 
50101256:	00 80       	rfe 
	...

50101260 <__interrupt_147>:
50101260:	e0 93       	bisr 147
50101262:	91 00 00 f7 	movh.a %a15,28672
50101266:	d9 ff 80 64 	lea %a15,[%a15]18816 <70004980 <Cdisptab+0x498>>
5010126a:	c4 fe       	ld.a %a14,[%a15+]
5010126c:	54 f4       	ld.w %d4,[%a15]
5010126e:	2d 0e 00 00 	calli %a14
50101272:	0d 00 40 02 	rslcx 
50101276:	00 80       	rfe 
	...

50101280 <__interrupt_148>:
50101280:	e0 94       	bisr 148
50101282:	91 00 00 f7 	movh.a %a15,28672
50101286:	d9 ff 88 64 	lea %a15,[%a15]18824 <70004988 <Cdisptab+0x4a0>>
5010128a:	c4 fe       	ld.a %a14,[%a15+]
5010128c:	54 f4       	ld.w %d4,[%a15]
5010128e:	2d 0e 00 00 	calli %a14
50101292:	0d 00 40 02 	rslcx 
50101296:	00 80       	rfe 
	...

501012a0 <__interrupt_149>:
501012a0:	e0 95       	bisr 149
501012a2:	91 00 00 f7 	movh.a %a15,28672
501012a6:	d9 ff 90 64 	lea %a15,[%a15]18832 <70004990 <Cdisptab+0x4a8>>
501012aa:	c4 fe       	ld.a %a14,[%a15+]
501012ac:	54 f4       	ld.w %d4,[%a15]
501012ae:	2d 0e 00 00 	calli %a14
501012b2:	0d 00 40 02 	rslcx 
501012b6:	00 80       	rfe 
	...

501012c0 <__interrupt_150>:
501012c0:	e0 96       	bisr 150
501012c2:	91 00 00 f7 	movh.a %a15,28672
501012c6:	d9 ff 98 64 	lea %a15,[%a15]18840 <70004998 <Cdisptab+0x4b0>>
501012ca:	c4 fe       	ld.a %a14,[%a15+]
501012cc:	54 f4       	ld.w %d4,[%a15]
501012ce:	2d 0e 00 00 	calli %a14
501012d2:	0d 00 40 02 	rslcx 
501012d6:	00 80       	rfe 
	...

501012e0 <__interrupt_151>:
501012e0:	e0 97       	bisr 151
501012e2:	91 00 00 f7 	movh.a %a15,28672
501012e6:	d9 ff a0 64 	lea %a15,[%a15]18848 <700049a0 <Cdisptab+0x4b8>>
501012ea:	c4 fe       	ld.a %a14,[%a15+]
501012ec:	54 f4       	ld.w %d4,[%a15]
501012ee:	2d 0e 00 00 	calli %a14
501012f2:	0d 00 40 02 	rslcx 
501012f6:	00 80       	rfe 
	...

50101300 <__interrupt_152>:
50101300:	e0 98       	bisr 152
50101302:	91 00 00 f7 	movh.a %a15,28672
50101306:	d9 ff a8 64 	lea %a15,[%a15]18856 <700049a8 <Cdisptab+0x4c0>>
5010130a:	c4 fe       	ld.a %a14,[%a15+]
5010130c:	54 f4       	ld.w %d4,[%a15]
5010130e:	2d 0e 00 00 	calli %a14
50101312:	0d 00 40 02 	rslcx 
50101316:	00 80       	rfe 
	...

50101320 <__interrupt_153>:
50101320:	e0 99       	bisr 153
50101322:	91 00 00 f7 	movh.a %a15,28672
50101326:	d9 ff b0 64 	lea %a15,[%a15]18864 <700049b0 <Cdisptab+0x4c8>>
5010132a:	c4 fe       	ld.a %a14,[%a15+]
5010132c:	54 f4       	ld.w %d4,[%a15]
5010132e:	2d 0e 00 00 	calli %a14
50101332:	0d 00 40 02 	rslcx 
50101336:	00 80       	rfe 
	...

50101340 <__interrupt_154>:
50101340:	e0 9a       	bisr 154
50101342:	91 00 00 f7 	movh.a %a15,28672
50101346:	d9 ff b8 64 	lea %a15,[%a15]18872 <700049b8 <Cdisptab+0x4d0>>
5010134a:	c4 fe       	ld.a %a14,[%a15+]
5010134c:	54 f4       	ld.w %d4,[%a15]
5010134e:	2d 0e 00 00 	calli %a14
50101352:	0d 00 40 02 	rslcx 
50101356:	00 80       	rfe 
	...

50101360 <__interrupt_155>:
50101360:	e0 9b       	bisr 155
50101362:	91 00 00 f7 	movh.a %a15,28672
50101366:	d9 ff 80 74 	lea %a15,[%a15]18880 <700049c0 <Cdisptab+0x4d8>>
5010136a:	c4 fe       	ld.a %a14,[%a15+]
5010136c:	54 f4       	ld.w %d4,[%a15]
5010136e:	2d 0e 00 00 	calli %a14
50101372:	0d 00 40 02 	rslcx 
50101376:	00 80       	rfe 
	...

50101380 <__interrupt_156>:
50101380:	e0 9c       	bisr 156
50101382:	91 00 00 f7 	movh.a %a15,28672
50101386:	d9 ff 88 74 	lea %a15,[%a15]18888 <700049c8 <Cdisptab+0x4e0>>
5010138a:	c4 fe       	ld.a %a14,[%a15+]
5010138c:	54 f4       	ld.w %d4,[%a15]
5010138e:	2d 0e 00 00 	calli %a14
50101392:	0d 00 40 02 	rslcx 
50101396:	00 80       	rfe 
	...

501013a0 <__interrupt_157>:
501013a0:	e0 9d       	bisr 157
501013a2:	91 00 00 f7 	movh.a %a15,28672
501013a6:	d9 ff 90 74 	lea %a15,[%a15]18896 <700049d0 <Cdisptab+0x4e8>>
501013aa:	c4 fe       	ld.a %a14,[%a15+]
501013ac:	54 f4       	ld.w %d4,[%a15]
501013ae:	2d 0e 00 00 	calli %a14
501013b2:	0d 00 40 02 	rslcx 
501013b6:	00 80       	rfe 
	...

501013c0 <__interrupt_158>:
501013c0:	e0 9e       	bisr 158
501013c2:	91 00 00 f7 	movh.a %a15,28672
501013c6:	d9 ff 98 74 	lea %a15,[%a15]18904 <700049d8 <Cdisptab+0x4f0>>
501013ca:	c4 fe       	ld.a %a14,[%a15+]
501013cc:	54 f4       	ld.w %d4,[%a15]
501013ce:	2d 0e 00 00 	calli %a14
501013d2:	0d 00 40 02 	rslcx 
501013d6:	00 80       	rfe 
	...

501013e0 <__interrupt_159>:
501013e0:	e0 9f       	bisr 159
501013e2:	91 00 00 f7 	movh.a %a15,28672
501013e6:	d9 ff a0 74 	lea %a15,[%a15]18912 <700049e0 <Cdisptab+0x4f8>>
501013ea:	c4 fe       	ld.a %a14,[%a15+]
501013ec:	54 f4       	ld.w %d4,[%a15]
501013ee:	2d 0e 00 00 	calli %a14
501013f2:	0d 00 40 02 	rslcx 
501013f6:	00 80       	rfe 
	...

50101400 <__interrupt_160>:
50101400:	e0 a0       	bisr 160
50101402:	91 00 00 f7 	movh.a %a15,28672
50101406:	d9 ff a8 74 	lea %a15,[%a15]18920 <700049e8 <Cdisptab+0x500>>
5010140a:	c4 fe       	ld.a %a14,[%a15+]
5010140c:	54 f4       	ld.w %d4,[%a15]
5010140e:	2d 0e 00 00 	calli %a14
50101412:	0d 00 40 02 	rslcx 
50101416:	00 80       	rfe 
	...

50101420 <__interrupt_161>:
50101420:	e0 a1       	bisr 161
50101422:	91 00 00 f7 	movh.a %a15,28672
50101426:	d9 ff b0 74 	lea %a15,[%a15]18928 <700049f0 <Cdisptab+0x508>>
5010142a:	c4 fe       	ld.a %a14,[%a15+]
5010142c:	54 f4       	ld.w %d4,[%a15]
5010142e:	2d 0e 00 00 	calli %a14
50101432:	0d 00 40 02 	rslcx 
50101436:	00 80       	rfe 
	...

50101440 <__interrupt_162>:
50101440:	e0 a2       	bisr 162
50101442:	91 00 00 f7 	movh.a %a15,28672
50101446:	d9 ff b8 74 	lea %a15,[%a15]18936 <700049f8 <Cdisptab+0x510>>
5010144a:	c4 fe       	ld.a %a14,[%a15+]
5010144c:	54 f4       	ld.w %d4,[%a15]
5010144e:	2d 0e 00 00 	calli %a14
50101452:	0d 00 40 02 	rslcx 
50101456:	00 80       	rfe 
	...

50101460 <__interrupt_163>:
50101460:	e0 a3       	bisr 163
50101462:	91 00 00 f7 	movh.a %a15,28672
50101466:	d9 ff 80 84 	lea %a15,[%a15]18944 <70004a00 <Cdisptab+0x518>>
5010146a:	c4 fe       	ld.a %a14,[%a15+]
5010146c:	54 f4       	ld.w %d4,[%a15]
5010146e:	2d 0e 00 00 	calli %a14
50101472:	0d 00 40 02 	rslcx 
50101476:	00 80       	rfe 
	...

50101480 <__interrupt_164>:
50101480:	e0 a4       	bisr 164
50101482:	91 00 00 f7 	movh.a %a15,28672
50101486:	d9 ff 88 84 	lea %a15,[%a15]18952 <70004a08 <Cdisptab+0x520>>
5010148a:	c4 fe       	ld.a %a14,[%a15+]
5010148c:	54 f4       	ld.w %d4,[%a15]
5010148e:	2d 0e 00 00 	calli %a14
50101492:	0d 00 40 02 	rslcx 
50101496:	00 80       	rfe 
	...

501014a0 <__interrupt_165>:
501014a0:	e0 a5       	bisr 165
501014a2:	91 00 00 f7 	movh.a %a15,28672
501014a6:	d9 ff 90 84 	lea %a15,[%a15]18960 <70004a10 <Cdisptab+0x528>>
501014aa:	c4 fe       	ld.a %a14,[%a15+]
501014ac:	54 f4       	ld.w %d4,[%a15]
501014ae:	2d 0e 00 00 	calli %a14
501014b2:	0d 00 40 02 	rslcx 
501014b6:	00 80       	rfe 
	...

501014c0 <__interrupt_166>:
501014c0:	e0 a6       	bisr 166
501014c2:	91 00 00 f7 	movh.a %a15,28672
501014c6:	d9 ff 98 84 	lea %a15,[%a15]18968 <70004a18 <Cdisptab+0x530>>
501014ca:	c4 fe       	ld.a %a14,[%a15+]
501014cc:	54 f4       	ld.w %d4,[%a15]
501014ce:	2d 0e 00 00 	calli %a14
501014d2:	0d 00 40 02 	rslcx 
501014d6:	00 80       	rfe 
	...

501014e0 <__interrupt_167>:
501014e0:	e0 a7       	bisr 167
501014e2:	91 00 00 f7 	movh.a %a15,28672
501014e6:	d9 ff a0 84 	lea %a15,[%a15]18976 <70004a20 <Cdisptab+0x538>>
501014ea:	c4 fe       	ld.a %a14,[%a15+]
501014ec:	54 f4       	ld.w %d4,[%a15]
501014ee:	2d 0e 00 00 	calli %a14
501014f2:	0d 00 40 02 	rslcx 
501014f6:	00 80       	rfe 
	...

50101500 <__interrupt_168>:
50101500:	e0 a8       	bisr 168
50101502:	91 00 00 f7 	movh.a %a15,28672
50101506:	d9 ff a8 84 	lea %a15,[%a15]18984 <70004a28 <Cdisptab+0x540>>
5010150a:	c4 fe       	ld.a %a14,[%a15+]
5010150c:	54 f4       	ld.w %d4,[%a15]
5010150e:	2d 0e 00 00 	calli %a14
50101512:	0d 00 40 02 	rslcx 
50101516:	00 80       	rfe 
	...

50101520 <__interrupt_169>:
50101520:	e0 a9       	bisr 169
50101522:	91 00 00 f7 	movh.a %a15,28672
50101526:	d9 ff b0 84 	lea %a15,[%a15]18992 <70004a30 <Cdisptab+0x548>>
5010152a:	c4 fe       	ld.a %a14,[%a15+]
5010152c:	54 f4       	ld.w %d4,[%a15]
5010152e:	2d 0e 00 00 	calli %a14
50101532:	0d 00 40 02 	rslcx 
50101536:	00 80       	rfe 
	...

50101540 <__interrupt_170>:
50101540:	e0 aa       	bisr 170
50101542:	91 00 00 f7 	movh.a %a15,28672
50101546:	d9 ff b8 84 	lea %a15,[%a15]19000 <70004a38 <Cdisptab+0x550>>
5010154a:	c4 fe       	ld.a %a14,[%a15+]
5010154c:	54 f4       	ld.w %d4,[%a15]
5010154e:	2d 0e 00 00 	calli %a14
50101552:	0d 00 40 02 	rslcx 
50101556:	00 80       	rfe 
	...

50101560 <__interrupt_171>:
50101560:	e0 ab       	bisr 171
50101562:	91 00 00 f7 	movh.a %a15,28672
50101566:	d9 ff 80 94 	lea %a15,[%a15]19008 <70004a40 <Cdisptab+0x558>>
5010156a:	c4 fe       	ld.a %a14,[%a15+]
5010156c:	54 f4       	ld.w %d4,[%a15]
5010156e:	2d 0e 00 00 	calli %a14
50101572:	0d 00 40 02 	rslcx 
50101576:	00 80       	rfe 
	...

50101580 <__interrupt_172>:
50101580:	e0 ac       	bisr 172
50101582:	91 00 00 f7 	movh.a %a15,28672
50101586:	d9 ff 88 94 	lea %a15,[%a15]19016 <70004a48 <Cdisptab+0x560>>
5010158a:	c4 fe       	ld.a %a14,[%a15+]
5010158c:	54 f4       	ld.w %d4,[%a15]
5010158e:	2d 0e 00 00 	calli %a14
50101592:	0d 00 40 02 	rslcx 
50101596:	00 80       	rfe 
	...

501015a0 <__interrupt_173>:
501015a0:	e0 ad       	bisr 173
501015a2:	91 00 00 f7 	movh.a %a15,28672
501015a6:	d9 ff 90 94 	lea %a15,[%a15]19024 <70004a50 <Cdisptab+0x568>>
501015aa:	c4 fe       	ld.a %a14,[%a15+]
501015ac:	54 f4       	ld.w %d4,[%a15]
501015ae:	2d 0e 00 00 	calli %a14
501015b2:	0d 00 40 02 	rslcx 
501015b6:	00 80       	rfe 
	...

501015c0 <__interrupt_174>:
501015c0:	e0 ae       	bisr 174
501015c2:	91 00 00 f7 	movh.a %a15,28672
501015c6:	d9 ff 98 94 	lea %a15,[%a15]19032 <70004a58 <Cdisptab+0x570>>
501015ca:	c4 fe       	ld.a %a14,[%a15+]
501015cc:	54 f4       	ld.w %d4,[%a15]
501015ce:	2d 0e 00 00 	calli %a14
501015d2:	0d 00 40 02 	rslcx 
501015d6:	00 80       	rfe 
	...

501015e0 <__interrupt_175>:
501015e0:	e0 af       	bisr 175
501015e2:	91 00 00 f7 	movh.a %a15,28672
501015e6:	d9 ff a0 94 	lea %a15,[%a15]19040 <70004a60 <Cdisptab+0x578>>
501015ea:	c4 fe       	ld.a %a14,[%a15+]
501015ec:	54 f4       	ld.w %d4,[%a15]
501015ee:	2d 0e 00 00 	calli %a14
501015f2:	0d 00 40 02 	rslcx 
501015f6:	00 80       	rfe 
	...

50101600 <__interrupt_176>:
50101600:	e0 b0       	bisr 176
50101602:	91 00 00 f7 	movh.a %a15,28672
50101606:	d9 ff a8 94 	lea %a15,[%a15]19048 <70004a68 <Cdisptab+0x580>>
5010160a:	c4 fe       	ld.a %a14,[%a15+]
5010160c:	54 f4       	ld.w %d4,[%a15]
5010160e:	2d 0e 00 00 	calli %a14
50101612:	0d 00 40 02 	rslcx 
50101616:	00 80       	rfe 
	...

50101620 <__interrupt_177>:
50101620:	e0 b1       	bisr 177
50101622:	91 00 00 f7 	movh.a %a15,28672
50101626:	d9 ff b0 94 	lea %a15,[%a15]19056 <70004a70 <Cdisptab+0x588>>
5010162a:	c4 fe       	ld.a %a14,[%a15+]
5010162c:	54 f4       	ld.w %d4,[%a15]
5010162e:	2d 0e 00 00 	calli %a14
50101632:	0d 00 40 02 	rslcx 
50101636:	00 80       	rfe 
	...

50101640 <__interrupt_178>:
50101640:	e0 b2       	bisr 178
50101642:	91 00 00 f7 	movh.a %a15,28672
50101646:	d9 ff b8 94 	lea %a15,[%a15]19064 <70004a78 <Cdisptab+0x590>>
5010164a:	c4 fe       	ld.a %a14,[%a15+]
5010164c:	54 f4       	ld.w %d4,[%a15]
5010164e:	2d 0e 00 00 	calli %a14
50101652:	0d 00 40 02 	rslcx 
50101656:	00 80       	rfe 
	...

50101660 <__interrupt_179>:
50101660:	e0 b3       	bisr 179
50101662:	91 00 00 f7 	movh.a %a15,28672
50101666:	d9 ff 80 a4 	lea %a15,[%a15]19072 <70004a80 <Cdisptab+0x598>>
5010166a:	c4 fe       	ld.a %a14,[%a15+]
5010166c:	54 f4       	ld.w %d4,[%a15]
5010166e:	2d 0e 00 00 	calli %a14
50101672:	0d 00 40 02 	rslcx 
50101676:	00 80       	rfe 
	...

50101680 <__interrupt_180>:
50101680:	e0 b4       	bisr 180
50101682:	91 00 00 f7 	movh.a %a15,28672
50101686:	d9 ff 88 a4 	lea %a15,[%a15]19080 <70004a88 <Cdisptab+0x5a0>>
5010168a:	c4 fe       	ld.a %a14,[%a15+]
5010168c:	54 f4       	ld.w %d4,[%a15]
5010168e:	2d 0e 00 00 	calli %a14
50101692:	0d 00 40 02 	rslcx 
50101696:	00 80       	rfe 
	...

501016a0 <__interrupt_181>:
501016a0:	e0 b5       	bisr 181
501016a2:	91 00 00 f7 	movh.a %a15,28672
501016a6:	d9 ff 90 a4 	lea %a15,[%a15]19088 <70004a90 <Cdisptab+0x5a8>>
501016aa:	c4 fe       	ld.a %a14,[%a15+]
501016ac:	54 f4       	ld.w %d4,[%a15]
501016ae:	2d 0e 00 00 	calli %a14
501016b2:	0d 00 40 02 	rslcx 
501016b6:	00 80       	rfe 
	...

501016c0 <__interrupt_182>:
501016c0:	e0 b6       	bisr 182
501016c2:	91 00 00 f7 	movh.a %a15,28672
501016c6:	d9 ff 98 a4 	lea %a15,[%a15]19096 <70004a98 <Cdisptab+0x5b0>>
501016ca:	c4 fe       	ld.a %a14,[%a15+]
501016cc:	54 f4       	ld.w %d4,[%a15]
501016ce:	2d 0e 00 00 	calli %a14
501016d2:	0d 00 40 02 	rslcx 
501016d6:	00 80       	rfe 
	...

501016e0 <__interrupt_183>:
501016e0:	e0 b7       	bisr 183
501016e2:	91 00 00 f7 	movh.a %a15,28672
501016e6:	d9 ff a0 a4 	lea %a15,[%a15]19104 <70004aa0 <Cdisptab+0x5b8>>
501016ea:	c4 fe       	ld.a %a14,[%a15+]
501016ec:	54 f4       	ld.w %d4,[%a15]
501016ee:	2d 0e 00 00 	calli %a14
501016f2:	0d 00 40 02 	rslcx 
501016f6:	00 80       	rfe 
	...

50101700 <__interrupt_184>:
50101700:	e0 b8       	bisr 184
50101702:	91 00 00 f7 	movh.a %a15,28672
50101706:	d9 ff a8 a4 	lea %a15,[%a15]19112 <70004aa8 <Cdisptab+0x5c0>>
5010170a:	c4 fe       	ld.a %a14,[%a15+]
5010170c:	54 f4       	ld.w %d4,[%a15]
5010170e:	2d 0e 00 00 	calli %a14
50101712:	0d 00 40 02 	rslcx 
50101716:	00 80       	rfe 
	...

50101720 <__interrupt_185>:
50101720:	e0 b9       	bisr 185
50101722:	91 00 00 f7 	movh.a %a15,28672
50101726:	d9 ff b0 a4 	lea %a15,[%a15]19120 <70004ab0 <Cdisptab+0x5c8>>
5010172a:	c4 fe       	ld.a %a14,[%a15+]
5010172c:	54 f4       	ld.w %d4,[%a15]
5010172e:	2d 0e 00 00 	calli %a14
50101732:	0d 00 40 02 	rslcx 
50101736:	00 80       	rfe 
	...

50101740 <__interrupt_186>:
50101740:	e0 ba       	bisr 186
50101742:	91 00 00 f7 	movh.a %a15,28672
50101746:	d9 ff b8 a4 	lea %a15,[%a15]19128 <70004ab8 <Cdisptab+0x5d0>>
5010174a:	c4 fe       	ld.a %a14,[%a15+]
5010174c:	54 f4       	ld.w %d4,[%a15]
5010174e:	2d 0e 00 00 	calli %a14
50101752:	0d 00 40 02 	rslcx 
50101756:	00 80       	rfe 
	...

50101760 <__interrupt_187>:
50101760:	e0 bb       	bisr 187
50101762:	91 00 00 f7 	movh.a %a15,28672
50101766:	d9 ff 80 b4 	lea %a15,[%a15]19136 <70004ac0 <Cdisptab+0x5d8>>
5010176a:	c4 fe       	ld.a %a14,[%a15+]
5010176c:	54 f4       	ld.w %d4,[%a15]
5010176e:	2d 0e 00 00 	calli %a14
50101772:	0d 00 40 02 	rslcx 
50101776:	00 80       	rfe 
	...

50101780 <__interrupt_188>:
50101780:	e0 bc       	bisr 188
50101782:	91 00 00 f7 	movh.a %a15,28672
50101786:	d9 ff 88 b4 	lea %a15,[%a15]19144 <70004ac8 <Cdisptab+0x5e0>>
5010178a:	c4 fe       	ld.a %a14,[%a15+]
5010178c:	54 f4       	ld.w %d4,[%a15]
5010178e:	2d 0e 00 00 	calli %a14
50101792:	0d 00 40 02 	rslcx 
50101796:	00 80       	rfe 
	...

501017a0 <__interrupt_189>:
501017a0:	e0 bd       	bisr 189
501017a2:	91 00 00 f7 	movh.a %a15,28672
501017a6:	d9 ff 90 b4 	lea %a15,[%a15]19152 <70004ad0 <Cdisptab+0x5e8>>
501017aa:	c4 fe       	ld.a %a14,[%a15+]
501017ac:	54 f4       	ld.w %d4,[%a15]
501017ae:	2d 0e 00 00 	calli %a14
501017b2:	0d 00 40 02 	rslcx 
501017b6:	00 80       	rfe 
	...

501017c0 <__interrupt_190>:
501017c0:	e0 be       	bisr 190
501017c2:	91 00 00 f7 	movh.a %a15,28672
501017c6:	d9 ff 98 b4 	lea %a15,[%a15]19160 <70004ad8 <Cdisptab+0x5f0>>
501017ca:	c4 fe       	ld.a %a14,[%a15+]
501017cc:	54 f4       	ld.w %d4,[%a15]
501017ce:	2d 0e 00 00 	calli %a14
501017d2:	0d 00 40 02 	rslcx 
501017d6:	00 80       	rfe 
	...

501017e0 <__interrupt_191>:
501017e0:	e0 bf       	bisr 191
501017e2:	91 00 00 f7 	movh.a %a15,28672
501017e6:	d9 ff a0 b4 	lea %a15,[%a15]19168 <70004ae0 <Cdisptab+0x5f8>>
501017ea:	c4 fe       	ld.a %a14,[%a15+]
501017ec:	54 f4       	ld.w %d4,[%a15]
501017ee:	2d 0e 00 00 	calli %a14
501017f2:	0d 00 40 02 	rslcx 
501017f6:	00 80       	rfe 
	...

50101800 <__interrupt_192>:
50101800:	e0 c0       	bisr 192
50101802:	91 00 00 f7 	movh.a %a15,28672
50101806:	d9 ff a8 b4 	lea %a15,[%a15]19176 <70004ae8 <Cdisptab+0x600>>
5010180a:	c4 fe       	ld.a %a14,[%a15+]
5010180c:	54 f4       	ld.w %d4,[%a15]
5010180e:	2d 0e 00 00 	calli %a14
50101812:	0d 00 40 02 	rslcx 
50101816:	00 80       	rfe 
	...

50101820 <__interrupt_193>:
50101820:	e0 c1       	bisr 193
50101822:	91 00 00 f7 	movh.a %a15,28672
50101826:	d9 ff b0 b4 	lea %a15,[%a15]19184 <70004af0 <Cdisptab+0x608>>
5010182a:	c4 fe       	ld.a %a14,[%a15+]
5010182c:	54 f4       	ld.w %d4,[%a15]
5010182e:	2d 0e 00 00 	calli %a14
50101832:	0d 00 40 02 	rslcx 
50101836:	00 80       	rfe 
	...

50101840 <__interrupt_194>:
50101840:	e0 c2       	bisr 194
50101842:	91 00 00 f7 	movh.a %a15,28672
50101846:	d9 ff b8 b4 	lea %a15,[%a15]19192 <70004af8 <Cdisptab+0x610>>
5010184a:	c4 fe       	ld.a %a14,[%a15+]
5010184c:	54 f4       	ld.w %d4,[%a15]
5010184e:	2d 0e 00 00 	calli %a14
50101852:	0d 00 40 02 	rslcx 
50101856:	00 80       	rfe 
	...

50101860 <__interrupt_195>:
50101860:	e0 c3       	bisr 195
50101862:	91 00 00 f7 	movh.a %a15,28672
50101866:	d9 ff 80 c4 	lea %a15,[%a15]19200 <70004b00 <Cdisptab+0x618>>
5010186a:	c4 fe       	ld.a %a14,[%a15+]
5010186c:	54 f4       	ld.w %d4,[%a15]
5010186e:	2d 0e 00 00 	calli %a14
50101872:	0d 00 40 02 	rslcx 
50101876:	00 80       	rfe 
	...

50101880 <__interrupt_196>:
50101880:	e0 c4       	bisr 196
50101882:	91 00 00 f7 	movh.a %a15,28672
50101886:	d9 ff 88 c4 	lea %a15,[%a15]19208 <70004b08 <Cdisptab+0x620>>
5010188a:	c4 fe       	ld.a %a14,[%a15+]
5010188c:	54 f4       	ld.w %d4,[%a15]
5010188e:	2d 0e 00 00 	calli %a14
50101892:	0d 00 40 02 	rslcx 
50101896:	00 80       	rfe 
	...

501018a0 <__interrupt_197>:
501018a0:	e0 c5       	bisr 197
501018a2:	91 00 00 f7 	movh.a %a15,28672
501018a6:	d9 ff 90 c4 	lea %a15,[%a15]19216 <70004b10 <Cdisptab+0x628>>
501018aa:	c4 fe       	ld.a %a14,[%a15+]
501018ac:	54 f4       	ld.w %d4,[%a15]
501018ae:	2d 0e 00 00 	calli %a14
501018b2:	0d 00 40 02 	rslcx 
501018b6:	00 80       	rfe 
	...

501018c0 <__interrupt_198>:
501018c0:	e0 c6       	bisr 198
501018c2:	91 00 00 f7 	movh.a %a15,28672
501018c6:	d9 ff 98 c4 	lea %a15,[%a15]19224 <70004b18 <Cdisptab+0x630>>
501018ca:	c4 fe       	ld.a %a14,[%a15+]
501018cc:	54 f4       	ld.w %d4,[%a15]
501018ce:	2d 0e 00 00 	calli %a14
501018d2:	0d 00 40 02 	rslcx 
501018d6:	00 80       	rfe 
	...

501018e0 <__interrupt_199>:
501018e0:	e0 c7       	bisr 199
501018e2:	91 00 00 f7 	movh.a %a15,28672
501018e6:	d9 ff a0 c4 	lea %a15,[%a15]19232 <70004b20 <Cdisptab+0x638>>
501018ea:	c4 fe       	ld.a %a14,[%a15+]
501018ec:	54 f4       	ld.w %d4,[%a15]
501018ee:	2d 0e 00 00 	calli %a14
501018f2:	0d 00 40 02 	rslcx 
501018f6:	00 80       	rfe 
	...

50101900 <__interrupt_200>:
50101900:	e0 c8       	bisr 200
50101902:	91 00 00 f7 	movh.a %a15,28672
50101906:	d9 ff a8 c4 	lea %a15,[%a15]19240 <70004b28 <Cdisptab+0x640>>
5010190a:	c4 fe       	ld.a %a14,[%a15+]
5010190c:	54 f4       	ld.w %d4,[%a15]
5010190e:	2d 0e 00 00 	calli %a14
50101912:	0d 00 40 02 	rslcx 
50101916:	00 80       	rfe 
	...

50101920 <__interrupt_201>:
50101920:	e0 c9       	bisr 201
50101922:	91 00 00 f7 	movh.a %a15,28672
50101926:	d9 ff b0 c4 	lea %a15,[%a15]19248 <70004b30 <Cdisptab+0x648>>
5010192a:	c4 fe       	ld.a %a14,[%a15+]
5010192c:	54 f4       	ld.w %d4,[%a15]
5010192e:	2d 0e 00 00 	calli %a14
50101932:	0d 00 40 02 	rslcx 
50101936:	00 80       	rfe 
	...

50101940 <__interrupt_202>:
50101940:	e0 ca       	bisr 202
50101942:	91 00 00 f7 	movh.a %a15,28672
50101946:	d9 ff b8 c4 	lea %a15,[%a15]19256 <70004b38 <Cdisptab+0x650>>
5010194a:	c4 fe       	ld.a %a14,[%a15+]
5010194c:	54 f4       	ld.w %d4,[%a15]
5010194e:	2d 0e 00 00 	calli %a14
50101952:	0d 00 40 02 	rslcx 
50101956:	00 80       	rfe 
	...

50101960 <__interrupt_203>:
50101960:	e0 cb       	bisr 203
50101962:	91 00 00 f7 	movh.a %a15,28672
50101966:	d9 ff 80 d4 	lea %a15,[%a15]19264 <70004b40 <Cdisptab+0x658>>
5010196a:	c4 fe       	ld.a %a14,[%a15+]
5010196c:	54 f4       	ld.w %d4,[%a15]
5010196e:	2d 0e 00 00 	calli %a14
50101972:	0d 00 40 02 	rslcx 
50101976:	00 80       	rfe 
	...

50101980 <__interrupt_204>:
50101980:	e0 cc       	bisr 204
50101982:	91 00 00 f7 	movh.a %a15,28672
50101986:	d9 ff 88 d4 	lea %a15,[%a15]19272 <70004b48 <Cdisptab+0x660>>
5010198a:	c4 fe       	ld.a %a14,[%a15+]
5010198c:	54 f4       	ld.w %d4,[%a15]
5010198e:	2d 0e 00 00 	calli %a14
50101992:	0d 00 40 02 	rslcx 
50101996:	00 80       	rfe 
	...

501019a0 <__interrupt_205>:
501019a0:	e0 cd       	bisr 205
501019a2:	91 00 00 f7 	movh.a %a15,28672
501019a6:	d9 ff 90 d4 	lea %a15,[%a15]19280 <70004b50 <Cdisptab+0x668>>
501019aa:	c4 fe       	ld.a %a14,[%a15+]
501019ac:	54 f4       	ld.w %d4,[%a15]
501019ae:	2d 0e 00 00 	calli %a14
501019b2:	0d 00 40 02 	rslcx 
501019b6:	00 80       	rfe 
	...

501019c0 <__interrupt_206>:
501019c0:	e0 ce       	bisr 206
501019c2:	91 00 00 f7 	movh.a %a15,28672
501019c6:	d9 ff 98 d4 	lea %a15,[%a15]19288 <70004b58 <Cdisptab+0x670>>
501019ca:	c4 fe       	ld.a %a14,[%a15+]
501019cc:	54 f4       	ld.w %d4,[%a15]
501019ce:	2d 0e 00 00 	calli %a14
501019d2:	0d 00 40 02 	rslcx 
501019d6:	00 80       	rfe 
	...

501019e0 <__interrupt_207>:
501019e0:	e0 cf       	bisr 207
501019e2:	91 00 00 f7 	movh.a %a15,28672
501019e6:	d9 ff a0 d4 	lea %a15,[%a15]19296 <70004b60 <Cdisptab+0x678>>
501019ea:	c4 fe       	ld.a %a14,[%a15+]
501019ec:	54 f4       	ld.w %d4,[%a15]
501019ee:	2d 0e 00 00 	calli %a14
501019f2:	0d 00 40 02 	rslcx 
501019f6:	00 80       	rfe 
	...

50101a00 <__interrupt_208>:
50101a00:	e0 d0       	bisr 208
50101a02:	91 00 00 f7 	movh.a %a15,28672
50101a06:	d9 ff a8 d4 	lea %a15,[%a15]19304 <70004b68 <Cdisptab+0x680>>
50101a0a:	c4 fe       	ld.a %a14,[%a15+]
50101a0c:	54 f4       	ld.w %d4,[%a15]
50101a0e:	2d 0e 00 00 	calli %a14
50101a12:	0d 00 40 02 	rslcx 
50101a16:	00 80       	rfe 
	...

50101a20 <__interrupt_209>:
50101a20:	e0 d1       	bisr 209
50101a22:	91 00 00 f7 	movh.a %a15,28672
50101a26:	d9 ff b0 d4 	lea %a15,[%a15]19312 <70004b70 <Cdisptab+0x688>>
50101a2a:	c4 fe       	ld.a %a14,[%a15+]
50101a2c:	54 f4       	ld.w %d4,[%a15]
50101a2e:	2d 0e 00 00 	calli %a14
50101a32:	0d 00 40 02 	rslcx 
50101a36:	00 80       	rfe 
	...

50101a40 <__interrupt_210>:
50101a40:	e0 d2       	bisr 210
50101a42:	91 00 00 f7 	movh.a %a15,28672
50101a46:	d9 ff b8 d4 	lea %a15,[%a15]19320 <70004b78 <Cdisptab+0x690>>
50101a4a:	c4 fe       	ld.a %a14,[%a15+]
50101a4c:	54 f4       	ld.w %d4,[%a15]
50101a4e:	2d 0e 00 00 	calli %a14
50101a52:	0d 00 40 02 	rslcx 
50101a56:	00 80       	rfe 
	...

50101a60 <__interrupt_211>:
50101a60:	e0 d3       	bisr 211
50101a62:	91 00 00 f7 	movh.a %a15,28672
50101a66:	d9 ff 80 e4 	lea %a15,[%a15]19328 <70004b80 <Cdisptab+0x698>>
50101a6a:	c4 fe       	ld.a %a14,[%a15+]
50101a6c:	54 f4       	ld.w %d4,[%a15]
50101a6e:	2d 0e 00 00 	calli %a14
50101a72:	0d 00 40 02 	rslcx 
50101a76:	00 80       	rfe 
	...

50101a80 <__interrupt_212>:
50101a80:	e0 d4       	bisr 212
50101a82:	91 00 00 f7 	movh.a %a15,28672
50101a86:	d9 ff 88 e4 	lea %a15,[%a15]19336 <70004b88 <Cdisptab+0x6a0>>
50101a8a:	c4 fe       	ld.a %a14,[%a15+]
50101a8c:	54 f4       	ld.w %d4,[%a15]
50101a8e:	2d 0e 00 00 	calli %a14
50101a92:	0d 00 40 02 	rslcx 
50101a96:	00 80       	rfe 
	...

50101aa0 <__interrupt_213>:
50101aa0:	e0 d5       	bisr 213
50101aa2:	91 00 00 f7 	movh.a %a15,28672
50101aa6:	d9 ff 90 e4 	lea %a15,[%a15]19344 <70004b90 <Cdisptab+0x6a8>>
50101aaa:	c4 fe       	ld.a %a14,[%a15+]
50101aac:	54 f4       	ld.w %d4,[%a15]
50101aae:	2d 0e 00 00 	calli %a14
50101ab2:	0d 00 40 02 	rslcx 
50101ab6:	00 80       	rfe 
	...

50101ac0 <__interrupt_214>:
50101ac0:	e0 d6       	bisr 214
50101ac2:	91 00 00 f7 	movh.a %a15,28672
50101ac6:	d9 ff 98 e4 	lea %a15,[%a15]19352 <70004b98 <Cdisptab+0x6b0>>
50101aca:	c4 fe       	ld.a %a14,[%a15+]
50101acc:	54 f4       	ld.w %d4,[%a15]
50101ace:	2d 0e 00 00 	calli %a14
50101ad2:	0d 00 40 02 	rslcx 
50101ad6:	00 80       	rfe 
	...

50101ae0 <__interrupt_215>:
50101ae0:	e0 d7       	bisr 215
50101ae2:	91 00 00 f7 	movh.a %a15,28672
50101ae6:	d9 ff a0 e4 	lea %a15,[%a15]19360 <70004ba0 <Cdisptab+0x6b8>>
50101aea:	c4 fe       	ld.a %a14,[%a15+]
50101aec:	54 f4       	ld.w %d4,[%a15]
50101aee:	2d 0e 00 00 	calli %a14
50101af2:	0d 00 40 02 	rslcx 
50101af6:	00 80       	rfe 
	...

50101b00 <__interrupt_216>:
50101b00:	e0 d8       	bisr 216
50101b02:	91 00 00 f7 	movh.a %a15,28672
50101b06:	d9 ff a8 e4 	lea %a15,[%a15]19368 <70004ba8 <Cdisptab+0x6c0>>
50101b0a:	c4 fe       	ld.a %a14,[%a15+]
50101b0c:	54 f4       	ld.w %d4,[%a15]
50101b0e:	2d 0e 00 00 	calli %a14
50101b12:	0d 00 40 02 	rslcx 
50101b16:	00 80       	rfe 
	...

50101b20 <__interrupt_217>:
50101b20:	e0 d9       	bisr 217
50101b22:	91 00 00 f7 	movh.a %a15,28672
50101b26:	d9 ff b0 e4 	lea %a15,[%a15]19376 <70004bb0 <Cdisptab+0x6c8>>
50101b2a:	c4 fe       	ld.a %a14,[%a15+]
50101b2c:	54 f4       	ld.w %d4,[%a15]
50101b2e:	2d 0e 00 00 	calli %a14
50101b32:	0d 00 40 02 	rslcx 
50101b36:	00 80       	rfe 
	...

50101b40 <__interrupt_218>:
50101b40:	e0 da       	bisr 218
50101b42:	91 00 00 f7 	movh.a %a15,28672
50101b46:	d9 ff b8 e4 	lea %a15,[%a15]19384 <70004bb8 <Cdisptab+0x6d0>>
50101b4a:	c4 fe       	ld.a %a14,[%a15+]
50101b4c:	54 f4       	ld.w %d4,[%a15]
50101b4e:	2d 0e 00 00 	calli %a14
50101b52:	0d 00 40 02 	rslcx 
50101b56:	00 80       	rfe 
	...

50101b60 <__interrupt_219>:
50101b60:	e0 db       	bisr 219
50101b62:	91 00 00 f7 	movh.a %a15,28672
50101b66:	d9 ff 80 f4 	lea %a15,[%a15]19392 <70004bc0 <Cdisptab+0x6d8>>
50101b6a:	c4 fe       	ld.a %a14,[%a15+]
50101b6c:	54 f4       	ld.w %d4,[%a15]
50101b6e:	2d 0e 00 00 	calli %a14
50101b72:	0d 00 40 02 	rslcx 
50101b76:	00 80       	rfe 
	...

50101b80 <__interrupt_220>:
50101b80:	e0 dc       	bisr 220
50101b82:	91 00 00 f7 	movh.a %a15,28672
50101b86:	d9 ff 88 f4 	lea %a15,[%a15]19400 <70004bc8 <Cdisptab+0x6e0>>
50101b8a:	c4 fe       	ld.a %a14,[%a15+]
50101b8c:	54 f4       	ld.w %d4,[%a15]
50101b8e:	2d 0e 00 00 	calli %a14
50101b92:	0d 00 40 02 	rslcx 
50101b96:	00 80       	rfe 
	...

50101ba0 <__interrupt_221>:
50101ba0:	e0 dd       	bisr 221
50101ba2:	91 00 00 f7 	movh.a %a15,28672
50101ba6:	d9 ff 90 f4 	lea %a15,[%a15]19408 <70004bd0 <Cdisptab+0x6e8>>
50101baa:	c4 fe       	ld.a %a14,[%a15+]
50101bac:	54 f4       	ld.w %d4,[%a15]
50101bae:	2d 0e 00 00 	calli %a14
50101bb2:	0d 00 40 02 	rslcx 
50101bb6:	00 80       	rfe 
	...

50101bc0 <__interrupt_222>:
50101bc0:	e0 de       	bisr 222
50101bc2:	91 00 00 f7 	movh.a %a15,28672
50101bc6:	d9 ff 98 f4 	lea %a15,[%a15]19416 <70004bd8 <Cdisptab+0x6f0>>
50101bca:	c4 fe       	ld.a %a14,[%a15+]
50101bcc:	54 f4       	ld.w %d4,[%a15]
50101bce:	2d 0e 00 00 	calli %a14
50101bd2:	0d 00 40 02 	rslcx 
50101bd6:	00 80       	rfe 
	...

50101be0 <__interrupt_223>:
50101be0:	e0 df       	bisr 223
50101be2:	91 00 00 f7 	movh.a %a15,28672
50101be6:	d9 ff a0 f4 	lea %a15,[%a15]19424 <70004be0 <Cdisptab+0x6f8>>
50101bea:	c4 fe       	ld.a %a14,[%a15+]
50101bec:	54 f4       	ld.w %d4,[%a15]
50101bee:	2d 0e 00 00 	calli %a14
50101bf2:	0d 00 40 02 	rslcx 
50101bf6:	00 80       	rfe 
	...

50101c00 <__interrupt_224>:
50101c00:	e0 e0       	bisr 224
50101c02:	91 00 00 f7 	movh.a %a15,28672
50101c06:	d9 ff a8 f4 	lea %a15,[%a15]19432 <70004be8 <Cdisptab+0x700>>
50101c0a:	c4 fe       	ld.a %a14,[%a15+]
50101c0c:	54 f4       	ld.w %d4,[%a15]
50101c0e:	2d 0e 00 00 	calli %a14
50101c12:	0d 00 40 02 	rslcx 
50101c16:	00 80       	rfe 
	...

50101c20 <__interrupt_225>:
50101c20:	e0 e1       	bisr 225
50101c22:	91 00 00 f7 	movh.a %a15,28672
50101c26:	d9 ff b0 f4 	lea %a15,[%a15]19440 <70004bf0 <Cdisptab+0x708>>
50101c2a:	c4 fe       	ld.a %a14,[%a15+]
50101c2c:	54 f4       	ld.w %d4,[%a15]
50101c2e:	2d 0e 00 00 	calli %a14
50101c32:	0d 00 40 02 	rslcx 
50101c36:	00 80       	rfe 
	...

50101c40 <__interrupt_226>:
50101c40:	e0 e2       	bisr 226
50101c42:	91 00 00 f7 	movh.a %a15,28672
50101c46:	d9 ff b8 f4 	lea %a15,[%a15]19448 <70004bf8 <Cdisptab+0x710>>
50101c4a:	c4 fe       	ld.a %a14,[%a15+]
50101c4c:	54 f4       	ld.w %d4,[%a15]
50101c4e:	2d 0e 00 00 	calli %a14
50101c52:	0d 00 40 02 	rslcx 
50101c56:	00 80       	rfe 
	...

50101c60 <__interrupt_227>:
50101c60:	e0 e3       	bisr 227
50101c62:	91 00 00 f7 	movh.a %a15,28672
50101c66:	d9 ff c0 04 	lea %a15,[%a15]19456 <70004c00 <Cdisptab+0x718>>
50101c6a:	c4 fe       	ld.a %a14,[%a15+]
50101c6c:	54 f4       	ld.w %d4,[%a15]
50101c6e:	2d 0e 00 00 	calli %a14
50101c72:	0d 00 40 02 	rslcx 
50101c76:	00 80       	rfe 
	...

50101c80 <__interrupt_228>:
50101c80:	e0 e4       	bisr 228
50101c82:	91 00 00 f7 	movh.a %a15,28672
50101c86:	d9 ff c8 04 	lea %a15,[%a15]19464 <70004c08 <Cdisptab+0x720>>
50101c8a:	c4 fe       	ld.a %a14,[%a15+]
50101c8c:	54 f4       	ld.w %d4,[%a15]
50101c8e:	2d 0e 00 00 	calli %a14
50101c92:	0d 00 40 02 	rslcx 
50101c96:	00 80       	rfe 
	...

50101ca0 <__interrupt_229>:
50101ca0:	e0 e5       	bisr 229
50101ca2:	91 00 00 f7 	movh.a %a15,28672
50101ca6:	d9 ff d0 04 	lea %a15,[%a15]19472 <70004c10 <Cdisptab+0x728>>
50101caa:	c4 fe       	ld.a %a14,[%a15+]
50101cac:	54 f4       	ld.w %d4,[%a15]
50101cae:	2d 0e 00 00 	calli %a14
50101cb2:	0d 00 40 02 	rslcx 
50101cb6:	00 80       	rfe 
	...

50101cc0 <__interrupt_230>:
50101cc0:	e0 e6       	bisr 230
50101cc2:	91 00 00 f7 	movh.a %a15,28672
50101cc6:	d9 ff d8 04 	lea %a15,[%a15]19480 <70004c18 <Cdisptab+0x730>>
50101cca:	c4 fe       	ld.a %a14,[%a15+]
50101ccc:	54 f4       	ld.w %d4,[%a15]
50101cce:	2d 0e 00 00 	calli %a14
50101cd2:	0d 00 40 02 	rslcx 
50101cd6:	00 80       	rfe 
	...

50101ce0 <__interrupt_231>:
50101ce0:	e0 e7       	bisr 231
50101ce2:	91 00 00 f7 	movh.a %a15,28672
50101ce6:	d9 ff e0 04 	lea %a15,[%a15]19488 <70004c20 <Cdisptab+0x738>>
50101cea:	c4 fe       	ld.a %a14,[%a15+]
50101cec:	54 f4       	ld.w %d4,[%a15]
50101cee:	2d 0e 00 00 	calli %a14
50101cf2:	0d 00 40 02 	rslcx 
50101cf6:	00 80       	rfe 
	...

50101d00 <__interrupt_232>:
50101d00:	e0 e8       	bisr 232
50101d02:	91 00 00 f7 	movh.a %a15,28672
50101d06:	d9 ff e8 04 	lea %a15,[%a15]19496 <70004c28 <Cdisptab+0x740>>
50101d0a:	c4 fe       	ld.a %a14,[%a15+]
50101d0c:	54 f4       	ld.w %d4,[%a15]
50101d0e:	2d 0e 00 00 	calli %a14
50101d12:	0d 00 40 02 	rslcx 
50101d16:	00 80       	rfe 
	...

50101d20 <__interrupt_233>:
50101d20:	e0 e9       	bisr 233
50101d22:	91 00 00 f7 	movh.a %a15,28672
50101d26:	d9 ff f0 04 	lea %a15,[%a15]19504 <70004c30 <Cdisptab+0x748>>
50101d2a:	c4 fe       	ld.a %a14,[%a15+]
50101d2c:	54 f4       	ld.w %d4,[%a15]
50101d2e:	2d 0e 00 00 	calli %a14
50101d32:	0d 00 40 02 	rslcx 
50101d36:	00 80       	rfe 
	...

50101d40 <__interrupt_234>:
50101d40:	e0 ea       	bisr 234
50101d42:	91 00 00 f7 	movh.a %a15,28672
50101d46:	d9 ff f8 04 	lea %a15,[%a15]19512 <70004c38 <Cdisptab+0x750>>
50101d4a:	c4 fe       	ld.a %a14,[%a15+]
50101d4c:	54 f4       	ld.w %d4,[%a15]
50101d4e:	2d 0e 00 00 	calli %a14
50101d52:	0d 00 40 02 	rslcx 
50101d56:	00 80       	rfe 
	...

50101d60 <__interrupt_235>:
50101d60:	e0 eb       	bisr 235
50101d62:	91 00 00 f7 	movh.a %a15,28672
50101d66:	d9 ff c0 14 	lea %a15,[%a15]19520 <70004c40 <Cdisptab+0x758>>
50101d6a:	c4 fe       	ld.a %a14,[%a15+]
50101d6c:	54 f4       	ld.w %d4,[%a15]
50101d6e:	2d 0e 00 00 	calli %a14
50101d72:	0d 00 40 02 	rslcx 
50101d76:	00 80       	rfe 
	...

50101d80 <__interrupt_236>:
50101d80:	e0 ec       	bisr 236
50101d82:	91 00 00 f7 	movh.a %a15,28672
50101d86:	d9 ff c8 14 	lea %a15,[%a15]19528 <70004c48 <Cdisptab+0x760>>
50101d8a:	c4 fe       	ld.a %a14,[%a15+]
50101d8c:	54 f4       	ld.w %d4,[%a15]
50101d8e:	2d 0e 00 00 	calli %a14
50101d92:	0d 00 40 02 	rslcx 
50101d96:	00 80       	rfe 
	...

50101da0 <__interrupt_237>:
50101da0:	e0 ed       	bisr 237
50101da2:	91 00 00 f7 	movh.a %a15,28672
50101da6:	d9 ff d0 14 	lea %a15,[%a15]19536 <70004c50 <Cdisptab+0x768>>
50101daa:	c4 fe       	ld.a %a14,[%a15+]
50101dac:	54 f4       	ld.w %d4,[%a15]
50101dae:	2d 0e 00 00 	calli %a14
50101db2:	0d 00 40 02 	rslcx 
50101db6:	00 80       	rfe 
	...

50101dc0 <__interrupt_238>:
50101dc0:	e0 ee       	bisr 238
50101dc2:	91 00 00 f7 	movh.a %a15,28672
50101dc6:	d9 ff d8 14 	lea %a15,[%a15]19544 <70004c58 <Cdisptab+0x770>>
50101dca:	c4 fe       	ld.a %a14,[%a15+]
50101dcc:	54 f4       	ld.w %d4,[%a15]
50101dce:	2d 0e 00 00 	calli %a14
50101dd2:	0d 00 40 02 	rslcx 
50101dd6:	00 80       	rfe 
	...

50101de0 <__interrupt_239>:
50101de0:	e0 ef       	bisr 239
50101de2:	91 00 00 f7 	movh.a %a15,28672
50101de6:	d9 ff e0 14 	lea %a15,[%a15]19552 <70004c60 <Cdisptab+0x778>>
50101dea:	c4 fe       	ld.a %a14,[%a15+]
50101dec:	54 f4       	ld.w %d4,[%a15]
50101dee:	2d 0e 00 00 	calli %a14
50101df2:	0d 00 40 02 	rslcx 
50101df6:	00 80       	rfe 
	...

50101e00 <__interrupt_240>:
50101e00:	e0 f0       	bisr 240
50101e02:	91 00 00 f7 	movh.a %a15,28672
50101e06:	d9 ff e8 14 	lea %a15,[%a15]19560 <70004c68 <Cdisptab+0x780>>
50101e0a:	c4 fe       	ld.a %a14,[%a15+]
50101e0c:	54 f4       	ld.w %d4,[%a15]
50101e0e:	2d 0e 00 00 	calli %a14
50101e12:	0d 00 40 02 	rslcx 
50101e16:	00 80       	rfe 
	...

50101e20 <__interrupt_241>:
50101e20:	e0 f1       	bisr 241
50101e22:	91 00 00 f7 	movh.a %a15,28672
50101e26:	d9 ff f0 14 	lea %a15,[%a15]19568 <70004c70 <Cdisptab+0x788>>
50101e2a:	c4 fe       	ld.a %a14,[%a15+]
50101e2c:	54 f4       	ld.w %d4,[%a15]
50101e2e:	2d 0e 00 00 	calli %a14
50101e32:	0d 00 40 02 	rslcx 
50101e36:	00 80       	rfe 
	...

50101e40 <__interrupt_242>:
50101e40:	e0 f2       	bisr 242
50101e42:	91 00 00 f7 	movh.a %a15,28672
50101e46:	d9 ff f8 14 	lea %a15,[%a15]19576 <70004c78 <Cdisptab+0x790>>
50101e4a:	c4 fe       	ld.a %a14,[%a15+]
50101e4c:	54 f4       	ld.w %d4,[%a15]
50101e4e:	2d 0e 00 00 	calli %a14
50101e52:	0d 00 40 02 	rslcx 
50101e56:	00 80       	rfe 
	...

50101e60 <__interrupt_243>:
50101e60:	e0 f3       	bisr 243
50101e62:	91 00 00 f7 	movh.a %a15,28672
50101e66:	d9 ff c0 24 	lea %a15,[%a15]19584 <70004c80 <Cdisptab+0x798>>
50101e6a:	c4 fe       	ld.a %a14,[%a15+]
50101e6c:	54 f4       	ld.w %d4,[%a15]
50101e6e:	2d 0e 00 00 	calli %a14
50101e72:	0d 00 40 02 	rslcx 
50101e76:	00 80       	rfe 
	...

50101e80 <__interrupt_244>:
50101e80:	e0 f4       	bisr 244
50101e82:	91 00 00 f7 	movh.a %a15,28672
50101e86:	d9 ff c8 24 	lea %a15,[%a15]19592 <70004c88 <Cdisptab+0x7a0>>
50101e8a:	c4 fe       	ld.a %a14,[%a15+]
50101e8c:	54 f4       	ld.w %d4,[%a15]
50101e8e:	2d 0e 00 00 	calli %a14
50101e92:	0d 00 40 02 	rslcx 
50101e96:	00 80       	rfe 
	...

50101ea0 <__interrupt_245>:
50101ea0:	e0 f5       	bisr 245
50101ea2:	91 00 00 f7 	movh.a %a15,28672
50101ea6:	d9 ff d0 24 	lea %a15,[%a15]19600 <70004c90 <Cdisptab+0x7a8>>
50101eaa:	c4 fe       	ld.a %a14,[%a15+]
50101eac:	54 f4       	ld.w %d4,[%a15]
50101eae:	2d 0e 00 00 	calli %a14
50101eb2:	0d 00 40 02 	rslcx 
50101eb6:	00 80       	rfe 
	...

50101ec0 <__interrupt_246>:
50101ec0:	e0 f6       	bisr 246
50101ec2:	91 00 00 f7 	movh.a %a15,28672
50101ec6:	d9 ff d8 24 	lea %a15,[%a15]19608 <70004c98 <Cdisptab+0x7b0>>
50101eca:	c4 fe       	ld.a %a14,[%a15+]
50101ecc:	54 f4       	ld.w %d4,[%a15]
50101ece:	2d 0e 00 00 	calli %a14
50101ed2:	0d 00 40 02 	rslcx 
50101ed6:	00 80       	rfe 
	...

50101ee0 <__interrupt_247>:
50101ee0:	e0 f7       	bisr 247
50101ee2:	91 00 00 f7 	movh.a %a15,28672
50101ee6:	d9 ff e0 24 	lea %a15,[%a15]19616 <70004ca0 <Cdisptab+0x7b8>>
50101eea:	c4 fe       	ld.a %a14,[%a15+]
50101eec:	54 f4       	ld.w %d4,[%a15]
50101eee:	2d 0e 00 00 	calli %a14
50101ef2:	0d 00 40 02 	rslcx 
50101ef6:	00 80       	rfe 
	...

50101f00 <__interrupt_248>:
50101f00:	e0 f8       	bisr 248
50101f02:	91 00 00 f7 	movh.a %a15,28672
50101f06:	d9 ff e8 24 	lea %a15,[%a15]19624 <70004ca8 <Cdisptab+0x7c0>>
50101f0a:	c4 fe       	ld.a %a14,[%a15+]
50101f0c:	54 f4       	ld.w %d4,[%a15]
50101f0e:	2d 0e 00 00 	calli %a14
50101f12:	0d 00 40 02 	rslcx 
50101f16:	00 80       	rfe 
	...

50101f20 <__interrupt_249>:
50101f20:	e0 f9       	bisr 249
50101f22:	91 00 00 f7 	movh.a %a15,28672
50101f26:	d9 ff f0 24 	lea %a15,[%a15]19632 <70004cb0 <Cdisptab+0x7c8>>
50101f2a:	c4 fe       	ld.a %a14,[%a15+]
50101f2c:	54 f4       	ld.w %d4,[%a15]
50101f2e:	2d 0e 00 00 	calli %a14
50101f32:	0d 00 40 02 	rslcx 
50101f36:	00 80       	rfe 
	...

50101f40 <__interrupt_250>:
50101f40:	e0 fa       	bisr 250
50101f42:	91 00 00 f7 	movh.a %a15,28672
50101f46:	d9 ff f8 24 	lea %a15,[%a15]19640 <70004cb8 <Cdisptab+0x7d0>>
50101f4a:	c4 fe       	ld.a %a14,[%a15+]
50101f4c:	54 f4       	ld.w %d4,[%a15]
50101f4e:	2d 0e 00 00 	calli %a14
50101f52:	0d 00 40 02 	rslcx 
50101f56:	00 80       	rfe 
	...

50101f60 <__interrupt_251>:
50101f60:	e0 fb       	bisr 251
50101f62:	91 00 00 f7 	movh.a %a15,28672
50101f66:	d9 ff c0 34 	lea %a15,[%a15]19648 <70004cc0 <Cdisptab+0x7d8>>
50101f6a:	c4 fe       	ld.a %a14,[%a15+]
50101f6c:	54 f4       	ld.w %d4,[%a15]
50101f6e:	2d 0e 00 00 	calli %a14
50101f72:	0d 00 40 02 	rslcx 
50101f76:	00 80       	rfe 
	...

50101f80 <__interrupt_252>:
50101f80:	e0 fc       	bisr 252
50101f82:	91 00 00 f7 	movh.a %a15,28672
50101f86:	d9 ff c8 34 	lea %a15,[%a15]19656 <70004cc8 <Cdisptab+0x7e0>>
50101f8a:	c4 fe       	ld.a %a14,[%a15+]
50101f8c:	54 f4       	ld.w %d4,[%a15]
50101f8e:	2d 0e 00 00 	calli %a14
50101f92:	0d 00 40 02 	rslcx 
50101f96:	00 80       	rfe 
	...

50101fa0 <__interrupt_253>:
50101fa0:	e0 fd       	bisr 253
50101fa2:	91 00 00 f7 	movh.a %a15,28672
50101fa6:	d9 ff d0 34 	lea %a15,[%a15]19664 <70004cd0 <Cdisptab+0x7e8>>
50101faa:	c4 fe       	ld.a %a14,[%a15+]
50101fac:	54 f4       	ld.w %d4,[%a15]
50101fae:	2d 0e 00 00 	calli %a14
50101fb2:	0d 00 40 02 	rslcx 
50101fb6:	00 80       	rfe 
	...

50101fc0 <__interrupt_254>:
50101fc0:	e0 fe       	bisr 254
50101fc2:	91 00 00 f7 	movh.a %a15,28672
50101fc6:	d9 ff d8 34 	lea %a15,[%a15]19672 <70004cd8 <Cdisptab+0x7f0>>
50101fca:	c4 fe       	ld.a %a14,[%a15+]
50101fcc:	54 f4       	ld.w %d4,[%a15]
50101fce:	2d 0e 00 00 	calli %a14
50101fd2:	0d 00 40 02 	rslcx 
50101fd6:	00 80       	rfe 
	...

50101fe0 <__interrupt_255>:
50101fe0:	e0 ff       	bisr 255
50101fe2:	91 00 00 f7 	movh.a %a15,28672
50101fe6:	d9 ff e0 34 	lea %a15,[%a15]19680 <70004ce0 <Cdisptab+0x7f8>>
50101fea:	c4 fe       	ld.a %a14,[%a15+]
50101fec:	54 f4       	ld.w %d4,[%a15]
50101fee:	2d 0e 00 00 	calli %a14
50101ff2:	0d 00 40 02 	rslcx 
50101ff6:	00 80       	rfe 
	...
