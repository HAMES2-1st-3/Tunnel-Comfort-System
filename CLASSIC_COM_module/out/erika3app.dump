
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004000 vaddr 0x50100000 paddr 0x50100000 align 2**14
         filesz 0x00002000 memsz 0x00002000 flags r-x
    LOAD off    0x00008020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x00011ef8 memsz 0x00011ef8 flags r-x
    LOAD off    0x0001c000 vaddr 0x70000000 paddr 0x80011f18 align 2**14
         filesz 0x00001ca8 memsz 0x00001ca8 flags rw-
    LOAD off    0x0001e600 vaddr 0x5001a600 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x0001f700 vaddr 0x5001b700 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0001fc00 vaddr 0x5001bc00 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x0001e600 vaddr 0x6001a600 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x0001f700 vaddr 0x6001b700 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x0001fc00 vaddr 0x6001bc00 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x0001dca8 vaddr 0x70001ca8 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00003430 flags rw-
    LOAD off    0x00020600 vaddr 0x70018600 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00021700 vaddr 0x70019700 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00021c00 vaddr 0x70019c00 paddr 0x80013bc0 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00008020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000ee0  80000028  80000028  00008028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .bss          00003430  70001ca8  80013bc0  0001dca8  2**3
                  ALLOC
  3 .data         00001ca8  70000000  80011f18  0001c000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .traptab      00000200  80001000  80001000  00009000  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ctors        00000008  80001200  80001200  00009200  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .dtors        00000008  80001208  80001208  00009208  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .inttab_cpu0  00002000  80002000  80002000  0000a000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text         0000df18  80004000  80004000  0000c000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .inttab       00002000  50100000  50100000  00004000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .CPU2.ustack  00001000  5001a600  80013bc0  0001e600  2**3
                  ALLOC, CPU2
 11 .CPU2.istack  00000400  5001b700  80013bc0  0001f700  2**3
                  ALLOC, CPU2
 12 .CPU2.csa     00002000  5001bc00  80013bc0  0001fc00  2**6
                  ALLOC, CPU2
 13 .CPU1.ustack  00001000  6001a600  80013bc0  0001e600  2**3
                  ALLOC, CPU1
 14 .CPU1.istack  00000400  6001b700  80013bc0  0001f700  2**3
                  ALLOC, CPU1
 15 .CPU1.csa     00002000  6001bc00  80013bc0  0001fc00  2**6
                  ALLOC, CPU1
 16 .CPU0.ustack  00001000  70018600  80013bc0  00020600  2**3
                  ALLOC, CPU0
 17 .CPU0.istack  00000400  70019700  80013bc0  00021700  2**3
                  ALLOC, CPU0
 18 .CPU0.csa     00002000  70019c00  80013bc0  00021c00  2**6
                  ALLOC, CPU0
 19 .comment      00000053  00000000  00000000  0001dca8  2**0
                  CONTENTS, READONLY
 20 .debug_aranges 00000da8  00000000  00000000  0001dd00  2**3
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_info   000b6014  00000000  00000000  0001eaa8  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_abbrev 0000bbc8  00000000  00000000  000d4abc  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   000191c2  00000000  00000000  000e0684  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  00002058  00000000  00000000  000f9848  2**2
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    00001e5f  00000000  00000000  000fb8a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_loc    0001ad75  00000000  00000000  000fd6ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_ranges 000030b8  00000000  00000000  00118474  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .version_info 0007f542  00000000  00000000  0011b52c  2**0
                  CONTENTS, READONLY
 29 .debug_macro  00290dda  00000000  00000000  0019aa6e  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
70001ca8 l    d  .bss	00000000 .bss
70000000 l    d  .data	00000000 .data
80001000 l    d  .traptab	00000000 .traptab
80001200 l    d  .ctors	00000000 .ctors
80001208 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
50100000 l    d  .inttab	00000000 .inttab
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 COM.c
00000000 l    df *ABS*	00000000 Driver_Can.c
00000000 l    df *ABS*	00000000 IfxMultican_PinMap.c
00000000 l    df *ABS*	00000000 IfxMultican_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
80007d3c l     F .text	000000e4 IfxScuCcu_wait
700012c0 l     O .data	00000004 IfxScuCcu_xtalFrequency
80000674 l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 asclin.c
00000000 l    df *ABS*	00000000 ee_applcfg.c
8000073c l     O .rodata	00000030 osEE_tdb_ptr_array
80000730 l     O .rodata	00000004 osEE_res_db_ptr_array
80000720 l     O .rodata	00000004 osEE_counter_db_ptr_array
80000700 l     O .rodata	00000004 osEE_alarm_db_ptr_array
8000076c l     O .rodata	00000180 osEE_tdb_array
80000724 l     O .rodata	0000000c osEE_counter_db_array
700012e8 l     O .data	00000058 osEE_sn_array
80000704 l     O .rodata	0000001c osEE_alarm_db_array
70001fec l     O .bss	00000010 osEE_alarm_cb_array
70001ffc l     O .bss	00000008 osEE_counter_cb_array
80000734 l     O .rodata	00000008 osEE_res_db_array
70002004 l     O .bss	0000000c osEE_res_cb_array
800008ec l     O .rodata	00000058 osEE_sdb_array
70001430 l     O .data	0000002c osEE_scb_array
70001340 l     O .data	000000f0 osEE_tcb_array
70004458 l     O .bss	00000404 osEE_task_stack_1
70004050 l     O .bss	00000404 osEE_task_stack_2
70003c48 l     O .bss	00000404 osEE_task_stack_3
70003840 l     O .bss	00000404 osEE_task_stack_4
70003438 l     O .bss	00000404 osEE_task_stack_5
70003030 l     O .bss	00000404 osEE_task_stack_6
70002c28 l     O .bss	00000404 osEE_task_stack_7
70002820 l     O .bss	00000404 osEE_task_stack_8
70002418 l     O .bss	00000404 osEE_task_stack_9
70002010 l     O .bss	00000404 osEE_task_stack_10
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 ctype_.c
80000a76 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 impure.c
7000146c l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 vfprintf.c
80000c44 l     O .rodata	00000010 blanks.4035
80000c34 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000f118 l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 locale.c
80000c70 l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80000ca8 l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 CAN_DB.c
00000000 l    df *ABS*	00000000 SWC_DB.c
00000000 l    df *ABS*	00000000 IfxPort_PinMap.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70001ca0 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ctraptab.c
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
8000c9ce l     F .text	0000000c osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 ASW.c
00000000 l    df *ABS*	00000000 IfxMultican.c
80004dc8 l     F .text	0000013c IfxMultican_MsgObj_doReadLongFrame
00000000 l    df *ABS*	00000000 IfxMultican_Can.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 etc.c
00000000 l    df *ABS*	00000000 GPIO.c
00000000 l    df *ABS*	00000000 ToF.c
70001fe0 l     O .bss	00000004 rxBufIdx
70001fc0 l     O .bss	00000010 rxBuf.37683
70001fd0 l     O .bss	00000010 gBuf_tof
00000000 l    df *ABS*	00000000 interrupts.c
00000000 l    df *ABS*	00000000 system_tc27x.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
70004860 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
00000000 l    df *ABS*	00000000 ee_oo_counter.c
00000000 l    df *ABS*	00000000 ee_oo_alarm.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
8000dc68 l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 int1.c
00000000 l    df *ABS*	00000000 trap6.c
0000fe00 l       *ABS*	00000000 $pcxi
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 cint.c
800111f4 l     F .text	0000000e __class_0_trap_handler
700050c8 l     O .bss	00000004 _init_vectab_initialized
8001121c l     F .text	0000000a __class_7_trap_handler
80011226 l     F .text	0000000a __class_6_trap_handler
80011230 l     F .text	0000000a __class_5_trap_handler
8001123a l     F .text	0000000a __class_4_trap_handler
80011244 l     F .text	0000000a __class_3_trap_handler
8001124e l     F .text	0000000a __class_2_trap_handler
80011258 l     F .text	0000000a __class_1_trap_handler
0000fe24 l       *ABS*	00000000 $btv
0000fe20 l       *ABS*	00000000 $biv
00000000 l    df *ABS*	00000000 wdtcon.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
80011434 l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 cinttab.c
00000000 l    df *ABS*	00000000 CompilerGcc.c
00000000 l    df *ABS*	00000000 CompilerGhs.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 CompilerTasking.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 gpt12.c
00000000 l    df *ABS*	00000000 vadc.c
00000000 l    df *ABS*	00000000 Buzzer.c
00000000 l    df *ABS*	00000000 Motor.c
00000000 l    df *ABS*	00000000 Ultrasonic.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 reent.c
50101a80 g       .inttab	00000000 __interrupt_212
800031c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_142
80002d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_105
700012c8 g     O .data	00000020 osEE_ccb_var
700050a8 g     O .bss	00000020 Tdisptab
700050d8 g     O .inttab	00000001 __HEAP
80003980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_204
8000a346 g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
501017a0 g       .inttab	00000000 __interrupt_189
80002c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_100
8000a798 g     F .text	00000036 IfxScuWdt_setCpuEndinit
80000cb4 g     O .rodata	00000028 __mprec_tinytens
50100a00 g       .inttab	00000000 __interrupt_80
8000b4fa g     F .text	00000062 Init_GPIO
50101b80 g       .inttab	00000000 __interrupt_220
80011bd2 g     F .text	0000001a .hidden __ashldi3
50100080 g       .inttab	00000000 __interrupt_4
50100260 g       .inttab	00000000 __interrupt_19
70001068 g     O .data	00000008 IfxPort_P15_2
8000a2dc g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
800021e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_15
8000ccea g     F .text	00000050 TerminateTask
70000ea0 g     O .data	00000008 IfxPort_P33_11
50100ee0 g       .inttab	00000000 __interrupt_119
50101c20 g       .inttab	00000000 __interrupt_225
70001fe8 g     O .bss	00000004 osEE_kcb_var
70001108 g     O .data	00000008 IfxPort_P11_9
80002f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_123
70001158 g     O .data	00000008 IfxPort_P11_13
50101320 g       .inttab	00000000 __interrupt_153
8000bdbe g     F .text	00000004 SYSTEM_DisableSecProtection
80011904 g     F .text	00000040 .hidden __eqdf2
8000a270 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
700011a0 g     O .data	00000008 IfxPort_P10_5
70000ee8 g     O .data	00000008 IfxPort_P32_2
70000ed8 g     O .data	00000008 IfxPort_P32_4
80005370 g     F .text	0000000e IfxMultican_MsgObj_setStatusFlag
00000000 g       *ABS*	00000000 __HEAP_SIZE
8000db6c g     F .text	00000030 osEE_alarm_get
8000d4b2 g     F .text	0000001c osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80003e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_242
80002300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_24
70000fc8 g     O .data	00000008 IfxPort_P21_1
80003580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_172
8000bd94 g     F .text	00000006 SYSTEM_DisableInterrupts
8000bfa2 g     F .text	0000046a osEE_tc_core0_start
501015a0 g       .inttab	00000000 __interrupt_173
70000f98 g     O .data	00000008 IfxPort_P21_7
50100380 g       .inttab	00000000 __interrupt_28
50101140 g       .inttab	00000000 __interrupt_138
800024c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_38
8000df5c g     F .text	00000016 vsprintf
50101ae0 g       .inttab	00000000 __interrupt_215
50101fe0 g       .inttab	00000000 __interrupt_255
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
80004332 g     F .text	00000244 CAN_RxInt0Handler
50101e80 g       .inttab	00000000 __interrupt_244
700010a0 g     O .data	00000008 IfxPort_P14_5
70000000 g       *ABS*	00000000 __DSPR0_START
80002be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_95
8000db1e g     F .text	00000026 osEE_alarm_set_abs
501018a0 g       .inttab	00000000 __interrupt_197
80002740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_58
50100b40 g       .inttab	00000000 __interrupt_90
8000dcc8 g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80002c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_97
80000204 g     O .rodata	00000014 IfxMultican_TXD3_P11_12_OUT
70001e58 g     O .bss	00000150 stEcu1Can
50100960 g       .inttab	00000000 __interrupt_75
80009628 g     F .text	00000012 IfxScuCcu_initErayPllConfig
8000db9c g     F .text	0000001a osEE_change_context_from_running
800001f0 g     O .rodata	00000014 IfxMultican_TXD3_P20_10_OUT
501002a0 g       .inttab	00000000 __interrupt_21
50101960 g       .inttab	00000000 __interrupt_203
8000affe g     F .text	00000098 my_printf
70001140 g     O .data	00000008 IfxPort_P11_2
80002560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_43
80002040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_2
800103e2 g     F .text	00000002 __malloc_unlock
70001020 g     O .data	00000008 IfxPort_P20_10
8000d010 g     F .text	0000005a SetRelAlarm
800032e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_151
70001228 g     O .data	00000008 IfxPort_P02_0
700010e0 g     O .data	00000008 IfxPort_P13_2
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_118
80002c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_99
80002680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_52
8000a964 g     F .text	00000656 usr_vsprintf
80004fb2 g     F .text	00000082 IfxMultican_MsgObj_readLongFrame
8000a118 g     F .text	000000bc IfxScuCcu_enableExtClockOut0
50101500 g       .inttab	00000000 __interrupt_168
8000d204 g     F .text	0000007a SetEvent
70000fd8 g     O .data	00000008 IfxPort_P20_9
50101460 g       .inttab	00000000 __interrupt_163
80003e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_244
80002380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_28
70000fc0 g     O .data	00000008 IfxPort_P21_2
80003920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_201
70001138 g     O .data	00000008 IfxPort_P11_3
8000d3ec g     F .text	00000008 osEE_scheduler_task_wrapper_restore
8000bda2 g     F .text	0000000c SYSTEM_EnableProtectionExt
70019600 g     O .CPU0.ustack	00000000 __USTACK0
80003720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_185
80010da2 g     F .text	00000050 memmove
8000621e g     F .text	0000001a IfxMultican_getIndex
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
70001198 g     O .data	00000008 IfxPort_P10_6
50101c60 g       .inttab	00000000 __interrupt_227
8000040c g     O .rodata	00000014 IfxMultican_RXD2B_P02_3_IN
800103e4 g     F .text	00000056 _Balloc
8000bdc2 g     F .text	00000018 SYSTEM_Reset
70001060 g     O .data	00000008 IfxPort_P15_3
50101d80 g       .inttab	00000000 __interrupt_236
80003b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_216
80000470 g     O .rodata	00000014 IfxMultican_RXD1B_P14_1_IN
50101040 g       .inttab	00000000 __interrupt_130
700012b0 g     O .data	00000008 IfxPort_P00_1
8000893e g     F .text	0000019c IfxScuCcu_getModuleFrequency
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_213
800028e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_71
800010a0 g       .traptab	00000000 __trap_5
80009084 g     F .text	000003f0 IfxScuCcu_init
8000b454 g     F .text	0000003a _poll_uart0
501007e0 g       .inttab	00000000 __interrupt_63
80011984 g     F .text	00000040 .hidden __gtdf2
80011418  w    F .text	0000000a __errno
800037e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_191
80003380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_156
8000ca0a g     F .text	00000058 SuspendAllInterrupts
80002140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_10
80003180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_140
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_103
8000be2e g     F .text	00000058 SYSTEM_Idle
00001000 g       *ABS*	00000000 __USTACK0_SIZE
8000dd36 g     F .text	00000066 osEE_hal_terminate_ctx
70000e08 g     O .data	00000008 IfxPort_P40_1
8000b55c g     F .text	0000001a setLED1
8000d56e g     F .text	00000074 osEE_sn_priority_insert
70000f10 g     O .data	00000008 IfxPort_P23_4
80003480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_164
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_215
8000bd00 g     F .text	0000008e SYSTEM_GetCanClock
8000027c g     O .rodata	00000014 IfxMultican_TXD2_P02_2_OUT
8000cfa2 g     F .text	0000006e GetTaskState
8000d67e g     F .text	00000020 osEE_task_event_set_mask
8000a576 g     F .text	000000da IfxScuWdt_initCpuWatchdog
80007a98 g     F .text	000000b6 IfxPort_setGroupModeOutput
80004728 g     F .text	00000028 Driver_Can_Txtest
8000a936 g     F .text	0000002e _poll_uart3
80000434 g     O .rodata	00000014 IfxMultican_RXD1E_P02_10_IN
50100d60 g       .inttab	00000000 __interrupt_107
8000b716 g     F .text	00000004 Init_ToF
80002080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_4
80006df2 g     F .text	00000028 IfxMultican_Can_MsgObj_isTransmitRequested
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80008c28 g     F .text	000000ac IfxScuCcu_getPllFrequency
80002a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_82
700048a0 g     O .bss	00000004 errno
8000bd8e g     F .text	00000006 SYSTEM_EnableInterrupts
80002e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_114
8000d116 g     F .text	0000005a GetAlarm
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
50100540 g       .inttab	00000000 __interrupt_42
50100aa0 g       .inttab	00000000 __interrupt_85
800022a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_21
80001160 g       .traptab	00000000 osEE_tc_trap_context
8000a800 g     F .text	00000048 IfxScuWdt_enableWatchdogWithDebugger
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_117
70000e00 g     O .data	00000008 IfxPort_P40_2
501008e0 g       .inttab	00000000 __interrupt_71
800027e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_63
80003560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_171
700012b8 g     O .data	00000008 IfxPort_P00_0
800023c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_30
80006f14 g     F .text	000000ae IfxMultican_Can_Node_getConfig
800020c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_6
80003780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_188
50101620 g       .inttab	00000000 __interrupt_177
501011c0 g       .inttab	00000000 __interrupt_142
70001238 g     O .data	00000008 IfxPort_P01_6
8000b680 g     F .text	00000096 getSW2_Debounce
50100340 g       .inttab	00000000 __interrupt_26
50101aa0 g       .inttab	00000000 __interrupt_213
50100d20 g       .inttab	00000000 __interrupt_105
501001a0 g       .inttab	00000000 __interrupt_13
8000a238 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
80004576 g     F .text	00000016 Can_rx_data_extracter
50100160 g       .inttab	00000000 __interrupt_11
8000d2aa g     F .text	00000046 ClearEvent
50100200 g       .inttab	00000000 __interrupt_16
80008350 g     F .text	00000190 IfxScuCcu_getCpuFrequency
80003d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_232
50101220 g       .inttab	00000000 __interrupt_145
50101840 g       .inttab	00000000 __interrupt_194
70000ed0 g     O .data	00000008 IfxPort_P32_5
70000ee0 g     O .data	00000008 IfxPort_P32_3
501006e0 g       .inttab	00000000 __interrupt_55
800028a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_69
70001040 g     O .data	00000008 IfxPort_P15_7
8000d3f4 g     F .text	000000be osEE_scheduler_task_wrapper_run
80006202 g     F .text	0000001c IfxMultican_setListCommand
70000f58 g     O .data	00000008 IfxPort_P22_5
70000f50 g     O .data	00000008 IfxPort_P22_6
70000e60 g     O .data	00000008 IfxPort_P33_5
80006044 g     F .text	0000016a IfxMultican_deinit
80003f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_251
501014e0 g       .inttab	00000000 __interrupt_167
8000b5ae g     F .text	0000001e toggleLED2
8000b5dc g     F .text	00000010 getSW2
50100ce0 g       .inttab	00000000 __interrupt_103
800035c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_174
80006238 g     F .text	00000014 IfxMultican_getAddress
80003700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_184
80011360 g     F .text	0000002c lock_wdtcon
80000518 g     O .rodata	00000080 IfxPort_cfg_indexMap
80006fc2 g     F .text	000002bc IfxMultican_Can_Node_init
8000d81c g     F .text	00000024 osEE_scheduler_task_preemption_point
80004c0a g     F .text	00000006 IM2_act_task
800103c4 g     F .text	0000001c memcpy
800073e0 g     F .text	0000009a IfxMultican_Can_getConfig
800021c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_14
501013c0 g       .inttab	00000000 __interrupt_158
50100100 g       .inttab	00000000 __interrupt_8
8000be86 g     F .text	00000050 SYSTEM_Sleep
50101060 g       .inttab	00000000 __interrupt_131
50100480 g       .inttab	00000000 __interrupt_36
8000d2f0 g     F .text	0000002c GetCounterValue
80004d6a g     F .text	0000005c readIM
8000df74 g     F .text	000011a4 _svfprintf_r
80011a44 g     F .text	00000048 .hidden __floatsidf
8000d4ce g     F .text	0000003c osEE_scheduler_rq_insert
80002940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_74
80011a04 g     F .text	00000040 .hidden __ltdf2
50100e20 g       .inttab	00000000 __interrupt_113
800002f4 g     O .rodata	00000014 IfxMultican_TXD0_P34_1_OUT
80001210 g       .dtors	00000000 __DTOR_END__
70001220 g     O .data	00000008 IfxPort_P02_1
8000963a g     F .text	000001e8 IfxScuCcu_setCpuFrequency
8000dbca g     F .text	00000022 osEE_idle_task_terminate
50100a20 g       .inttab	00000000 __interrupt_81
80003c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_228
80000308 g     O .rodata	00000014 IfxMultican_TXD0_P33_8_OUT
50101d20 g       .inttab	00000000 __interrupt_233
700012a0 g     O .data	00000008 IfxPort_P00_11
8000b338 g     F .text	00000034 _in_uart1
8000b834 g     F .text	00000046 InterruptInstall
70000e70 g     O .data	00000008 IfxPort_P33_3
800002a4 g     O .rodata	00000014 IfxMultican_TXD1_P14_0_OUT
501008c0 g       .inttab	00000000 __interrupt_70
8001098a g     F .text	00000042 __fpclassifyd
800023a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_29
8000a2a8 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
80003a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_211
80002340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_26
80001040 g       .traptab	00000000 __trap_2
8000a440 g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
70001ca8 g     O .bss	00000003 is_rx_msg
80002540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_42
8000402c g     F .text	00000004 FuncTASK2
8000d748 g     F .text	00000044 osEE_scheduler_task_unblocked
80002960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_75
80003820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_193
800033c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_158
501010e0 g       .inttab	00000000 __interrupt_135
70000e18 g     O .data	00000008 IfxPort_P34_5
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_102
00000000 g       *ABS*	00000000 NULL
8000c458 g     F .text	00000098 osEE_tc_initialize_system_timer
50101860 g       .inttab	00000000 __interrupt_195
80001140 g       .traptab	00000000 osEE_tc_trap_instruction
80000d04 g     O .rodata	000000c8 __mprec_tens
50100da0 g       .inttab	00000000 __interrupt_109
80005398 g     F .text	00000032 IfxMultican_Node_initRxPin
50101240 g       .inttab	00000000 __interrupt_146
8000bd9e g     F .text	00000004 SYSTEM_DisableProtection
80002260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_19
8000cda4 g     F .text	000000a0 GetResource
50101d40 g       .inttab	00000000 __interrupt_234
70000fb0 g     O .data	00000008 IfxPort_P21_4
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_214
800029a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_77
8000036c g     O .rodata	00000014 IfxMultican_RXD3E_P20_9_IN
8000afba g     F .text	00000006 usr_sprintf
50100880 g       .inttab	00000000 __interrupt_68
800038a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_197
501016c0 g       .inttab	00000000 __interrupt_182
70004898 g     O .bss	00000004 __malloc_top_pad
50101ec0 g       .inttab	00000000 __interrupt_246
80006e1a g     F .text	00000028 IfxMultican_Can_MsgObj_isTxPending
80000268 g     O .rodata	00000014 IfxMultican_TXD2_P10_3_OUT
80009822 g     F .text	000001f6 IfxScuCcu_setGtmFrequency
80007c54 g     F .text	00000068 IfxPort_setPinModeLvdsHigh
8000dcec g     F .text	0000002c osEE_hal_ready2stacked
80002660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_51
70001000 g     O .data	00000008 IfxPort_P20_14
8000ff08 g     F .text	0000000a _localeconv_r
80003460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_163
80004750 g     F .text	000004b4 Driver_Can_Init
80010576 g     F .text	00000010 __i2b
8000cd3a g     F .text	0000006a Schedule
80003f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_250
50101e00 g       .inttab	00000000 __interrupt_240
501019a0 g       .inttab	00000000 __interrupt_205
80009efe g     F .text	0000021a IfxScuCcu_switchToBackupClock
80003100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_136
8000a49c g     F .text	00000070 IfxScuWdt_enableSafetyWatchdog
80002060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_3
80003e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_240
800109cc g     F .text	0000001e _sbrk_r
8000bf16 g     F .text	00000002 SYSTEM_DbgBreak
50100740 g       .inttab	00000000 __interrupt_58
80003040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_130
80002b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_89
70001208 g     O .data	00000008 IfxPort_P02_2
800025c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_46
700010a8 g     O .data	00000008 IfxPort_P14_4
50101f40 g       .inttab	00000000 __interrupt_250
700010f0 g     O .data	00000008 IfxPort_P13_0
50100120 g       .inttab	00000000 __interrupt_9
501000e0 g       .inttab	00000000 __interrupt_7
70001270 g     O .data	00000008 IfxPort_P00_6
50101a40 g       .inttab	00000000 __interrupt_210
50101480 g       .inttab	00000000 __interrupt_164
70001048 g     O .data	00000008 IfxPort_P15_6
800027a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_61
80002800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_64
80000484 g     O .rodata	00000014 IfxMultican_RXD1A_P15_3_IN
8000bf7c g     F .text	00000004 FuncUART_Echo
800003bc g     O .rodata	00000014 IfxMultican_RXD3A_P00_3_IN
80011d24 g     F .text	000000ac .hidden __unpack_d
70001218 g     O .data	00000008 IfxPort_P02_10
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
80007cfe g     F .text	0000003c IfxPort_setPinPadDriver
800003e4 g     O .rodata	00000014 IfxMultican_RXD2D_P14_8_IN
50100d40 g       .inttab	00000000 __interrupt_106
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_246
80002480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_36
70001010 g     O .data	00000008 IfxPort_P20_12
50101300 g       .inttab	00000000 __interrupt_152
70004894 g     O .bss	00000004 __malloc_max_sbrked_mem
80002a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_81
50100ba0 g       .inttab	00000000 __interrupt_93
800011a0 g       .traptab	00000000 osEE_tc_trap_assertion
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_93
80008000 g       *ABS*	00000000 __A1_MEM
501003e0 g       .inttab	00000000 __interrupt_31
70000ec8 g     O .data	00000008 IfxPort_P32_6
80002700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_56
70000374 g     O .data	00000014 im_IsDark
800115d0 g     F .text	00000038 .hidden __adddf3
50100600 g       .inttab	00000000 __interrupt_48
8000cbba g     F .text	0000001a GetActiveApplicationMode
70001250 g     O .data	00000008 IfxPort_P01_3
50100440 g       .inttab	00000000 __interrupt_34
80008f3c g     F .text	00000148 IfxScuCcu_getSriFrequency
50101e20 g       .inttab	00000000 __interrupt_241
800030c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_134
50100fa0 g       .inttab	00000000 __interrupt_125
50101900 g       .inttab	00000000 __interrupt_200
8000ca62 g     F .text	00000024 ResumeAllInterrupts
70000fa8 g     O .data	00000008 IfxPort_P21_5
50100d00 g       .inttab	00000000 __interrupt_104
70001180 g     O .data	00000008 IfxPort_P11_0
800036c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_182
800038e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_199
80009dc2 g     F .text	0000013c IfxScuCcu_setSriFrequency
80011bac g     F .text	00000026 .hidden __umoddi3
80000510 g     O .rodata	00000008 IfxMultican_cfg_indexMap
80003740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_186
70019c00 g     O .CPU0.csa	00000000 __CSA0
80003840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_194
800033e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_159
80003280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_148
800062d0 g     F .text	00000a64 IfxMultican_Can_MsgObj_init
80002180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_12
8000beec g     F .text	0000002a SYSTEM_EnaDisCache
80000290 g     O .rodata	00000014 IfxMultican_TXD1_P15_2_OUT
80011202 g     F .text	0000001a tsim_abort
80000bf8 g     O .rodata	00000004 _global_impure_ptr
70000de8 g     O .data	00000008 IfxPort_P40_5
501017e0 g       .inttab	00000000 __interrupt_191
70001080 g     O .data	00000008 IfxPort_P14_9
50100f00 g       .inttab	00000000 __interrupt_120
800084e0 g     F .text	0000018e IfxScuCcu_getFsi2Frequency
80010e02 g     F .text	000003f0 _realloc_r
70001058 g     O .data	00000008 IfxPort_P15_4
700011e0 g     O .data	00000008 IfxPort_P02_7
70000f88 g     O .data	00000008 IfxPort_P22_1
70000f48 g     O .data	00000008 IfxPort_P22_7
80007822 g     F .text	00000060 IfxPort_enableEmergencyStop
50100920 g       .inttab	00000000 __interrupt_73
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_254
50100420 g       .inttab	00000000 __interrupt_33
50101bc0 g       .inttab	00000000 __interrupt_222
80011b0c g     F .text	000000a0 .hidden __udivdi3
70008000 g       *ABS*	00000000 __A0_MEM
8000d50a g     F .text	00000064 osEE_scheduler_core_rq_preempt_stk
50101ca0 g       .inttab	00000000 __interrupt_229
80000cdc g     O .rodata	00000028 __mprec_bigtens
80011422 g     F .text	00000012 abort
50101580 g       .inttab	00000000 __interrupt_172
8000403c g     F .text	00000004 FuncTASK6
50101cc0 g       .inttab	00000000 __interrupt_230
80011ada g     F .text	00000032 .hidden __floatunsidf
8000bf18 g     F .text	0000000c StartupHook
8000b87a g     F .text	0000029c SYSTEM_Init
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_85
8000747a g     F .text	0000007c IfxMultican_Can_getModuleFrequency
800107d6 g     F .text	00000042 __mcmp
80000448 g     O .rodata	00000014 IfxMultican_RXD1D_P00_1_IN
800038c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_198
8000cbd4 g     F .text	00000068 ActivateTask
80003300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_152
50100520 g       .inttab	00000000 __interrupt_41
80002020 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_1
70001e54 g     O .bss	00000004 u32nuCanRxCnt
80002de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_111
50100a80 g       .inttab	00000000 __interrupt_84
80000394 g     O .rodata	00000014 IfxMultican_RXD3C_P20_0_IN
501000c0 g       .inttab	00000000 __interrupt_6
70000360 g     O .data	00000014 im_IsIntunnel
80002420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_33
8000b82a g     F .text	0000000a InterruptInit
700050d0  w    O .bss	00000004 _my_errno
80007882 g     F .text	0000004e IfxPort_getAddress
800010e0 g       .traptab	00000000 __trap_7
80003760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_187
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
50101dc0 g       .inttab	00000000 __interrupt_238
8000df22 g     F .text	00000012 strtol
8000cf4e g     F .text	00000054 GetTaskID
50101100 g       .inttab	00000000 __interrupt_136
80009490 g     F .text	00000198 IfxScuCcu_initErayPll
50100c60 g       .inttab	00000000 __interrupt_99
800003a8 g     O .rodata	00000014 IfxMultican_RXD3B_P32_2_IN
70001150 g     O .data	00000008 IfxPort_P11_14
501006c0 g       .inttab	00000000 __interrupt_54
800003d0 g     O .rodata	00000014 IfxMultican_RXD2E_P10_2_IN
50101160 g       .inttab	00000000 __interrupt_139
70001190 g     O .data	00000008 IfxPort_P10_7
800076a8 g     F .text	00000086 IfxMultican_Can_initModuleConfig
80003de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_239
800111f2 g     F .text	00000002 __int_handler
70000df8 g     O .data	00000008 IfxPort_P40_3
80000620 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
700011d8 g     O .data	00000008 IfxPort_P02_8
800061bc g     F .text	00000046 IfxMultican_resetModule
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
8000b48e g     F .text	00000016 _out_uart0
8000624c g     F .text	00000084 IfxMultican_Can_MsgObj_getConfig
8000ca86 g     F .text	00000066 SuspendOSInterrupts
80003a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_210
8000a378 g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
50100360 g       .inttab	00000000 __interrupt_27
8000c76e g     F .text	000000be osEE_tc_stm_set_clockpersec
80003a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_208
501001c0 g       .inttab	00000000 __interrupt_14
800031e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_143
80002d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_106
8000d840 g     F .text	00000044 osEE_scheduler_task_set_running
50101080 g       .inttab	00000000 __interrupt_132
8000bc70 g     F .text	00000090 SYSTEM_GetStmClock
b0008000 g     O *ABS*	00000000 _SMALL_DATA4_
8000bed6 g     F .text	00000016 SYSTEM_IsCacheEnabled
70001160 g     O .data	00000008 IfxPort_P11_12
50101760 g       .inttab	00000000 __interrupt_187
8000c82c g     F .text	000000c8 osEE_tc_stm_set_sr1
8000a3d2 g     F .text	0000006e IfxScuWdt_disableSafetyWatchdog
80002c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_96
8000a766 g     F .text	00000032 IfxScuWdt_serviceSafetyWatchdog
800104ce g     F .text	00000042 __hi0bits
80002760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_59
700010e8 g     O .data	00000008 IfxPort_P13_1
80002e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_115
8000d980 g     F .text	00000152 osEE_counter_increment
700048a8 g     O .bss	00000800 Cdisptab
80011a8c g     F .text	0000004e .hidden __fixdfsi
80003160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_139
8000d6bc g     F .text	00000064 osEE_scheduler_task_activated
80008206 g     F .text	0000014a IfxScuCcu_getBbbFrequency
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
70000f90 g     O .data	00000008 IfxPort_P22_0
70000e98 g     O .data	00000008 IfxPort_P33_12
70000f00 g     O .data	00000008 IfxPort_P23_6
70001248 g     O .data	00000008 IfxPort_P01_4
70000e58 g     O .data	00000008 IfxPort_P33_6
80002f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_121
8000866e g     F .text	00000190 IfxScuCcu_getFsiFrequency
80002100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_8
80002580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_44
800061ae g     F .text	0000000e IfxMultican_getSrcPointer
50100f80 g       .inttab	00000000 __interrupt_124
80003d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_234
800032a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_149
8000a310 g     F .text	00000036 IfxScuWdt_clearCpuEndinit
50100c20 g       .inttab	00000000 __interrupt_97
80002e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_113
80003320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_153
800025e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_47
700011a8 g     O .data	00000008 IfxPort_P10_4
80000330 g     O .rodata	00000014 IfxMultican_TXD0_P12_1_OUT
700010b0 g     O .data	00000008 IfxPort_P14_3
50100680 g       .inttab	00000000 __interrupt_52
800022e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_23
70001070 g     O .data	00000008 IfxPort_P15_1
501005e0 g       .inttab	00000000 __interrupt_47
70001050 g     O .data	00000008 IfxPort_P15_5
501013a0 g       .inttab	00000000 __interrupt_157
50101520 g       .inttab	00000000 __interrupt_169
80004fa8 g     F .text	0000000a IfxMultican_MsgObj_getStatusFlag
70001240 g     O .data	00000008 IfxPort_P01_5
50101400 g       .inttab	00000000 __interrupt_160
50101be0 g       .inttab	00000000 __interrupt_223
80011bec g     F .text	00000026 .hidden __lshrdi3
70001128 g     O .data	00000008 IfxPort_P11_5
800039a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_205
50100e00 g       .inttab	00000000 __interrupt_112
70000e88 g     O .data	00000008 IfxPort_P33_14
70000e30 g     O .data	00000008 IfxPort_P34_2
800106a0 g     F .text	0000007c __pow5mult
50100b60 g       .inttab	00000000 __interrupt_91
70001030 g     O .data	00000008 IfxPort_P20_0
50100980 g       .inttab	00000000 __interrupt_76
800001c8 g     O .rodata	00000014 IfxMultican_TXD3_P32_3_OUT
50101de0 g       .inttab	00000000 __interrupt_239
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_255
70001268 g     O .data	00000008 IfxPort_P00_7
70000eb8 g     O .data	00000008 IfxPort_P33_0
80002860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_67
80002e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_112
70000e68 g     O .data	00000008 IfxPort_P33_4
70000f18 g     O .data	00000008 IfxPort_P23_3
800001c4 g     O .rodata	00000004 dataLow
70001288 g     O .data	00000008 IfxPort_P00_3
70000e40 g     O .data	00000008 IfxPort_P33_9
8000a848 g     F .text	000000ac _init_uart3
8000d78c g     F .text	00000090 osEE_scheduler_task_terminated
8000bbe0 g     F .text	00000090 SYSTEM_GetSysClock
80002460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_35
800036a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_181
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_245
70000e80 g     O .data	00000008 IfxPort_P33_15
8000d0c4 g     F .text	00000052 CancelAlarm
50101d60 g       .inttab	00000000 __interrupt_235
80004f80 g     F .text	00000022 IfxMultican_MsgObj_getPendingId
70001cb8 g     O .bss	0000000a newTxMsgSet_flag
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
80011262 g     F .text	00000026 _install_int_handler
80003b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_219
50101440 g       .inttab	00000000 __interrupt_162
50101020 g       .inttab	00000000 __interrupt_129
80002360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_27
80006e9a g     F .text	0000007a IfxMultican_Can_MsgObj_sendMessage
800037a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_189
8000a55c g     F .text	0000001a IfxScuWdt_initConfig
80001200 g       .ctors	00000000 __CTOR_LIST__
80001080 g       .traptab	00000000 __trap_4
8000c6d2 g     F .text	0000009c osEE_tc_get_fsource
8000a730 g     F .text	00000036 IfxScuWdt_serviceCpuWatchdog
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_247
501012c0 g       .inttab	00000000 __interrupt_150
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_86
50101740 g       .inttab	00000000 __interrupt_186
50100840 g       .inttab	00000000 __interrupt_66
8001138c g     F .text	00000020 unlock_safety_wdtcon
501016a0 g       .inttab	00000000 __interrupt_181
80002e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_116
70000dd8 g     O .data	00000008 IfxPort_P40_7
8000dd18 g     F .text	0000001e osEE_tc_change_context_from_isr2_end
80002a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_83
800103ac g     F .text	00000018 memchr
70000e38 g     O .data	00000008 IfxPort_P34_1
80003400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_160
80010bf6 g     F .text	000001ac _free_r
8000b71a g     F .text	00000042 IsrUart1RxHandler_tof
80002220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_17
800023e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_31
8000d3d4 g     F .text	00000018 GetISRID
70000ff0 g     O .data	00000008 IfxPort_P20_6
8000dc8a g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
70000fa0 g     O .data	00000008 IfxPort_P21_6
50101660 g       .inttab	00000000 __interrupt_179
8000dad4 g     F .text	0000004a osEE_alarm_set_rel
50100180 g       .inttab	00000000 __interrupt_12
50100140 g       .inttab	00000000 __interrupt_10
80001180 g       .traptab	00000000 osEE_tc_trap_bus
80000420 g     O .rodata	00000014 IfxMultican_RXD2A_P15_1_IN
80007e20 g     F .text	00000102 IfxScuCcu_calculateSysPllDividers
8000532c g     F .text	00000044 IfxMultican_MsgObj_setFilter
50101260 g       .inttab	00000000 __interrupt_147
70001890 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80003520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_169
50101880 g       .inttab	00000000 __interrupt_196
70000000 g     O .data	0000008c sig_to_tx_msg
800053ee g     F .text	0000006a IfxMultican_Node_recoverBusOff
80003f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_249
8000a52c g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
00001000 g       *ABS*	00000000 __USTACK2_SIZE
70001fa8 g     O .bss	00000014 SIG_to_IM
800011e0 g       .traptab	00000000 osEE_tc_trap_nmi
800001dc g     O .rodata	00000014 IfxMultican_TXD3_P20_3_OUT
50101b00 g       .inttab	00000000 __interrupt_216
501009c0 g       .inttab	00000000 __interrupt_78
70000220 g     O .data	0000012c signals
800020a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_5
50100f20 g       .inttab	00000000 __interrupt_121
8001071c g     F .text	000000ba __lshift
80003600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_176
50100c80 g       .inttab	00000000 __interrupt_100
00002000 g       *ABS*	00000000 __CSA_SIZE
8000bdba g     F .text	00000004 SYSTEM_EnableSecProtection
700011c0 g     O .data	00000008 IfxPort_P10_1
800109ea g     F .text	000000f0 __ssprint_r
50101ea0 g       .inttab	00000000 __interrupt_245
50101f80 g       .inttab	00000000 __interrupt_252
5001bc00 g       .CPU2.csa	00000000 __CSA2
800004fc g     O .rodata	00000014 IfxMultican_RXD0A_P02_1_IN
800034a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_165
80003c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_227
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
70001148 g     O .data	00000008 IfxPort_P11_15
80006d34 g     F .text	00000096 IfxMultican_Can_MsgObj_initConfig
50100040 g       .inttab	00000000 __interrupt_2
800027c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_62
70000eb0 g     O .data	00000008 IfxPort_P33_1
50100900 g       .inttab	00000000 __interrupt_72
50101980 g       .inttab	00000000 __interrupt_204
50100ec0 g       .inttab	00000000 __interrupt_118
80011288 g     F .text	000000ac _init_vectab
50101c80 g       .inttab	00000000 __interrupt_228
80010586 g     F .text	0000011a __multiply
00000001 g       *ABS*	00000000 _.
70004868 g     O .bss	00000028 __malloc_current_mallinfo
800108e2 g     F .text	000000a8 __d2b
80003c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_226
800037c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_190
80003360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_155
70001098 g     O .data	00000008 IfxPort_P14_6
70000f78 g     O .data	00000008 IfxPort_P22_11
800026c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_54
70000e10 g     O .data	00000008 IfxPort_P40_0
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_125
80002b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_91
501014a0 g       .inttab	00000000 __interrupt_165
70001cab g     O .bss	00000003 rx_msgid_to_rx_MsgObjId
80005458 g     F .text	000004fa IfxMultican_Node_setBitTiming
50100300 g       .inttab	00000000 __interrupt_24
800001c0 g     O .rodata	00000004 dataHigh
80003680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_180
70001210 g     O .data	00000008 IfxPort_P02_11
80008bbe g     F .text	0000006a IfxScuCcu_getPllErayVcoFrequency
80001200 g       .ctors	00000000 __EH_FRAME_END__
8000a90a g     F .text	0000002c _in_uart3
80009a18 g     F .text	00000122 IfxScuCcu_setPll2ErayFrequency
6001bb00 g       .CPU1.istack	00000000 __ISTACK1
80003800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_192
800033a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_157
80008092 g     F .text	00000174 IfxScuCcu_getBaud2Frequency
80003240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_146
80002da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_109
80011dd0 g     F .text	000000a6 .hidden __fpcmp_parts_d
50100bc0 g       .inttab	00000000 __interrupt_94
70001fbd g     O .bss	00000001 im_IsDark_data
50100e80 g       .inttab	00000000 __interrupt_116
70000e28 g     O .data	00000008 IfxPort_P34_3
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
50100ae0 g       .inttab	00000000 __interrupt_87
8000d5e2 g     F .text	0000006c osEE_scheduler_core_pop_running
800021a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_13
80003f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_252
50100580 g       .inttab	00000000 __interrupt_44
800003f8 g     O .rodata	00000014 IfxMultican_RXD2C_P32_6_IN
50101120 g       .inttab	00000000 __interrupt_137
8000dbec g     F .text	0000007c osEE_cpu_startos
50101340 g       .inttab	00000000 __interrupt_154
80003b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_218
70000f68 g     O .data	00000008 IfxPort_P22_3
800050dc g     F .text	00000188 IfxMultican_MsgObj_sendLongFrame
50101c00 g       .inttab	00000000 __interrupt_224
800004e8 g     O .rodata	00000014 IfxMultican_RXD0B_P20_7_IN
80003e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_241
800029c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_78
80004f28 g     F .text	00000058 IfxMultican_MsgObj_deinit
800078d0 g     F .text	000000c2 IfxPort_getIndex
800030a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_133
501018e0 g       .inttab	00000000 __interrupt_199
501004a0 g       .inttab	00000000 __interrupt_37
8000d27e g     F .text	0000002c GetEvent
50100820 g       .inttab	00000000 __interrupt_65
70001120 g     O .data	00000008 IfxPort_P11_6
80004034 g     F .text	00000004 FuncTASK4
50101640 g       .inttab	00000000 __interrupt_178
501016e0 g       .inttab	00000000 __interrupt_183
6001b600 g       .CPU1.ustack	00000000 __USTACK1
700010d0 g     O .data	00000008 IfxPort_P14_0
8000d720 g     F .text	00000028 osEE_scheduler_task_insert
80003be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_223
80002620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_49
800117ec g     F .text	00000118 .hidden __divdf3
70001898 g     O .data	00000408 __malloc_av_
80002f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_120
80004f04 g     F .text	00000018 IfxMultican_MsgObj_cancelSend
8000cee6 g     F .text	00000068 ShutdownOS
80003060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_131
800035e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_175
70018600 g     O .CPU0.ustack	00000000 __USTACK0_END
80003900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_200
80001020 g       .traptab	00000000 __trap_1
80002120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_9
80011648 g     F .text	000001a4 .hidden __muldf3
80002500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_40
80002520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_41
50101ac0 g       .inttab	00000000 __interrupt_214
80005952 g     F .text	000004fa IfxMultican_Node_setFastBitTiming
70000e20 g     O .data	00000008 IfxPort_P34_4
70001200 g     O .data	00000008 IfxPort_P02_3
70001088 g     O .data	00000008 IfxPort_P14_8
501012a0 g       .inttab	00000000 __interrupt_149
800103e0 g     F .text	00000002 __malloc_lock
50101200 g       .inttab	00000000 __interrupt_144
800113dc g     F .text	0000003c sbrk
80008ada g     F .text	0000000e IfxScuCcu_getOsc0Frequency
80000000 g       .startup	00000000 BootModeHeader0
800011c0 g       .traptab	00000000 osEE_tc_trap_system
50100d80 g       .inttab	00000000 __interrupt_108
80010ada g     F .text	00000062 _calloc_r
70000f30 g     O .data	00000008 IfxPort_P23_0
00002000 g       *ABS*	00000000 __CSA0_SIZE
50100cc0 g       .inttab	00000000 __interrupt_102
80008df4 g     F .text	00000148 IfxScuCcu_getSpbFrequency
80002820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_65
501007a0 g       .inttab	00000000 __interrupt_61
70000190 g     O .data	00000090 messages
70001fbc g     O .bss	00000001 im_IsIntunnel_data
70001018 g     O .data	00000008 IfxPort_P20_11
800024a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_37
8000bb16 g     F .text	0000000a SYSTEM_GetExtClock
50100b80 g       .inttab	00000000 __interrupt_92
8000bb20 g     F .text	000000c0 SYSTEM_GetCpuClock
80003d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_233
80003960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_203
80010df2 g     F .text	00000010 memset
8000045c g     O .rodata	00000014 IfxMultican_RXD1C_P01_4_IN
800034e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_167
70000dd0 g     O .data	00000008 IfxPort_P40_8
80002640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_50
8000bf80 g     F .text	00000022 main
8000a50c g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
8000b4a4 g     F .text	00000056 delay_ms
50100240 g       .inttab	00000000 __interrupt_18
80002200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_16
70004890 g     O .bss	00000004 __malloc_max_total_mem
8000b096 g     F .text	000001b0 my_scanf
8000dd9c g       .text	00000000 __interrupt_1
80003540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_170
501004e0 g       .inttab	00000000 __interrupt_39
80011e76 g     F .text	0000009c .hidden __udiv6432
50101360 g       .inttab	00000000 __interrupt_155
00000400 g       *ABS*	00000000 __ISTACK_SIZE
70001280 g     O .data	00000008 IfxPort_P00_4
80007f22 g     F .text	00000170 IfxScuCcu_getBaud1Frequency
50101c40 g       .inttab	00000000 __interrupt_226
800025a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_45
80002b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_88
700011b8 g     O .data	00000008 IfxPort_P10_2
8000d64e g     F .text	00000018 osEE_task_activated
80005fd8 g     F .text	0000006c IfxMultican_calcTimingFromBTR
50101700 g       .inttab	00000000 __interrupt_184
5001bb00 g       .CPU2.istack	00000000 __ISTACK2
800006d0 g     O .rodata	00000024 osEE_kdb_var
700010d8 g     O .data	00000008 IfxPort_P13_3
50100fc0 g       .inttab	00000000 __interrupt_126
50100dc0 g       .inttab	00000000 __interrupt_110
50101820 g       .inttab	00000000 __interrupt_193
50100400 g       .inttab	00000000 __interrupt_32
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
8000a548 g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
70000118 g     O .data	00000078 nodes
8000de1c g     F .text	00000106 _strtol_r
700011f0 g     O .data	00000008 IfxPort_P02_5
70000ef8 g     O .data	00000008 IfxPort_P23_7
80003b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_220
70001038 g     O .data	00000008 IfxPort_P15_8
80003020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_129
8000f234 g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000ff12 g     F .text	0000049a _malloc_r
80007cbc g     F .text	00000042 IfxPort_setPinModeLvdsMedium
70001290 g     O .data	00000008 IfxPort_P00_2
800004c0 g     O .rodata	00000014 IfxMultican_RXD0D_P02_4_IN
800039e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_207
501015c0 g       .inttab	00000000 __interrupt_174
8000d8fc g     F .text	00000060 osEE_counter_insert_abs_trigger
800010c0 g       .traptab	00000000 ___trap_6
80003d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_235
800024e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_39
50101b60 g       .inttab	00000000 __interrupt_219
80002a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_80
80008000 g       *ABS*	00000000 __A8_MEM
b0008000 g       *ABS*	00000000 __A9_MEM
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_231
50101fa0 g       .inttab	00000000 __interrupt_253
50100760 g       .inttab	00000000 __interrupt_59
80003340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_154
8000b3a0 g     F .text	0000007c _init_uart0
80002c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_98
70001078 g     O .data	00000008 IfxPort_P15_0
700010c0 g     O .data	00000008 IfxPort_P14_10
800074f6 g     F .text	000001b2 IfxMultican_Can_initModule
80000dcc g     O .rodata	00000014 .hidden __thenan_df
50100620 g       .inttab	00000000 __interrupt_49
80010b3c g     F .text	000000ba _malloc_trim_r
70000094 g     O .data	00000084 msg_in_sig_M
50100ea0 g       .inttab	00000000 __interrupt_117
80001208 g       .ctors	00000000 __CTOR_END__
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
50101540 g       .inttab	00000000 __interrupt_170
50000000 g       *ABS*	00000000 __DSPR2_START
800028c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_70
70001258 g     O .data	00000008 IfxPort_P00_9
80004040 g     F .text	00000038 Funcinner_COM
80000218 g     O .rodata	00000014 IfxMultican_TXD3_P00_2_OUT
8000ce44 g     F .text	000000a2 ReleaseResource
80003da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_237
8000458c g     F .text	000000c6 Can_data_disassembler
80001208 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
80003c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_224
501011e0 g       .inttab	00000000 __interrupt_143
800026a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_53
00001000 g       *ABS*	00000000 __USTACK1_SIZE
80002b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_90
70000ef0 g     O .data	00000008 IfxPort_P32_0
800046b2 g     F .text	00000010 isTxMsgObj_ready
8000a1d4 g     F .text	00000064 IfxScuCcu_enableExtClockOut1
8000bdda g     F .text	00000054 SYSTEM_IdleExt
80005e4c g     F .text	0000018c IfxMultican_Node_setNominalBitTiming
80011944 g     F .text	00000040 .hidden __nedf2
80003a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_209
50100280 g       .inttab	00000000 __interrupt_20
70000fb8 g     O .data	00000008 IfxPort_P21_3
8000bdae g     F .text	0000000c SYSTEM_DisableProtectionExt
80003880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_196
80008cd4 g     F .text	0000006a IfxScuCcu_getPllVcoFrequency
80011334 g     F .text	0000002c unlock_wdtcon
80009c5c g     F .text	00000166 IfxScuCcu_setSpbFrequency
80006dca g     F .text	00000028 IfxMultican_Can_MsgObj_isRxPending
80000380 g     O .rodata	00000014 IfxMultican_RXD3D_P11_10_IN
80003220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_145
80002d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_108
50101d00 g       .inttab	00000000 __interrupt_232
501010c0 g       .inttab	00000000 __interrupt_134
80000598 g     O .rodata	00000080 IfxPort_cfg_esrMasks
80002a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_84
700010c8 g     O .data	00000008 IfxPort_P14_1
80003500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_168
80005264 g     F .text	0000005e IfxMultican_MsgObj_sendMessage
70000f60 g     O .data	00000008 IfxPort_P22_4
80002400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_32
80003000 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_128
800079ba g     F .text	0000002a IfxPort_setESR
501002c0 g       .inttab	00000000 __interrupt_22
80003620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_177
8000df34 g     F .text	00000028 _vsprintf_r
80003120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_137
80002900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_72
8000b246 g     F .text	00000060 remove_null
8000ddb8 g       .text	00000000 __trap_6
800002e0 g     O .rodata	00000014 IfxMultican_TXD1_P00_0_OUT
501007c0 g       .inttab	00000000 __interrupt_62
501012e0 g       .inttab	00000000 __interrupt_151
50101b40 g       .inttab	00000000 __interrupt_218
50100c00 g       .inttab	00000000 __interrupt_96
80001000 g     F .traptab	00000000 TriCore_trap_table
80002600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_48
50100660 g       .inttab	00000000 __interrupt_51
50100b20 g       .inttab	00000000 __interrupt_89
8000d31c g     F .text	0000004a GetElapsedValue
70001468 g     O .data	00000004 _impure_ptr
501017c0 g       .inttab	00000000 __interrupt_190
501005c0 g       .inttab	00000000 __interrupt_46
501000a0 g       .inttab	00000000 __interrupt_5
50101420 g       .inttab	00000000 __interrupt_161
80003660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_179
80007992 g     F .text	00000028 IfxPort_resetESR
80004f1c g     F .text	0000000c IfxMultican_MsgObj_clearStatusFlag
501014c0 g       .inttab	00000000 __interrupt_166
501009e0 g       .inttab	00000000 __interrupt_79
70000f28 g     O .data	00000008 IfxPort_P23_1
8000031c g     O .rodata	00000014 IfxMultican_TXD0_P20_8_OUT
80004030 g     F .text	00000004 FuncTASK3
501001e0 g       .inttab	00000000 __interrupt_15
70001130 g     O .data	00000008 IfxPort_P11_4
501013e0 g       .inttab	00000000 __interrupt_159
50100e40 g       .inttab	00000000 __interrupt_114
800036e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_183
8000d170 g     F .text	00000030 GetAlarmBase
70000e90 g     O .data	00000008 IfxPort_P33_13
80004c04 g     F .text	00000006 IM1_act_task
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_230
50101ee0 g       .inttab	00000000 __interrupt_247
70001168 g     O .data	00000008 IfxPort_P11_11
00002000 g       *ABS*	00000000 __CSA1_SIZE
800022c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_22
8000c9dc g     F .text	00000014 DisableAllInterrupts
8000b75c g     F .text	000000ce getTofDistance
8000afc0 g     F .text	0000003e my_puts
800079e4 g     F .text	000000b4 IfxPort_setGroupModeInput
00001000 g       *ABS*	00000000 __USTACK_SIZE
80004cea g     F .text	00000080 writeIM_from_sig
70000e78 g     O .data	00000008 IfxPort_P33_2
8000cc3c g     F .text	000000ae ChainTask
70000e48 g     O .data	00000008 IfxPort_P33_8
8000a8f4 g     F .text	00000016 _out_uart3
501019c0 g       .inttab	00000000 __interrupt_206
50100fe0 g       .inttab	00000000 __interrupt_127
50100f40 g       .inttab	00000000 __interrupt_122
70001110 g     O .data	00000008 IfxPort_P11_8
70001118 g     O .data	00000008 IfxPort_P11_7
50100320 g       .inttab	00000000 __interrupt_25
700011b0 g     O .data	00000008 IfxPort_P10_3
70001298 g     O .data	00000008 IfxPort_P00_12
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_101
501018c0 g       .inttab	00000000 __interrupt_198
800004ac g     O .rodata	00000014 IfxMultican_RXD0E_P33_7_IN
70001100 g     O .data	00000008 IfxPort_P12_0
8000c40c g     F .text	0000004c osEE_tricore_system_timer_handler
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_126
70000350 g     O .data	00000008 IM_to_SIG_M
80009474 g     F .text	0000001c IfxScuCcu_initConfig
80003b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_217
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_221
8000b5cc g     F .text	00000010 getSW1
80001100 g       .traptab	00000000 osEE_tc_trap_mmu
50100000 g     F .inttab	00000000 TriCore_int_table
70001230 g     O .data	00000008 IfxPort_P01_7
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_87
8000bf24 g     F .text	00000058 FuncCAN_Tx
80004038 g     F .text	00000004 FuncTASK5
8000c960 g     F .text	0000006e osEE_tc_delay
700011c8 g     O .data	00000008 IfxPort_P10_0
80000de0 g     O .rodata	00000000 __clear_table
800113ac g     F .text	00000020 lock_safety_wdtcon
80008b1a g     F .text	000000a4 IfxScuCcu_getPllErayFrequency
501010a0 g       .inttab	00000000 __interrupt_133
50100560 g       .inttab	00000000 __interrupt_43
70001090 g     O .data	00000008 IfxPort_P14_7
8000d666 g     F .text	00000018 osEE_task_end
50100ac0 g       .inttab	00000000 __interrupt_86
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_110
80002f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_124
80000498 g     O .rodata	00000014 IfxMultican_RXD0G_P34_2_IN
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_222
80002240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_18
70000358 g     O .data	00000008 IM_block
50101920 g       .inttab	00000000 __interrupt_201
80002440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_34
80001200 g       .ctors	00000000 __EH_FRAME_BEGIN__
80004c42 g     F .text	00000010 im_to_sig
50101e40 g       .inttab	00000000 __interrupt_242
80002840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_66
50101180 g       .inttab	00000000 __interrupt_140
80003140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_138
8000d884 g     F .text	00000078 osEE_counter_insert_rel_trigger
80003e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_243
50101560 g       .inttab	00000000 __interrupt_171
80008d3e g     F .text	000000b6 IfxScuCcu_getSourceFrequency
8000537e g     F .text	0000001a IfxMultican_Node_deinit
70000f38 g     O .data	00000008 IfxPort_P22_9
8000dbb6 g     F .text	00000014 osEE_change_context_from_task_end
8000022c g     O .rodata	00000014 IfxMultican_TXD2_P32_5_OUT
50100220 g       .inttab	00000000 __interrupt_17
80004c62 g     F .text	00000088 writeIM_from_swc
8000d1a0 g     F .text	00000064 WaitEvent
70001d8c g     O .bss	000000c8 stRxMsgData
8000772e g     F .text	000000f4 IfxPort_disableEmergencyStop
50101a00 g       .inttab	00000000 __interrupt_208
50101da0 g       .inttab	00000000 __interrupt_237
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_253
80003c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_225
50100700 g       .inttab	00000000 __interrupt_56
501009a0 g       .inttab	00000000 __interrupt_77
80002880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_68
70000fe0 g     O .data	00000008 IfxPort_P20_8
70000f40 g     O .data	00000008 IfxPort_P22_8
70000fe8 g     O .data	00000008 IfxPort_P20_7
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
50101280 g       .inttab	00000000 __interrupt_148
50100ca0 g       .inttab	00000000 __interrupt_101
8000d366 g     F .text	0000006e IncrementCounter
80001060 g       .traptab	00000000 __trap_3
80002980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_76
70001178 g     O .data	00000008 IfxPort_P11_1
50101f20 g       .inttab	00000000 __interrupt_249
5001b600 g       .CPU2.ustack	00000000 __USTACK2
50101e60 g       .inttab	00000000 __interrupt_243
50101940 g       .inttab	00000000 __interrupt_202
8000db44 g     F .text	00000028 osEE_alarm_cancel
80003940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_202
50101ce0 g       .inttab	00000000 __interrupt_231
80000240 g     O .rodata	00000014 IfxMultican_TXD2_P15_0_OUT
8000c8f4 g     F .text	0000006c osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80003260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_147
50100860 g       .inttab	00000000 __interrupt_67
80000020 g       .startup	00000000 BootModeIndex
50101f00 g       .inttab	00000000 __interrupt_248
501019e0 g       .inttab	00000000 __interrupt_207
8000731a g     F .text	000000c6 IfxMultican_Can_Node_sendToBusOff
70000388 g     O .data	00000a40 IfxPort_Pin_pinTable
70001cae g     O .bss	00000003 tx_msgid_to_tx_MsgObjId
800032c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_150
80003d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_236
70001894 g     O .data	00000004 __malloc_trim_threshold
800031a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_141
80002d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_104
501003a0 g       .inttab	00000000 __interrupt_29
8000d95c g     F .text	00000024 osEE_counter_cancel_trigger
50100020 g       .inttab	00000000 ___interrupt_1
80010818 g     F .text	000000ca __mdiff
800020e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_7
501015e0 g       .inttab	00000000 __interrupt_175
80002920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_73
8000d69e g     F .text	0000001e osEE_activate_isr2
80004c10 g     F .text	00000032 swc_db_init
70001460 g     O .data	00000004 __ctype_ptr__
80009b3a g     F .text	00000122 IfxScuCcu_setPll2Frequency
700011f8 g     O .data	00000008 IfxPort_P02_4
800004d4 g     O .rodata	00000014 IfxMultican_RXD0C_P12_0_IN
50101ba0 g       .inttab	00000000 __interrupt_221
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_238
70000df0 g     O .data	00000008 IfxPort_P40_4
80020000 g       .startup	00000000 BootModeHeader1
8000c4f0 g     F .text	000001e2 osEE_tc_set_pll_fsource
50101800 g       .inttab	00000000 __interrupt_192
80007b4e g     F .text	000000a4 IfxPort_setGroupPadDriver
50100a40 g       .inttab	00000000 __interrupt_82
800026e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_55
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_127
700012a8 g     O .data	00000008 IfxPort_P00_10
80002b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_92
70000f80 g     O .data	00000008 IfxPort_P22_10
8000dde2 g     F .text	0000000a atoi
80000344 g     O .rodata	00000014 IfxMultican_TXD0_P02_5_OUT
501002e0 g       .inttab	00000000 __interrupt_23
80000975 g     O .rodata	00000101 _ctype_
80002320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_25
800039c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_206
800029e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_79
80000e48 g     O .rodata	00000000 __copy_table
501011a0 g       .inttab	00000000 __interrupt_141
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
8000b36c g     F .text	00000034 _poll_uart1
50100e60 g       .inttab	00000000 __interrupt_115
70001008 g     O .data	00000008 IfxPort_P20_13
50101fc0 g       .inttab	00000000 __interrupt_254
50100720 g       .inttab	00000000 __interrupt_57
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_119
800113cc g     F .text	00000010 _exit
80002280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_20
80001120 g       .traptab	00000000 osEE_tc_trap_protection
80001100 g     F .traptab	00000000 __TRAPTAB
700011e8 g     O .data	00000008 IfxPort_P02_6
70000f08 g     O .data	00000008 IfxPort_P23_5
50101380 g       .inttab	00000000 __interrupt_156
80000358 g     O .rodata	00000014 IfxMultican_TXD0_P02_0_OUT
00002000 g       *ABS*	00000000 __CSA2_SIZE
8000b590 g     F .text	0000001e toggleLED1
800035a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_173
800053ca g     F .text	00000024 IfxMultican_Node_initTxPin
70000fd0 g     O .data	00000008 IfxPort_P21_0
8000a650 g     F .text	000000e0 IfxScuWdt_initSafetyWatchdog
50101a60 g       .inttab	00000000 __interrupt_211
50100800 g       .inttab	00000000 __interrupt_64
8000de08 g     F .text	00000014 strlen
50100de0 g       .inttab	00000000 __interrupt_111
501008a0 g       .inttab	00000000 __interrupt_69
80000254 g     O .rodata	00000014 IfxMultican_TXD2_P14_10_OUT
80003860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_195
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
50101720 g       .inttab	00000000 __interrupt_185
800002cc g     O .rodata	00000014 IfxMultican_TXD1_P01_3_OUT
50101680 g       .inttab	00000000 __interrupt_180
800119c4 g     F .text	00000040 .hidden __gedf2
700010b8 g     O .data	00000008 IfxPort_P14_2
80000618 g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_94
70001188 g     O .data	00000008 IfxPort_P10_8
50101a20 g       .inttab	00000000 __interrupt_209
80004c52 g     F .text	00000010 sig_to_im
80002720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_57
70000ec0 g     O .data	00000008 IfxPort_P32_7
501003c0 g       .inttab	00000000 __interrupt_30
700011d0 g     O .data	00000008 IfxPort_P02_9
700010f8 g     O .data	00000008 IfxPort_P12_1
80003420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_161
70000091 g     O .data	00000003 is_tx_msg
80002f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_122
70001cc4 g     O .bss	000000c8 stTxMsgData
70000e50 g     O .data	00000008 IfxPort_P33_7
80001000 g       .traptab	00000000 __trap_0
8000ddec g     F .text	0000001c strchr
700050d8 g     O .inttab	00000001 __HEAP_END
80004078 g     F .text	000002ba Funcouter_COM
50100640 g       .inttab	00000000 __interrupt_50
8000bd9a g     F .text	00000004 SYSTEM_EnableProtection
6001bc00 g       .CPU1.csa	00000000 __CSA1
50101780 g       .inttab	00000000 __interrupt_188
70000ea8 g     O .data	00000008 IfxPort_P33_10
800087fe g     F .text	00000140 IfxScuCcu_getMaxFrequency
50101f60 g       .inttab	00000000 __interrupt_251
50101b20 g       .inttab	00000000 __interrupt_217
50100be0 g       .inttab	00000000 __interrupt_95
8000c9f0 g     F .text	0000001a EnableAllInterrupts
7000008c g     O .data	00000005 is_tx_sig
50100b00 g       .inttab	00000000 __interrupt_88
8000b41c g     F .text	00000038 _in_uart0
501005a0 g       .inttab	00000000 __interrupt_45
80007bf2 g     F .text	00000062 IfxPort_setPinMode
80003640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_178
70000f20 g     O .data	00000008 IfxPort_P23_2
80006e42 g     F .text	00000058 IfxMultican_Can_MsgObj_readMessage
80002780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_60
8000b2a6 g     F .text	00000092 _init_uart1
8000dcae g     F .text	0000001a osEE_hal_restore_ctx
50101600 g       .inttab	00000000 __interrupt_176
80011608 g     F .text	00000040 .hidden __subdf3
70001278 g     O .data	00000008 IfxPort_P00_5
50100780 g       .inttab	00000000 __interrupt_60
70008000 g     O *ABS*	00000000 _SMALL_DATA_
80003f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_248
8000a7ce g     F .text	00000032 IfxScuWdt_setSafetyEndinit
80010510 g     F .text	00000066 __lo0bits
800034c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_166
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
50100500 g       .inttab	00000000 __interrupt_40
70000de0 g     O .data	00000008 IfxPort_P40_6
70001028 g     O .data	00000008 IfxPort_P20_1
50100a60 g       .inttab	00000000 __interrupt_83
80005034 g     F .text	000000a8 IfxMultican_MsgObj_readMessage
8000b576 g     F .text	0000001a setLED2
800046c2 g     F .text	00000066 Driver_Can_Tx
50100060 g       .inttab	00000000 __interrupt_3
50100460 g       .inttab	00000000 __interrupt_35
70000dc8 g     O .data	00000008 IfxPort_P40_9
80003080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_132
50101000 g       .inttab	00000000 __interrupt_128
80008ae8 g     F .text	00000032 IfxScuCcu_getOscFrequency
8000727e g     F .text	0000009c IfxMultican_Can_Node_initConfig
8000caec g     F .text	00000038 ResumeOSInterrupts
50100f60 g       .inttab	00000000 __interrupt_123
800030e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_135
80004fa2 g     F .text	00000006 IfxMultican_MsgObj_getStatus
501004c0 g       .inttab	00000000 __interrupt_38
80004000 g     F .text	0000002c FuncTASK1
50100c40 g       .inttab	00000000 __interrupt_98
80003200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_144
80002d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_107
80002160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_11
800006f4 g     O .rodata	0000000c osEE_cdb_var
501006a0 g       .inttab	00000000 __interrupt_53
80011c12 g     F .text	00000112 .hidden __pack_d
70001170 g     O .data	00000008 IfxPort_P11_10
8000d06a g     F .text	0000005a SetAbsAlarm
80004652 g     F .text	00000060 Driver_Can_Tx_set
8000b5ec g     F .text	00000094 getSW1_Debounce
8000cb24 g     F .text	00000096 StartOS
70000ff8 g     O .data	00000008 IfxPort_P20_3
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_229
70001260 g     O .data	00000008 IfxPort_P00_8
80003440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_162
800052c2 g     F .text	0000006a IfxMultican_MsgObj_writeTxfifo
800002b8 g     O .rodata	00000014 IfxMultican_TXD1_P02_9_OUT
50100940 g       .inttab	00000000 __interrupt_74
70000f70 g     O .data	00000008 IfxPort_P22_2
8001044c g     F .text	00000082 __multadd
8001043a g     F .text	00000012 _Bfree
00000000         *UND*	00000000 __do_global_ctors
80008000 g     O *ABS*	00000000 _SMALL_DATA3_
80003a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_212



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 d1 5f 	ja 8000bfa2 <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80001000 <TriCore_trap_table>:
80001000:	0d 00 00 02 	svlcx 
80001004:	91 00 00 f7 	movh.a %a15,28672
80001008:	19 f4 28 25 	ld.w %d4,[%a15]20648 <700050a8 <Tdisptab>>
8000100c:	60 4f       	mov.a %a15,%d4
8000100e:	02 f4       	mov %d4,%d15
80001010:	2d 0f 00 00 	calli %a15
80001014:	0d 00 40 02 	rslcx 
80001018:	00 80       	rfe 
8000101a:	00 00       	nop 
8000101c:	00 00       	nop 
	...

80001020 <__trap_1>:
80001020:	0d 00 00 02 	svlcx 
80001024:	91 00 00 f7 	movh.a %a15,28672
80001028:	19 f4 2c 25 	ld.w %d4,[%a15]20652 <700050ac <Tdisptab+0x4>>
8000102c:	60 4f       	mov.a %a15,%d4
8000102e:	02 f4       	mov %d4,%d15
80001030:	2d 0f 00 00 	calli %a15
80001034:	0d 00 40 02 	rslcx 
80001038:	00 80       	rfe 
8000103a:	00 00       	nop 
8000103c:	00 00       	nop 
	...

80001040 <__trap_2>:
80001040:	0d 00 00 02 	svlcx 
80001044:	91 00 00 f7 	movh.a %a15,28672
80001048:	19 f4 30 25 	ld.w %d4,[%a15]20656 <700050b0 <Tdisptab+0x8>>
8000104c:	60 4f       	mov.a %a15,%d4
8000104e:	02 f4       	mov %d4,%d15
80001050:	2d 0f 00 00 	calli %a15
80001054:	0d 00 40 02 	rslcx 
80001058:	00 80       	rfe 
8000105a:	00 00       	nop 
8000105c:	00 00       	nop 
	...

80001060 <__trap_3>:
80001060:	0d 00 00 02 	svlcx 
80001064:	91 00 00 f7 	movh.a %a15,28672
80001068:	19 f4 34 25 	ld.w %d4,[%a15]20660 <700050b4 <Tdisptab+0xc>>
8000106c:	60 4f       	mov.a %a15,%d4
8000106e:	02 f4       	mov %d4,%d15
80001070:	2d 0f 00 00 	calli %a15
80001074:	0d 00 40 02 	rslcx 
80001078:	00 80       	rfe 
8000107a:	00 00       	nop 
8000107c:	00 00       	nop 
	...

80001080 <__trap_4>:
80001080:	0d 00 00 02 	svlcx 
80001084:	91 00 00 f7 	movh.a %a15,28672
80001088:	19 f4 38 25 	ld.w %d4,[%a15]20664 <700050b8 <Tdisptab+0x10>>
8000108c:	60 4f       	mov.a %a15,%d4
8000108e:	02 f4       	mov %d4,%d15
80001090:	2d 0f 00 00 	calli %a15
80001094:	0d 00 40 02 	rslcx 
80001098:	00 80       	rfe 
8000109a:	00 00       	nop 
8000109c:	00 00       	nop 
	...

800010a0 <__trap_5>:
800010a0:	0d 00 00 02 	svlcx 
800010a4:	91 00 00 f7 	movh.a %a15,28672
800010a8:	19 f4 3c 25 	ld.w %d4,[%a15]20668 <700050bc <Tdisptab+0x14>>
800010ac:	60 4f       	mov.a %a15,%d4
800010ae:	02 f4       	mov %d4,%d15
800010b0:	2d 0f 00 00 	calli %a15
800010b4:	0d 00 40 02 	rslcx 
800010b8:	00 80       	rfe 
800010ba:	00 00       	nop 
800010bc:	00 00       	nop 
	...

800010c0 <___trap_6>:
800010c0:	1d 00 7c 66 	j 8000ddb8 <__trap_6>
	...

800010e0 <__trap_7>:
800010e0:	0d 00 00 02 	svlcx 
800010e4:	91 00 00 f7 	movh.a %a15,28672
800010e8:	19 f4 04 35 	ld.w %d4,[%a15]20676 <700050c4 <Tdisptab+0x1c>>
800010ec:	60 4f       	mov.a %a15,%d4
800010ee:	02 f4       	mov %d4,%d15
800010f0:	2d 0f 00 00 	calli %a15
800010f4:	0d 00 40 02 	rslcx 
800010f8:	00 80       	rfe 
800010fa:	00 00       	nop 
800010fc:	00 00       	nop 
	...

80001100 <__TRAPTAB>:
80001100:	00 a0       	debug 
80001102:	1d ff ff ff 	j 80001100 <__TRAPTAB>
	...

80001120 <osEE_tc_trap_protection>:
80001120:	00 a0       	debug 
80001122:	1d ff ff ff 	j 80001120 <osEE_tc_trap_protection>
	...

80001140 <osEE_tc_trap_instruction>:
80001140:	00 a0       	debug 
80001142:	1d ff ff ff 	j 80001140 <osEE_tc_trap_instruction>
	...

80001160 <osEE_tc_trap_context>:
80001160:	00 a0       	debug 
80001162:	1d ff ff ff 	j 80001160 <osEE_tc_trap_context>
	...

80001180 <osEE_tc_trap_bus>:
80001180:	00 a0       	debug 
80001182:	1d ff ff ff 	j 80001180 <osEE_tc_trap_bus>
	...

800011a0 <osEE_tc_trap_assertion>:
800011a0:	00 a0       	debug 
800011a2:	1d ff ff ff 	j 800011a0 <osEE_tc_trap_assertion>
	...

800011c0 <osEE_tc_trap_system>:
800011c0:	00 a0       	debug 
800011c2:	1d ff ff ff 	j 800011c0 <osEE_tc_trap_system>
	...

800011e0 <osEE_tc_trap_nmi>:
800011e0:	00 a0       	debug 
800011e2:	1d ff ff ff 	j 800011e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001200 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001208 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_isr2_entry_1>:
80002020:	0d 00 00 02 	svlcx 
80002024:	82 04       	mov %d4,0
80002026:	1d 00 d4 54 	j 8000c9ce <osEE_tc_isr2_wrapper>
	...

80002040 <osEE_tc_isr_dummy_entry_2>:
80002040:	3c 00       	j 80002040 <osEE_tc_isr_dummy_entry_2>
	...

80002060 <osEE_tc_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_isr_dummy_entry_3>
	...

80002080 <osEE_tc_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_isr_dummy_entry_7>
	...

80002100 <osEE_tc_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_isr_dummy_entry_8>
	...

80002120 <osEE_tc_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_isr_dummy_entry_9>
	...

80002140 <osEE_tc_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_isr_dummy_entry_10>
	...

80002160 <osEE_tc_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_isr_dummy_entry_11>
	...

80002180 <osEE_tc_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_isr_dummy_entry_15>
	...

80002200 <osEE_tc_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_isr_dummy_entry_16>
	...

80002220 <osEE_tc_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_isr_dummy_entry_17>
	...

80002240 <osEE_tc_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_isr_dummy_entry_18>
	...

80002260 <osEE_tc_isr_dummy_entry_19>:
80002260:	3c 00       	j 80002260 <osEE_tc_isr_dummy_entry_19>
	...

80002280 <osEE_tc_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_isr_dummy_entry_23>
	...

80002300 <osEE_tc_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_isr_dummy_entry_24>
	...

80002320 <osEE_tc_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_isr_dummy_entry_25>
	...

80002340 <osEE_tc_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_isr_dummy_entry_26>
	...

80002360 <osEE_tc_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_isr_dummy_entry_27>
	...

80002380 <osEE_tc_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_isr_dummy_entry_31>
	...

80002400 <osEE_tc_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_isr_dummy_entry_32>
	...

80002420 <osEE_tc_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_isr_dummy_entry_33>
	...

80002440 <osEE_tc_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_isr_dummy_entry_34>
	...

80002460 <osEE_tc_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_isr_dummy_entry_35>
	...

80002480 <osEE_tc_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_isr_dummy_entry_39>
	...

80002500 <osEE_tc_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_isr_dummy_entry_40>
	...

80002520 <osEE_tc_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_isr_dummy_entry_41>
	...

80002540 <osEE_tc_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_isr_dummy_entry_42>
	...

80002560 <osEE_tc_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_isr_dummy_entry_43>
	...

80002580 <osEE_tc_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_isr_dummy_entry_47>
	...

80002600 <osEE_tc_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_isr_dummy_entry_48>
	...

80002620 <osEE_tc_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_isr_dummy_entry_49>
	...

80002640 <osEE_tc_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_isr_dummy_entry_50>
	...

80002660 <osEE_tc_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_isr_dummy_entry_51>
	...

80002680 <osEE_tc_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_isr_dummy_entry_55>
	...

80002700 <osEE_tc_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_isr_dummy_entry_56>
	...

80002720 <osEE_tc_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_isr_dummy_entry_57>
	...

80002740 <osEE_tc_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_isr_dummy_entry_58>
	...

80002760 <osEE_tc_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_isr_dummy_entry_59>
	...

80002780 <osEE_tc_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_isr_dummy_entry_63>
	...

80002800 <osEE_tc_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_isr_dummy_entry_64>
	...

80002820 <osEE_tc_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_isr_dummy_entry_65>
	...

80002840 <osEE_tc_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_isr_dummy_entry_66>
	...

80002860 <osEE_tc_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_isr_dummy_entry_67>
	...

80002880 <osEE_tc_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_isr_dummy_entry_71>
	...

80002900 <osEE_tc_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_isr_dummy_entry_72>
	...

80002920 <osEE_tc_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_isr_dummy_entry_73>
	...

80002940 <osEE_tc_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_isr_dummy_entry_74>
	...

80002960 <osEE_tc_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_isr_dummy_entry_75>
	...

80002980 <osEE_tc_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_isr_dummy_entry_127>
	...

80003000 <osEE_tc_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_isr_dummy_entry_128>
	...

80003020 <osEE_tc_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_isr_dummy_entry_129>
	...

80003040 <osEE_tc_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_isr_dummy_entry_130>
	...

80003060 <osEE_tc_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_isr_dummy_entry_131>
	...

80003080 <osEE_tc_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_isr_dummy_entry_135>
	...

80003100 <osEE_tc_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_isr_dummy_entry_136>
	...

80003120 <osEE_tc_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_isr_dummy_entry_137>
	...

80003140 <osEE_tc_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_isr_dummy_entry_138>
	...

80003160 <osEE_tc_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_isr_dummy_entry_139>
	...

80003180 <osEE_tc_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_isr_dummy_entry_143>
	...

80003200 <osEE_tc_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_isr_dummy_entry_144>
	...

80003220 <osEE_tc_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_isr_dummy_entry_145>
	...

80003240 <osEE_tc_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_isr_dummy_entry_146>
	...

80003260 <osEE_tc_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_isr_dummy_entry_147>
	...

80003280 <osEE_tc_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_isr_dummy_entry_151>
	...

80003300 <osEE_tc_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_isr_dummy_entry_152>
	...

80003320 <osEE_tc_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_isr_dummy_entry_153>
	...

80003340 <osEE_tc_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_isr_dummy_entry_154>
	...

80003360 <osEE_tc_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_isr_dummy_entry_155>
	...

80003380 <osEE_tc_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_isr_dummy_entry_159>
	...

80003400 <osEE_tc_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_isr_dummy_entry_160>
	...

80003420 <osEE_tc_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_isr_dummy_entry_161>
	...

80003440 <osEE_tc_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_isr_dummy_entry_162>
	...

80003460 <osEE_tc_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_isr_dummy_entry_163>
	...

80003480 <osEE_tc_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_isr_dummy_entry_167>
	...

80003500 <osEE_tc_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_isr_dummy_entry_168>
	...

80003520 <osEE_tc_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_isr_dummy_entry_169>
	...

80003540 <osEE_tc_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_isr_dummy_entry_170>
	...

80003560 <osEE_tc_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_isr_dummy_entry_171>
	...

80003580 <osEE_tc_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_isr_dummy_entry_175>
	...

80003600 <osEE_tc_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_isr_dummy_entry_176>
	...

80003620 <osEE_tc_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_isr_dummy_entry_177>
	...

80003640 <osEE_tc_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_isr_dummy_entry_178>
	...

80003660 <osEE_tc_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_isr_dummy_entry_179>
	...

80003680 <osEE_tc_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_isr_dummy_entry_183>
	...

80003700 <osEE_tc_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_isr_dummy_entry_184>
	...

80003720 <osEE_tc_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_isr_dummy_entry_185>
	...

80003740 <osEE_tc_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_isr_dummy_entry_186>
	...

80003760 <osEE_tc_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_isr_dummy_entry_187>
	...

80003780 <osEE_tc_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_isr_dummy_entry_191>
	...

80003800 <osEE_tc_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_isr_dummy_entry_192>
	...

80003820 <osEE_tc_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_isr_dummy_entry_193>
	...

80003840 <osEE_tc_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_isr_dummy_entry_194>
	...

80003860 <osEE_tc_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_isr_dummy_entry_195>
	...

80003880 <osEE_tc_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_isr_dummy_entry_199>
	...

80003900 <osEE_tc_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_isr_dummy_entry_200>
	...

80003920 <osEE_tc_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_isr_dummy_entry_201>
	...

80003940 <osEE_tc_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_isr_dummy_entry_202>
	...

80003960 <osEE_tc_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_isr_dummy_entry_203>
	...

80003980 <osEE_tc_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <FuncTASK1>:
DeclareTask(TASK4);
DeclareTask(TASK5);
DeclareTask(TASK6);


TASK(TASK1){
80004000:	20 08       	sub.a %sp,8
	char val = -1;
80004002:	d9 ae 08 00 	lea %a14,[%sp]8
80004006:	82 ff       	mov %d15,-1
80004008:	89 ef 3f f4 	st.b [+%a14]-1,%d15

	receiveMessage(IsDark, &val);
8000400c:	91 00 00 47 	movh.a %a4,28672
80004010:	40 e5       	mov.aa %a5,%a14
80004012:	d9 44 34 d0 	lea %a4,[%a4]884 <70000374 <im_IsDark>>
80004016:	6d 00 aa 06 	call 80004d6a <readIM>
//			IM_block[i]->inner_pass_flag = 0;
//
//		}
//	}
//
	sendMessage(IsIntunnel, &val);
8000401a:	91 00 00 47 	movh.a %a4,28672
8000401e:	d9 44 20 d0 	lea %a4,[%a4]864 <70000360 <im_IsIntunnel>>
80004022:	40 e5       	mov.aa %a5,%a14
80004024:	6d 00 1f 06 	call 80004c62 <writeIM_from_swc>


	TerminateTask();
80004028:	1d 00 61 46 	j 8000ccea <TerminateTask>

8000402c <FuncTASK2>:


TASK(TASK2){


	TerminateTask();
8000402c:	1d 00 5f 46 	j 8000ccea <TerminateTask>

80004030 <FuncTASK3>:
}

TASK(TASK3){

	TerminateTask();
80004030:	1d 00 5d 46 	j 8000ccea <TerminateTask>

80004034 <FuncTASK4>:
}

TASK(TASK4){

	TerminateTask();
80004034:	1d 00 5b 46 	j 8000ccea <TerminateTask>

80004038 <FuncTASK5>:
}

TASK(TASK5){

	TerminateTask();
80004038:	1d 00 59 46 	j 8000ccea <TerminateTask>

8000403c <FuncTASK6>:
}

TASK(TASK6){

	TerminateTask();
8000403c:	1d 00 57 46 	j 8000ccea <TerminateTask>

80004040 <Funcinner_COM>:
DeclareTask(outer_COM);


TASK(inner_COM){
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->inner_pass_flag == 1) {
80004040:	91 00 00 c7 	movh.a %a12,28672
80004044:	99 cf 18 d0 	ld.a %a15,[%a12]856 <70000358 <IM_block>>
80004048:	79 ff 08 00 	ld.b %d15,[%a15]8 <70000358 <IM_block>>
8000404c:	9e 10       	jeq %d15,1,8000406c <Funcinner_COM+0x2c>
8000404e:	d9 cf 18 d0 	lea %a15,[%a12]856 <70000358 <IM_block>>
80004052:	c8 1f       	ld.a %a15,[%a15]4
80004054:	79 ff 08 00 	ld.b %d15,[%a15]8 <70000001 <__DSPR0_START+0x1>>
80004058:	1e 13       	jeq %d15,1,8000405e <Funcinner_COM+0x1e>

			(IM_block[i]->activateTaskFunc)();
		}
	}

	TerminateTask();
8000405a:	1d 00 48 46 	j 8000ccea <TerminateTask>


TASK(inner_COM){
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->inner_pass_flag == 1) {
			IM_block[i]->inner_pass_flag = 0;
8000405e:	82 0f       	mov %d15,0
80004060:	28 8f       	st.b [%a15]8,%d15

			(IM_block[i]->activateTaskFunc)();
80004062:	c8 4f       	ld.a %a15,[%a15]16
80004064:	2d 0f 00 00 	calli %a15
		}
	}

	TerminateTask();
80004068:	1d 00 41 46 	j 8000ccea <TerminateTask>


TASK(inner_COM){
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->inner_pass_flag == 1) {
			IM_block[i]->inner_pass_flag = 0;
8000406c:	82 0f       	mov %d15,0
8000406e:	28 8f       	st.b [%a15]8,%d15

			(IM_block[i]->activateTaskFunc)();
80004070:	c8 4f       	ld.a %a15,[%a15]16
80004072:	2d 0f 00 00 	calli %a15
80004076:	3c ec       	j 8000404e <Funcinner_COM+0xe>

80004078 <Funcouter_COM>:
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
80004078:	7b 00 00 07 	movh %d0,28672
8000407c:	60 02       	mov.a %a2,%d0
8000407e:	82 0f       	mov %d15,0
80004080:	d9 2d 00 00 	lea %a13,[%a2]0



TASK(outer_COM) {
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->outer_pass_flag == 1) {
80004084:	91 00 00 27 	movh.a %a2,28672
80004088:	d9 22 18 d0 	lea %a2,[%a2]856 <70000358 <IM_block>>
8000408c:	90 2f       	addsc.a %a15,%a2,%d15,2
	TerminateTask();
}



TASK(outer_COM) {
8000408e:	20 20       	sub.a %sp,32
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->outer_pass_flag == 1) {
80004090:	c8 0f       	ld.a %a15,[%a15]0
}



TASK(outer_COM) {
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
80004092:	82 03       	mov %d3,0
80004094:	59 a3 10 00 	st.w [%sp]16,%d3
		if(IM_block[i]->outer_pass_flag == 1) {
80004098:	79 ff 09 00 	ld.b %d15,[%a15]9
8000409c:	df 1f 57 00 	jeq %d15,1,8000414a <Funcouter_COM+0xd2>
}



TASK(outer_COM) {
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
800040a0:	19 a3 10 00 	ld.w %d3,[%sp]16
800040a4:	df 13 45 80 	jne %d3,1,8000412e <Funcouter_COM+0xb6>
		}
	}

	for(int i = 0; i < 10; i++) {
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040a8:	82 04       	mov %d4,0
800040aa:	6d 00 04 03 	call 800046b2 <isTxMsgObj_ready>
800040ae:	df 02 25 81 	jne %d2,0,800042f8 <Funcouter_COM+0x280>
800040b2:	82 14       	mov %d4,1
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040b4:	82 18       	mov %d8,1
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040b6:	6d 00 fe 02 	call 800046b2 <isTxMsgObj_ready>
800040ba:	df 02 1a 81 	jne %d2,0,800042ee <Funcouter_COM+0x276>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040be:	9a 18       	add %d15,%d8,1
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040c0:	02 f4       	mov %d4,%d15
800040c2:	6d 00 f8 02 	call 800046b2 <isTxMsgObj_ready>
800040c6:	df 02 0f 81 	jne %d2,0,800042e4 <Funcouter_COM+0x26c>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040ca:	9a 28       	add %d15,%d8,2
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040cc:	02 f4       	mov %d4,%d15
800040ce:	6d 00 f2 02 	call 800046b2 <isTxMsgObj_ready>
800040d2:	df 02 04 81 	jne %d2,0,800042da <Funcouter_COM+0x262>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040d6:	9a 38       	add %d15,%d8,3
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040d8:	02 f4       	mov %d4,%d15
800040da:	6d 00 ec 02 	call 800046b2 <isTxMsgObj_ready>
800040de:	df 02 f9 80 	jne %d2,0,800042d0 <Funcouter_COM+0x258>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040e2:	9a 48       	add %d15,%d8,4
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040e4:	02 f4       	mov %d4,%d15
800040e6:	6d 00 e6 02 	call 800046b2 <isTxMsgObj_ready>
800040ea:	df 02 ee 80 	jne %d2,0,800042c6 <Funcouter_COM+0x24e>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040ee:	9a 58       	add %d15,%d8,5
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040f0:	02 f4       	mov %d4,%d15
800040f2:	6d 00 e0 02 	call 800046b2 <isTxMsgObj_ready>
800040f6:	df 02 e3 80 	jne %d2,0,800042bc <Funcouter_COM+0x244>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
800040fa:	9a 68       	add %d15,%d8,6
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
800040fc:	02 f4       	mov %d4,%d15
800040fe:	6d 00 da 02 	call 800046b2 <isTxMsgObj_ready>
80004102:	df 02 d8 80 	jne %d2,0,800042b2 <Funcouter_COM+0x23a>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
80004106:	9a 78       	add %d15,%d8,7
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
80004108:	02 f4       	mov %d4,%d15
8000410a:	6d 00 d4 02 	call 800046b2 <isTxMsgObj_ready>
8000410e:	df 02 cd 80 	jne %d2,0,800042a8 <Funcouter_COM+0x230>
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
			}
		}
	}

	for(int i = 0; i < 10; i++) {
80004112:	1b 88 00 f0 	addi %d15,%d8,8
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
80004116:	02 f4       	mov %d4,%d15
80004118:	6d 00 cd 02 	call 800046b2 <isTxMsgObj_ready>
8000411c:	df 02 bc 80 	jne %d2,0,80004294 <Funcouter_COM+0x21c>
			Driver_Can_Tx(i);
		}
	}

	ActivateTask(inner_COM);
80004120:	82 34       	mov %d4,3
80004122:	6d 00 59 45 	call 8000cbd4 <ActivateTask>
	TerminateTask();
}
80004126:	d9 aa 20 00 	lea %sp,[%sp]32
			Driver_Can_Tx(i);
		}
	}

	ActivateTask(inner_COM);
	TerminateTask();
8000412a:	1d 00 e0 45 	j 8000ccea <TerminateTask>



TASK(outer_COM) {
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->outer_pass_flag == 1) {
8000412e:	91 00 00 27 	movh.a %a2,28672
80004132:	82 1f       	mov %d15,1
80004134:	d9 22 18 d0 	lea %a2,[%a2]856 <70000358 <IM_block>>
80004138:	90 2f       	addsc.a %a15,%a2,%d15,2
8000413a:	82 13       	mov %d3,1
8000413c:	c8 0f       	ld.a %a15,[%a15]0
8000413e:	59 a3 10 00 	st.w [%sp]16 <70000000 <__DSPR0_START>>,%d3
80004142:	79 ff 09 00 	ld.b %d15,[%a15]9 <70000000 <__DSPR0_START>>
80004146:	df 1f ad ff 	jne %d15,1,800040a0 <Funcouter_COM+0x28>
			IM_block[i]->outer_pass_flag = 0;
8000414a:	82 0f       	mov %d15,0
8000414c:	28 9f       	st.b [%a15]9,%d15

			uint64 data = 0;
			if(IM_block[i]->var_size == 1) data = (uint64) *((char* )(IM_block[i]->data_p));
8000414e:	4c f0       	ld.w %d15,[%a15]0
80004150:	df 1f d9 00 	jeq %d15,1,80004302 <Funcouter_COM+0x28a>
			else if(IM_block[i]->var_size == 2) data = (uint64) *((short* )(IM_block[i]->data_p));
80004154:	df 2f e3 00 	jeq %d15,2,8000431a <Funcouter_COM+0x2a2>
			else if(IM_block[i]->var_size == 4) data = (uint64) *((int* )(IM_block[i]->data_p));
80004158:	df 4f e7 00 	jeq %d15,4,80004326 <Funcouter_COM+0x2ae>
			else if(IM_block[i]->var_size == 8) data = (uint64) *((uint64* )(IM_block[i]->data_p));
8000415c:	8b 8f 20 f2 	ne %d15,%d15,8
TASK(outer_COM) {
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->outer_pass_flag == 1) {
			IM_block[i]->outer_pass_flag = 0;

			uint64 data = 0;
80004160:	d2 0a       	mov %e10,0
			if(IM_block[i]->var_size == 1) data = (uint64) *((char* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 2) data = (uint64) *((short* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 4) data = (uint64) *((int* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 8) data = (uint64) *((uint64* )(IM_block[i]->data_p));
80004162:	df 0f d7 00 	jeq %d15,0,80004310 <Funcouter_COM+0x298>

			int sig_id = im_to_sig(i);
80004166:	19 a4 10 00 	ld.w %d4,[%sp]16
8000416a:	6d 00 6c 05 	call 80004c42 <im_to_sig>
			//ix_sig_blocker
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
8000416e:	91 00 00 27 	movh.a %a2,28672
80004172:	d9 22 20 80 	lea %a2,[%a2]544 <70000220 <signals>>
			if(IM_block[i]->var_size == 1) data = (uint64) *((char* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 2) data = (uint64) *((short* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 4) data = (uint64) *((int* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 8) data = (uint64) *((uint64* )(IM_block[i]->data_p));

			int sig_id = im_to_sig(i);
80004176:	60 2c       	mov.a %a12,%d2
			//ix_sig_blocker
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
80004178:	02 2f       	mov %d15,%d2
8000417a:	80 22       	mov.d %d2,%a2
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
8000417c:	80 c3       	mov.d %d3,%a12
			//ix_sig_blocker
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
8000417e:	13 cf 23 f2 	madd %d15,%d2,%d15,60
80004182:	60 ff       	mov.a %a15,%d15
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
80004184:	53 c3 21 f0 	mul %d15,%d3,28
			//ix_sig_blocker
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
80004188:	48 92       	ld.w %d2,[%a15]36
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
8000418a:	10 df       	addsc.a %a15,%a13,%d15,0
			//ix_sig_blocker
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
8000418c:	59 a2 0c 00 	st.w [%sp]12,%d2
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
80004190:	4c f0       	ld.w %d15,[%a15]0
80004192:	bf 1f 87 7f 	jlt %d15,1,800040a0 <Funcouter_COM+0x28>
80004196:	53 73 20 30 	mul %d3,%d3,7
8000419a:	c2 f2       	add %d2,-1
8000419c:	82 0e       	mov %d14,0
8000419e:	59 a3 14 00 	st.w [%sp]20,%d3
800041a2:	59 a2 1c 00 	st.w [%sp]28,%d2
800041a6:	40 fe       	mov.aa %a14,%a15
800041a8:	b5 ac 18 00 	st.a [%sp]24,%a12
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
800041ac:	58 05       	ld.w %d15,[%sp]20
				int tx_msg_can_id = messages[tx_msg_id].ID;
800041ae:	91 00 00 27 	movh.a %a2,28672

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
800041b2:	42 ef       	add %d15,%d14
800041b4:	90 df       	addsc.a %a15,%a13,%d15,2
				int tx_msg_can_id = messages[tx_msg_id].ID;
800041b6:	d9 22 10 60 	lea %a2,[%a2]400 <70000190 <messages>>

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
800041ba:	48 19       	ld.w %d9,[%a15]4
				int tx_msg_can_id = messages[tx_msg_id].ID;
800041bc:	80 22       	mov.d %d2,%a2
				int sit_start_bit = sig_to_tx_msg[sig_id].start_bit_list[i];

				int MsgObjId = tx_msgid_to_tx_MsgObjId[tx_msg_id];
800041be:	91 00 00 27 	movh.a %a2,28672
			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
				int tx_msg_can_id = messages[tx_msg_id].ID;
800041c2:	13 09 23 22 	madd %d2,%d2,%d9,48
				int sit_start_bit = sig_to_tx_msg[sig_id].start_bit_list[i];

				int MsgObjId = tx_msgid_to_tx_MsgObjId[tx_msg_id];
800041c6:	d9 22 ee 21 	lea %a2,[%a2]7342 <70001cae <tx_msgid_to_tx_MsgObjId>>
//				my_printf("outer_COM @ sit_start_bit : %d, sig_length : %d, sig_id : %d\n", sit_start_bit, sig_length, sig_id);


				uint64 bit_mask_n = 1;
				for(int i = 0; i < sig_length-1; i++)
800041ca:	19 a3 0c 00 	ld.w %d3,[%sp]12 <70001cae <tx_msgid_to_tx_MsgObjId>>
			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
				int tx_msg_can_id = messages[tx_msg_id].ID;
800041ce:	60 2f       	mov.a %a15,%d2
				int MsgObjId = tx_msgid_to_tx_MsgObjId[tx_msg_id];
//				my_printf("outer_COM @ sit_start_bit : %d, sig_length : %d, sig_id : %d\n", sit_start_bit, sig_length, sig_id);


				uint64 bit_mask_n = 1;
				for(int i = 0; i < sig_length-1; i++)
800041d0:	82 12       	mov %d2,1
			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
				int tx_msg_can_id = messages[tx_msg_id].ID;
800041d2:	c8 9c       	ld.a %a12,[%a15]36
				int sit_start_bit = sig_to_tx_msg[sig_id].start_bit_list[i];
800041d4:	90 df       	addsc.a %a15,%a13,%d15,2
				int MsgObjId = tx_msgid_to_tx_MsgObjId[tx_msg_id];
//				my_printf("outer_COM @ sit_start_bit : %d, sig_length : %d, sig_id : %d\n", sit_start_bit, sig_length, sig_id);


				uint64 bit_mask_n = 1;
				for(int i = 0; i < sig_length-1; i++)
800041d6:	82 0f       	mov %d15,0
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
				int tx_msg_id = sig_to_tx_msg[sig_id].msg_id_list[i];
				int tx_msg_can_id = messages[tx_msg_id].ID;
				int sit_start_bit = sig_to_tx_msg[sig_id].start_bit_list[i];
800041d8:	48 48       	ld.w %d8,[%a15]16

				int MsgObjId = tx_msgid_to_tx_MsgObjId[tx_msg_id];
800041da:	01 29 00 f6 	addsc.a %a15,%a2,%d9,0
800041de:	79 fd 00 00 	ld.b %d13,[%a15]0
//				my_printf("outer_COM @ sit_start_bit : %d, sig_length : %d, sig_id : %d\n", sit_start_bit, sig_length, sig_id);


				uint64 bit_mask_n = 1;
				for(int i = 0; i < sig_length-1; i++)
800041e2:	bf 23 0c 00 	jlt %d3,2,800041fa <Funcouter_COM+0x182>
800041e6:	d8 07       	ld.a %a15,[%sp]28
800041e8:	b0 ff       	add.a %a15,-1
					bit_mask_n = 1 + (bit_mask_n << 1);

				uint64 bit_mask = 1;

				for(int i = 0; i < sig_length-1; i++)
					bit_mask = 1 + (bit_mask << 1);
800041ea:	77 2f 80 f0 	dextr %d15,%d15,%d2,1
800041ee:	06 12       	sh %d2,1
800041f0:	8b 12 80 20 	addx %d2,%d2,1
800041f4:	8b 0f a0 f0 	addc %d15,%d15,0
				for(int i = 0; i < sig_length-1; i++)
					bit_mask_n = 1 + (bit_mask_n << 1);

				uint64 bit_mask = 1;

				for(int i = 0; i < sig_length-1; i++)
800041f8:	fc f9       	loop %a15,800041ea <Funcouter_COM+0x172>
					bit_mask = 1 + (bit_mask << 1);
				bit_mask = (bit_mask << sit_start_bit);
800041fa:	8f f8 01 31 	and %d3,%d8,31
800041fe:	8b 08 82 62 	ge %d6,%d8,32
80004202:	17 2f 80 f3 	dextr %d15,%d15,%d2,%d3
80004206:	0f 32 00 30 	sh %d3,%d2,%d3
				data = (data << sit_start_bit);
8000420a:	8f f8 01 21 	and %d2,%d8,31
8000420e:	02 67       	mov %d7,%d6

				uint64 bit_mask = 1;

				for(int i = 0; i < sig_length-1; i++)
					bit_mask = 1 + (bit_mask << 1);
				bit_mask = (bit_mask << sit_start_bit);
80004210:	2b 3f 50 f6 	seln %d15,%d6,%d15,%d3
80004214:	ab 03 a0 36 	seln %d3,%d6,%d3,0
				data = (data << sit_start_bit);
80004218:	17 ab 80 62 	dextr %d6,%d11,%d10,%d2
8000421c:	0f 2a 00 20 	sh %d2,%d10,%d2
80004220:	2b 26 50 67 	seln %d6,%d7,%d6,%d2
80004224:	ab 02 a0 27 	seln %d2,%d7,%d2,0
80004228:	0b 26 10 a8 	mov %e10,%d6,%d2


				__debug(outer_COM, sig_id);
8000422c:	19 a2 18 00 	ld.w %d2,[%sp]24
80004230:	91 00 00 48 	movh.a %a4,32768
80004234:	74 a2       	st.w [%sp],%d2
80004236:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <_start+0x8>>

				uint64 bit_mask = 1;

				for(int i = 0; i < sig_length-1; i++)
					bit_mask = 1 + (bit_mask << 1);
				bit_mask = (bit_mask << sit_start_bit);
8000423a:	02 3c       	mov %d12,%d3
				data = (data << sit_start_bit);


				__debug(outer_COM, sig_id);
8000423c:	6d 00 e1 36 	call 8000affe <my_printf>
				__debug(outer_COM, tx_msg_id);
80004240:	91 00 00 48 	movh.a %a4,32768
80004244:	d9 44 06 10 	lea %a4,[%a4]70 <80000046 <_start+0x26>>
80004248:	74 a9       	st.w [%sp],%d9
8000424a:	6d 00 da 36 	call 8000affe <my_printf>
				__debug(outer_COM, tx_msg_can_id);
8000424e:	91 00 00 48 	movh.a %a4,32768
80004252:	d9 44 27 10 	lea %a4,[%a4]103 <80000067 <_start+0x47>>
80004256:	f4 ac       	st.a [%sp],%a12
80004258:	6d 00 d3 36 	call 8000affe <my_printf>
				__debug(outer_COM, sit_start_bit);
8000425c:	91 00 00 48 	movh.a %a4,32768
80004260:	d9 44 0c 20 	lea %a4,[%a4]140 <8000008c <_start+0x6c>>
80004264:	74 a8       	st.w [%sp],%d8
80004266:	6d 00 cc 36 	call 8000affe <my_printf>
				__debug(outer_COM, MsgObjId);
8000426a:	91 00 00 48 	movh.a %a4,32768
8000426e:	d9 44 31 20 	lea %a4,[%a4]177 <800000b1 <_start+0x91>>
80004272:	74 ad       	st.w [%sp],%d13
80004274:	6d 00 c5 36 	call 8000affe <my_printf>
//				my_printf("outer_COM" " : sit_start_bit: %d , bit_mask : %d", sit_start_bit, bit_mask);
//				if(sit_start_bit == 0 && bit_mask == 31) {
//					my_printf("Ture");
//				}
				Driver_Can_Tx_set(MsgObjId, tx_msg_can_id, data, bit_mask);
80004278:	80 c5       	mov.d %d5,%a12
8000427a:	0b ab 10 68 	mov %e6,%d11,%d10
8000427e:	78 01       	st.w [%sp]4,%d15
80004280:	74 ac       	st.w [%sp],%d12
80004282:	02 d4       	mov %d4,%d13
80004284:	6d 00 e7 01 	call 80004652 <Driver_Can_Tx_set>
//			if(!is_tx_sig[sig_id]) break;

			//
			// signal  tx_msg   txMsgObj 
			int sig_length = signals[sig_id].length;
			for(int i = 0; i < sig_to_tx_msg[sig_id].msg_cnt; i++) {
80004288:	4c e0       	ld.w %d15,[%a14]0
8000428a:	c2 1e       	add %d14,1
8000428c:	3f fe 90 7f 	jlt %d14,%d15,800041ac <Funcouter_COM+0x134>
80004290:	1d ff 08 ff 	j 800040a0 <Funcouter_COM+0x28>
	}

	for(int i = 0; i < 10; i++) {
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
			Driver_Can_Tx(i);
80004294:	02 f4       	mov %d4,%d15
80004296:	6d 00 16 02 	call 800046c2 <Driver_Can_Tx>
		}
	}

	ActivateTask(inner_COM);
8000429a:	82 34       	mov %d4,3
8000429c:	6d 00 9c 44 	call 8000cbd4 <ActivateTask>
	TerminateTask();
}
800042a0:	d9 aa 20 00 	lea %sp,[%sp]32
			Driver_Can_Tx(i);
		}
	}

	ActivateTask(inner_COM);
	TerminateTask();
800042a4:	1d 00 23 45 	j 8000ccea <TerminateTask>
	}

	for(int i = 0; i < 10; i++) {
		//CAN   -  sigbit   CAN  
		if(isTxMsgObj_ready(i)) {
			Driver_Can_Tx(i);
800042a8:	02 f4       	mov %d4,%d15
800042aa:	6d 00 0c 02 	call 800046c2 <Driver_Can_Tx>
800042ae:	1d ff 32 ff 	j 80004112 <Funcouter_COM+0x9a>
800042b2:	02 f4       	mov %d4,%d15
800042b4:	6d 00 07 02 	call 800046c2 <Driver_Can_Tx>
800042b8:	1d ff 27 ff 	j 80004106 <Funcouter_COM+0x8e>
800042bc:	02 f4       	mov %d4,%d15
800042be:	6d 00 02 02 	call 800046c2 <Driver_Can_Tx>
800042c2:	1d ff 1c ff 	j 800040fa <Funcouter_COM+0x82>
800042c6:	02 f4       	mov %d4,%d15
800042c8:	6d 00 fd 01 	call 800046c2 <Driver_Can_Tx>
800042cc:	1d ff 11 ff 	j 800040ee <Funcouter_COM+0x76>
800042d0:	02 f4       	mov %d4,%d15
800042d2:	6d 00 f8 01 	call 800046c2 <Driver_Can_Tx>
800042d6:	1d ff 06 ff 	j 800040e2 <Funcouter_COM+0x6a>
800042da:	02 f4       	mov %d4,%d15
800042dc:	6d 00 f3 01 	call 800046c2 <Driver_Can_Tx>
800042e0:	1d ff fb fe 	j 800040d6 <Funcouter_COM+0x5e>
800042e4:	02 f4       	mov %d4,%d15
800042e6:	6d 00 ee 01 	call 800046c2 <Driver_Can_Tx>
800042ea:	1d ff f0 fe 	j 800040ca <Funcouter_COM+0x52>
800042ee:	82 14       	mov %d4,1
800042f0:	6d 00 e9 01 	call 800046c2 <Driver_Can_Tx>
800042f4:	1d ff e5 fe 	j 800040be <Funcouter_COM+0x46>
800042f8:	82 04       	mov %d4,0
800042fa:	6d 00 e4 01 	call 800046c2 <Driver_Can_Tx>
800042fe:	1d ff da fe 	j 800040b2 <Funcouter_COM+0x3a>
	for(int i = 0 ; i < IM_TYPE_CNT; i++) {
		if(IM_block[i]->outer_pass_flag == 1) {
			IM_block[i]->outer_pass_flag = 0;

			uint64 data = 0;
			if(IM_block[i]->var_size == 1) data = (uint64) *((char* )(IM_block[i]->data_p));
80004302:	c8 3f       	ld.a %a15,[%a15]12
80004304:	79 fa 00 00 	ld.b %d10,[%a15]0
80004308:	0b a0 00 a8 	mov %e10,%d10
8000430c:	1d ff 2d ff 	j 80004166 <Funcouter_COM+0xee>
			else if(IM_block[i]->var_size == 2) data = (uint64) *((short* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 4) data = (uint64) *((int* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 8) data = (uint64) *((uint64* )(IM_block[i]->data_p));
80004310:	c8 3f       	ld.a %a15,[%a15]12
80004312:	09 fa 40 09 	ld.d %e10,[%a15]
80004316:	1d ff 28 ff 	j 80004166 <Funcouter_COM+0xee>
		if(IM_block[i]->outer_pass_flag == 1) {
			IM_block[i]->outer_pass_flag = 0;

			uint64 data = 0;
			if(IM_block[i]->var_size == 1) data = (uint64) *((char* )(IM_block[i]->data_p));
			else if(IM_block[i]->var_size == 2) data = (uint64) *((short* )(IM_block[i]->data_p));
8000431a:	c8 3f       	ld.a %a15,[%a15]12
8000431c:	88 0a       	ld.h %d10,[%a15]0
8000431e:	0b a0 00 a8 	mov %e10,%d10
80004322:	1d ff 22 ff 	j 80004166 <Funcouter_COM+0xee>
			else if(IM_block[i]->var_size == 4) data = (uint64) *((int* )(IM_block[i]->data_p));
80004326:	c8 3f       	ld.a %a15,[%a15]12
80004328:	48 0a       	ld.w %d10,[%a15]0
8000432a:	0b a0 00 a8 	mov %e10,%d10
8000432e:	1d ff 1c ff 	j 80004166 <Funcouter_COM+0xee>

80004332 <CAN_RxInt0Handler>:
	}
}



void CAN_RxInt0Handler(void){
80004332:	20 10       	sub.a %sp,16
}


IFX_INLINE void IfxCpu_enableInterrupts(void)
{
    __enable();
80004334:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();

    int can_id;
    uint64 can_data;

    for(int i = 0; i < TOTAL_MSG; i++) {
80004338:	82 09       	mov %d9,0
    	int rxMsgObjId = rx_msgid_to_rx_MsgObjId[i];
    	if(rxMsgObjId != -1) {
    		if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId], &stRxMsgData[rxMsgObjId])){
8000433a:	3b 00 10 e0 	mov %d14,256

    int can_id;
    uint64 can_data;

    for(int i = 0; i < TOTAL_MSG; i++) {
    	int rxMsgObjId = rx_msgid_to_rx_MsgObjId[i];
8000433e:	91 00 00 27 	movh.a %a2,28672
80004342:	d9 22 eb 21 	lea %a2,[%a2]7339 <70001cab <rx_msgid_to_rx_MsgObjId>>
80004346:	01 29 00 f6 	addsc.a %a15,%a2,%d9,0
8000434a:	79 ff 00 00 	ld.b %d15,[%a15]0
    	if(rxMsgObjId != -1) {
8000434e:	9e f8       	jeq %d15,-1,8000437e <CAN_RxInt0Handler+0x4c>
    		if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId], &stRxMsgData[rxMsgObjId])){
80004350:	91 00 00 27 	movh.a %a2,28672
80004354:	d9 22 cc 61 	lea %a2,[%a2]7564 <70001d8c <stRxMsgData>>
80004358:	80 22       	mov.d %d2,%a2
8000435a:	91 00 00 27 	movh.a %a2,28672
8000435e:	13 4f 21 22 	madd %d2,%d2,%d15,20
80004362:	d9 22 d8 91 	lea %a2,[%a2]7768 <70001e58 <stEcu1Can>>
80004366:	1b bf 00 f0 	addi %d15,%d15,11
8000436a:	60 2f       	mov.a %a15,%d2
8000436c:	80 22       	mov.d %d2,%a2
8000436e:	40 f5       	mov.aa %a5,%a15
80004370:	13 0f 21 22 	madd %d2,%d2,%d15,16
80004374:	60 24       	mov.a %a4,%d2
80004376:	6d 00 66 15 	call 80006e42 <IfxMultican_Can_MsgObj_readMessage>
8000437a:	5f e2 8a 00 	jeq %d2,%d14,8000448e <CAN_RxInt0Handler+0x15c>
    IfxCpu_enableInterrupts();

    int can_id;
    uint64 can_data;

    for(int i = 0; i < TOTAL_MSG; i++) {
8000437e:	c2 19       	add %d9,1
80004380:	df 39 df ff 	jne %d9,3,8000433e <CAN_RxInt0Handler+0xc>
			}
    	}
    }

    //for rxTest
    if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[9], &stRxMsgData[9])){
80004384:	91 00 00 57 	movh.a %a5,28672
80004388:	d9 5f c0 91 	lea %a15,[%a5]7744 <70001e40 <stRxMsgData+0xb4>>
8000438c:	91 00 00 47 	movh.a %a4,28672
80004390:	d9 44 d8 e1 	lea %a4,[%a4]8088 <70001f98 <stEcu1Can+0x140>>
80004394:	40 f5       	mov.aa %a5,%a15
80004396:	6d 00 56 15 	call 80006e42 <IfxMultican_Can_MsgObj_readMessage>
8000439a:	3b 00 10 f0 	mov %d15,256
8000439e:	5f f2 03 00 	jeq %d2,%d15,800043a4 <CAN_RxInt0Handler+0x72>
800043a2:	00 90       	ret 
		toggleLED2();
800043a4:	6d 00 05 39 	call 8000b5ae <toggleLED2>
800043a8:	40 f5       	mov.aa %a5,%a15
		u32nuCanRxCnt++;
800043aa:	91 00 00 27 	movh.a %a2,28672
800043ae:	19 2f d4 91 	ld.w %d15,[%a2]7764 <70001e54 <u32nuCanRxCnt>>
//IFX_INTERRUPT(CAN_RxInt0Handler, 0, 30);



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
800043b2:	09 54 0c d1 	ld.w %d4,[%a5+]-180 <70001e54 <u32nuCanRxCnt>>
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
800043b6:	19 52 3c 20 	ld.w %d2,[%a5]188 <70001e54 <u32nuCanRxCnt>>
void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
		if(messages[m].ID == can_id) {
800043ba:	91 00 00 f7 	movh.a %a15,28672
    }

    //for rxTest
    if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[9], &stRxMsgData[9])){
		toggleLED2();
		u32nuCanRxCnt++;
800043be:	c2 1f       	add %d15,1
void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
		if(messages[m].ID == can_id) {
800043c0:	d9 ff 10 60 	lea %a15,[%a15]400 <70000190 <messages>>
    }

    //for rxTest
    if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[9], &stRxMsgData[9])){
		toggleLED2();
		u32nuCanRxCnt++;
800043c4:	59 2f d4 91 	st.w [%a2]7764 <70001e54 <u32nuCanRxCnt>>,%d15



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
800043c8:	82 03       	mov %d3,0
800043ca:	19 5f 00 30 	ld.w %d15,[%a5]192
800043ce:	02 2c       	mov %d12,%d2
void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
		if(messages[m].ID == can_id) {
800043d0:	48 92       	ld.w %d2,[%a15]36



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
800043d2:	02 39       	mov %d9,%d3
800043d4:	42 f9       	add %d9,%d15

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800043d6:	82 0f       	mov %d15,0
		if(messages[m].ID == can_id) {
800043d8:	5f 24 0e 00 	jeq %d4,%d2,800043f4 <CAN_RxInt0Handler+0xc2>
800043dc:	19 f2 14 10 	ld.w %d2,[%a15]84 <70000054 <__DSPR0_START+0x54>>

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800043e0:	82 1f       	mov %d15,1
		if(messages[m].ID == can_id) {
800043e2:	5f 24 09 00 	jeq %d4,%d2,800043f4 <CAN_RxInt0Handler+0xc2>
800043e6:	19 ff 04 20 	ld.w %d15,[%a15]132 <70000084 <__DSPR0_START+0x84>>

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800043ea:	82 02       	mov %d2,0
800043ec:	0b f4 10 f1 	ne %d15,%d4,%d15
800043f0:	ab 22 80 ff 	sel %d15,%d15,%d2,2
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
800043f4:	7b 00 00 87 	movh %d8,28672
800043f8:	1b 48 09 80 	addi %d8,%d8,148
800043fc:	13 cf 22 28 	madd %d2,%d8,%d15,44
80004400:	60 2e       	mov.a %a14,%d2
80004402:	54 e2       	ld.w %d2,[%a14]
80004404:	bf 12 cf 7f 	jlt %d2,1,800043a2 <CAN_RxInt0Handler+0x70>
80004408:	53 bf 20 d0 	mul %d13,%d15,11
8000440c:	7b 00 00 b7 	movh %d11,28672
80004410:	91 00 00 d7 	movh.a %a13,28672
80004414:	82 0a       	mov %d10,0
80004416:	1b 0b 22 b0 	addi %d11,%d11,544
8000441a:	d9 dd 18 d0 	lea %a13,[%a13]856 <70000358 <IM_block>>
8000441e:	d9 ac 0f 00 	lea %a12,[%sp]15 <70000358 <IM_block>>
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
80004422:	1a ad       	add %d15,%d13,%d10
80004424:	60 82       	mov.a %a2,%d8
80004426:	90 2f       	addsc.a %a15,%a2,%d15,2
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];
80004428:	90 22       	addsc.a %a2,%a2,%d15,2
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
8000442a:	48 14       	ld.w %d4,[%a15]4
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];
8000442c:	19 26 18 00 	ld.w %d6,[%a2]24
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
80004430:	13 c4 23 2b 	madd %d2,%d11,%d4,60
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
80004434:	82 1f       	mov %d15,1
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
80004436:	60 2f       	mov.a %a15,%d2
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
80004438:	82 02       	mov %d2,0
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
8000443a:	48 93       	ld.w %d3,[%a15]36
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
		for(int i = 0; i < sig_length-1; i++)
8000443c:	bf 23 0c 00 	jlt %d3,2,80004454 <CAN_RxInt0Handler+0x122>
80004440:	60 3f       	mov.a %a15,%d3
80004442:	b0 ef       	add.a %a15,-2
			bit_mask_n = 1 + (bit_mask_n << 1);
80004444:	77 f2 80 20 	dextr %d2,%d2,%d15,1
80004448:	06 1f       	sh %d15,1
8000444a:	8b 1f 80 f0 	addx %d15,%d15,1
8000444e:	8b 02 a0 20 	addc %d2,%d2,0
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
		for(int i = 0; i < sig_length-1; i++)
80004452:	fc f9       	loop %a15,80004444 <CAN_RxInt0Handler+0x112>
			bit_mask_n = 1 + (bit_mask_n << 1);

		uint64 data = (can_data >> sig_start_bit) & bit_mask_n;
80004454:	8b 06 82 32 	ge %d3,%d6,32
80004458:	2b 9c 50 53 	seln %d5,%d3,%d12,%d9
8000445c:	ab 09 a0 23 	seln %d2,%d3,%d9,0
80004460:	8f f6 01 31 	and %d3,%d6,31
80004464:	8b 03 02 61 	rsub %d6,%d3,32
80004468:	17 52 80 26 	dextr %d2,%d2,%d5,%d6
8000446c:	2b 52 40 23 	sel %d2,%d3,%d2,%d5
80004470:	26 2f       	and %d15,%d2


		char temp = (char)data; //     
80004472:	2c af       	st.b [%sp]15,%d15

		int im_id = sig_to_im(sig_id);
80004474:	6d 00 ef 03 	call 80004c52 <sig_to_im>
		writeIM_from_sig((IM_block[im_id]),&temp);
80004478:	01 d2 02 f6 	addsc.a %a15,%a13,%d2,2
8000447c:	40 c5       	mov.aa %a5,%a12
8000447e:	c8 04       	ld.a %a4,[%a15]0
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
80004480:	c2 1a       	add %d10,1


		char temp = (char)data; //     

		int im_id = sig_to_im(sig_id);
		writeIM_from_sig((IM_block[im_id]),&temp);
80004482:	6d 00 34 04 	call 80004cea <writeIM_from_sig>
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
80004486:	4c e0       	ld.w %d15,[%a14]0
80004488:	3f fa cd 7f 	jlt %d10,%d15,80004422 <CAN_RxInt0Handler+0xf0>
8000448c:	00 90       	ret 

    for(int i = 0; i < TOTAL_MSG; i++) {
    	int rxMsgObjId = rx_msgid_to_rx_MsgObjId[i];
    	if(rxMsgObjId != -1) {
    		if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId], &stRxMsgData[rxMsgObjId])){
				toggleLED1();
8000448e:	6d 00 81 38 	call 8000b590 <toggleLED1>
				u32nuCanRxCnt++;
80004492:	91 00 00 27 	movh.a %a2,28672
80004496:	19 2f d4 91 	ld.w %d15,[%a2]7764 <70001e54 <u32nuCanRxCnt>>



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
8000449a:	48 22       	ld.w %d2,[%a15]8
    for(int i = 0; i < TOTAL_MSG; i++) {
    	int rxMsgObjId = rx_msgid_to_rx_MsgObjId[i];
    	if(rxMsgObjId != -1) {
    		if(IfxMultican_Status_newData==IfxMultican_Can_MsgObj_readMessage(&stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId], &stRxMsgData[rxMsgObjId])){
				toggleLED1();
				u32nuCanRxCnt++;
8000449c:	c2 1f       	add %d15,1
8000449e:	59 2f d4 91 	st.w [%a2]7764 <70001e54 <u32nuCanRxCnt>>,%d15
//IFX_INTERRUPT(CAN_RxInt0Handler, 0, 30);



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
800044a2:	48 04       	ld.w %d4,[%a15]0
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
800044a4:	4c f3       	ld.w %d15,[%a15]12
void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
		if(messages[m].ID == can_id) {
800044a6:	91 00 00 f7 	movh.a %a15,28672
800044aa:	d9 ff 10 60 	lea %a15,[%a15]400 <70000190 <messages>>



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
800044ae:	82 03       	mov %d3,0
800044b0:	02 2d       	mov %d13,%d2
void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
		if(messages[m].ID == can_id) {
800044b2:	48 92       	ld.w %d2,[%a15]36



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
800044b4:	02 3a       	mov %d10,%d3
800044b6:	42 fa       	add %d10,%d15

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800044b8:	82 0f       	mov %d15,0
		if(messages[m].ID == can_id) {
800044ba:	5f 24 0e 00 	jeq %d4,%d2,800044d6 <CAN_RxInt0Handler+0x1a4>
800044be:	19 f2 14 10 	ld.w %d2,[%a15]84 <70000054 <__DSPR0_START+0x54>>

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800044c2:	82 1f       	mov %d15,1
		if(messages[m].ID == can_id) {
800044c4:	5f 24 09 00 	jeq %d4,%d2,800044d6 <CAN_RxInt0Handler+0x1a4>
800044c8:	19 ff 04 20 	ld.w %d15,[%a15]132 <70000084 <__DSPR0_START+0x84>>

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800044cc:	82 02       	mov %d2,0
800044ce:	0b f4 10 f1 	ne %d15,%d4,%d15
800044d2:	ab 22 80 ff 	sel %d15,%d15,%d2,2
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
800044d6:	7b 00 00 87 	movh %d8,28672
800044da:	1b 48 09 80 	addi %d8,%d8,148
800044de:	13 cf 22 28 	madd %d2,%d8,%d15,44
800044e2:	60 2e       	mov.a %a14,%d2
800044e4:	54 e2       	ld.w %d2,[%a14]
800044e6:	bf 12 4c 7f 	jlt %d2,1,8000437e <CAN_RxInt0Handler+0x4c>
800044ea:	53 bf 20 f0 	mul %d15,%d15,11
800044ee:	7b 00 00 b7 	movh %d11,28672
800044f2:	91 00 00 d7 	movh.a %a13,28672
800044f6:	82 0c       	mov %d12,0
800044f8:	78 01       	st.w [%sp]4,%d15
800044fa:	1b 0b 22 b0 	addi %d11,%d11,544
800044fe:	d9 dd 18 d0 	lea %a13,[%a13]856 <70000358 <IM_block>>
80004502:	d9 ac 0f 00 	lea %a12,[%sp]15 <70000358 <IM_block>>
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
80004506:	58 01       	ld.w %d15,[%sp]4
80004508:	60 82       	mov.a %a2,%d8
8000450a:	42 cf       	add %d15,%d12
8000450c:	90 2f       	addsc.a %a15,%a2,%d15,2
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];
8000450e:	90 22       	addsc.a %a2,%a2,%d15,2
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
80004510:	48 14       	ld.w %d4,[%a15]4
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];
80004512:	19 26 18 00 	ld.w %d6,[%a2]24
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
80004516:	13 c4 23 2b 	madd %d2,%d11,%d4,60
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
8000451a:	82 1f       	mov %d15,1
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
8000451c:	60 2f       	mov.a %a15,%d2
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
8000451e:	82 02       	mov %d2,0
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
80004520:	48 93       	ld.w %d3,[%a15]36
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
		for(int i = 0; i < sig_length-1; i++)
80004522:	bf 23 0c 00 	jlt %d3,2,8000453a <CAN_RxInt0Handler+0x208>
80004526:	60 3f       	mov.a %a15,%d3
80004528:	b0 ef       	add.a %a15,-2
			bit_mask_n = 1 + (bit_mask_n << 1);
8000452a:	77 f2 80 20 	dextr %d2,%d2,%d15,1
8000452e:	06 1f       	sh %d15,1
80004530:	8b 1f 80 f0 	addx %d15,%d15,1
80004534:	8b 02 a0 20 	addc %d2,%d2,0
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
		for(int i = 0; i < sig_length-1; i++)
80004538:	fc f9       	loop %a15,8000452a <CAN_RxInt0Handler+0x1f8>
			bit_mask_n = 1 + (bit_mask_n << 1);

		uint64 data = (can_data >> sig_start_bit) & bit_mask_n;
8000453a:	8b 06 82 32 	ge %d3,%d6,32
8000453e:	2b ad 50 53 	seln %d5,%d3,%d13,%d10
80004542:	ab 0a a0 23 	seln %d2,%d3,%d10,0
80004546:	8f f6 01 31 	and %d3,%d6,31
8000454a:	8b 03 02 61 	rsub %d6,%d3,32
8000454e:	17 52 80 26 	dextr %d2,%d2,%d5,%d6
80004552:	2b 52 40 23 	sel %d2,%d3,%d2,%d5
80004556:	26 2f       	and %d15,%d2


		char temp = (char)data; //     
80004558:	2c af       	st.b [%sp]15,%d15

		int im_id = sig_to_im(sig_id);
8000455a:	6d 00 7c 03 	call 80004c52 <sig_to_im>
		writeIM_from_sig((IM_block[im_id]),&temp);
8000455e:	01 d2 02 f6 	addsc.a %a15,%a13,%d2,2
80004562:	40 c5       	mov.aa %a5,%a12
80004564:	c8 04       	ld.a %a4,[%a15]0
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
80004566:	c2 1c       	add %d12,1


		char temp = (char)data; //     

		int im_id = sig_to_im(sig_id);
		writeIM_from_sig((IM_block[im_id]),&temp);
80004568:	6d 00 c1 03 	call 80004cea <writeIM_from_sig>
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
8000456c:	4c e0       	ld.w %d15,[%a14]0
8000456e:	3f fc cc 7f 	jlt %d12,%d15,80004506 <CAN_RxInt0Handler+0x1d4>
80004572:	1d ff 06 ff 	j 8000437e <CAN_RxInt0Handler+0x4c>

80004576 <Can_rx_data_extracter>:
//IFX_INTERRUPT(CAN_RxInt0Handler, 0, 30);



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
	*can_id = RxCanMsg.id;
80004576:	4c 40       	ld.w %d15,[%a4]0

//IFX_INTERRUPT(CAN_RxInt0Handler, 0, 30);



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
80004578:	19 44 0c 00 	ld.w %d4,[%a4]12
	*can_id = RxCanMsg.id;
8000457c:	6c 50       	st.w [%a5]0,%d15

//IFX_INTERRUPT(CAN_RxInt0Handler, 0, 30);



void Can_rx_data_extracter(IfxMultican_Message RxCanMsg, int* can_id, uint64* can_data_storage){
8000457e:	19 42 08 00 	ld.w %d2,[%a4]8
	*can_id = RxCanMsg.id;
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);
80004582:	82 0f       	mov %d15,0
80004584:	42 4f       	add %d15,%d4
80004586:	74 62       	st.w [%a6],%d2
80004588:	6c 61       	st.w [%a6]4,%d15
8000458a:	00 90       	ret 

8000458c <Can_data_disassembler>:
void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
		if(messages[m].ID == can_id) {
8000458c:	91 00 00 f7 	movh.a %a15,28672
80004590:	d9 ff 10 60 	lea %a15,[%a15]400 <70000190 <messages>>
80004594:	48 92       	ld.w %d2,[%a15]36
	*can_data_storage = (uint64)(RxCanMsg.data[0]) + ((uint64)(RxCanMsg.data[1]) << 32);

	return;
}

void Can_data_disassembler(int can_id, uint64 can_data) {
80004596:	20 08       	sub.a %sp,8
80004598:	0b 76 10 a8 	mov %e10,%d6,%d7
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
8000459c:	82 0f       	mov %d15,0
		if(messages[m].ID == can_id) {
8000459e:	5f 42 0e 00 	jeq %d2,%d4,800045ba <Can_data_disassembler+0x2e>
800045a2:	19 f2 14 10 	ld.w %d2,[%a15]84 <70000054 <__DSPR0_START+0x54>>

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800045a6:	82 1f       	mov %d15,1
		if(messages[m].ID == can_id) {
800045a8:	5f 42 09 00 	jeq %d2,%d4,800045ba <Can_data_disassembler+0x2e>
800045ac:	19 ff 04 20 	ld.w %d15,[%a15]132 <70000084 <__DSPR0_START+0x84>>

void Can_data_disassembler(int can_id, uint64 can_data) {
	int msg_id = 0;

	int m = 0;
	for(m = 0 ; m < TOTAL_MSG; m++) {
800045b0:	0b 4f 10 41 	ne %d4,%d15,%d4
800045b4:	82 0f       	mov %d15,0
800045b6:	ab 2f 80 f4 	sel %d15,%d4,%d15,2
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
800045ba:	7b 00 00 87 	movh %d8,28672
800045be:	1b 48 09 80 	addi %d8,%d8,148
800045c2:	13 cf 22 28 	madd %d2,%d8,%d15,44
800045c6:	7b 00 00 c7 	movh %d12,28672
800045ca:	91 00 00 d7 	movh.a %a13,28672
800045ce:	60 2c       	mov.a %a12,%d2
800045d0:	82 09       	mov %d9,0
800045d2:	54 c2       	ld.w %d2,[%a12]
800045d4:	53 bf 20 d0 	mul %d13,%d15,11
800045d8:	1b 0c 22 c0 	addi %d12,%d12,544
800045dc:	d9 dd 18 d0 	lea %a13,[%a13]856 <70000358 <IM_block>>
800045e0:	bf 12 38 00 	jlt %d2,1,80004650 <Can_data_disassembler+0xc4>
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
800045e4:	1a 9d       	add %d15,%d13,%d9
800045e6:	60 82       	mov.a %a2,%d8
800045e8:	90 2f       	addsc.a %a15,%a2,%d15,2
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];
800045ea:	90 22       	addsc.a %a2,%a2,%d15,2
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
800045ec:	48 14       	ld.w %d4,[%a15]4
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];
800045ee:	19 20 18 00 	ld.w %d0,[%a2]24
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
800045f2:	13 c4 23 2c 	madd %d2,%d12,%d4,60
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
800045f6:	82 1f       	mov %d15,1
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
800045f8:	60 2f       	mov.a %a15,%d2
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
800045fa:	82 02       	mov %d2,0
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
		int sig_id = msg_in_sig_M[msg_id].sig_id[i];
		int sig_length = signals[sig_id].length;
800045fc:	48 93       	ld.w %d3,[%a15]36
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
		for(int i = 0; i < sig_length-1; i++)
800045fe:	bf 23 0c 00 	jlt %d3,2,80004616 <Can_data_disassembler+0x8a>
80004602:	60 3f       	mov.a %a15,%d3
80004604:	b0 ef       	add.a %a15,-2
			bit_mask_n = 1 + (bit_mask_n << 1);
80004606:	77 f2 80 20 	dextr %d2,%d2,%d15,1
8000460a:	06 1f       	sh %d15,1
8000460c:	8b 1f 80 f0 	addx %d15,%d15,1
80004610:	8b 02 a0 20 	addc %d2,%d2,0
		int sig_length = signals[sig_id].length;
		int sig_start_bit = msg_in_sig_M[msg_id].sig_start_bit[i];


		uint64 bit_mask_n = 1;
		for(int i = 0; i < sig_length-1; i++)
80004614:	fc f9       	loop %a15,80004606 <Can_data_disassembler+0x7a>
			bit_mask_n = 1 + (bit_mask_n << 1);

		uint64 data = (can_data >> sig_start_bit) & bit_mask_n;
80004616:	8b 00 82 32 	ge %d3,%d0,32
8000461a:	2b ab 50 53 	seln %d5,%d3,%d11,%d10
8000461e:	ab 0a a0 23 	seln %d2,%d3,%d10,0
80004622:	8f f0 01 31 	and %d3,%d0,31
80004626:	8b 03 02 71 	rsub %d7,%d3,32
8000462a:	17 52 80 27 	dextr %d2,%d2,%d5,%d7
8000462e:	2b 52 40 23 	sel %d2,%d3,%d2,%d5
80004632:	26 2f       	and %d15,%d2


		char temp = (char)data; //     
80004634:	2c a7       	st.b [%sp]7,%d15

		int im_id = sig_to_im(sig_id);
80004636:	6d 00 0e 03 	call 80004c52 <sig_to_im>
		writeIM_from_sig((IM_block[im_id]),&temp);
8000463a:	01 d2 02 f6 	addsc.a %a15,%a13,%d2,2
8000463e:	d9 a5 07 00 	lea %a5,[%sp]7
80004642:	c8 04       	ld.a %a4,[%a15]0
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
80004644:	c2 19       	add %d9,1


		char temp = (char)data; //     

		int im_id = sig_to_im(sig_id);
		writeIM_from_sig((IM_block[im_id]),&temp);
80004646:	6d 00 52 03 	call 80004cea <writeIM_from_sig>
			msg_id = m;
			break;
		}
	}

	for(int i = 0 ;i < msg_in_sig_M[msg_id].sig_cnt; i++) {
8000464a:	4c c0       	ld.w %d15,[%a12]0
8000464c:	3f f9 cc 7f 	jlt %d9,%d15,800045e4 <Can_data_disassembler+0x58>
80004650:	00 90       	ret 

80004652 <Driver_Can_Tx_set>:
		Can_data_disassembler(can_id, can_data);
	}
}

void Driver_Can_Tx_set(int txMsgObjId, uint32 can_id, uint64 new_data, uint64 bit_mask) {
	uint64 existing_data = ((uint64)(stTxMsgData[txMsgObjId].data[1]) << 32) + (uint64)(stTxMsgData[txMsgObjId].data[0]);
80004652:	91 00 00 f7 	movh.a %a15,28672
80004656:	80 f2       	mov.d %d2,%a15

		Can_data_disassembler(can_id, can_data);
	}
}

void Driver_Can_Tx_set(int txMsgObjId, uint32 can_id, uint64 new_data, uint64 bit_mask) {
80004658:	19 a1 04 00 	ld.w %d1,[%sp]4
	uint64 existing_data = ((uint64)(stTxMsgData[txMsgObjId].data[1]) << 32) + (uint64)(stTxMsgData[txMsgObjId].data[0]);
8000465c:	1b 42 cc f1 	addi %d15,%d2,7364
80004660:	13 44 21 2f 	madd %d2,%d15,%d4,20
80004664:	82 03       	mov %d3,0

		Can_data_disassembler(can_id, can_data);
	}
}

void Driver_Can_Tx_set(int txMsgObjId, uint32 can_id, uint64 new_data, uint64 bit_mask) {
80004666:	54 a8       	ld.w %d8,[%sp]
	uint64 existing_data = ((uint64)(stTxMsgData[txMsgObjId].data[1]) << 32) + (uint64)(stTxMsgData[txMsgObjId].data[0]);
80004668:	60 2f       	mov.a %a15,%d2
8000466a:	02 3f       	mov %d15,%d3
8000466c:	48 22       	ld.w %d2,[%a15]8

	uint64 one_set = new_data & bit_mask;
8000466e:	0f 86 80 30 	and %d3,%d6,%d8
		Can_data_disassembler(can_id, can_data);
	}
}

void Driver_Can_Tx_set(int txMsgObjId, uint32 can_id, uint64 new_data, uint64 bit_mask) {
	uint64 existing_data = ((uint64)(stTxMsgData[txMsgObjId].data[1]) << 32) + (uint64)(stTxMsgData[txMsgObjId].data[0]);
80004672:	02 20       	mov %d0,%d2
80004674:	48 32       	ld.w %d2,[%a15]12

	uint64 one_set = new_data & bit_mask;
	existing_data |= one_set;
80004676:	a6 30       	or %d0,%d3
		Can_data_disassembler(can_id, can_data);
	}
}

void Driver_Can_Tx_set(int txMsgObjId, uint32 can_id, uint64 new_data, uint64 bit_mask) {
	uint64 existing_data = ((uint64)(stTxMsgData[txMsgObjId].data[1]) << 32) + (uint64)(stTxMsgData[txMsgObjId].data[0]);
80004678:	42 2f       	add %d15,%d2

	uint64 one_set = new_data & bit_mask;
8000467a:	0f 17 80 20 	and %d2,%d7,%d1
	existing_data |= one_set;
8000467e:	a6 2f       	or %d15,%d2

	uint64 zero_set = new_data | (~bit_mask);
80004680:	0f 17 f0 70 	orn %d7,%d7,%d1
	existing_data &= zero_set;
80004684:	0f 7f 80 30 	and %d3,%d15,%d7
	uint64 existing_data = ((uint64)(stTxMsgData[txMsgObjId].data[1]) << 32) + (uint64)(stTxMsgData[txMsgObjId].data[0]);

	uint64 one_set = new_data & bit_mask;
	existing_data |= one_set;

	uint64 zero_set = new_data | (~bit_mask);
80004688:	0f 86 f0 60 	orn %d6,%d6,%d8


	stTxMsgData[txMsgObjId].id = can_id;
	stTxMsgData[txMsgObjId].data[1] = dataHigh;
	stTxMsgData[txMsgObjId].data[0] = dataLow;
	stTxMsgData[txMsgObjId].lengthCode = IfxMultican_DataLengthCode_8;
8000468c:	da 08       	mov %d15,8
8000468e:	28 4f       	st.b [%a15]4,%d15

	uint64 one_set = new_data & bit_mask;
	existing_data |= one_set;

	uint64 zero_set = new_data | (~bit_mask);
	existing_data &= zero_set;
80004690:	0f 60 80 20 	and %d2,%d0,%d6
	stTxMsgData[txMsgObjId].id = can_id;
	stTxMsgData[txMsgObjId].data[1] = dataHigh;
	stTxMsgData[txMsgObjId].data[0] = dataLow;
	stTxMsgData[txMsgObjId].lengthCode = IfxMultican_DataLengthCode_8;

	stTxMsgData[txMsgObjId].fastBitRate = FALSE;
80004694:	82 0f       	mov %d15,0

	uint32 dataLow = (uint32)existing_data;
	uint32 dataHigh = (uint32)(existing_data >> 32);


	stTxMsgData[txMsgObjId].id = can_id;
80004696:	68 05       	st.w [%a15]0,%d5
	stTxMsgData[txMsgObjId].data[1] = dataHigh;
	stTxMsgData[txMsgObjId].data[0] = dataLow;
	stTxMsgData[txMsgObjId].lengthCode = IfxMultican_DataLengthCode_8;

	stTxMsgData[txMsgObjId].fastBitRate = FALSE;
80004698:	e9 ff 10 00 	st.b [%a15]16,%d15

	uint64 zero_set = new_data | (~bit_mask);
	existing_data &= zero_set;

	uint32 dataLow = (uint32)existing_data;
	uint32 dataHigh = (uint32)(existing_data >> 32);
8000469c:	68 33       	st.w [%a15]12,%d3
	existing_data |= one_set;

	uint64 zero_set = new_data | (~bit_mask);
	existing_data &= zero_set;

	uint32 dataLow = (uint32)existing_data;
8000469e:	68 22       	st.w [%a15]8,%d2
	stTxMsgData[txMsgObjId].data[0] = dataLow;
	stTxMsgData[txMsgObjId].lengthCode = IfxMultican_DataLengthCode_8;

	stTxMsgData[txMsgObjId].fastBitRate = FALSE;

	newTxMsgSet_flag[txMsgObjId] = TRUE;
800046a0:	91 00 00 f7 	movh.a %a15,28672
800046a4:	d9 ff f8 21 	lea %a15,[%a15]7352 <70001cb8 <newTxMsgSet_flag>>
800046a8:	01 f4 00 f6 	addsc.a %a15,%a15,%d4,0
800046ac:	82 1f       	mov %d15,1
800046ae:	28 0f       	st.b [%a15]0,%d15
800046b0:	00 90       	ret 

800046b2 <isTxMsgObj_ready>:
}

int isTxMsgObj_ready(int txMsgObjId) {
	return newTxMsgSet_flag[txMsgObjId];
800046b2:	91 00 00 f7 	movh.a %a15,28672
800046b6:	d9 ff f8 21 	lea %a15,[%a15]7352 <70001cb8 <newTxMsgSet_flag>>
800046ba:	01 f4 00 f6 	addsc.a %a15,%a15,%d4,0
}
800046be:	08 02       	ld.bu %d2,[%a15]0
800046c0:	00 90       	ret 

800046c2 <Driver_Can_Tx>:


void Driver_Can_Tx(int txMsgObjId)
{

	my_printf("txMsgObj - id : %d, data[1] : %d, data[0] : %d \n", 	(stTxMsgData[txMsgObjId]).id,
800046c2:	91 00 00 f7 	movh.a %a15,28672
800046c6:	80 f3       	mov.d %d3,%a15
	return newTxMsgSet_flag[txMsgObjId];
}


void Driver_Can_Tx(int txMsgObjId)
{
800046c8:	20 10       	sub.a %sp,16

	my_printf("txMsgObj - id : %d, data[1] : %d, data[0] : %d \n", 	(stTxMsgData[txMsgObjId]).id,
800046ca:	1b 43 cc 21 	addi %d2,%d3,7364
800046ce:	13 44 21 32 	madd %d3,%d2,%d4,20
800046d2:	91 00 00 48 	movh.a %a4,32768
800046d6:	d9 44 14 30 	lea %a4,[%a4]212 <800000d4 <_start+0xb4>>
800046da:	60 3f       	mov.a %a15,%d3
	return newTxMsgSet_flag[txMsgObjId];
}


void Driver_Can_Tx(int txMsgObjId)
{
800046dc:	02 4f       	mov %d15,%d4

	my_printf("txMsgObj - id : %d, data[1] : %d, data[0] : %d \n", 	(stTxMsgData[txMsgObjId]).id,
800046de:	48 02       	ld.w %d2,[%a15]0
800046e0:	74 a2       	st.w [%sp],%d2
800046e2:	48 33       	ld.w %d3,[%a15]12
800046e4:	59 a3 04 00 	st.w [%sp]4 <80000000 <BootModeHeader0>>,%d3
800046e8:	48 22       	ld.w %d2,[%a15]8
800046ea:	59 a2 08 00 	st.w [%sp]8 <80000000 <BootModeHeader0>>,%d2
800046ee:	6d 00 88 34 	call 8000affe <my_printf>
																	(stTxMsgData[txMsgObjId]).data[1],
																	(stTxMsgData[txMsgObjId]).data[0]);

	__debug(Driver_Can_Tx, txMsgObjId);
800046f2:	91 00 00 48 	movh.a %a4,32768
800046f6:	78 00       	st.w [%sp]0,%d15
800046f8:	d9 44 05 40 	lea %a4,[%a4]261 <80000105 <_start+0xe5>>
800046fc:	6d 00 81 34 	call 8000affe <my_printf>
	__debug(Driver_Can_Tx, stTxMsgData[txMsgObjId].data[0]);
80004700:	48 23       	ld.w %d3,[%a15]8
80004702:	91 00 00 48 	movh.a %a4,32768
80004706:	74 a3       	st.w [%sp],%d3
80004708:	d9 44 2b 40 	lea %a4,[%a4]299 <8000012b <_start+0x10b>>
8000470c:	6d 00 79 34 	call 8000affe <my_printf>
	IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[txMsgObjId], &(stTxMsgData[txMsgObjId]));
80004710:	91 00 00 47 	movh.a %a4,28672
80004714:	c2 1f       	add %d15,1
80004716:	d9 44 d8 91 	lea %a4,[%a4]7768 <70001e58 <stEcu1Can>>
8000471a:	d0 44       	addsc.a %a4,%a4,%d15,3
8000471c:	d0 44       	addsc.a %a4,%a4,%d15,3
8000471e:	40 f5       	mov.aa %a5,%a15
//
//	IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[0], &(stTxMsgData[0]));

//	while (IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[txMsgObjId], &(stTxMsgData[txMsgObjId])) == IfxMultican_Status_notSentBusy){}

}
80004720:	d9 aa 10 00 	lea %sp,[%sp]16
																	(stTxMsgData[txMsgObjId]).data[1],
																	(stTxMsgData[txMsgObjId]).data[0]);

	__debug(Driver_Can_Tx, txMsgObjId);
	__debug(Driver_Can_Tx, stTxMsgData[txMsgObjId].data[0]);
	IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[txMsgObjId], &(stTxMsgData[txMsgObjId]));
80004724:	1d 00 bb 13 	j 80006e9a <IfxMultican_Can_MsgObj_sendMessage>

80004728 <Driver_Can_Txtest>:

}


void Driver_Can_Txtest(uint32 can_id, uint64 can_data)
{
80004728:	20 18       	sub.a %sp,24
IFX_INLINE void IfxMultican_Message_init(IfxMultican_Message *msg, uint32 id, uint32 dataLow, uint32 dataHigh, IfxMultican_DataLengthCode lengthCode)
{
    msg->id          = id;
    msg->data[0]     = dataLow;
    msg->data[1]     = dataHigh;
    msg->lengthCode  = lengthCode;
8000472a:	da 08       	mov %d15,8
	int dataLow = (int)can_data;
	int dataHigh = (int)(can_data >> 32);
	IfxMultican_Message msg;
	IfxMultican_Message_init(&msg, can_id, dataLow, dataHigh, IfxMultican_DataLengthCode_8);

	IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[9], &msg);
8000472c:	91 00 00 47 	movh.a %a4,28672
80004730:	2c a8       	st.b [%sp]8,%d15
80004732:	d9 44 f8 b1 	lea %a4,[%a4]7928 <70001ef8 <stEcu1Can+0xa0>>

    msg->fastBitRate = FALSE;
80004736:	82 0f       	mov %d15,0
80004738:	d9 a5 04 00 	lea %a5,[%sp]4
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxMultican_Message_init(IfxMultican_Message *msg, uint32 id, uint32 dataLow, uint32 dataHigh, IfxMultican_DataLengthCode lengthCode)
{
    msg->id          = id;
8000473c:	59 a4 04 00 	st.w [%sp]4,%d4
void Driver_Can_Txtest(uint32 can_id, uint64 can_data)
{
	int dataLow = (int)can_data;
	int dataHigh = (int)(can_data >> 32);
	IfxMultican_Message msg;
	IfxMultican_Message_init(&msg, can_id, dataLow, dataHigh, IfxMultican_DataLengthCode_8);
80004740:	59 a6 0c 00 	st.w [%sp]12,%d6
80004744:	59 a7 10 00 	st.w [%sp]16,%d7
    msg->data[0]     = dataLow;
    msg->data[1]     = dataHigh;
    msg->lengthCode  = lengthCode;

    msg->fastBitRate = FALSE;
80004748:	e9 af 14 00 	st.b [%sp]20,%d15

	IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[9], &msg);
8000474c:	1d 00 a7 13 	j 80006e9a <IfxMultican_Can_MsgObj_sendMessage>

80004750 <Driver_Can_Init>:


void Driver_Can_Init(void)
{
    /* create module config */
    InterruptInstall(SRC_ID_CANINT0, (void(*)(void))CAN_RxInt0Handler,5,0);
80004750:	91 00 00 48 	movh.a %a4,32768
//	while (IfxMultican_Can_MsgObj_sendMessage(&stEcu1Can.CanEcu1MsgTxObj[9], &msg) == IfxMultican_Status_notSentBusy){}
}


void Driver_Can_Init(void)
{
80004754:	20 d8       	sub.a %sp,216
    /* create module config */
    InterruptInstall(SRC_ID_CANINT0, (void(*)(void))CAN_RxInt0Handler,5,0);
80004756:	3b 00 24 40 	mov %d4,576
8000475a:	82 55       	mov %d5,5
8000475c:	82 06       	mov %d6,0
8000475e:	d9 44 32 c4 	lea %a4,[%a4]17202
80004762:	6d 00 69 38 	call 8000b834 <InterruptInstall>
    IfxMultican_Can_Config canConfig;
    IfxMultican_Can_initModuleConfig(&canConfig, &MODULE_CAN);
80004766:	91 20 00 5f 	movh.a %a5,61442
8000476a:	d9 a4 0c 20 	lea %a4,[%sp]140
8000476e:	d9 55 00 08 	lea %a5,[%a5]-32768 <f0018000 <_SMALL_DATA4_+0x40010000>>
80004772:	6d 00 9b 17 	call 800076a8 <IfxMultican_Can_initModuleConfig>

    /* initialize module */
    IfxMultican_Can_initModule(&stEcu1Can.CanEcu1, &canConfig);
80004776:	91 00 00 d7 	movh.a %a13,28672
8000477a:	d9 dd d8 91 	lea %a13,[%a13]7768 <70001e58 <stEcu1Can>>
8000477e:	40 d4       	mov.aa %a4,%a13
80004780:	d9 a5 0c 20 	lea %a5,[%sp]140
80004784:	6d 00 b9 16 	call 800074f6 <IfxMultican_Can_initModule>

    /* create CAN node config */
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
80004788:	7b 80 00 f0 	movh %d15,8
    /* initialize module */
    IfxMultican_Can_initModule(&stEcu1Can.CanEcu1, &canConfig);

    /* create CAN node config */
    IfxMultican_Can_NodeConfig canNodeConfig;
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);
8000478c:	d9 a4 08 10 	lea %a4,[%sp]72
80004790:	40 d5       	mov.aa %a5,%a13
80004792:	6d 00 76 15 	call 8000727e <IfxMultican_Can_Node_initConfig>

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
80004796:	1b 0f 12 fa 	addi %d15,%d15,-24288
8000479a:	78 14       	st.w [%sp]80,%d15
    {
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
8000479c:	7b 00 00 f8 	movh %d15,32768
800047a0:	1b 8f 4e f0 	addi %d15,%d15,1256
800047a4:	78 1c       	st.w [%sp]112,%d15
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
800047a6:	da 10       	mov %d15,16
800047a8:	e9 af 34 10 	st.b [%sp]116,%d15
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
800047ac:	7b 00 00 f8 	movh %d15,32768
800047b0:	1b cf 31 f0 	addi %d15,%d15,796
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
800047b4:	d9 dc 04 00 	lea %a12,[%a13]4 <70000004 <__DSPR0_START+0x4>>
    {
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
800047b8:	78 1e       	st.w [%sp]120,%d15
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
    {
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
800047ba:	82 09       	mov %d9,0
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;
800047bc:	3b 00 f8 ff 	mov %d15,-128

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
800047c0:	40 c4       	mov.aa %a4,%a12
800047c2:	d9 a5 08 10 	lea %a5,[%sp]72
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;
800047c6:	e9 af 3c 10 	st.b [%sp]124,%d15
    IfxMultican_Can_Node_initConfig(&canNodeConfig, &stEcu1Can.CanEcu1);

    canNodeConfig.baudrate = 500000UL;     /*500kbps*/
    {
        //0 
        canNodeConfig.nodeId    = (IfxMultican_NodeId)((int)IfxMultican_NodeId_0);
800047ca:	e9 a9 0c 10 	st.b [%sp]76,%d9
        canNodeConfig.rxPin     = &IfxMultican_RXD0B_P20_7_IN;
        canNodeConfig.rxPinMode = IfxPort_InputMode_pullUp;
        canNodeConfig.txPin     = &IfxMultican_TXD0_P20_8_OUT;
        canNodeConfig.txPinMode = IfxPort_OutputMode_pushPull;

        IfxMultican_Can_Node_init(&stEcu1Can.CanEcu1Node, &canNodeConfig);
800047ce:	6d 00 fa 13 	call 80006fc2 <IfxMultican_Can_Node_init>
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
800047d2:	7b 00 00 87 	movh %d8,28672
800047d6:	60 82       	mov.a %a2,%d8
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;
800047d8:	91 00 00 e7 	movh.a %a14,28672
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
800047dc:	79 2f 11 20 	ld.b %d15,[%a2]145
800047e0:	df 0f 8b 80 	jne %d15,0,800048f6 <Driver_Can_Init+0x1a6>
800047e4:	1b 18 09 80 	addi %d8,%d8,145
800047e8:	60 82       	mov.a %a2,%d8
		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);

		   txMsgObjId_cnt++;

	   } else {
		   tx_msgid_to_tx_MsgObjId[i] = -1;
800047ea:	82 ff       	mov %d15,-1
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
800047ec:	79 22 01 00 	ld.b %d2,[%a2]1
		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);

		   txMsgObjId_cnt++;

	   } else {
		   tx_msgid_to_tx_MsgObjId[i] = -1;
800047f0:	e9 ef ee 21 	st.b [%a14]7342 <70001cae <tx_msgid_to_tx_MsgObjId>>,%d15
800047f4:	d9 af 0c 00 	lea %a15,[%sp]12 <70001cae <tx_msgid_to_tx_MsgObjId>>


    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
800047f8:	82 0f       	mov %d15,0
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;
800047fa:	d9 ee ee 21 	lea %a14,[%a14]7342 <70001cae <tx_msgid_to_tx_MsgObjId>>
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
800047fe:	df 02 b4 80 	jne %d2,0,80004966 <Driver_Can_Init+0x216>
80004802:	60 82       	mov.a %a2,%d8
		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);

		   txMsgObjId_cnt++;

	   } else {
		   tx_msgid_to_tx_MsgObjId[i] = -1;
80004804:	82 f2       	mov %d2,-1
80004806:	e9 e2 01 00 	st.b [%a14]1 <70000001 <__DSPR0_START+0x1>>,%d2
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
8000480a:	79 22 02 00 	ld.b %d2,[%a2]2 <70000001 <__DSPR0_START+0x1>>
8000480e:	df 02 df 80 	jne %d2,0,800049cc <Driver_Can_Init+0x27c>
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004812:	7b 00 00 87 	movh %d8,28672
80004816:	60 82       	mov.a %a2,%d8
		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);

		   txMsgObjId_cnt++;

	   } else {
		   tx_msgid_to_tx_MsgObjId[i] = -1;
80004818:	82 ff       	mov %d15,-1
8000481a:	2c e2       	st.b [%a14]2,%d15
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
8000481c:	79 2f e8 21 	ld.b %d15,[%a2]7336 <70000002 <__DSPR0_START+0x2>>
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004820:	91 00 00 e7 	movh.a %a14,28672
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004824:	df 0f 0b 81 	jne %d15,0,80004a3a <Driver_Can_Init+0x2ea>
80004828:	1b 88 ca 81 	addi %d8,%d8,7336
8000482c:	60 82       	mov.a %a2,%d8

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
		   rxMsgObjId_cnt++;

	   } else {
		   rx_msgid_to_rx_MsgObjId[i] = -1;
8000482e:	82 ff       	mov %d15,-1
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004830:	79 22 01 00 	ld.b %d2,[%a2]1

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
		   rxMsgObjId_cnt++;

	   } else {
		   rx_msgid_to_rx_MsgObjId[i] = -1;
80004834:	e9 ef eb 21 	st.b [%a14]7339 <70001cab <rx_msgid_to_rx_MsgObjId>>,%d15
80004838:	82 0f       	mov %d15,0
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
8000483a:	d9 ee eb 21 	lea %a14,[%a14]7339 <70001cab <rx_msgid_to_rx_MsgObjId>>
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
8000483e:	df 02 4b 81 	jne %d2,0,80004ad4 <Driver_Can_Init+0x384>
80004842:	60 82       	mov.a %a2,%d8

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
		   rxMsgObjId_cnt++;

	   } else {
		   rx_msgid_to_rx_MsgObjId[i] = -1;
80004844:	82 f2       	mov %d2,-1
80004846:	e9 e2 01 00 	st.b [%a14]1 <70000001 <__DSPR0_START+0x1>>,%d2
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
8000484a:	79 22 02 00 	ld.b %d2,[%a2]2 <70000001 <__DSPR0_START+0x1>>
8000484e:	df 02 92 81 	jne %d2,0,80004b72 <Driver_Can_Init+0x422>

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
		   rxMsgObjId_cnt++;

	   } else {
		   rx_msgid_to_rx_MsgObjId[i] = -1;
80004852:	82 ff       	mov %d15,-1
80004854:	2c e2       	st.b [%a14]2,%d15

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004856:	40 f4       	mov.aa %a4,%a15
80004858:	40 c5       	mov.aa %a5,%a12
8000485a:	6d 00 6d 12 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
8000485e:	da 09       	mov %d15,9
80004860:	78 04       	st.w [%sp]16,%d15
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80004862:	39 af 1a 00 	ld.bu %d15,[%sp]26
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004866:	82 f8       	mov %d8,-1
    canMsgObjConfig.control.matchingId    = TRUE;
80004868:	16 fe       	and %d15,254
8000486a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
8000486e:	3b 50 05 b0 	mov %d11,85
    canMsgObjConfig.frame                 = frameType;
80004872:	82 19       	mov %d9,1
    canMsgObjConfig.control.messageLen    = msgDlc;
80004874:	3b 80 00 a0 	mov %d10,8
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004878:	06 f8       	sh %d8,-1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
8000487a:	d9 c4 1c 20 	lea %a4,[%a12]156
8000487e:	40 f5       	mov.aa %a5,%a15
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80004880:	e9 af 1a 00 	st.b [%sp]26,%d15
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80004884:	59 ab 30 00 	st.w [%sp]48,%d11
    canMsgObjConfig.frame                 = frameType;
80004888:	e9 a9 28 00 	st.b [%sp]40,%d9
    canMsgObjConfig.control.messageLen    = msgDlc;
8000488c:	e9 aa 19 00 	st.b [%sp]25,%d10
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004890:	59 a8 2c 00 	st.w [%sp]44,%d8
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004894:	6d 00 1e 0d 	call 800062d0 <IfxMultican_Can_MsgObj_init>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004898:	40 f4       	mov.aa %a4,%a15
8000489a:	40 c5       	mov.aa %a5,%a12
8000489c:	6d 00 4c 12 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
800048a0:	da 13       	mov %d15,19
800048a2:	78 04       	st.w [%sp]16,%d15
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
800048a4:	39 af 1a 00 	ld.bu %d15,[%sp]26
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
800048a8:	82 02       	mov %d2,0
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
800048aa:	16 fe       	and %d15,254
800048ac:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
800048b0:	91 40 00 2f 	movh.a %a2,61444
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
800048b4:	59 ab 30 00 	st.w [%sp]48,%d11
    canMsgObjConfig.frame                 = frameType;
800048b8:	e9 a2 28 00 	st.b [%sp]40,%d2
    canMsgObjConfig.control.messageLen    = msgDlc;
800048bc:	e9 aa 19 00 	st.b [%sp]25,%d10
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
800048c0:	59 a8 2c 00 	st.w [%sp]44,%d8
    canMsgObjConfig.control.matchingId    = TRUE;
800048c4:	e9 af 1a 00 	st.b [%sp]26,%d15
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
800048c8:	e9 a9 36 00 	st.b [%sp]54,%d9
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
800048cc:	e9 a2 37 00 	st.b [%sp]55,%d2
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
800048d0:	d9 22 80 48 	lea %a2,[%a2]-30464 <f0038900 <_SMALL_DATA4_+0x40030900>>
800048d4:	4c 20       	ld.w %d15,[%a2]0
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800048d6:	d9 c4 3c 40 	lea %a4,[%a12]316 <f0040000 <_SMALL_DATA4_+0x40038000>>
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
800048da:	b7 5f 08 f0 	insert %d15,%d15,5,0,8
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800048de:	40 f5       	mov.aa %a5,%a15
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
800048e0:	6c 20       	st.w [%a2]0,%d15
        SRC_CAN_CAN0_INT0.B.TOS=0u;
800048e2:	4c 20       	ld.w %d15,[%a2]0
800048e4:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
800048e8:	6c 20       	st.w [%a2]0,%d15
        SRC_CAN_CAN0_INT0.B.SRE=1u;
800048ea:	4c 20       	ld.w %d15,[%a2]0
800048ec:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800048f0:	6c 20       	st.w [%a2]0,%d15
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800048f2:	1d 00 ef 0c 	j 800062d0 <IfxMultican_Can_MsgObj_init>
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;

		   __debug(Driver_Can_Init, txMsgObjId_cnt);
800048f6:	82 0f       	mov %d15,0
800048f8:	91 00 00 48 	movh.a %a4,32768
800048fc:	78 00       	st.w [%sp]0,%d15
800048fe:	d9 44 26 50 	lea %a4,[%a4]358 <80000166 <_start+0x146>>
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;
80004902:	e9 e9 ee 21 	st.b [%a14]7342 <70001cae <tx_msgid_to_tx_MsgObjId>>,%d9

		   __debug(Driver_Can_Init, txMsgObjId_cnt);
80004906:	6d 00 7c 33 	call 8000affe <my_printf>

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
8000490a:	91 00 00 f7 	movh.a %a15,28672
8000490e:	d9 ff 10 60 	lea %a15,[%a15]400 <70000190 <messages>>
80004912:	48 99       	ld.w %d9,[%a15]36

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004914:	d9 af 0c 00 	lea %a15,[%sp]12 <70000009 <__DSPR0_START+0x9>>
80004918:	40 f4       	mov.aa %a4,%a15
8000491a:	40 c5       	mov.aa %a5,%a12
8000491c:	6d 00 0c 12 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
80004920:	78 04       	st.w [%sp]16,%d15
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
80004922:	82 1f       	mov %d15,1
80004924:	e9 af 28 00 	st.b [%sp]40,%d15
    canMsgObjConfig.control.messageLen    = msgDlc;
80004928:	da 08       	mov %d15,8
8000492a:	e9 af 19 00 	st.b [%sp]25,%d15
    canMsgObjConfig.control.extendedFrame = extendedFrame;
8000492e:	39 af 1a 00 	ld.bu %d15,[%sp]26
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004932:	82 f2       	mov %d2,-1
    canMsgObjConfig.control.matchingId    = TRUE;
80004934:	16 fe       	and %d15,254
80004936:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
8000493a:	06 f2       	sh %d2,-1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
8000493c:	d9 d4 10 00 	lea %a4,[%a13]16 <70000010 <__DSPR0_START+0x10>>
80004940:	40 f5       	mov.aa %a5,%a15
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80004942:	e9 af 1a 00 	st.b [%sp]26,%d15
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80004946:	59 a9 30 00 	st.w [%sp]48,%d9
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
8000494a:	59 a2 2c 00 	st.w [%sp]44,%d2
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
8000494e:	6d 00 c1 0c 	call 800062d0 <IfxMultican_Can_MsgObj_init>
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
80004952:	1b 18 09 80 	addi %d8,%d8,145
80004956:	60 82       	mov.a %a2,%d8

		   __debug(Driver_Can_Init, txMsgObjId_cnt);

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);

		   txMsgObjId_cnt++;
80004958:	82 1f       	mov %d15,1
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
8000495a:	79 22 01 00 	ld.b %d2,[%a2]1
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;
8000495e:	d9 ee ee 21 	lea %a14,[%a14]7342 <70001cae <tx_msgid_to_tx_MsgObjId>>
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
80004962:	df 02 50 7f 	jeq %d2,0,80004802 <Driver_Can_Init+0xb2>
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;
80004966:	2c e1       	st.b [%a14]1,%d15

		   __debug(Driver_Can_Init, txMsgObjId_cnt);
80004968:	91 00 00 48 	movh.a %a4,32768
8000496c:	78 00       	st.w [%sp]0,%d15
8000496e:	d9 44 26 50 	lea %a4,[%a4]358 <80000166 <_start+0x146>>
80004972:	6d 00 46 33 	call 8000affe <my_printf>

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
80004976:	91 00 00 27 	movh.a %a2,28672
8000497a:	d9 22 10 60 	lea %a2,[%a2]400 <70000190 <messages>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
8000497e:	40 f4       	mov.aa %a4,%a15
80004980:	40 c5       	mov.aa %a5,%a12
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;

		   __debug(Driver_Can_Init, txMsgObjId_cnt);

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
80004982:	19 29 14 10 	ld.w %d9,[%a2]84 <70000054 <__DSPR0_START+0x54>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004986:	6d 00 d7 11 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
8000498a:	82 12       	mov %d2,1
8000498c:	e9 a2 28 00 	st.b [%sp]40,%d2
    canMsgObjConfig.control.messageLen    = msgDlc;
80004990:	3b 80 00 20 	mov %d2,8
80004994:	e9 a2 19 00 	st.b [%sp]25,%d2
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80004998:	39 a2 1a 00 	ld.bu %d2,[%sp]26
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
8000499c:	78 04       	st.w [%sp]16,%d15
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;

		   __debug(Driver_Can_Init, txMsgObjId_cnt);

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
8000499e:	c2 1f       	add %d15,1
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
800049a0:	8f e2 0f 21 	and %d2,%d2,254
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800049a4:	d0 d4       	addsc.a %a4,%a13,%d15,3
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
800049a6:	b7 12 81 20 	insert %d2,%d2,1,1,1
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
800049aa:	82 f3       	mov %d3,-1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800049ac:	d0 44       	addsc.a %a4,%a4,%d15,3
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
800049ae:	06 f3       	sh %d3,-1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800049b0:	40 f5       	mov.aa %a5,%a15
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
800049b2:	59 a9 30 00 	st.w [%sp]48,%d9
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
800049b6:	59 a3 2c 00 	st.w [%sp]44,%d3
    canMsgObjConfig.control.matchingId    = TRUE;
800049ba:	e9 a2 1a 00 	st.b [%sp]26,%d2
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
800049be:	6d 00 89 0c 	call 800062d0 <IfxMultican_Can_MsgObj_init>
    /*TxMsgObject Enrollment*/
    //eg : Driver_Can_EnrollObject(0u, 0x200, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[0]);
	int txMsgObjId_base = 0;
	int txMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_tx_msg[i]) {
800049c2:	60 82       	mov.a %a2,%d8
800049c4:	79 22 02 00 	ld.b %d2,[%a2]2
800049c8:	df 02 25 7f 	jeq %d2,0,80004812 <Driver_Can_Init+0xc2>
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;
800049cc:	2c e2       	st.b [%a14]2,%d15

		   __debug(Driver_Can_Init, txMsgObjId_cnt);
800049ce:	91 00 00 48 	movh.a %a4,32768
800049d2:	78 00       	st.w [%sp]0,%d15
800049d4:	d9 44 26 50 	lea %a4,[%a4]358 <80000166 <_start+0x146>>
800049d8:	6d 00 13 33 	call 8000affe <my_printf>

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
800049dc:	91 00 00 27 	movh.a %a2,28672
800049e0:	d9 22 10 60 	lea %a2,[%a2]400 <70000190 <messages>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
800049e4:	40 f4       	mov.aa %a4,%a15
800049e6:	40 c5       	mov.aa %a5,%a12
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;

		   __debug(Driver_Can_Init, txMsgObjId_cnt);

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
800049e8:	19 28 04 20 	ld.w %d8,[%a2]132 <70000084 <__DSPR0_START+0x84>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
800049ec:	6d 00 a4 11 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
800049f0:	82 12       	mov %d2,1
800049f2:	e9 a2 28 00 	st.b [%sp]40,%d2
    canMsgObjConfig.control.messageLen    = msgDlc;
800049f6:	3b 80 00 20 	mov %d2,8
800049fa:	e9 a2 19 00 	st.b [%sp]25,%d2
    canMsgObjConfig.control.extendedFrame = extendedFrame;
800049fe:	39 a2 1a 00 	ld.bu %d2,[%sp]26
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80004a02:	78 04       	st.w [%sp]16,%d15
	   if(is_tx_msg[i]) {
		   tx_msgid_to_tx_MsgObjId[i] = txMsgObjId_cnt;

		   __debug(Driver_Can_Init, txMsgObjId_cnt);

		   Driver_Can_EnrollObject(txMsgObjId_base + txMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[txMsgObjId_cnt]);
80004a04:	c2 1f       	add %d15,1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004a06:	d0 d4       	addsc.a %a4,%a13,%d15,3
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80004a08:	8f e2 0f 21 	and %d2,%d2,254
80004a0c:	b7 12 81 20 	insert %d2,%d2,1,1,1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004a10:	d0 44       	addsc.a %a4,%a4,%d15,3
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004a12:	82 f3       	mov %d3,-1
80004a14:	06 f3       	sh %d3,-1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004a16:	40 f5       	mov.aa %a5,%a15
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80004a18:	59 a8 30 00 	st.w [%sp]48,%d8
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004a1c:	59 a3 2c 00 	st.w [%sp]44,%d3
    canMsgObjConfig.control.matchingId    = TRUE;
80004a20:	e9 a2 1a 00 	st.b [%sp]26,%d2
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004a24:	6d 00 56 0c 	call 800062d0 <IfxMultican_Can_MsgObj_init>
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004a28:	7b 00 00 87 	movh %d8,28672
80004a2c:	60 82       	mov.a %a2,%d8
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004a2e:	91 00 00 e7 	movh.a %a14,28672
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004a32:	79 2f e8 21 	ld.b %d15,[%a2]7336
80004a36:	df 0f f9 7e 	jeq %d15,0,80004828 <Driver_Can_Init+0xd8>
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);
80004a3a:	82 09       	mov %d9,0
80004a3c:	91 00 00 48 	movh.a %a4,32768
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004a40:	82 0f       	mov %d15,0

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);
80004a42:	d9 44 12 60 	lea %a4,[%a4]402 <80000192 <_start+0x172>>
80004a46:	74 a9       	st.w [%sp],%d9
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004a48:	e9 ef eb 21 	st.b [%a14]7339 <70001cab <rx_msgid_to_rx_MsgObjId>>,%d15

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);
80004a4c:	6d 00 d9 32 	call 8000affe <my_printf>

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004a50:	91 00 00 27 	movh.a %a2,28672
80004a54:	d9 22 10 60 	lea %a2,[%a2]400 <70000190 <messages>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004a58:	40 f4       	mov.aa %a4,%a15
80004a5a:	40 c5       	mov.aa %a5,%a12
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004a5c:	4c 29       	ld.w %d15,[%a2]36

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004a5e:	6d 00 6b 11 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80004a62:	78 0c       	st.w [%sp]48,%d15
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
80004a64:	da 08       	mov %d15,8
80004a66:	e9 af 19 00 	st.b [%sp]25,%d15
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80004a6a:	39 af 1a 00 	ld.bu %d15,[%sp]26
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80004a6e:	3b a0 00 20 	mov %d2,10
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80004a72:	16 fe       	and %d15,254
80004a74:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80004a78:	59 a2 10 00 	st.w [%sp]16,%d2
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004a7c:	82 f2       	mov %d2,-1
    canMsgObjConfig.control.matchingId    = TRUE;
80004a7e:	e9 af 1a 00 	st.b [%sp]26,%d15
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004a82:	06 f2       	sh %d2,-1
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80004a84:	82 1f       	mov %d15,1
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004a86:	91 40 00 2f 	movh.a %a2,61444
80004a8a:	d9 22 80 48 	lea %a2,[%a2]-30464 <f0038900 <_SMALL_DATA4_+0x40030900>>
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
80004a8e:	e9 a9 28 00 	st.b [%sp]40 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d9
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004a92:	59 a2 2c 00 	st.w [%sp]44 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d2
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80004a96:	e9 af 36 00 	st.b [%sp]54 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d15
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
80004a9a:	e9 a9 37 00 	st.b [%sp]55 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d9
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004a9e:	4c 20       	ld.w %d15,[%a2]0
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004aa0:	d9 c4 2c 20 	lea %a4,[%a12]172 <f0040000 <_SMALL_DATA4_+0x40038000>>
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004aa4:	b7 5f 08 f0 	insert %d15,%d15,5,0,8
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004aa8:	40 f5       	mov.aa %a5,%a15
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004aaa:	6c 20       	st.w [%a2]0,%d15
        SRC_CAN_CAN0_INT0.B.TOS=0u;
80004aac:	4c 20       	ld.w %d15,[%a2]0
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004aae:	1b 88 ca 81 	addi %d8,%d8,7336
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
80004ab2:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
80004ab6:	6c 20       	st.w [%a2]0,%d15
        SRC_CAN_CAN0_INT0.B.SRE=1u;
80004ab8:	4c 20       	ld.w %d15,[%a2]0
80004aba:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80004abe:	6c 20       	st.w [%a2]0,%d15
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004ac0:	6d 00 08 0c 	call 800062d0 <IfxMultican_Can_MsgObj_init>
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004ac4:	60 82       	mov.a %a2,%d8
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
		   rxMsgObjId_cnt++;
80004ac6:	82 1f       	mov %d15,1
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004ac8:	79 22 01 00 	ld.b %d2,[%a2]1
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004acc:	d9 ee eb 21 	lea %a14,[%a14]7339 <70001cab <rx_msgid_to_rx_MsgObjId>>
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004ad0:	df 02 b9 7e 	jeq %d2,0,80004842 <Driver_Can_Init+0xf2>
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004ad4:	2c e1       	st.b [%a14]1,%d15

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);
80004ad6:	91 00 00 48 	movh.a %a4,32768
80004ada:	78 00       	st.w [%sp]0,%d15
80004adc:	d9 44 12 60 	lea %a4,[%a4]402 <80000192 <_start+0x172>>
80004ae0:	6d 00 8f 32 	call 8000affe <my_printf>

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004ae4:	91 00 00 27 	movh.a %a2,28672
80004ae8:	d9 22 10 60 	lea %a2,[%a2]400 <70000190 <messages>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004aec:	40 f4       	mov.aa %a4,%a15
80004aee:	40 c5       	mov.aa %a5,%a12
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004af0:	19 29 14 10 	ld.w %d9,[%a2]84 <70000054 <__DSPR0_START+0x54>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004af4:	6d 00 20 11 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004af8:	1b af 00 20 	addi %d2,%d15,10
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80004afc:	59 a2 10 00 	st.w [%sp]16,%d2
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
80004b00:	3b 80 00 20 	mov %d2,8
80004b04:	e9 a2 19 00 	st.b [%sp]25,%d2
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80004b08:	39 a2 1a 00 	ld.bu %d2,[%sp]26
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004b0c:	82 f4       	mov %d4,-1
    canMsgObjConfig.control.matchingId    = TRUE;
80004b0e:	8f e2 0f 21 	and %d2,%d2,254
80004b12:	b7 12 81 20 	insert %d2,%d2,1,1,1
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
80004b16:	82 03       	mov %d3,0
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80004b18:	e9 a2 1a 00 	st.b [%sp]26,%d2
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004b1c:	06 f4       	sh %d4,-1
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80004b1e:	82 12       	mov %d2,1
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004b20:	91 40 00 2f 	movh.a %a2,61444
80004b24:	d9 22 80 48 	lea %a2,[%a2]-30464 <f0038900 <_SMALL_DATA4_+0x40030900>>
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80004b28:	59 a9 30 00 	st.w [%sp]48 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d9
    canMsgObjConfig.frame                 = frameType;
80004b2c:	e9 a3 28 00 	st.b [%sp]40 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d3
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004b30:	59 a4 2c 00 	st.w [%sp]44 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d4
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80004b34:	e9 a2 36 00 	st.b [%sp]54 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d2
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
80004b38:	e9 a3 37 00 	st.b [%sp]55 <f0038900 <_SMALL_DATA4_+0x40030900>>,%d3
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004b3c:	54 22       	ld.w %d2,[%a2]
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004b3e:	40 f5       	mov.aa %a5,%a15
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004b40:	b7 52 08 20 	insert %d2,%d2,5,0,8
80004b44:	74 22       	st.w [%a2],%d2
        SRC_CAN_CAN0_INT0.B.TOS=0u;
80004b46:	54 22       	ld.w %d2,[%a2]
80004b48:	b7 02 82 25 	insert %d2,%d2,0,11,2
80004b4c:	74 22       	st.w [%a2],%d2
        SRC_CAN_CAN0_INT0.B.SRE=1u;
80004b4e:	54 22       	ld.w %d2,[%a2]
80004b50:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80004b54:	74 22       	st.w [%a2],%d2
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004b56:	1b bf 00 20 	addi %d2,%d15,11
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004b5a:	01 d2 03 46 	addsc.a %a4,%a13,%d2,3
80004b5e:	01 42 03 46 	addsc.a %a4,%a4,%d2,3
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
		   rxMsgObjId_cnt++;
80004b62:	c2 1f       	add %d15,1
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004b64:	6d 00 b6 0b 	call 800062d0 <IfxMultican_Can_MsgObj_init>
	/*RxMsgObject Enrollment*/
	//eg : Driver_Can_EnrollObject(1u, 0x101, IfxMultican_Frame_transmit,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgTxObj[1]);
	int rxMsgObjId_base = 10;
	int rxMsgObjId_cnt = 0;
	for(int i = 0 ; i < TOTAL_MSG; i++) {
	   if(is_rx_msg[i]) {
80004b68:	60 82       	mov.a %a2,%d8
80004b6a:	79 22 02 00 	ld.b %d2,[%a2]2
80004b6e:	df 02 72 7e 	jeq %d2,0,80004852 <Driver_Can_Init+0x102>
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;
80004b72:	2c e2       	st.b [%a14]2,%d15

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);
80004b74:	91 00 00 48 	movh.a %a4,32768
80004b78:	78 00       	st.w [%sp]0,%d15
80004b7a:	d9 44 12 60 	lea %a4,[%a4]402 <80000192 <_start+0x172>>
80004b7e:	6d 00 40 32 	call 8000affe <my_printf>

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004b82:	91 00 00 27 	movh.a %a2,28672
80004b86:	d9 22 10 60 	lea %a2,[%a2]400 <70000190 <messages>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004b8a:	40 f4       	mov.aa %a4,%a15
80004b8c:	40 c5       	mov.aa %a5,%a12
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004b8e:	19 28 04 20 	ld.w %d8,[%a2]132 <70000084 <__DSPR0_START+0x84>>

static void Driver_Can_EnrollObject(int32_t msgObjId,  uint32_t msgId, uint8_t frameType, uint8_t msgDlc,  uint32_t extendedFrame, IfxMultican_Can_MsgObj* pArrObjNum)
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);
80004b92:	6d 00 d1 10 	call 80006d34 <IfxMultican_Can_MsgObj_initConfig>
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004b96:	1b af 00 20 	addi %d2,%d15,10
{
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
80004b9a:	59 a2 10 00 	st.w [%sp]16,%d2
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
80004b9e:	3b 80 00 20 	mov %d2,8
80004ba2:	e9 a2 19 00 	st.b [%sp]25,%d2
    canMsgObjConfig.control.extendedFrame = extendedFrame;
80004ba6:	39 a2 1a 00 	ld.bu %d2,[%sp]26
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004baa:	82 f4       	mov %d4,-1
    canMsgObjConfig.control.matchingId    = TRUE;
80004bac:	8f e2 0f 21 	and %d2,%d2,254
80004bb0:	b7 12 81 20 	insert %d2,%d2,1,1,1
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
80004bb4:	82 03       	mov %d3,0
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
    canMsgObjConfig.control.matchingId    = TRUE;
80004bb6:	e9 a2 1a 00 	st.b [%sp]26,%d2
    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
    canMsgObjConfig.frame                 = frameType;
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004bba:	06 f4       	sh %d4,-1
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80004bbc:	82 12       	mov %d2,1
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004bbe:	91 40 00 2f 	movh.a %a2,61444
    /* create message object config */
    IfxMultican_Can_MsgObjConfig canMsgObjConfig;
    IfxMultican_Can_MsgObj_initConfig(&canMsgObjConfig, &stEcu1Can.CanEcu1Node);

    canMsgObjConfig.msgObjId              = msgObjId;
    canMsgObjConfig.messageId             = msgId;
80004bc2:	59 a8 30 00 	st.w [%sp]48,%d8
    canMsgObjConfig.frame                 = frameType;
80004bc6:	e9 a3 28 00 	st.b [%sp]40,%d3
    canMsgObjConfig.control.messageLen    = msgDlc;
    canMsgObjConfig.control.extendedFrame = extendedFrame;
    canMsgObjConfig.acceptanceMask        = 0x7FFFFFFFUL;
80004bca:	59 a4 2c 00 	st.w [%sp]44,%d4
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
80004bce:	e9 a2 36 00 	st.b [%sp]54,%d2
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
80004bd2:	e9 a3 37 00 	st.b [%sp]55,%d3
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004bd6:	d9 22 80 48 	lea %a2,[%a2]-30464 <f0038900 <_SMALL_DATA4_+0x40030900>>
80004bda:	54 22       	ld.w %d2,[%a2]
	   if(is_rx_msg[i]) {
		   rx_msgid_to_rx_MsgObjId[i] = rxMsgObjId_cnt;

		   __debug(Driver_Can_Init, rxMsgObjId_cnt);

		   Driver_Can_EnrollObject(rxMsgObjId_base + rxMsgObjId_cnt, messages[i].ID, IfxMultican_Frame_receive,  IfxMultican_DataLengthCode_8, FALSE, &stEcu1Can.CanEcu1MsgRxObj[rxMsgObjId_cnt]);
80004bdc:	1b bf 00 f0 	addi %d15,%d15,11
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004be0:	b7 52 08 20 	insert %d2,%d2,5,0,8
        SRC_CAN_CAN0_INT0.B.TOS=0u;
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004be4:	d0 d4       	addsc.a %a4,%a13,%d15,3
    canMsgObjConfig.control.matchingId    = TRUE;
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
80004be6:	74 22       	st.w [%a2],%d2
        SRC_CAN_CAN0_INT0.B.TOS=0u;
80004be8:	54 22       	ld.w %d2,[%a2]
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004bea:	d0 44       	addsc.a %a4,%a4,%d15,3
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
80004bec:	b7 02 82 25 	insert %d2,%d2,0,11,2
        SRC_CAN_CAN0_INT0.B.SRE=1u;
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004bf0:	40 f5       	mov.aa %a5,%a15
    if(frameType==IfxMultican_Frame_receive)
    {
        canMsgObjConfig.rxInterrupt.enabled=TRUE;
        canMsgObjConfig.rxInterrupt.srcId=0u; //source id 0
        SRC_CAN_CAN0_INT0.B.SRPN=5u;
        SRC_CAN_CAN0_INT0.B.TOS=0u;
80004bf2:	74 22       	st.w [%a2],%d2
        SRC_CAN_CAN0_INT0.B.SRE=1u;
80004bf4:	54 22       	ld.w %d2,[%a2]
80004bf6:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80004bfa:	74 22       	st.w [%a2],%d2
    }
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
80004bfc:	6d 00 6a 0b 	call 800062d0 <IfxMultican_Can_MsgObj_init>
80004c00:	1d ff 2b fe 	j 80004856 <Driver_Can_Init+0x106>

80004c04 <IM1_act_task>:
#elif __ECU__ == 2

/* each imq number config */

void IM1_act_task() {
	ActivateTask(TASK1);
80004c04:	82 44       	mov %d4,4
80004c06:	1d 00 e7 3f 	j 8000cbd4 <ActivateTask>

80004c0a <IM2_act_task>:
}

void IM2_act_task() {
	ActivateTask(TASK2);
80004c0a:	82 54       	mov %d4,5
80004c0c:	1d 00 e4 3f 	j 8000cbd4 <ActivateTask>

80004c10 <swc_db_init>:
 */


void swc_db_init(void) {
	// SIG_to_IM initialization
	for(int i = 0; i < TOTAL_SIG; i++) SIG_to_IM[i] = -1; // initialization
80004c10:	82 ff       	mov %d15,-1
80004c12:	91 00 00 27 	movh.a %a2,28672
80004c16:	d9 2f e8 e1 	lea %a15,[%a2]8104 <70001fa8 <SIG_to_IM>>
80004c1a:	59 2f e8 e1 	st.w [%a2]8104 <70001fa8 <SIG_to_IM>>,%d15
	for(int i = 0; i < IM_TYPE_CNT; i++) {
		SIG_to_IM[IM_to_SIG_M[i]] = i;
80004c1e:	91 00 00 27 	movh.a %a2,28672
 */


void swc_db_init(void) {
	// SIG_to_IM initialization
	for(int i = 0; i < TOTAL_SIG; i++) SIG_to_IM[i] = -1; // initialization
80004c22:	68 1f       	st.w [%a15]4,%d15
80004c24:	68 2f       	st.w [%a15]8,%d15
80004c26:	68 3f       	st.w [%a15]12,%d15
80004c28:	68 4f       	st.w [%a15]16,%d15
	for(int i = 0; i < IM_TYPE_CNT; i++) {
		SIG_to_IM[IM_to_SIG_M[i]] = i;
80004c2a:	19 2f 10 d0 	ld.w %d15,[%a2]848 <70000350 <IM_to_SIG_M>>
80004c2e:	d9 23 10 d0 	lea %a3,[%a2]848 <70000350 <IM_to_SIG_M>>
80004c32:	90 f2       	addsc.a %a2,%a15,%d15,2
80004c34:	82 0f       	mov %d15,0
80004c36:	6c 20       	st.w [%a2]0,%d15
80004c38:	4c 31       	ld.w %d15,[%a3]4
80004c3a:	90 ff       	addsc.a %a15,%a15,%d15,2
80004c3c:	82 1f       	mov %d15,1
80004c3e:	68 0f       	st.w [%a15]0,%d15
80004c40:	00 90       	ret 

80004c42 <im_to_sig>:
	}
}


int im_to_sig(int im_id) {
	return IM_to_SIG_M[im_id];
80004c42:	91 00 00 f7 	movh.a %a15,28672
80004c46:	d9 ff 10 d0 	lea %a15,[%a15]848 <70000350 <IM_to_SIG_M>>
80004c4a:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
}
80004c4e:	48 02       	ld.w %d2,[%a15]0
80004c50:	00 90       	ret 

80004c52 <sig_to_im>:

int sig_to_im(int sig_id) {
	return SIG_to_IM[sig_id];
80004c52:	91 00 00 f7 	movh.a %a15,28672
80004c56:	d9 ff e8 e1 	lea %a15,[%a15]8104 <70001fa8 <SIG_to_IM>>
80004c5a:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
}
80004c5e:	48 02       	ld.w %d2,[%a15]0
80004c60:	00 90       	ret 

80004c62 <writeIM_from_swc>:

// IM     &im_IsDark .
//receive(IsDark, &data); -> writeIM(&im_IsDark, &data);
int writeIM_from_swc(IM* target_IM, void* data_p) {

	target_IM->inner_pass_flag = 1;
80004c62:	82 1f       	mov %d15,1
80004c64:	2c 48       	st.b [%a4]8,%d15
	target_IM->outer_pass_flag = 1;
80004c66:	2c 49       	st.b [%a4]9,%d15

	switch(target_IM->var_size) {
80004c68:	4c 40       	ld.w %d15,[%a4]0
80004c6a:	c2 ff       	add %d15,-1
80004c6c:	ff 8f 1b 80 	jge.u %d15,8,80004ca2 <writeIM_from_swc+0x40>
80004c70:	91 00 00 f8 	movh.a %a15,32768
80004c74:	d9 ff fc 14 	lea %a15,[%a15]19580 <80004c7c <writeIM_from_swc+0x1a>>
80004c78:	90 ff       	addsc.a %a15,%a15,%d15,2
80004c7a:	dc 0f       	ji %a15
80004c7c:	1d 00 2d 00 	j 80004cd6 <writeIM_from_swc+0x74>
80004c80:	1d 00 0e 00 	j 80004c9c <writeIM_from_swc+0x3a>
80004c84:	1d 00 0f 00 	j 80004ca2 <writeIM_from_swc+0x40>
80004c88:	1d 00 1e 00 	j 80004cc4 <writeIM_from_swc+0x62>
80004c8c:	1d 00 0b 00 	j 80004ca2 <writeIM_from_swc+0x40>
80004c90:	1d 00 09 00 	j 80004ca2 <writeIM_from_swc+0x40>
80004c94:	1d 00 07 00 	j 80004ca2 <writeIM_from_swc+0x40>
80004c98:	1d 00 0b 00 	j 80004cae <writeIM_from_swc+0x4c>
	case 1: {
		*((char*)(target_IM->data_p)) = *((char*)data_p);
		break;
	}
	case 2: {
		*((short*)(target_IM->data_p)) = *((short*)data_p);
80004c9c:	cc 43       	ld.a %a15,[%a4]12
80004c9e:	8c 50       	ld.h %d15,[%a5]0
80004ca0:	a8 0f       	st.h [%a15]0,%d15
		break;
	}
	}


	ActivateTask(outer_COM);
80004ca2:	3b a0 00 40 	mov %d4,10
80004ca6:	6d 00 97 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004caa:	82 02       	mov %d2,0
80004cac:	00 90       	ret 
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
		break;
	}
	case 8: {
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
80004cae:	cc 43       	ld.a %a15,[%a4]12
80004cb0:	09 52 40 09 	ld.d %e2,[%a5]
		break;
	}
	}


	ActivateTask(outer_COM);
80004cb4:	3b a0 00 40 	mov %d4,10
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
		break;
	}
	case 8: {
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
80004cb8:	89 f2 40 09 	st.d [%a15],%e2
		break;
	}
	}


	ActivateTask(outer_COM);
80004cbc:	6d 00 8c 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004cc0:	82 02       	mov %d2,0
80004cc2:	00 90       	ret 
	case 2: {
		*((short*)(target_IM->data_p)) = *((short*)data_p);
		break;
	}
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
80004cc4:	cc 43       	ld.a %a15,[%a4]12
80004cc6:	4c 50       	ld.w %d15,[%a5]0
		break;
	}
	}


	ActivateTask(outer_COM);
80004cc8:	3b a0 00 40 	mov %d4,10
	case 2: {
		*((short*)(target_IM->data_p)) = *((short*)data_p);
		break;
	}
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
80004ccc:	68 0f       	st.w [%a15]0,%d15
		break;
	}
	}


	ActivateTask(outer_COM);
80004cce:	6d 00 83 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004cd2:	82 02       	mov %d2,0
80004cd4:	00 90       	ret 
	target_IM->outer_pass_flag = 1;

	switch(target_IM->var_size) {

	case 1: {
		*((char*)(target_IM->data_p)) = *((char*)data_p);
80004cd6:	cc 43       	ld.a %a15,[%a4]12
80004cd8:	79 5f 00 00 	ld.b %d15,[%a5]0
		break;
	}
	}


	ActivateTask(outer_COM);
80004cdc:	3b a0 00 40 	mov %d4,10
	target_IM->outer_pass_flag = 1;

	switch(target_IM->var_size) {

	case 1: {
		*((char*)(target_IM->data_p)) = *((char*)data_p);
80004ce0:	28 0f       	st.b [%a15]0,%d15
		break;
	}
	}


	ActivateTask(outer_COM);
80004ce2:	6d 00 79 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004ce6:	82 02       	mov %d2,0
80004ce8:	00 90       	ret 

80004cea <writeIM_from_sig>:

int writeIM_from_sig(IM* target_IM, void* data_p) {

	target_IM->inner_pass_flag = 1;
80004cea:	82 1f       	mov %d15,1
80004cec:	2c 48       	st.b [%a4]8,%d15

	switch(target_IM->var_size) {
80004cee:	4c 40       	ld.w %d15,[%a4]0
80004cf0:	c2 ff       	add %d15,-1
80004cf2:	ff 8f 1c 80 	jge.u %d15,8,80004d2a <writeIM_from_sig+0x40>
80004cf6:	91 00 00 f8 	movh.a %a15,32768
80004cfa:	d9 ff c4 44 	lea %a15,[%a15]19716 <80004d04 <writeIM_from_sig+0x1a>>
80004cfe:	90 ff       	addsc.a %a15,%a15,%d15,2
80004d00:	dc 0f       	ji %a15
80004d02:	00 00       	nop 
80004d04:	1d 00 2a 00 	j 80004d58 <writeIM_from_sig+0x6e>
80004d08:	1d 00 0e 00 	j 80004d24 <writeIM_from_sig+0x3a>
80004d0c:	1d 00 0f 00 	j 80004d2a <writeIM_from_sig+0x40>
80004d10:	1d 00 1c 00 	j 80004d48 <writeIM_from_sig+0x5e>
80004d14:	1d 00 0b 00 	j 80004d2a <writeIM_from_sig+0x40>
80004d18:	1d 00 09 00 	j 80004d2a <writeIM_from_sig+0x40>
80004d1c:	1d 00 07 00 	j 80004d2a <writeIM_from_sig+0x40>
80004d20:	1d 00 0a 00 	j 80004d34 <writeIM_from_sig+0x4a>
	case 1: {
		*((char*)(target_IM->data_p)) = *((char*)data_p);
		break;
	}
	case 2: {
		*((short*)(target_IM->data_p)) = *((short*)data_p);
80004d24:	cc 43       	ld.a %a15,[%a4]12
80004d26:	8c 50       	ld.h %d15,[%a5]0
80004d28:	a8 0f       	st.h [%a15]0,%d15
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
		break;
	}
	}

	ActivateTask(inner_COM);
80004d2a:	82 34       	mov %d4,3
80004d2c:	6d 00 54 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004d30:	82 02       	mov %d2,0
80004d32:	00 90       	ret 
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
		break;
	}
	case 8: {
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
80004d34:	cc 43       	ld.a %a15,[%a4]12
80004d36:	09 52 40 09 	ld.d %e2,[%a5]
		break;
	}
	}

	ActivateTask(inner_COM);
80004d3a:	82 34       	mov %d4,3
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
		break;
	}
	case 8: {
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
80004d3c:	89 f2 40 09 	st.d [%a15],%e2
		break;
	}
	}

	ActivateTask(inner_COM);
80004d40:	6d 00 4a 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004d44:	82 02       	mov %d2,0
80004d46:	00 90       	ret 
	case 2: {
		*((short*)(target_IM->data_p)) = *((short*)data_p);
		break;
	}
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
80004d48:	cc 43       	ld.a %a15,[%a4]12
80004d4a:	4c 50       	ld.w %d15,[%a5]0
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
		break;
	}
	}

	ActivateTask(inner_COM);
80004d4c:	82 34       	mov %d4,3
	case 2: {
		*((short*)(target_IM->data_p)) = *((short*)data_p);
		break;
	}
	case 4: {
		*((int*)(target_IM->data_p)) = *((int*)data_p);
80004d4e:	68 0f       	st.w [%a15]0,%d15
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
		break;
	}
	}

	ActivateTask(inner_COM);
80004d50:	6d 00 42 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004d54:	82 02       	mov %d2,0
80004d56:	00 90       	ret 
	target_IM->inner_pass_flag = 1;

	switch(target_IM->var_size) {

	case 1: {
		*((char*)(target_IM->data_p)) = *((char*)data_p);
80004d58:	cc 43       	ld.a %a15,[%a4]12
80004d5a:	79 5f 00 00 	ld.b %d15,[%a5]0
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
		break;
	}
	}

	ActivateTask(inner_COM);
80004d5e:	82 34       	mov %d4,3
	target_IM->inner_pass_flag = 1;

	switch(target_IM->var_size) {

	case 1: {
		*((char*)(target_IM->data_p)) = *((char*)data_p);
80004d60:	28 0f       	st.b [%a15]0,%d15
		*((uint64*)(target_IM->data_p)) = *((uint64*)data_p);
		break;
	}
	}

	ActivateTask(inner_COM);
80004d62:	6d 00 39 3f 	call 8000cbd4 <ActivateTask>

	return 0;
}
80004d66:	82 02       	mov %d2,0
80004d68:	00 90       	ret 

80004d6a <readIM>:


//char receive_data_p
//receive(IsDark, &receive_data_p); -> readIMQ(im_IsDark, receive_data_p);
int readIM(IM target_IM, void* data_p) {
	switch(target_IM.var_size) {
80004d6a:	4c 40       	ld.w %d15,[%a4]0
}


//char receive_data_p
//receive(IsDark, &receive_data_p); -> readIMQ(im_IsDark, receive_data_p);
int readIM(IM target_IM, void* data_p) {
80004d6c:	cc 43       	ld.a %a15,[%a4]12
	switch(target_IM.var_size) {
80004d6e:	c2 ff       	add %d15,-1
80004d70:	ff 8f 1a 80 	jge.u %d15,8,80004da4 <readIM+0x3a>
80004d74:	91 00 00 28 	movh.a %a2,32768
80004d78:	d9 22 c0 64 	lea %a2,[%a2]19840 <80004d80 <readIM+0x16>>
80004d7c:	90 22       	addsc.a %a2,%a2,%d15,2
80004d7e:	dc 02       	ji %a2
80004d80:	1d 00 1e 00 	j 80004dbc <readIM+0x52>
80004d84:	1d 00 0e 00 	j 80004da0 <readIM+0x36>
80004d88:	1d 00 0e 00 	j 80004da4 <readIM+0x3a>
80004d8c:	1d 00 14 00 	j 80004db4 <readIM+0x4a>
80004d90:	1d 00 0a 00 	j 80004da4 <readIM+0x3a>
80004d94:	1d 00 08 00 	j 80004da4 <readIM+0x3a>
80004d98:	1d 00 06 00 	j 80004da4 <readIM+0x3a>
80004d9c:	1d 00 06 00 	j 80004da8 <readIM+0x3e>
	case 1: {
		*((char *)data_p) = *((char*)(target_IM.data_p)) ;
		break;
	}
	case 2: {
		*((short *)data_p) = *((short*)(target_IM.data_p)) ;
80004da0:	8c f0       	ld.h %d15,[%a15]0
80004da2:	ac 50       	st.h [%a5]0,%d15
		*((uint64 *)data_p) = *((uint64*)(target_IM.data_p)) ;
		break;
	}

	return 0;
}
80004da4:	82 02       	mov %d2,0
80004da6:	00 90       	ret 
	case 4: {
		*((int *)data_p) = *((int*)(target_IM.data_p)) ;
		break;
	}
	case 8:
		*((uint64 *)data_p) = *((uint64*)(target_IM.data_p)) ;
80004da8:	09 f2 40 09 	ld.d %e2,[%a15]
80004dac:	89 52 40 09 	st.d [%a5],%e2
		break;
	}

	return 0;
}
80004db0:	82 02       	mov %d2,0
80004db2:	00 90       	ret 
	case 2: {
		*((short *)data_p) = *((short*)(target_IM.data_p)) ;
		break;
	}
	case 4: {
		*((int *)data_p) = *((int*)(target_IM.data_p)) ;
80004db4:	4c f0       	ld.w %d15,[%a15]0
		*((uint64 *)data_p) = *((uint64*)(target_IM.data_p)) ;
		break;
	}

	return 0;
}
80004db6:	82 02       	mov %d2,0
	case 2: {
		*((short *)data_p) = *((short*)(target_IM.data_p)) ;
		break;
	}
	case 4: {
		*((int *)data_p) = *((int*)(target_IM.data_p)) ;
80004db8:	6c 50       	st.w [%a5]0,%d15
		*((uint64 *)data_p) = *((uint64*)(target_IM.data_p)) ;
		break;
	}

	return 0;
}
80004dba:	00 90       	ret 
//receive(IsDark, &receive_data_p); -> readIMQ(im_IsDark, receive_data_p);
int readIM(IM target_IM, void* data_p) {
	switch(target_IM.var_size) {

	case 1: {
		*((char *)data_p) = *((char*)(target_IM.data_p)) ;
80004dbc:	79 ff 00 00 	ld.b %d15,[%a15]0
		*((uint64 *)data_p) = *((uint64*)(target_IM.data_p)) ;
		break;
	}

	return 0;
}
80004dc0:	82 02       	mov %d2,0
//receive(IsDark, &receive_data_p); -> readIMQ(im_IsDark, receive_data_p);
int readIM(IM target_IM, void* data_p) {
	switch(target_IM.var_size) {

	case 1: {
		*((char *)data_p) = *((char*)(target_IM.data_p)) ;
80004dc2:	2c 50       	st.b [%a5]0,%d15
		*((uint64 *)data_p) = *((uint64*)(target_IM.data_p)) ;
		break;
	}

	return 0;
}
80004dc4:	00 90       	ret 
	...

80004dc8 <IfxMultican_MsgObj_doReadLongFrame>:

IFX_STATIC void IfxMultican_MsgObj_doReadLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj       = IfxMultican_MsgObj_getPointer(mcan, msgObjId);

    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004dc8:	8f 54 00 30 	sh %d3,%d4,5
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
80004dcc:	1b 04 08 40 	addi %d4,%d4,128
80004dd0:	01 43 00 f6 	addsc.a %a15,%a4,%d3,0
80004dd4:	8f 54 00 60 	sh %d6,%d4,5
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80004dd8:	da 08       	mov %d15,8
80004dda:	01 46 00 36 	addsc.a %a3,%a4,%d6,0

IFX_STATIC void IfxMultican_MsgObj_doReadLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj       = IfxMultican_MsgObj_getPointer(mcan, msgObjId);

    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004dde:	19 f5 04 01 	ld.w %d5,[%a15]4100
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
80004de2:	19 f2 04 01 	ld.w %d2,[%a15]4100
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80004de6:	59 ff 1c 01 	st.w [%a15]4124,%d15
80004dea:	4c 30       	ld.w %d15,[%a3]0

IFX_STATIC void IfxMultican_MsgObj_doReadLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj       = IfxMultican_MsgObj_getPointer(mcan, msgObjId);

    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
80004dec:	8f f5 0f 51 	and %d5,%d5,255
80004df0:	37 0f 64 fc 	extr.u %d15,%d15,24,4
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
80004df4:	37 02 68 24 	extr.u %d2,%d2,8,8

    /* copy the length code from hardware */
    IfxMultican_DataLengthCode lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);

    /* read the data from the data registers */
    if (lengthCode > IfxMultican_DataLengthCode_0) /* no.of bytes 0 to 8 */
80004df8:	6e 6c       	jz %d15,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwObj->DATAL.U;
80004dfa:	19 f6 10 01 	ld.w %d6,[%a15]4112
80004dfe:	74 66       	st.w [%a6],%d6
        *data++ = hwObj->DATAH.U;
80004e00:	19 f6 14 01 	ld.w %d6,[%a15]4116
80004e04:	59 66 04 00 	st.w [%a6]4,%d6
    }

    /* read from bottom message object extended data registers */
    if (lengthCode > IfxMultican_DataLengthCode_8)
80004e08:	bf 9f 64 80 	jlt.u %d15,9,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA0.U;
80004e0c:	1b 05 08 60 	addi %d6,%d5,128
80004e10:	8f 56 00 70 	sh %d7,%d6,5
80004e14:	01 47 00 f6 	addsc.a %a15,%a4,%d7,0
80004e18:	48 06       	ld.w %d6,[%a15]0
80004e1a:	59 66 08 00 	st.w [%a6]8,%d6
    }

    if (lengthCode > IfxMultican_DataLengthCode_12)
80004e1e:	8b 9f 00 62 	eq %d6,%d15,9
80004e22:	df 06 57 80 	jne %d6,0,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA1.U;
80004e26:	8f 55 00 60 	sh %d6,%d5,5
80004e2a:	01 46 00 26 	addsc.a %a2,%a4,%d6,0
80004e2e:	19 25 04 01 	ld.w %d5,[%a2]4100
80004e32:	59 65 0c 00 	st.w [%a6]12,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_16)
80004e36:	8b af 00 52 	eq %d5,%d15,10
80004e3a:	df 05 4b 80 	jne %d5,0,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA2.U;
80004e3e:	19 25 08 01 	ld.w %d5,[%a2]4104
80004e42:	59 65 10 00 	st.w [%a6]16,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_20)
80004e46:	8b bf 00 52 	eq %d5,%d15,11
80004e4a:	df 05 43 80 	jne %d5,0,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA3.U;
80004e4e:	19 25 0c 01 	ld.w %d5,[%a2]4108
80004e52:	59 65 14 00 	st.w [%a6]20,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_24)
80004e56:	8b cf 00 52 	eq %d5,%d15,12
80004e5a:	df 05 3b 80 	jne %d5,0,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA4.U;
80004e5e:	19 25 10 01 	ld.w %d5,[%a2]4112
80004e62:	59 65 18 00 	st.w [%a6]24,%d5
        *data++ = hwBotObj->EDATA5.U;
80004e66:	19 25 14 01 	ld.w %d5,[%a2]4116
80004e6a:	59 65 1c 00 	st.w [%a6]28,%d5
    }

    if (lengthCode > IfxMultican_DataLengthCode_32)
80004e6e:	8b df 00 52 	eq %d5,%d15,13
80004e72:	df 05 2f 80 	jne %d5,0,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwBotObj->EDATA6.U;
80004e76:	19 25 18 01 	ld.w %d5,[%a2]4120
80004e7a:	59 65 20 00 	st.w [%a6]32,%d5
        /* read from top message object extended data registers */
        *data++ = hwTopObj->EDATA0.U;
80004e7e:	1b 02 08 50 	addi %d5,%d2,128
80004e82:	8f 55 00 70 	sh %d7,%d5,5
80004e86:	01 47 00 f6 	addsc.a %a15,%a4,%d7,0
80004e8a:	48 05       	ld.w %d5,[%a15]0
80004e8c:	59 65 24 00 	st.w [%a6]36,%d5
        *data++ = hwTopObj->EDATA1.U;
80004e90:	8f 52 00 50 	sh %d5,%d2,5
80004e94:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
80004e98:	19 f2 04 01 	ld.w %d2,[%a15]4100
80004e9c:	59 62 28 00 	st.w [%a6]40,%d2
        *data++ = hwTopObj->EDATA2.U;
80004ea0:	19 f2 08 01 	ld.w %d2,[%a15]4104
80004ea4:	59 62 2c 00 	st.w [%a6]44,%d2
    }

    if (lengthCode > IfxMultican_DataLengthCode_48)
80004ea8:	8b ff 20 22 	ne %d2,%d15,15
80004eac:	df 02 12 80 	jne %d2,0,80004ed0 <IfxMultican_MsgObj_doReadLongFrame+0x108>
    {
        *data++ = hwTopObj->EDATA3.U;
80004eb0:	19 f2 0c 01 	ld.w %d2,[%a15]4108
80004eb4:	59 62 30 00 	st.w [%a6]48,%d2
        *data++ = hwTopObj->EDATA4.U;
80004eb8:	19 f2 10 01 	ld.w %d2,[%a15]4112
80004ebc:	59 62 34 00 	st.w [%a6]52,%d2
        *data++ = hwTopObj->EDATA5.U;
80004ec0:	19 f2 14 01 	ld.w %d2,[%a15]4116
80004ec4:	59 62 38 00 	st.w [%a6]56,%d2
        *data   = hwTopObj->EDATA6.U;
80004ec8:	19 f2 18 01 	ld.w %d2,[%a15]4120
80004ecc:	59 62 3c 00 	st.w [%a6]60,%d2
    }

    msg->fastBitRate = hwObj->FCR.B.BRS;
80004ed0:	8f 54 00 60 	sh %d6,%d4,5
80004ed4:	01 46 00 f6 	addsc.a %a15,%a4,%d6,0


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
80004ed8:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80004edc:	48 02       	ld.w %d2,[%a15]0

    msg->lengthCode  = lengthCode;
80004ede:	2c 54       	st.b [%a5]4,%d15
        *data++ = hwTopObj->EDATA4.U;
        *data++ = hwTopObj->EDATA5.U;
        *data   = hwTopObj->EDATA6.U;
    }

    msg->fastBitRate = hwObj->FCR.B.BRS;
80004ee0:	37 02 e1 22 	extr.u %d2,%d2,5,1
80004ee4:	e9 52 10 00 	st.b [%a5]16,%d2
80004ee8:	19 4f 18 01 	ld.w %d15,[%a4]4120
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
80004eec:	37 0f 7d 20 	extr.u %d2,%d15,0,29
80004ef0:	87 ff dd fe 	nor.t %d15,%d15,29,%d15,29
80004ef4:	ab 2f a1 ff 	seln %d15,%d15,%d15,18
80004ef8:	8b 0f 00 71 	rsub %d7,%d15,0
80004efc:	0f 72 20 70 	shas %d7,%d2,%d7

    msg->lengthCode  = lengthCode;

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
80004f00:	74 57       	st.w [%a5],%d7
80004f02:	00 90       	ret 

80004f04 <IfxMultican_MsgObj_cancelSend>:
{
    boolean         result = FALSE;
    Ifx_CAN_MO_CTR  ctr;
    Ifx_CAN_MO_STAT stat;

    stat.U = hwObj->STAT.U;
80004f04:	4c 47       	ld.w %d15,[%a4]28

    if ((stat.B.TXRQ != 0) && (stat.B.NEWDAT != 0))
80004f06:	3b 80 10 30 	mov %d3,264
80004f0a:	8f 8f 10 f1 	and %d15,%d15,264
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxMultican_MsgObj_cancelSend(Ifx_CAN_MO *hwObj)
{
    boolean         result = FALSE;
80004f0e:	82 02       	mov %d2,0
    Ifx_CAN_MO_CTR  ctr;
    Ifx_CAN_MO_STAT stat;

    stat.U = hwObj->STAT.U;

    if ((stat.B.TXRQ != 0) && (stat.B.NEWDAT != 0))
80004f10:	3e 32       	jeq %d15,%d3,80004f14 <IfxMultican_MsgObj_cancelSend+0x10>
        hwObj->CTR.U   = ctr.U;
        result         = TRUE;
    }

    return result;
}
80004f12:	00 90       	ret 
    stat.U = hwObj->STAT.U;

    if ((stat.B.TXRQ != 0) && (stat.B.NEWDAT != 0))
    {
        ctr.U          = 0;
        ctr.B.RESRTSEL = 1; /* take out from transmission */
80004f14:	da 40       	mov %d15,64
        hwObj->CTR.U   = ctr.U;
80004f16:	6c 47       	st.w [%a4]28,%d15
        result         = TRUE;
80004f18:	82 12       	mov %d2,1
    }

    return result;
}
80004f1a:	00 90       	ret 

80004f1c <IfxMultican_MsgObj_clearStatusFlag>:

void IfxMultican_MsgObj_clearStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;
80004f1c:	82 1f       	mov %d15,1
80004f1e:	0f 4f 00 40 	sh %d4,%d15,%d4

    hwObj->CTR.U = ctr.U;
80004f22:	59 44 1c 00 	st.w [%a4]28,%d4
80004f26:	00 90       	ret 

80004f28 <IfxMultican_MsgObj_deinit>:

void IfxMultican_setListCommand(Ifx_CAN *mcan, uint32 cmd, uint32 arg2, uint32 arg1)
{
    Ifx_CAN_PANCTR panctr;

    panctr.B.PANAR1 = arg1;
80004f28:	82 0f       	mov %d15,0
80004f2a:	37 4f 08 f8 	insert %d15,%d15,%d4,16,8
    panctr.B.PANAR2 = arg2;
80004f2e:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
    panctr.B.PANCMD = cmd;
80004f32:	b7 2f 08 f0 	insert %d15,%d15,2,0,8

    /** - write to CAN_PANCTR */
    mcan->PANCTR.U = panctr.U;
80004f36:	59 4f 04 70 	st.w [%a4]452,%d15
}


IFX_INLINE void IfxMultican_waitListReady(Ifx_CAN *mcan)
{
    while (mcan->PANCTR.B.BUSY != 0)
80004f3a:	19 4f 04 70 	ld.w %d15,[%a4]452
80004f3e:	37 0f 61 f4 	extr.u %d15,%d15,8,1
80004f42:	ee fc       	jnz %d15,80004f3a <IfxMultican_MsgObj_deinit+0x12>
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
80004f44:	8f 54 00 20 	sh %d2,%d4,5
80004f48:	01 42 00 f6 	addsc.a %a15,%a4,%d2,0

    hwObj->FCR.U   = 0x00000000UL;
80004f4c:	1b 04 08 40 	addi %d4,%d4,128
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
80004f50:	bb f0 ff 2f 	mov.u %d2,65535
80004f54:	59 f2 1c 01 	st.w [%a15]4124,%d2

    hwObj->FCR.U   = 0x00000000UL;
80004f58:	8f 54 00 20 	sh %d2,%d4,5
80004f5c:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
    hwObj->FGPR.U  = 0x00000000UL;
    hwObj->IPR.U   = 0x00000000UL;
    hwObj->AMR.U   = 0x3FFFFFFFUL;
80004f60:	82 f2       	mov %d2,-1
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */

    hwObj->FCR.U   = 0x00000000UL;
80004f62:	6c 40       	st.w [%a4]0,%d15
    hwObj->FGPR.U  = 0x00000000UL;
80004f64:	59 ff 04 01 	st.w [%a15]4100,%d15
    hwObj->IPR.U   = 0x00000000UL;
80004f68:	59 ff 08 01 	st.w [%a15]4104,%d15
    hwObj->AMR.U   = 0x3FFFFFFFUL;
80004f6c:	06 e2       	sh %d2,-2
80004f6e:	59 f2 0c 01 	st.w [%a15]4108,%d2
    hwObj->DATAL.U = 0x00000000UL;
80004f72:	59 ff 10 01 	st.w [%a15]4112,%d15
    hwObj->DATAH.U = 0x00000000UL;
80004f76:	59 ff 14 01 	st.w [%a15]4116,%d15
    hwObj->AR.U    = 0x00000000UL;
80004f7a:	59 ff 18 01 	st.w [%a15]4120,%d15
80004f7e:	00 90       	ret 

80004f80 <IfxMultican_MsgObj_getPendingId>:
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
}


IfxMultican_MsgObjId IfxMultican_MsgObj_getPendingId(Ifx_CAN *mcan, IfxMultican_MsgObjGroup msgObjGroup)
{
80004f80:	01 44 02 46 	addsc.a %a4,%a4,%d4,2
    uint32               index    = mcan->MSID[msgObjGroup].U;
    IfxMultican_MsgObjId msgObjId = -1;
80004f84:	82 f2       	mov %d2,-1
}


IfxMultican_MsgObjId IfxMultican_MsgObj_getPendingId(Ifx_CAN *mcan, IfxMultican_MsgObjGroup msgObjGroup)
{
    uint32               index    = mcan->MSID[msgObjGroup].U;
80004f86:	19 4f 00 60 	ld.w %d15,[%a4]384
    IfxMultican_MsgObjId msgObjId = -1;

    if (index != 0x20U)
80004f8a:	8b 0f 02 32 	eq %d3,%d15,32
80004f8e:	f6 39       	jnz %d3,80004fa0 <IfxMultican_MsgObj_getPendingId+0x20>
    {
        mcan->MSPND[msgObjGroup].U = ~(1UL << index);
80004f90:	82 12       	mov %d2,1
80004f92:	0f f2 00 20 	sh %d2,%d2,%d15
80004f96:	46 02       	not %d2
80004f98:	59 42 00 50 	st.w [%a4]320,%d2
        msgObjId                   = index + (msgObjGroup << 5);
80004f9c:	13 04 22 2f 	madd %d2,%d15,%d4,32
    }

    return msgObjId;
}
80004fa0:	00 90       	ret 

80004fa2 <IfxMultican_MsgObj_getStatus>:

IfxMultican_MsgObjStat IfxMultican_MsgObj_getStatus(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat status;

    status.U = hwObj->STAT.U;
80004fa2:	19 42 1c 00 	ld.w %d2,[%a4]28

    return status;
}
80004fa6:	00 90       	ret 

80004fa8 <IfxMultican_MsgObj_getStatusFlag>:

boolean IfxMultican_MsgObj_getStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
    uint32 shift = (1U << flag);

    return (hwObj->STAT.U & shift) ? TRUE : FALSE;
80004fa8:	19 42 1c 00 	ld.w %d2,[%a4]28
}
80004fac:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80004fb0:	00 90       	ret 

80004fb2 <IfxMultican_MsgObj_readLongFrame>:
IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
80004fb2:	1b 04 08 20 	addi %d2,%d4,128
80004fb6:	8f 52 00 30 	sh %d3,%d2,5
80004fba:	01 43 00 26 	addsc.a %a2,%a4,%d3,0
    return (hwObj->STAT.U & shift) ? TRUE : FALSE;
}


IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
80004fbe:	40 4f       	mov.aa %a15,%a4
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
80004fc0:	54 22       	ld.w %d2,[%a2]
    return (hwObj->STAT.U & shift) ? TRUE : FALSE;
}


IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
80004fc2:	02 4f       	mov %d15,%d4
80004fc4:	40 53       	mov.aa %a3,%a5
80004fc6:	40 67       	mov.aa %a7,%a6
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
80004fc8:	6f 62 04 80 	jnz.t %d2,6,80004fd0 <IfxMultican_MsgObj_readLongFrame+0x1e>


IfxMultican_Status IfxMultican_MsgObj_readLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status status    = IfxMultican_Status_ok;
80004fcc:	82 02       	mov %d2,0
80004fce:	00 90       	ret 
    boolean            longFrame = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;

    if (longFrame)
    {
        /* if new data available in the message object */
        if (hwObj->STAT.B.NEWDAT != 0)
80004fd0:	8f 54 00 80 	sh %d8,%d4,5
80004fd4:	01 48 00 c6 	addsc.a %a12,%a4,%d8,0
80004fd8:	19 c2 1c 01 	ld.w %d2,[%a12]4124
80004fdc:	6f 32 05 80 	jnz.t %d2,3,80004fe6 <IfxMultican_MsgObj_readLongFrame+0x34>
                status |= IfxMultican_Status_messageLost;
            }
        }
        else
        {
            status = IfxMultican_Status_receiveEmpty;
80004fe0:	3b 00 04 20 	mov %d2,64
    {
        /* use normal read message API */
    }

    return status;
}
80004fe4:	00 90       	ret 
80004fe6:	40 3e       	mov.aa %a14,%a3
80004fe8:	40 7d       	mov.aa %a13,%a7
    {
        /* if new data available in the message object */
        if (hwObj->STAT.B.NEWDAT != 0)
        {
            Ifx_CAN_MO_STAT stat;
            IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);
80004fea:	6d ff ef fe 	call 80004dc8 <IfxMultican_MsgObj_doReadLongFrame>
            stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */
80004fee:	19 c9 1c 01 	ld.w %d9,[%a12]4124

            if (stat.B.RXUPD != 0)
            {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
                status = IfxMultican_Status_messageLost;
80004ff2:	3b 00 08 20 	mov %d2,128
        {
            Ifx_CAN_MO_STAT stat;
            IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);
            stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */

            if (stat.B.RXUPD != 0)
80004ff6:	6f 29 06 80 	jnz.t %d9,2,80005002 <IfxMultican_MsgObj_readLongFrame+0x50>
                {   /* Return message lost at 2nd read attempt, data will be read next time the API is called*/
                }
            }
            else
            {
                status = IfxMultican_Status_newData;
80004ffa:	3b 00 10 20 	mov %d2,256

            if (stat.B.RXUPD != 0)
            {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
                status = IfxMultican_Status_messageLost;
            }
            else if (stat.B.NEWDAT != 0)
80004ffe:	6f 39 0c 80 	jnz.t %d9,3,80005016 <IfxMultican_MsgObj_readLongFrame+0x64>
            else
            {
                status = IfxMultican_Status_newData;
            }

            if (stat.B.MSGLST != 0)
80005002:	6f 49 f1 7f 	jz.t %d9,4,80004fe4 <IfxMultican_MsgObj_readLongFrame+0x32>
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80005006:	01 f8 00 f6 	addsc.a %a15,%a15,%d8,0
8000500a:	da 10       	mov %d15,16
8000500c:	59 ff 1c 01 	st.w [%a15]4124,%d15
            }

            if (stat.B.MSGLST != 0)
            {   /* At least on message has been lost */
                IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
                status |= IfxMultican_Status_messageLost;
80005010:	8f 02 48 21 	or %d2,%d2,128
80005014:	00 90       	ret 
            else if (stat.B.NEWDAT != 0)
            {   /* Data might be inconsistent (update while reading), force massage lost flag, read new incoming data */
                Ifx_CAN_MO_STAT stat2;
                status = IfxMultican_Status_messageLost;
                /* perform read from the hardware */
                IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);
80005016:	02 f4       	mov %d4,%d15
80005018:	40 f4       	mov.aa %a4,%a15
8000501a:	40 e5       	mov.aa %a5,%a14
8000501c:	40 d6       	mov.aa %a6,%a13
8000501e:	6d ff d5 fe 	call 80004dc8 <IfxMultican_MsgObj_doReadLongFrame>

                stat2 = hwObj->STAT; /* Cache the status after reading */
80005022:	19 c2 1c 01 	ld.w %d2,[%a12]4124

                if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
                {
                    status |= IfxMultican_Status_newData;
80005026:	3b 00 18 f0 	mov %d15,384
                /* perform read from the hardware */
                IfxMultican_MsgObj_doReadLongFrame(mcan, msgObjId, msg, data);

                stat2 = hwObj->STAT; /* Cache the status after reading */

                if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
8000502a:	8f c2 00 21 	and %d2,%d2,12
                {
                    status |= IfxMultican_Status_newData;
8000502e:	ab 0f a8 22 	seln %d2,%d2,%d15,128
80005032:	3c e8       	j 80005002 <IfxMultican_MsgObj_readLongFrame+0x50>

80005034 <IfxMultican_MsgObj_readMessage>:
IfxMultican_Status IfxMultican_MsgObj_readMessage(Ifx_CAN_MO *hwObj, IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
80005034:	4c 47       	ld.w %d15,[%a4]28
            status |= IfxMultican_Status_messageLost;
        }
    }
    else
    {
        status = IfxMultican_Status_receiveEmpty;
80005036:	3b 00 04 20 	mov %d2,64
IfxMultican_Status IfxMultican_MsgObj_readMessage(Ifx_CAN_MO *hwObj, IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
8000503a:	ae 32       	jnz.t %d15,3,8000503e <IfxMultican_MsgObj_readMessage+0xa>
    {
        status = IfxMultican_Status_receiveEmpty;
    }

    return status;
}
8000503c:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
8000503e:	3b 80 00 40 	mov %d4,8
80005042:	59 44 1c 00 	st.w [%a4]28,%d4
{
    /* for standard message object and FIFO message objects*/
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);

    /* read the data from the data registers */
    msg->data[0] = hwObj->DATAL.U;
80005046:	4c 44       	ld.w %d15,[%a4]16
80005048:	6c 52       	st.w [%a5]8,%d15
    msg->data[1] = hwObj->DATAH.U;
8000504a:	4c 45       	ld.w %d15,[%a4]20
8000504c:	6c 53       	st.w [%a5]12,%d15
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
8000504e:	4c 40       	ld.w %d15,[%a4]0
80005050:	37 0f 64 fc 	extr.u %d15,%d15,24,4

    /* copy the length code from hardware */
    msg->lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);
80005054:	2c 54       	st.b [%a5]4,%d15


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
80005056:	4c 46       	ld.w %d15,[%a4]24
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
80005058:	37 0f 7d 20 	extr.u %d2,%d15,0,29
8000505c:	87 ff dd fe 	nor.t %d15,%d15,29,%d15,29
80005060:	ab 2f a1 ff 	seln %d15,%d15,%d15,18
80005064:	8b 0f 00 31 	rsub %d3,%d15,0
80005068:	0f 32 20 30 	shas %d3,%d2,%d3

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
8000506c:	74 53       	st.w [%a5],%d3
    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
    {
        Ifx_CAN_MO_STAT stat;
        IfxMultican_MsgObj_doReadMessage(hwObj, msg);
        stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */
8000506e:	4c 47       	ld.w %d15,[%a4]28

        if (stat.B.RXUPD != 0)
        {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
            status = IfxMultican_Status_messageLost;
80005070:	3b 00 08 20 	mov %d2,128
    {
        Ifx_CAN_MO_STAT stat;
        IfxMultican_MsgObj_doReadMessage(hwObj, msg);
        stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */

        if (stat.B.RXUPD != 0)
80005074:	8f 4f 00 31 	and %d3,%d15,4
80005078:	df 03 2b 80 	jne %d3,0,800050ce <IfxMultican_MsgObj_readMessage+0x9a>
            {   /* Return message lost at 2nd read attempt, data will be read next time the API is called*/
            }
        }
        else
        {
            status = IfxMultican_Status_newData;
8000507c:	3b 00 10 20 	mov %d2,256

        if (stat.B.RXUPD != 0)
        {                   /* Data might be inconsistent (update while reading), declare as message lost, data will be read next time the API is called */
            status = IfxMultican_Status_messageLost;
        }
        else if (stat.B.NEWDAT != 0)
80005080:	6f 3f 27 00 	jz.t %d15,3,800050ce <IfxMultican_MsgObj_readMessage+0x9a>
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80005084:	59 44 1c 00 	st.w [%a4]28,%d4
{
    /* for standard message object and FIFO message objects*/
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);

    /* read the data from the data registers */
    msg->data[0] = hwObj->DATAL.U;
80005088:	19 42 10 00 	ld.w %d2,[%a4]16
8000508c:	7b 00 00 52 	movh %d5,8192
80005090:	59 52 08 00 	st.w [%a5]8,%d2
    msg->data[1] = hwObj->DATAH.U;
80005094:	19 42 14 00 	ld.w %d2,[%a4]20
80005098:	59 52 0c 00 	st.w [%a5]12,%d2
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
8000509c:	54 42       	ld.w %d2,[%a4]
8000509e:	37 02 64 2c 	extr.u %d2,%d2,24,4

    /* copy the length code from hardware */
    msg->lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);
800050a2:	e9 52 04 00 	st.b [%a5]4,%d2


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
800050a6:	19 42 18 00 	ld.w %d2,[%a4]24
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
800050aa:	37 02 7d 40 	extr.u %d4,%d2,0,29
800050ae:	26 52       	and %d2,%d5
800050b0:	ab 23 81 32 	sel %d3,%d2,%d3,18
800050b4:	8b 03 00 21 	rsub %d2,%d3,0
800050b8:	0f 24 20 20 	shas %d2,%d4,%d2

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
800050bc:	74 52       	st.w [%a5],%d2
            Ifx_CAN_MO_STAT stat2;
            status = IfxMultican_Status_messageLost;
            /* perform read from the hardware */
            IfxMultican_MsgObj_doReadMessage(hwObj, msg);

            stat2 = hwObj->STAT; /* Cache the status after reading */
800050be:	19 42 1c 00 	ld.w %d2,[%a4]28

            if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
800050c2:	8f c2 00 31 	and %d3,%d2,12
            {
                status |= IfxMultican_Status_newData;
800050c6:	3b 00 18 20 	mov %d2,384
800050ca:	ab 02 a8 23 	seln %d2,%d3,%d2,128
        else
        {
            status = IfxMultican_Status_newData;
        }

        if (stat.B.MSGLST != 0)
800050ce:	6f 4f b7 7f 	jz.t %d15,4,8000503c <IfxMultican_MsgObj_readMessage+0x8>
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
800050d2:	da 10       	mov %d15,16
800050d4:	6c 47       	st.w [%a4]28,%d15
        }

        if (stat.B.MSGLST != 0)
        {   /* At least on message has been lost */
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
            status |= IfxMultican_Status_messageLost;
800050d6:	8f 02 48 21 	or %d2,%d2,128
    {
        status = IfxMultican_Status_receiveEmpty;
    }

    return status;
}
800050da:	00 90       	ret 

800050dc <IfxMultican_MsgObj_sendLongFrame>:
{
    Ifx_CAN_MO          *hwObj  = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status   status = IfxMultican_Status_ok;

    /* get the base address of top and bottom message objects */
    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
800050dc:	8f 54 00 f0 	sh %d15,%d4,5
800050e0:	10 4f       	addsc.a %a15,%a4,%d15,0
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
    Ifx_CAN_MO          *hwTopObj    = IfxMultican_MsgObj_getPointer(mcan, topMsgObjId);

    boolean              longFrame   = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
800050e2:	1b 04 08 40 	addi %d4,%d4,128
{
    Ifx_CAN_MO          *hwObj  = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status   status = IfxMultican_Status_ok;

    /* get the base address of top and bottom message objects */
    IfxMultican_MsgObjId botMsgObjId = hwObj->FGPR.B.BOT;
800050e6:	19 f2 04 01 	ld.w %d2,[%a15]4100
800050ea:	8f f2 0f 61 	and %d6,%d2,255
    Ifx_CAN_MO          *hwBotObj    = IfxMultican_MsgObj_getPointer(mcan, botMsgObjId);

    IfxMultican_MsgObjId topMsgObjId = hwObj->FGPR.B.TOP;
800050ee:	19 f2 04 01 	ld.w %d2,[%a15]4100
800050f2:	37 02 68 34 	extr.u %d3,%d2,8,8
    Ifx_CAN_MO          *hwTopObj    = IfxMultican_MsgObj_getPointer(mcan, topMsgObjId);

    boolean              longFrame   = (hwObj->FCR.B.FDF != 0) ? TRUE : FALSE;
800050f6:	8f 54 00 20 	sh %d2,%d4,5
800050fa:	01 42 00 26 	addsc.a %a2,%a4,%d2,0
800050fe:	54 22       	ld.w %d2,[%a2]
80005100:	6f 62 04 80 	jnz.t %d2,6,80005108 <IfxMultican_MsgObj_sendLongFrame+0x2c>
    /* standard frame */
    /* FDEN = 0/1, EDL = 0 and BRS = 0 (BRS = 1 also has no effect here) */
    else
    {
        /* use normal send message API */
        status = IfxMultican_Status_notInitialised;
80005104:	82 12       	mov %d2,1
80005106:	00 90       	ret 
    /* in either of the below cases, the two conditions FDEN = 0, EDl = 1 and BRS = 0/1 will not reach */
    /* long frame CAN FD */
    /* FDEN = 1, EDL = 1 and BRS = 0/1 */
    if (longFrame)
    {
        if (hwObj->STAT.B.TXRQ)
80005108:	19 f5 1c 01 	ld.w %d5,[%a15]4124
        {                           /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
            status = IfxMultican_Status_notSentBusy;
8000510c:	3b 00 02 20 	mov %d2,32
    /* in either of the below cases, the two conditions FDEN = 0, EDl = 1 and BRS = 0/1 will not reach */
    /* long frame CAN FD */
    /* FDEN = 1, EDL = 1 and BRS = 0/1 */
    if (longFrame)
    {
        if (hwObj->STAT.B.TXRQ)
80005110:	6f 85 03 00 	jz.t %d5,8,80005116 <IfxMultican_MsgObj_sendLongFrame+0x3a>
        /* use normal send message API */
        status = IfxMultican_Status_notInitialised;
    }

    return status;
}
80005114:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80005116:	59 f2 1c 01 	st.w [%a15]4124,%d2
        else
        {
            /* MSGVAL: Set message as not valid */
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);

            if (msg->lengthCode > IfxMultican_DataLengthCode_0) /* no.of bytes 0 to 8 */
8000511a:	39 52 04 00 	ld.bu %d2,[%a5]4
8000511e:	df 02 6f 00 	jeq %d2,0,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwObj->DATAL.U = *data++;
80005122:	54 65       	ld.w %d5,[%a6]
80005124:	59 f5 10 01 	st.w [%a15]4112,%d5
                hwObj->DATAH.U = *data++;
80005128:	19 62 04 00 	ld.w %d2,[%a6]4
8000512c:	59 f2 14 01 	st.w [%a15]4116,%d2
            }

            /* load bottom message object extended data registers */
            if (msg->lengthCode > IfxMultican_DataLengthCode_8)
80005130:	39 52 04 00 	ld.bu %d2,[%a5]4
80005134:	bf 92 64 80 	jlt.u %d2,9,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA0.U = *data++;
80005138:	1b 06 08 20 	addi %d2,%d6,128
8000513c:	8f 52 00 50 	sh %d5,%d2,5
80005140:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
80005144:	19 62 08 00 	ld.w %d2,[%a6]8
80005148:	68 02       	st.w [%a15]0,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_12)
8000514a:	39 52 04 00 	ld.bu %d2,[%a5]4
8000514e:	bf a2 57 80 	jlt.u %d2,10,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA1.U = *data++;
80005152:	8f 56 00 50 	sh %d5,%d6,5
80005156:	19 62 0c 00 	ld.w %d2,[%a6]12
8000515a:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
8000515e:	59 f2 04 01 	st.w [%a15]4100,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_16)
80005162:	39 52 04 00 	ld.bu %d2,[%a5]4
80005166:	bf b2 4b 80 	jlt.u %d2,11,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA2.U = *data++;
8000516a:	19 65 10 00 	ld.w %d5,[%a6]16
8000516e:	59 f5 08 01 	st.w [%a15]4104,%d5
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_20)
80005172:	39 52 04 00 	ld.bu %d2,[%a5]4
80005176:	bf c2 43 80 	jlt.u %d2,12,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA3.U = *data++;
8000517a:	19 62 14 00 	ld.w %d2,[%a6]20
8000517e:	59 f2 0c 01 	st.w [%a15]4108,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_24)
80005182:	39 52 04 00 	ld.bu %d2,[%a5]4
80005186:	bf d2 3b 80 	jlt.u %d2,13,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA4.U = *data++;
8000518a:	19 65 18 00 	ld.w %d5,[%a6]24
8000518e:	59 f5 10 01 	st.w [%a15]4112,%d5
                hwBotObj->EDATA5.U = *data++;
80005192:	19 62 1c 00 	ld.w %d2,[%a6]28
80005196:	59 f2 14 01 	st.w [%a15]4116,%d2
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_32)
8000519a:	39 52 04 00 	ld.bu %d2,[%a5]4
8000519e:	bf e2 2f 80 	jlt.u %d2,14,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwBotObj->EDATA6.U = *data++;
800051a2:	19 65 20 00 	ld.w %d5,[%a6]32
                /* load bottom message object extended data registers */
                hwTopObj->EDATA0.U = *data++;
800051a6:	1b 03 08 20 	addi %d2,%d3,128
                hwBotObj->EDATA5.U = *data++;
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_32)
            {
                hwBotObj->EDATA6.U = *data++;
800051aa:	59 f5 18 01 	st.w [%a15]4120,%d5
                /* load bottom message object extended data registers */
                hwTopObj->EDATA0.U = *data++;
800051ae:	8f 52 00 50 	sh %d5,%d2,5
800051b2:	01 45 00 f6 	addsc.a %a15,%a4,%d5,0
800051b6:	19 62 24 00 	ld.w %d2,[%a6]36
800051ba:	68 02       	st.w [%a15]0,%d2
                hwTopObj->EDATA1.U = *data++;
800051bc:	8f 53 00 20 	sh %d2,%d3,5
800051c0:	01 42 00 26 	addsc.a %a2,%a4,%d2,0
800051c4:	19 63 28 00 	ld.w %d3,[%a6]40
800051c8:	59 23 04 01 	st.w [%a2]4100,%d3
                hwTopObj->EDATA2.U = *data++;
800051cc:	19 65 2c 00 	ld.w %d5,[%a6]44
800051d0:	59 25 08 01 	st.w [%a2]4104,%d5
            }

            if (msg->lengthCode > IfxMultican_DataLengthCode_48)
800051d4:	39 53 04 00 	ld.bu %d3,[%a5]4
800051d8:	bf f3 12 80 	jlt.u %d3,15,800051fc <IfxMultican_MsgObj_sendLongFrame+0x120>
            {
                hwTopObj->EDATA3.U = *data++;
800051dc:	19 62 30 00 	ld.w %d2,[%a6]48
800051e0:	59 22 0c 01 	st.w [%a2]4108,%d2
                hwTopObj->EDATA4.U = *data++;
800051e4:	19 63 34 00 	ld.w %d3,[%a6]52
800051e8:	59 23 10 01 	st.w [%a2]4112,%d3
                hwTopObj->EDATA5.U = *data++;
800051ec:	19 65 38 00 	ld.w %d5,[%a6]56
800051f0:	59 25 14 01 	st.w [%a2]4116,%d5
                hwTopObj->EDATA6.U = *data;
800051f4:	19 62 3c 00 	ld.w %d2,[%a6]60
800051f8:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
800051fc:	10 4f       	addsc.a %a15,%a4,%d15,0

            /* for long message */
            {
                /* set ID */
                boolean extendedFrame = IfxMultican_MsgObj_isExtendedFrame(hwObj);
                IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
800051fe:	54 52       	ld.w %d2,[%a5]
80005200:	19 ff 18 01 	ld.w %d15,[%a15]4120
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80005204:	87 ff dd fe 	nor.t %d15,%d15,29,%d15,29
80005208:	ab 2f a1 ff 	seln %d15,%d15,%d15,18
8000520c:	0f f2 00 f0 	sh %d15,%d2,%d15
80005210:	19 f2 18 01 	ld.w %d2,[%a15]4120
80005214:	37 f2 1d f0 	insert %d15,%d2,%d15,0,29
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80005218:	8f 54 00 20 	sh %d2,%d4,5
8000521c:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80005220:	59 ff 18 01 	st.w [%a15]4120,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80005224:	54 42       	ld.w %d2,[%a4]
80005226:	0c 54       	ld.bu %d15,[%a5]4
80005228:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
8000522c:	6c 40       	st.w [%a4]0,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBitRateSwitch(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.BRS = enabled ? 1 : 0;
8000522e:	39 5f 10 00 	ld.bu %d15,[%a5]16
80005232:	ab 0f a2 2f 	seln %d2,%d15,%d15,32
80005236:	4c 40       	ld.w %d15,[%a4]0
80005238:	8f 0f c2 f1 	andn %d15,%d15,32
8000523c:	a6 2f       	or %d15,%d2
8000523e:	6c 40       	st.w [%a4]0,%d15
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
80005240:	7b 80 00 f0 	movh %d15,8
80005244:	59 ff 1c 01 	st.w [%a15]4124,%d15
80005248:	7b 00 02 f0 	movh %d15,32
8000524c:	59 ff 1c 01 	st.w [%a15]4124,%d15
80005250:	7b 00 04 f0 	movh %d15,64
80005254:	59 ff 1c 01 	st.w [%a15]4124,%d15
80005258:	7b 00 10 f0 	movh %d15,256
8000525c:	59 ff 1c 01 	st.w [%a15]4124,%d15


IfxMultican_Status IfxMultican_MsgObj_sendLongFrame(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId, IfxMultican_Message *msg, uint32 *data)
{
    Ifx_CAN_MO          *hwObj  = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    IfxMultican_Status   status = IfxMultican_Status_ok;
80005260:	82 02       	mov %d2,0
80005262:	00 90       	ret 

80005264 <IfxMultican_MsgObj_sendMessage>:

IfxMultican_Status IfxMultican_MsgObj_sendMessage(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
80005264:	4c 47       	ld.w %d15,[%a4]28
    {                           /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
        status = IfxMultican_Status_notSentBusy;
80005266:	3b 00 02 20 	mov %d2,32

IfxMultican_Status IfxMultican_MsgObj_sendMessage(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
8000526a:	37 0f 61 f4 	extr.u %d15,%d15,8,1
8000526e:	6e 02       	jz %d15,80005272 <IfxMultican_MsgObj_sendMessage+0xe>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
80005270:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
80005272:	59 42 1c 00 	st.w [%a4]28,%d2
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);

        /* for standard and FIFO message object */
        hwObj->DATAL.U = msg->data[0];  /* Set the new data */
80005276:	19 52 08 00 	ld.w %d2,[%a5]8
8000527a:	59 42 10 00 	st.w [%a4]16,%d2
        hwObj->DATAH.U = msg->data[1];  /* Set the new data */
8000527e:	19 52 0c 00 	ld.w %d2,[%a5]12
80005282:	59 42 14 00 	st.w [%a4]20,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
80005286:	19 42 18 00 	ld.w %d2,[%a4]24

        /* for standard and FIFO message object */
        {
            /* set ID */
            boolean extendedFrame = IfxMultican_MsgObj_isExtendedFrame(hwObj);
            IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
8000528a:	54 53       	ld.w %d3,[%a5]
8000528c:	37 02 e1 2e 	extr.u %d2,%d2,29,1
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80005290:	ab 2f 81 f2 	sel %d15,%d2,%d15,18
80005294:	19 42 18 00 	ld.w %d2,[%a4]24
80005298:	0f f3 00 f0 	sh %d15,%d3,%d15
8000529c:	37 f2 1d f0 	insert %d15,%d2,%d15,0,29
800052a0:	6c 46       	st.w [%a4]24,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
800052a2:	54 42       	ld.w %d2,[%a4]
800052a4:	0c 54       	ld.bu %d15,[%a5]4
800052a6:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
}


IfxMultican_Status IfxMultican_MsgObj_sendMessage(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;
800052aa:	82 02       	mov %d2,0
800052ac:	6c 40       	st.w [%a4]0,%d15
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
800052ae:	7b 80 00 f0 	movh %d15,8
800052b2:	6c 47       	st.w [%a4]28,%d15
800052b4:	7b 00 02 f0 	movh %d15,32
800052b8:	6c 47       	st.w [%a4]28,%d15
800052ba:	7b 00 10 f0 	movh %d15,256
800052be:	6c 47       	st.w [%a4]28,%d15
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
800052c0:	00 90       	ret 

800052c2 <IfxMultican_MsgObj_writeTxfifo>:

IfxMultican_Status IfxMultican_MsgObj_writeTxfifo(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
800052c2:	4c 47       	ld.w %d15,[%a4]28
    {
        /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
        status = IfxMultican_Status_notSentBusy;
800052c4:	3b 00 02 20 	mov %d2,32

IfxMultican_Status IfxMultican_MsgObj_writeTxfifo(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;

    if (hwObj->STAT.B.TXRQ)
800052c8:	37 0f 61 f4 	extr.u %d15,%d15,8,1
800052cc:	6e 02       	jz %d15,800052d0 <IfxMultican_MsgObj_writeTxfifo+0xe>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
800052ce:	00 90       	ret 
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;

    hwObj->CTR.U = ctr.U;
800052d0:	3b 00 20 20 	mov %d2,512
800052d4:	59 42 1c 00 	st.w [%a4]28,%d2
    {
        /* Clear TXEN0 to update the data FIFO message object  */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);

        /* for standard and FIFO message object */
        hwObj->DATAL.U = msg->data[0];      /* Set the new data */
800052d8:	19 52 08 00 	ld.w %d2,[%a5]8
800052dc:	59 42 10 00 	st.w [%a4]16,%d2
        hwObj->DATAH.U = msg->data[1];      /* Set the new data */
800052e0:	19 52 0c 00 	ld.w %d2,[%a5]12
800052e4:	59 42 14 00 	st.w [%a4]20,%d2
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
800052e8:	7b 00 20 20 	movh %d2,512
800052ec:	59 42 1c 00 	st.w [%a4]28,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
800052f0:	19 42 18 00 	ld.w %d2,[%a4]24

        /* for standard and FIFO message object */
        {
            /* set ID */
            boolean extendedFrame = IfxMultican_MsgObj_isExtendedFrame(hwObj);
            IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
800052f4:	54 53       	ld.w %d3,[%a5]
800052f6:	37 02 e1 2e 	extr.u %d2,%d2,29,1
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
800052fa:	ab 2f 81 f2 	sel %d15,%d2,%d15,18
800052fe:	19 42 18 00 	ld.w %d2,[%a4]24
80005302:	0f f3 00 f0 	sh %d15,%d3,%d15
80005306:	37 f2 1d f0 	insert %d15,%d2,%d15,0,29
8000530a:	6c 46       	st.w [%a4]24,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
8000530c:	54 42       	ld.w %d2,[%a4]
8000530e:	0c 54       	ld.bu %d15,[%a5]4
80005310:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
}


IfxMultican_Status IfxMultican_MsgObj_writeTxfifo(Ifx_CAN_MO *hwObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status status = IfxMultican_Status_ok;
80005314:	82 02       	mov %d2,0
80005316:	6c 40       	st.w [%a4]0,%d15
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);

    hwObj->CTR.U = ctr.U;
80005318:	7b 80 00 f0 	movh %d15,8
8000531c:	6c 47       	st.w [%a4]28,%d15
8000531e:	7b 00 02 f0 	movh %d15,32
80005322:	6c 47       	st.w [%a4]28,%d15
80005324:	7b 00 10 f0 	movh %d15,256
80005328:	6c 47       	st.w [%a4]28,%d15
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
        }
    }

    return status;
}
8000532a:	00 90       	ret 

8000532c <IfxMultican_MsgObj_setFilter>:
void IfxMultican_MsgObj_setFilter(Ifx_CAN_MO *hwObj, boolean extend, uint32 id, uint32 accMask)
{
    Ifx_CAN_MO_CTR ctr;

    ctr.U           = 0;
    ctr.B.RESMSGVAL = 1;    /* MSGVAL: Set message as not valid */
8000532c:	da 20       	mov %d15,32
    hwObj->CTR.U    = ctr.U;
8000532e:	6c 47       	st.w [%a4]28,%d15

    hwObj->AMR.B.AM = accMask << ((extend != 0) ? 0 : 18);
80005330:	df 04 13 00 	jeq %d4,0,80005356 <IfxMultican_MsgObj_setFilter+0x2a>
80005334:	4c 43       	ld.w %d15,[%a4]12
80005336:	37 6f 1d 60 	insert %d6,%d15,%d6,0,29
    hwObj->AR.B.IDE = (id << ((extend != 0) ? 0 : 18)) | (extend << 29);
8000533a:	82 0f       	mov %d15,0

    ctr.U           = 0;
    ctr.B.RESMSGVAL = 1;    /* MSGVAL: Set message as not valid */
    hwObj->CTR.U    = ctr.U;

    hwObj->AMR.B.AM = accMask << ((extend != 0) ? 0 : 18);
8000533c:	59 46 0c 00 	st.w [%a4]12,%d6
    hwObj->AR.B.IDE = (id << ((extend != 0) ? 0 : 18)) | (extend << 29);
80005340:	0f f5 00 50 	sh %d5,%d5,%d15
80005344:	4c 46       	ld.w %d15,[%a4]24
80005346:	67 5f 1d 50 	ins.t %d5,%d15,29,%d5,0
8000534a:	59 45 18 00 	st.w [%a4]24,%d5

    ctr.U           = 0;
    ctr.B.SETMSGVAL = 1;    /* MSGVAL: Set message as valid */
8000534e:	7b 00 02 f0 	movh %d15,32
    hwObj->CTR.U    = ctr.U;
80005352:	6c 47       	st.w [%a4]28,%d15
80005354:	00 90       	ret 

    ctr.U           = 0;
    ctr.B.RESMSGVAL = 1;    /* MSGVAL: Set message as not valid */
    hwObj->CTR.U    = ctr.U;

    hwObj->AMR.B.AM = accMask << ((extend != 0) ? 0 : 18);
80005356:	8f 26 01 60 	sh %d6,%d6,18
8000535a:	b7 06 83 fe 	insert %d15,%d6,0,29,3
8000535e:	19 46 0c 00 	ld.w %d6,[%a4]12
80005362:	b7 06 1d 60 	insert %d6,%d6,0,0,29
80005366:	a6 f6       	or %d6,%d15
80005368:	59 46 0c 00 	st.w [%a4]12,%d6
    hwObj->AR.B.IDE = (id << ((extend != 0) ? 0 : 18)) | (extend << 29);
8000536c:	da 12       	mov %d15,18
8000536e:	3c e9       	j 80005340 <IfxMultican_MsgObj_setFilter+0x14>

80005370 <IfxMultican_MsgObj_setStatusFlag>:
void IfxMultican_MsgObj_setStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);
80005370:	1b 04 01 40 	addi %d4,%d4,16
80005374:	82 1f       	mov %d15,1
80005376:	0f 4f 00 f0 	sh %d15,%d15,%d4

    hwObj->CTR.U = ctr.U;
8000537a:	6c 47       	st.w [%a4]28,%d15
8000537c:	00 90       	ret 

8000537e <IfxMultican_Node_deinit>:
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
8000537e:	82 1f       	mov %d15,1
80005380:	6c 40       	st.w [%a4]0,%d15
    hwNode->SR.U    = 0x00000000;
80005382:	82 0f       	mov %d15,0
80005384:	6c 41       	st.w [%a4]4,%d15
    hwNode->IPR.U   = 0x00000000;
80005386:	6c 42       	st.w [%a4]8,%d15
    hwNode->PCR.U   = 0x00000000;
80005388:	6c 43       	st.w [%a4]12,%d15
    hwNode->BTEVR.U = 0x00000000;
8000538a:	6c 44       	st.w [%a4]16,%d15
    hwNode->ECNT.U  = 0x00600000;
8000538c:	7b 00 06 20 	movh %d2,96
80005390:	59 42 14 00 	st.w [%a4]20,%d2
    hwNode->FCR.U   = 0x00000000;
80005394:	6c 46       	st.w [%a4]24,%d15
80005396:	00 90       	ret 

80005398 <IfxMultican_Node_initRxPin>:
}


boolean IfxMultican_Node_initRxPin(Ifx_CAN_N *hwNode, IfxMultican_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver)
{
80005398:	40 4c       	mov.aa %a12,%a4
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000539a:	99 54 08 00 	ld.a %a4,[%a5]8
8000539e:	02 5f       	mov %d15,%d5
800053a0:	8f f4 0f 51 	and %d5,%d4,255
800053a4:	39 54 0c 00 	ld.bu %d4,[%a5]12
800053a8:	40 5f       	mov.aa %a15,%a5
800053aa:	6d 00 24 14 	call 80007bf2 <IfxPort_setPinMode>
    IfxPort_setPinModeInput(rxd->pin.port, rxd->pin.pinIndex, mode);
    IfxPort_setPinPadDriver(rxd->pin.port, rxd->pin.pinIndex, padDriver);
800053ae:	c8 24       	ld.a %a4,[%a15]8
800053b0:	02 f5       	mov %d5,%d15
800053b2:	08 c4       	ld.bu %d4,[%a15]12
800053b4:	6d 00 a5 14 	call 80007cfe <IfxPort_setPinPadDriver>
    hwNode->PCR.B.RXSEL = rxd->select;
800053b8:	19 c2 0c 00 	ld.w %d2,[%a12]12
800053bc:	39 ff 10 00 	ld.bu %d15,[%a15]16
800053c0:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3

    return TRUE;
}
800053c4:	82 12       	mov %d2,1

boolean IfxMultican_Node_initRxPin(Ifx_CAN_N *hwNode, IfxMultican_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeInput(rxd->pin.port, rxd->pin.pinIndex, mode);
    IfxPort_setPinPadDriver(rxd->pin.port, rxd->pin.pinIndex, padDriver);
    hwNode->PCR.B.RXSEL = rxd->select;
800053c6:	6c c3       	st.w [%a12]12,%d15

    return TRUE;
}
800053c8:	00 90       	ret 

800053ca <IfxMultican_Node_initTxPin>:
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800053ca:	99 54 08 00 	ld.a %a4,[%a5]8


boolean IfxMultican_Node_initTxPin(Ifx_CAN_N *hwNode, IfxMultican_Txd_Out *txd, IfxPort_OutputMode mode, IfxPort_PadDriver padDriver)
{
800053ce:	02 5f       	mov %d15,%d5
800053d0:	39 55 10 00 	ld.bu %d5,[%a5]16
800053d4:	40 5f       	mov.aa %a15,%a5
800053d6:	a6 45       	or %d5,%d4
800053d8:	39 54 0c 00 	ld.bu %d4,[%a5]12
800053dc:	6d 00 0b 14 	call 80007bf2 <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(txd->pin.port, txd->pin.pinIndex, mode, txd->select);
    IfxPort_setPinPadDriver(txd->pin.port, txd->pin.pinIndex, padDriver);
800053e0:	c8 24       	ld.a %a4,[%a15]8
800053e2:	08 c4       	ld.bu %d4,[%a15]12
800053e4:	02 f5       	mov %d5,%d15
800053e6:	6d 00 8c 14 	call 80007cfe <IfxPort_setPinPadDriver>

    return TRUE;
}
800053ea:	82 12       	mov %d2,1
800053ec:	00 90       	ret 

800053ee <IfxMultican_Node_recoverBusOff>:

IfxMultican_Status IfxMultican_Node_recoverBusOff(Ifx_CAN_N *hwNode)
{
    IfxMultican_Status status             = IfxMultican_Status_busOff;

    boolean            busOffState        = hwNode->SR.B.BOFF;
800053ee:	4c 41       	ld.w %d15,[%a4]4
    boolean            errorWarningStatus = hwNode->SR.B.EWRN;
800053f0:	19 43 04 00 	ld.w %d3,[%a4]4

IfxMultican_Status IfxMultican_Node_recoverBusOff(Ifx_CAN_N *hwNode)
{
    IfxMultican_Status status             = IfxMultican_Status_busOff;

    boolean            busOffState        = hwNode->SR.B.BOFF;
800053f4:	37 0f e1 f3 	extr.u %d15,%d15,7,1
    boolean            errorWarningStatus = hwNode->SR.B.EWRN;
800053f8:	37 03 61 33 	extr.u %d3,%d3,6,1

    /* if the node is in bus off state, initiaite the recovery process */
    if ((busOffState != 0) && (hwNode->ECNT.B.TEC > 254))
800053fc:	6e 24       	jz %d15,80005444 <IfxMultican_Node_recoverBusOff+0x56>
800053fe:	19 42 14 00 	ld.w %d2,[%a4]20
80005402:	37 02 68 24 	extr.u %d2,%d2,8,8
80005406:	8b f2 2f 22 	ne %d2,%d2,255
8000540a:	76 27       	jz %d2,80005418 <IfxMultican_Node_recoverBusOff+0x2a>
        /* disable node INIT = 1 */
        IfxMultican_Node_deactivate(hwNode);
    }

    /* during recovery process, if REC counter reaches 0x60 */
    else if ((busOffState != 0) && (errorWarningStatus != 0))
8000540c:	0f f3 80 40 	and %d4,%d3,%d15
    {
        status = IfxMultican_Status_notInitialised;
80005410:	82 12       	mov %d2,1
        /* disable node INIT = 1 */
        IfxMultican_Node_deactivate(hwNode);
    }

    /* during recovery process, if REC counter reaches 0x60 */
    else if ((busOffState != 0) && (errorWarningStatus != 0))
80005412:	df 04 19 00 	jeq %d4,0,80005444 <IfxMultican_Node_recoverBusOff+0x56>

        status = IfxMultican_Status_ok;
    }

    return status;
}
80005416:	00 90       	ret 
    if ((busOffState != 0) && (hwNode->ECNT.B.TEC > 254))
    {
        status = IfxMultican_Status_busOff;

        /* reset error counters */
        hwNode->ECNT.B.TEC = 0x01;
80005418:	4c 45       	ld.w %d15,[%a4]20
    boolean            errorWarningStatus = hwNode->SR.B.EWRN;

    /* if the node is in bus off state, initiaite the recovery process */
    if ((busOffState != 0) && (hwNode->ECNT.B.TEC > 254))
    {
        status = IfxMultican_Status_busOff;
8000541a:	3b 00 01 20 	mov %d2,16

        /* reset error counters */
        hwNode->ECNT.B.TEC = 0x01;
8000541e:	b7 1f 08 f4 	insert %d15,%d15,1,8,8
80005422:	6c 45       	st.w [%a4]20,%d15
        hwNode->ECNT.B.REC = 0x01;
80005424:	4c 45       	ld.w %d15,[%a4]20
80005426:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000542a:	6c 45       	st.w [%a4]20,%d15

        /* clear error warning status */
        hwNode->SR.B.EWRN = 0;
8000542c:	4c 41       	ld.w %d15,[%a4]4
8000542e:	8f 0f c4 f1 	andn %d15,%d15,64
80005432:	6c 41       	st.w [%a4]4,%d15

        /* clear ALERT status */
        hwNode->SR.B.ALERT = 0;
80005434:	4c 41       	ld.w %d15,[%a4]4
80005436:	8f 0f c2 f1 	andn %d15,%d15,32
8000543a:	6c 41       	st.w [%a4]4,%d15
}


IFX_INLINE void IfxMultican_Node_deactivate(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.INIT = 1;
8000543c:	4c 40       	ld.w %d15,[%a4]0
8000543e:	96 01       	or %d15,1
80005440:	6c 40       	st.w [%a4]0,%d15
80005442:	00 90       	ret 
    {
        status = IfxMultican_Status_notInitialised;
    }

    /* if the recovery process is been finished or not in Bus off mode */
    else if ((busOffState == 0) && (errorWarningStatus == 0))
80005444:	a6 3f       	or %d15,%d3
}


IfxMultican_Status IfxMultican_Node_recoverBusOff(Ifx_CAN_N *hwNode)
{
    IfxMultican_Status status             = IfxMultican_Status_busOff;
80005446:	3b 00 01 20 	mov %d2,16
    {
        status = IfxMultican_Status_notInitialised;
    }

    /* if the recovery process is been finished or not in Bus off mode */
    else if ((busOffState == 0) && (errorWarningStatus == 0))
8000544a:	ee e6       	jnz %d15,80005416 <IfxMultican_Node_recoverBusOff+0x28>
}


IFX_INLINE void IfxMultican_Node_activate(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.INIT = 0;
8000544c:	4c 40       	ld.w %d15,[%a4]0
    {
        /* enable node INIT = 0 */
        IfxMultican_Node_activate(hwNode);

        status = IfxMultican_Status_ok;
8000544e:	82 02       	mov %d2,0
80005450:	8f 1f c0 f1 	andn %d15,%d15,1
80005454:	6c 40       	st.w [%a4]0,%d15
    }

    return status;
}
80005456:	00 90       	ret 

80005458 <IfxMultican_Node_setBitTiming>:
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005458:	4b 05 61 51 	utof %d5,%d5
8000545c:	7b 00 f8 93 	movh %d9,16256
80005460:	4b 59 51 90 	div.f %d9,%d9,%d5
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005464:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005468:	7b d0 d4 83 	movh %d8,15693
8000546c:	1b d8 cc 8c 	addi %d8,%d8,-13107
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005470:	7b d0 dc c3 	movh %d12,15821
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005474:	4b 85 41 80 	mul.f %d8,%d5,%d8
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
80005478:	3b 80 00 b0 	mov %d11,8
8000547c:	82 0a       	mov %d10,0
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
8000547e:	82 13       	mov %d3,1
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005480:	1b dc cc cc 	addi %d12,%d12,-13107
    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = moduleFreq / tempBRP;
80005484:	4b 03 41 21 	itof %d2,%d3
80005488:	4b 24 51 20 	div.f %d2,%d4,%d2
        tempTBAUD = Fquanta / baudrate;
8000548c:	4b 92 41 00 	mul.f %d0,%d2,%d9
80005490:	4b 00 31 f1 	ftoiz %d15,%d0

        if (tempTBAUD == 0)
80005494:	df 0f 4b 02 	jeq %d15,0,8000592a <IfxMultican_Node_setBitTiming+0x4d2>
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
80005498:	4b 0f 41 01 	itof %d0,%d15
8000549c:	4b 02 51 20 	div.f %d2,%d2,%d0
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
800054a0:	8b 8f 80 02 	ge %d0,%d15,8
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);
800054a4:	6b 05 31 22 	sub.f %d2,%d2,%d5
800054a8:	b7 02 81 2f 	insert %d2,%d2,0,31,1

        if (tempTBAUD < minTBAUD)
800054ac:	df 00 3f 02 	jeq %d0,0,8000592a <IfxMultican_Node_setBitTiming+0x4d2>
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
800054b0:	4b 28 01 00 	cmp.f %d0,%d8,%d2
800054b4:	87 00 a2 00 	or.t %d0,%d0,2,%d0,1
800054b8:	8b af 41 12 	lt %d1,%d15,26
800054bc:	26 10       	and %d0,%d1
800054be:	76 0a       	jz %d0,800054d2 <IfxMultican_Node_setBitTiming+0x7a>
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800054c0:	4b c2 01 10 	cmp.f %d1,%d2,%d12
800054c4:	8b 5f 41 02 	lt %d0,%d15,21
800054c8:	26 10       	and %d0,%d1
800054ca:	f6 0d       	jnz %d0,800054e4 <IfxMultican_Node_setBitTiming+0x8c>

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;
800054cc:	02 28       	mov %d8,%d2
800054ce:	0b 3f 10 a8 	mov %e10,%d15,%d3
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
800054d2:	c2 13       	add %d3,1
800054d4:	fd f0 d8 7f 	loop %a15,80005484 <IfxMultican_Node_setBitTiming+0x2c>
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
800054d8:	f6 a4       	jnz %d10,800054e0 <IfxMultican_Node_setBitTiming+0x88>
800054da:	3b f0 03 c0 	mov %d12,63
800054de:	3c 06       	j 800054ea <IfxMultican_Node_setBitTiming+0x92>
800054e0:	02 bf       	mov %d15,%d11
800054e2:	02 a3       	mov %d3,%d10
800054e4:	c2 f3       	add %d3,-1
800054e6:	8f f3 03 c1 	and %d12,%d3,63

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800054ea:	7b 30 00 40 	movh %d4,3
800054ee:	1b 04 81 49 	addi %d4,%d4,-26608
800054f2:	4b f4 01 42 	div %e4,%d4,%d15
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
800054f6:	4b 06 41 31 	itof %d3,%d6
800054fa:	7b a0 e1 23 	movh %d2,15898

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800054fe:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005500:	0b 64 e0 40 	absdif %d4,%d4,%d6
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
80005504:	1b a2 99 29 	addi %d2,%d2,-26214
80005508:	4b 23 41 30 	mul.f %d3,%d3,%d2
    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > (float)error)
8000550c:	4b 04 41 41 	itof %d4,%d4
80005510:	4b 43 01 50 	cmp.f %d5,%d3,%d4
80005514:	8f 45 00 51 	and %d5,%d5,4
80005518:	2b 43 50 25 	seln %d2,%d5,%d3,%d4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000551c:	3f 60 17 02 	jlt %d0,%d6,8000594a <IfxMultican_Node_setBitTiming+0x4f2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005520:	7b 20 00 40 	movh %d4,2
80005524:	1b 04 10 47 	addi %d4,%d4,28928
80005528:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > (float)error)
8000552c:	3b f0 00 30 	mov %d3,15

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005530:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005532:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80005536:	4b 04 41 41 	itof %d4,%d4
8000553a:	4b 42 01 50 	cmp.f %d5,%d2,%d4
8000553e:	37 05 61 51 	extr.u %d5,%d5,2,1
80005542:	ab 03 81 35 	sel %d3,%d5,%d3,16
80005546:	2b 24 40 25 	sel %d2,%d5,%d4,%d2
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000554a:	3f 60 f8 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
8000554e:	7b 20 00 40 	movh %d4,2
80005552:	1b 04 9f 44 	addi %d4,%d4,18928
80005556:	4b f4 01 42 	div %e4,%d4,%d15
8000555a:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
8000555c:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80005560:	4b 04 41 41 	itof %d4,%d4
80005564:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005568:	37 05 61 51 	extr.u %d5,%d5,2,1
8000556c:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005570:	ab e3 a0 35 	seln %d3,%d5,%d3,14
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005574:	3f 60 e3 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005578:	7b 20 00 40 	movh %d4,2
8000557c:	1b 04 2e 42 	addi %d4,%d4,8928
80005580:	4b f4 01 42 	div %e4,%d4,%d15
80005584:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005586:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
8000558a:	4b 04 41 41 	itof %d4,%d4
8000558e:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005592:	37 05 61 51 	extr.u %d5,%d5,2,1
80005596:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
8000559a:	ab d3 a0 35 	seln %d3,%d5,%d3,13
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000559e:	3f 60 ce 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800055a2:	7b 20 00 40 	movh %d4,2
800055a6:	1b 04 bd 4f 	addi %d4,%d4,-1072
800055aa:	4b f4 01 42 	div %e4,%d4,%d15
800055ae:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800055b0:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800055b4:	4b 04 41 41 	itof %d4,%d4
800055b8:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800055bc:	37 05 61 51 	extr.u %d5,%d5,2,1
800055c0:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800055c4:	ab c3 a0 35 	seln %d3,%d5,%d3,12
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800055c8:	3f 60 b9 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800055cc:	7b 20 00 40 	movh %d4,2
800055d0:	1b 04 4c 4d 	addi %d4,%d4,-11072
800055d4:	4b f4 01 42 	div %e4,%d4,%d15
800055d8:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800055da:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800055de:	4b 04 41 41 	itof %d4,%d4
800055e2:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800055e6:	37 05 61 51 	extr.u %d5,%d5,2,1
800055ea:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800055ee:	ab b3 a0 35 	seln %d3,%d5,%d3,11
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800055f2:	3f 60 a4 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800055f6:	7b 20 00 40 	movh %d4,2
800055fa:	1b 04 db 4a 	addi %d4,%d4,-21072
800055fe:	4b f4 01 42 	div %e4,%d4,%d15
80005602:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005604:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80005608:	4b 04 41 41 	itof %d4,%d4
8000560c:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005610:	37 05 61 51 	extr.u %d5,%d5,2,1
80005614:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005618:	ab a3 a0 35 	seln %d3,%d5,%d3,10
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000561c:	3f 60 8f 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005620:	7b 20 00 40 	movh %d4,2
80005624:	1b 04 6a 48 	addi %d4,%d4,-31072
80005628:	4b f4 01 42 	div %e4,%d4,%d15
8000562c:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
8000562e:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80005632:	4b 04 41 41 	itof %d4,%d4
80005636:	4b 42 01 50 	cmp.f %d5,%d2,%d4
8000563a:	37 05 61 51 	extr.u %d5,%d5,2,1
8000563e:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005642:	ab 93 a0 35 	seln %d3,%d5,%d3,9
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005646:	3f 60 7a 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
8000564a:	7b 10 00 40 	movh %d4,1
8000564e:	1b 04 f9 45 	addi %d4,%d4,24464
80005652:	4b f4 01 42 	div %e4,%d4,%d15
80005656:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005658:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
8000565c:	4b 04 41 41 	itof %d4,%d4
80005660:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005664:	37 05 61 51 	extr.u %d5,%d5,2,1
80005668:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
8000566c:	ab 83 a0 35 	seln %d3,%d5,%d3,8
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005670:	3f 60 65 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005674:	7b 10 00 40 	movh %d4,1
80005678:	1b 04 88 43 	addi %d4,%d4,14464
8000567c:	4b f4 01 42 	div %e4,%d4,%d15
80005680:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005682:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80005686:	4b 04 41 41 	itof %d4,%d4
8000568a:	4b 42 01 50 	cmp.f %d5,%d2,%d4
8000568e:	37 05 61 51 	extr.u %d5,%d5,2,1
80005692:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005696:	ab 73 a0 35 	seln %d3,%d5,%d3,7
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000569a:	3f 60 50 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
8000569e:	7b 10 00 40 	movh %d4,1
800056a2:	1b 04 17 41 	addi %d4,%d4,4464
800056a6:	4b f4 01 42 	div %e4,%d4,%d15
800056aa:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800056ac:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800056b0:	4b 04 41 41 	itof %d4,%d4
800056b4:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800056b8:	37 05 61 51 	extr.u %d5,%d5,2,1
800056bc:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800056c0:	ab 63 a0 35 	seln %d3,%d5,%d3,6
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800056c4:	3f 60 3b 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800056c8:	bb 00 a6 4e 	mov.u %d4,60000
800056cc:	4b f4 01 42 	div %e4,%d4,%d15
800056d0:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800056d2:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800056d6:	4b 04 41 41 	itof %d4,%d4
800056da:	4b 42 01 50 	cmp.f %d5,%d2,%d4
800056de:	37 05 61 51 	extr.u %d5,%d5,2,1
800056e2:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
800056e6:	ab 53 a0 35 	seln %d3,%d5,%d3,5
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
800056ea:	3f 60 28 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800056ee:	bb 00 35 4c 	mov.u %d4,50000
800056f2:	4b f4 01 42 	div %e4,%d4,%d15
800056f6:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800056f8:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
800056fc:	4b 04 41 41 	itof %d4,%d4
80005700:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005704:	37 05 61 51 	extr.u %d5,%d5,2,1
80005708:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
8000570c:	ab 43 a0 35 	seln %d3,%d5,%d3,4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005710:	3f 60 15 00 	jlt %d0,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005714:	bb 00 c4 49 	mov.u %d4,40000
80005718:	4b f4 01 42 	div %e4,%d4,%d15
8000571c:	02 45       	mov %d5,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
8000571e:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > (float)error)
80005722:	4b 04 41 41 	itof %d4,%d4
80005726:	4b 24 01 20 	cmp.f %d2,%d4,%d2
8000572a:	6f 02 09 81 	jnz.t %d2,0,8000593c <IfxMultican_Node_setBitTiming+0x4e4>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000572e:	3f 65 06 00 	jlt %d5,%d6,8000573a <IfxMultican_Node_setBitTiming+0x2e2>

            break;  /* least possible error has already occured */
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
80005732:	8b 03 01 22 	eq %d2,%d3,16
80005736:	df 02 06 81 	jne %d2,0,80005942 <IfxMultican_Node_setBitTiming+0x4ea>
8000573a:	1b f3 ff af 	addi %d10,%d3,-1
8000573e:	8f fa 00 a1 	and %d10,%d10,15
    {
        bestTSEG1 = minTSEG1;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;
80005742:	52 33       	sub %d3,%d15,%d3
80005744:	c2 f3       	add %d3,-1

    if (bestTSEG2 > maxTSEG2)
80005746:	8b 93 80 22 	ge %d2,%d3,9
8000574a:	df 02 36 80 	jne %d2,0,800057b6 <IfxMultican_Node_setBitTiming+0x35e>
8000574e:	1b f3 ff df 	addi %d13,%d3,-1
80005752:	8f 7d 00 d1 	and %d13,%d13,7
    {
        bestTSEG2 = maxTSEG2;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
80005756:	ff 23 33 00 	jge %d3,2,800057bc <IfxMultican_Node_setBitTiming+0x364>
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
8000575a:	3b 00 71 22 	mov %d2,10000
8000575e:	4b f2 01 22 	div %e2,%d2,%d15
80005762:	3b 00 e2 44 	mov %d4,20000
80005766:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
8000576a:	0b 72 e0 20 	absdif %d2,%d2,%d7
8000576e:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
80005772:	4b 02 41 61 	itof %d6,%d2
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005776:	0b 74 e0 f0 	absdif %d15,%d4,%d7
8000577a:	1b 05 00 54 	addi %d5,%d5,16384
8000577e:	4b 56 01 30 	cmp.f %d3,%d6,%d5

        if (bestError > error)
80005782:	4b 0f 41 f1 	itof %d15,%d15
80005786:	8f 43 00 31 	and %d3,%d3,4
8000578a:	2b 56 50 43 	seln %d4,%d3,%d6,%d5
8000578e:	4b 4f 01 40 	cmp.f %d4,%d15,%d4
80005792:	37 04 61 40 	extr.u %d4,%d4,0,1
80005796:	82 22       	mov %d2,2
80005798:	ab 12 80 24 	sel %d2,%d4,%d2,1
        }
    }

    {
        Ifx_CAN_N_BTR nbtr;
        nbtr.U       = 0;
8000579c:	82 0f       	mov %d15,0
        nbtr.B.BRP   = bestBRP - 1;
8000579e:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nbtr.B.SJW   = bestSJW - 1;
800057a2:	c2 f2       	add %d2,-1
800057a4:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);

        if (bestError > error)
800057a8:	82 1d       	mov %d13,1
    {
        Ifx_CAN_N_BTR nbtr;
        nbtr.U       = 0;
        nbtr.B.BRP   = bestBRP - 1;
        nbtr.B.SJW   = bestSJW - 1;
        nbtr.B.TSEG1 = bestTSEG1 - 1;
800057aa:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nbtr.B.TSEG2 = bestTSEG2 - 1;
        nbtr.B.DIV8  = 0;
800057ae:	37 df 04 f6 	insert %d15,%d15,%d13,12,4
        //nbtr.B.FTX = 0; /* TTCAN only */

        hwNode->BTR.U = nbtr.U;
800057b2:	6c 44       	st.w [%a4]16,%d15
800057b4:	00 90       	ret 
800057b6:	82 7d       	mov %d13,7

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;
800057b8:	3b 80 00 30 	mov %d3,8
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
800057bc:	3b 00 71 42 	mov %d4,10000
800057c0:	4b f4 01 42 	div %e4,%d4,%d15
800057c4:	3b 00 e2 04 	mov %d0,20000
800057c8:	4b f0 01 02 	div %e0,%d0,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800057cc:	0b 74 e0 40 	absdif %d4,%d4,%d7
800057d0:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
800057d4:	4b 04 41 41 	itof %d4,%d4
800057d8:	1b 05 00 54 	addi %d5,%d5,16384
800057dc:	4b 54 01 20 	cmp.f %d2,%d4,%d5
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800057e0:	0b 70 e0 00 	absdif %d0,%d0,%d7
800057e4:	8f 42 00 21 	and %d2,%d2,4
800057e8:	2b 54 50 42 	seln %d4,%d2,%d4,%d5

        if (bestError > error)
800057ec:	4b 00 41 51 	itof %d5,%d0
800057f0:	82 26       	mov %d6,2
800057f2:	4b 45 01 20 	cmp.f %d2,%d5,%d4
800057f6:	37 02 61 20 	extr.u %d2,%d2,0,1
800057fa:	4b 45 01 10 	cmp.f %d1,%d5,%d4
800057fe:	8f 41 00 11 	and %d1,%d1,4
80005802:	ab 16 80 22 	sel %d2,%d2,%d6,1
80005806:	2b 45 50 b1 	seln %d11,%d1,%d5,%d4
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
8000580a:	df 23 84 00 	jeq %d3,2,80005912 <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
8000580e:	3b 00 53 87 	mov %d8,30000
80005812:	4b f8 01 82 	div %e8,%d8,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005816:	0b 78 e0 80 	absdif %d8,%d8,%d7

        if (bestError > error)
8000581a:	4b 08 41 81 	itof %d8,%d8
8000581e:	4b 8b 01 40 	cmp.f %d4,%d11,%d8
80005822:	4b 8b 01 00 	cmp.f %d0,%d11,%d8
80005826:	87 44 a0 40 	or.t %d4,%d4,0,%d4,1
8000582a:	8f 40 00 01 	and %d0,%d0,4
8000582e:	ab 32 80 24 	sel %d2,%d4,%d2,3
80005832:	2b 8b 50 10 	seln %d1,%d0,%d11,%d8
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005836:	df 33 6e 00 	jeq %d3,3,80005912 <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
8000583a:	bb 00 c4 49 	mov.u %d4,40000
8000583e:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005842:	0b 74 e0 40 	absdif %d4,%d4,%d7

        if (bestError > error)
80005846:	4b 04 41 51 	itof %d5,%d4
8000584a:	4b 15 01 40 	cmp.f %d4,%d5,%d1
8000584e:	4b 15 01 60 	cmp.f %d6,%d5,%d1
80005852:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005856:	8f 46 00 61 	and %d6,%d6,4
8000585a:	ab 42 80 24 	sel %d2,%d4,%d2,4
8000585e:	2b 15 50 06 	seln %d0,%d6,%d5,%d1
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005862:	df 43 58 00 	jeq %d3,4,80005912 <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005866:	bb 00 35 4c 	mov.u %d4,50000
8000586a:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
8000586e:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80005872:	4b 05 41 51 	itof %d5,%d5
80005876:	4b 05 01 40 	cmp.f %d4,%d5,%d0
8000587a:	4b 05 01 60 	cmp.f %d6,%d5,%d0
8000587e:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005882:	8f 46 00 61 	and %d6,%d6,4
80005886:	ab 52 80 24 	sel %d2,%d4,%d2,5
8000588a:	2b 05 50 66 	seln %d6,%d6,%d5,%d0
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
8000588e:	df 53 42 00 	jeq %d3,5,80005912 <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005892:	bb 00 a6 4e 	mov.u %d4,60000
80005896:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
8000589a:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
8000589e:	4b 05 41 51 	itof %d5,%d5
800058a2:	4b 65 01 40 	cmp.f %d4,%d5,%d6
800058a6:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
800058aa:	ab 62 80 24 	sel %d2,%d4,%d2,6
800058ae:	4b 65 01 40 	cmp.f %d4,%d5,%d6
800058b2:	8f 44 00 41 	and %d4,%d4,4
800058b6:	2b 65 50 54 	seln %d5,%d4,%d5,%d6
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
800058ba:	df 63 2c 00 	jeq %d3,6,80005912 <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
800058be:	7b 10 00 00 	movh %d0,1
800058c2:	1b 00 17 01 	addi %d0,%d0,4464
800058c6:	4b f0 01 02 	div %e0,%d0,%d15
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
800058ca:	8b 83 20 32 	ne %d3,%d3,8
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800058ce:	0b 70 e0 00 	absdif %d0,%d0,%d7

        if (bestError > error)
800058d2:	4b 00 41 61 	itof %d6,%d0
800058d6:	4b 56 01 40 	cmp.f %d4,%d6,%d5
800058da:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
800058de:	ab 72 80 24 	sel %d2,%d4,%d2,7
800058e2:	4b 56 01 40 	cmp.f %d4,%d6,%d5
800058e6:	8f 44 00 41 	and %d4,%d4,4
800058ea:	2b 56 50 64 	seln %d6,%d4,%d6,%d5
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
800058ee:	df 03 12 80 	jne %d3,0,80005912 <IfxMultican_Node_setBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
800058f2:	7b 10 00 40 	movh %d4,1
800058f6:	1b 04 88 43 	addi %d4,%d4,14464
800058fa:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
800058fe:	0b 74 e0 f0 	absdif %d15,%d4,%d7

        if (bestError > error)
80005902:	4b 0f 41 f1 	itof %d15,%d15
80005906:	4b f6 01 70 	cmp.f %d7,%d6,%d15
8000590a:	87 77 a0 70 	or.t %d7,%d7,0,%d7,1
8000590e:	ab 82 80 27 	sel %d2,%d7,%d2,8
        }
    }

    {
        Ifx_CAN_N_BTR nbtr;
        nbtr.U       = 0;
80005912:	82 0f       	mov %d15,0
        nbtr.B.BRP   = bestBRP - 1;
80005914:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nbtr.B.SJW   = bestSJW - 1;
80005918:	c2 f2       	add %d2,-1
8000591a:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
        nbtr.B.TSEG1 = bestTSEG1 - 1;
8000591e:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nbtr.B.TSEG2 = bestTSEG2 - 1;
        nbtr.B.DIV8  = 0;
80005922:	37 df 04 f6 	insert %d15,%d15,%d13,12,4
        //nbtr.B.FTX = 0; /* TTCAN only */

        hwNode->BTR.U = nbtr.U;
80005926:	6c 44       	st.w [%a4]16,%d15
80005928:	00 90       	ret 
8000592a:	82 0c       	mov %d12,0
        bestBRP   = maxBRP;
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
8000592c:	df 0a df 7d 	jeq %d10,0,800054ea <IfxMultican_Node_setBitTiming+0x92>
80005930:	c2 fa       	add %d10,-1
80005932:	8f fa 03 c1 	and %d12,%d10,63
80005936:	02 bf       	mov %d15,%d11
80005938:	1d ff d9 fd 	j 800054ea <IfxMultican_Node_setBitTiming+0x92>
    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
8000593c:	82 33       	mov %d3,3
8000593e:	1d ff fe fe 	j 8000573a <IfxMultican_Node_setBitTiming+0x2e2>
80005942:	82 2a       	mov %d10,2
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
    {
        bestTSEG1 = minTSEG1;
80005944:	82 33       	mov %d3,3
80005946:	1d ff fe fe 	j 80005742 <IfxMultican_Node_setBitTiming+0x2ea>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
8000594a:	3b 00 01 30 	mov %d3,16
8000594e:	1d ff f6 fe 	j 8000573a <IfxMultican_Node_setBitTiming+0x2e2>

80005952 <IfxMultican_Node_setFastBitTiming>:
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005952:	4b 05 61 51 	utof %d5,%d5
80005956:	7b 00 f8 93 	movh %d9,16256
8000595a:	4b 59 51 90 	div.f %d9,%d9,%d5
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
8000595e:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005962:	7b d0 d4 83 	movh %d8,15693
80005966:	1b d8 cc 8c 	addi %d8,%d8,-13107
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
8000596a:	7b d0 dc c3 	movh %d12,15821
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
8000596e:	4b 85 41 80 	mul.f %d8,%d5,%d8
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
80005972:	3b 80 00 b0 	mov %d11,8
80005976:	82 0a       	mov %d10,0
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
80005978:	82 13       	mov %d3,1
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
8000597a:	1b dc cc cc 	addi %d12,%d12,-13107
    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = moduleFreq / tempBRP;
8000597e:	4b 03 41 21 	itof %d2,%d3
80005982:	4b 24 51 20 	div.f %d2,%d4,%d2
        tempTBAUD = Fquanta / baudrate;
80005986:	4b 92 41 00 	mul.f %d0,%d2,%d9
8000598a:	4b 00 31 f1 	ftoiz %d15,%d0

        if (tempTBAUD == 0)
8000598e:	df 0f 4b 02 	jeq %d15,0,80005e24 <IfxMultican_Node_setFastBitTiming+0x4d2>
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
80005992:	4b 0f 41 01 	itof %d0,%d15
80005996:	4b 02 51 20 	div.f %d2,%d2,%d0
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
8000599a:	8b 8f 80 02 	ge %d0,%d15,8
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);
8000599e:	6b 05 31 22 	sub.f %d2,%d2,%d5
800059a2:	b7 02 81 2f 	insert %d2,%d2,0,31,1

        if (tempTBAUD < minTBAUD)
800059a6:	df 00 3f 02 	jeq %d0,0,80005e24 <IfxMultican_Node_setFastBitTiming+0x4d2>
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
800059aa:	4b 28 01 00 	cmp.f %d0,%d8,%d2
800059ae:	87 00 a2 00 	or.t %d0,%d0,2,%d0,1
800059b2:	8b af 41 12 	lt %d1,%d15,26
800059b6:	26 10       	and %d0,%d1
800059b8:	76 0a       	jz %d0,800059cc <IfxMultican_Node_setFastBitTiming+0x7a>
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
800059ba:	4b c2 01 10 	cmp.f %d1,%d2,%d12
800059be:	8b 5f 41 02 	lt %d0,%d15,21
800059c2:	26 10       	and %d0,%d1
800059c4:	f6 0d       	jnz %d0,800059de <IfxMultican_Node_setFastBitTiming+0x8c>

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;
800059c6:	02 28       	mov %d8,%d2
800059c8:	0b 3f 10 a8 	mov %e10,%d15,%d3
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
800059cc:	c2 13       	add %d3,1
800059ce:	fd f0 d8 7f 	loop %a15,8000597e <IfxMultican_Node_setFastBitTiming+0x2c>
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
800059d2:	f6 a4       	jnz %d10,800059da <IfxMultican_Node_setFastBitTiming+0x88>
800059d4:	3b f0 03 c0 	mov %d12,63
800059d8:	3c 06       	j 800059e4 <IfxMultican_Node_setFastBitTiming+0x92>
800059da:	02 bf       	mov %d15,%d11
800059dc:	02 a3       	mov %d3,%d10
800059de:	c2 f3       	add %d3,-1
800059e0:	8f f3 03 c1 	and %d12,%d3,63

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800059e4:	7b 30 00 40 	movh %d4,3
800059e8:	1b 04 81 49 	addi %d4,%d4,-26608
800059ec:	4b f4 01 42 	div %e4,%d4,%d15
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
800059f0:	4b 06 41 31 	itof %d3,%d6
800059f4:	7b a0 e1 23 	movh %d2,15898

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
800059f8:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
800059fa:	0b 64 e0 40 	absdif %d4,%d4,%d6
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
800059fe:	1b a2 99 29 	addi %d2,%d2,-26214
80005a02:	4b 23 41 30 	mul.f %d3,%d3,%d2
    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > error)
80005a06:	4b 04 41 41 	itof %d4,%d4
80005a0a:	4b 43 01 50 	cmp.f %d5,%d3,%d4
80005a0e:	8f 45 00 51 	and %d5,%d5,4
80005a12:	2b 43 50 25 	seln %d2,%d5,%d3,%d4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005a16:	3f 60 17 02 	jlt %d0,%d6,80005e44 <IfxMultican_Node_setFastBitTiming+0x4f2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005a1a:	7b 20 00 40 	movh %d4,2
80005a1e:	1b 04 10 47 	addi %d4,%d4,28928
80005a22:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > error)
80005a26:	3b f0 00 30 	mov %d3,15

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005a2a:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005a2c:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005a30:	4b 04 41 41 	itof %d4,%d4
80005a34:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005a38:	37 05 61 51 	extr.u %d5,%d5,2,1
80005a3c:	ab 03 81 35 	sel %d3,%d5,%d3,16
80005a40:	2b 24 40 25 	sel %d2,%d5,%d4,%d2
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005a44:	3f 60 f8 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005a48:	7b 20 00 40 	movh %d4,2
80005a4c:	1b 04 9f 44 	addi %d4,%d4,18928
80005a50:	4b f4 01 42 	div %e4,%d4,%d15
80005a54:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005a56:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005a5a:	4b 04 41 41 	itof %d4,%d4
80005a5e:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005a62:	37 05 61 51 	extr.u %d5,%d5,2,1
80005a66:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005a6a:	ab e3 a0 35 	seln %d3,%d5,%d3,14
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005a6e:	3f 60 e3 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005a72:	7b 20 00 40 	movh %d4,2
80005a76:	1b 04 2e 42 	addi %d4,%d4,8928
80005a7a:	4b f4 01 42 	div %e4,%d4,%d15
80005a7e:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005a80:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005a84:	4b 04 41 41 	itof %d4,%d4
80005a88:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005a8c:	37 05 61 51 	extr.u %d5,%d5,2,1
80005a90:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005a94:	ab d3 a0 35 	seln %d3,%d5,%d3,13
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005a98:	3f 60 ce 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005a9c:	7b 20 00 40 	movh %d4,2
80005aa0:	1b 04 bd 4f 	addi %d4,%d4,-1072
80005aa4:	4b f4 01 42 	div %e4,%d4,%d15
80005aa8:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005aaa:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005aae:	4b 04 41 41 	itof %d4,%d4
80005ab2:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005ab6:	37 05 61 51 	extr.u %d5,%d5,2,1
80005aba:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005abe:	ab c3 a0 35 	seln %d3,%d5,%d3,12
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005ac2:	3f 60 b9 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005ac6:	7b 20 00 40 	movh %d4,2
80005aca:	1b 04 4c 4d 	addi %d4,%d4,-11072
80005ace:	4b f4 01 42 	div %e4,%d4,%d15
80005ad2:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005ad4:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005ad8:	4b 04 41 41 	itof %d4,%d4
80005adc:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005ae0:	37 05 61 51 	extr.u %d5,%d5,2,1
80005ae4:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005ae8:	ab b3 a0 35 	seln %d3,%d5,%d3,11
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005aec:	3f 60 a4 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005af0:	7b 20 00 40 	movh %d4,2
80005af4:	1b 04 db 4a 	addi %d4,%d4,-21072
80005af8:	4b f4 01 42 	div %e4,%d4,%d15
80005afc:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005afe:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005b02:	4b 04 41 41 	itof %d4,%d4
80005b06:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005b0a:	37 05 61 51 	extr.u %d5,%d5,2,1
80005b0e:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005b12:	ab a3 a0 35 	seln %d3,%d5,%d3,10
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005b16:	3f 60 8f 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005b1a:	7b 20 00 40 	movh %d4,2
80005b1e:	1b 04 6a 48 	addi %d4,%d4,-31072
80005b22:	4b f4 01 42 	div %e4,%d4,%d15
80005b26:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005b28:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005b2c:	4b 04 41 41 	itof %d4,%d4
80005b30:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005b34:	37 05 61 51 	extr.u %d5,%d5,2,1
80005b38:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005b3c:	ab 93 a0 35 	seln %d3,%d5,%d3,9
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005b40:	3f 60 7a 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005b44:	7b 10 00 40 	movh %d4,1
80005b48:	1b 04 f9 45 	addi %d4,%d4,24464
80005b4c:	4b f4 01 42 	div %e4,%d4,%d15
80005b50:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005b52:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005b56:	4b 04 41 41 	itof %d4,%d4
80005b5a:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005b5e:	37 05 61 51 	extr.u %d5,%d5,2,1
80005b62:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005b66:	ab 83 a0 35 	seln %d3,%d5,%d3,8
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005b6a:	3f 60 65 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005b6e:	7b 10 00 40 	movh %d4,1
80005b72:	1b 04 88 43 	addi %d4,%d4,14464
80005b76:	4b f4 01 42 	div %e4,%d4,%d15
80005b7a:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005b7c:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005b80:	4b 04 41 41 	itof %d4,%d4
80005b84:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005b88:	37 05 61 51 	extr.u %d5,%d5,2,1
80005b8c:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005b90:	ab 73 a0 35 	seln %d3,%d5,%d3,7
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005b94:	3f 60 50 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005b98:	7b 10 00 40 	movh %d4,1
80005b9c:	1b 04 17 41 	addi %d4,%d4,4464
80005ba0:	4b f4 01 42 	div %e4,%d4,%d15
80005ba4:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005ba6:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005baa:	4b 04 41 41 	itof %d4,%d4
80005bae:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005bb2:	37 05 61 51 	extr.u %d5,%d5,2,1
80005bb6:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005bba:	ab 63 a0 35 	seln %d3,%d5,%d3,6
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005bbe:	3f 60 3b 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005bc2:	bb 00 a6 4e 	mov.u %d4,60000
80005bc6:	4b f4 01 42 	div %e4,%d4,%d15
80005bca:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005bcc:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005bd0:	4b 04 41 41 	itof %d4,%d4
80005bd4:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005bd8:	37 05 61 51 	extr.u %d5,%d5,2,1
80005bdc:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005be0:	ab 53 a0 35 	seln %d3,%d5,%d3,5
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005be4:	3f 60 28 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005be8:	bb 00 35 4c 	mov.u %d4,50000
80005bec:	4b f4 01 42 	div %e4,%d4,%d15
80005bf0:	02 40       	mov %d0,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005bf2:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005bf6:	4b 04 41 41 	itof %d4,%d4
80005bfa:	4b 42 01 50 	cmp.f %d5,%d2,%d4
80005bfe:	37 05 61 51 	extr.u %d5,%d5,2,1
80005c02:	2b 42 50 25 	seln %d2,%d5,%d2,%d4
80005c06:	ab 43 a0 35 	seln %d3,%d5,%d3,4
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005c0a:	3f 60 15 00 	jlt %d0,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005c0e:	bb 00 c4 49 	mov.u %d4,40000
80005c12:	4b f4 01 42 	div %e4,%d4,%d15
80005c16:	02 45       	mov %d5,%d4
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005c18:	0b 64 e0 40 	absdif %d4,%d4,%d6

        if (bestError > error)
80005c1c:	4b 04 41 41 	itof %d4,%d4
80005c20:	4b 24 01 20 	cmp.f %d2,%d4,%d2
80005c24:	6f 02 09 81 	jnz.t %d2,0,80005e36 <IfxMultican_Node_setFastBitTiming+0x4e4>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005c28:	3f 65 06 00 	jlt %d5,%d6,80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

            break;  /* least possible error has already occured */
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
80005c2c:	8b 03 01 22 	eq %d2,%d3,16
80005c30:	df 02 06 81 	jne %d2,0,80005e3c <IfxMultican_Node_setFastBitTiming+0x4ea>
80005c34:	1b f3 ff af 	addi %d10,%d3,-1
80005c38:	8f fa 00 a1 	and %d10,%d10,15
    {
        bestTSEG1 = minTSEG1;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;
80005c3c:	52 33       	sub %d3,%d15,%d3
80005c3e:	c2 f3       	add %d3,-1

    if (bestTSEG2 > maxTSEG2)
80005c40:	8b 93 80 22 	ge %d2,%d3,9
80005c44:	df 02 36 80 	jne %d2,0,80005cb0 <IfxMultican_Node_setFastBitTiming+0x35e>
80005c48:	1b f3 ff df 	addi %d13,%d3,-1
80005c4c:	8f 7d 00 d1 	and %d13,%d13,7
    {
        bestTSEG2 = maxTSEG2;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
80005c50:	ff 23 33 00 	jge %d3,2,80005cb6 <IfxMultican_Node_setFastBitTiming+0x364>
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005c54:	3b 00 71 22 	mov %d2,10000
80005c58:	4b f2 01 22 	div %e2,%d2,%d15
80005c5c:	3b 00 e2 44 	mov %d4,20000
80005c60:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005c64:	0b 72 e0 20 	absdif %d2,%d2,%d7
80005c68:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
80005c6c:	4b 02 41 61 	itof %d6,%d2
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005c70:	0b 74 e0 f0 	absdif %d15,%d4,%d7
80005c74:	1b 05 00 54 	addi %d5,%d5,16384
80005c78:	4b 56 01 30 	cmp.f %d3,%d6,%d5

        if (bestError > error)
80005c7c:	4b 0f 41 f1 	itof %d15,%d15
80005c80:	8f 43 00 31 	and %d3,%d3,4
80005c84:	2b 56 50 43 	seln %d4,%d3,%d6,%d5
80005c88:	4b 4f 01 40 	cmp.f %d4,%d15,%d4
80005c8c:	37 04 61 40 	extr.u %d4,%d4,0,1
80005c90:	82 22       	mov %d2,2
80005c92:	ab 12 80 24 	sel %d2,%d4,%d2,1
        }
    }

    {
        Ifx_CAN_N_FBTR nfbtr;
        nfbtr.U        = 0;
80005c96:	82 0f       	mov %d15,0
        nfbtr.B.FBRP   = bestBRP - 1;
80005c98:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nfbtr.B.FSJW   = bestSJW - 1;
80005c9c:	c2 f2       	add %d2,-1
80005c9e:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);

        if (bestError > error)
80005ca2:	82 1d       	mov %d13,1
    {
        Ifx_CAN_N_FBTR nfbtr;
        nfbtr.U        = 0;
        nfbtr.B.FBRP   = bestBRP - 1;
        nfbtr.B.FSJW   = bestSJW - 1;
        nfbtr.B.FTSEG1 = bestTSEG1 - 1;
80005ca4:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nfbtr.B.FTSEG2 = bestTSEG2 - 1;
80005ca8:	37 df 03 f6 	insert %d15,%d15,%d13,12,3

        hwNode->FBTR.U = nfbtr.U;
80005cac:	6c 4e       	st.w [%a4]56,%d15
80005cae:	00 90       	ret 
80005cb0:	82 7d       	mov %d13,7

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;
80005cb2:	3b 80 00 30 	mov %d3,8
    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005cb6:	3b 00 71 42 	mov %d4,10000
80005cba:	4b f4 01 42 	div %e4,%d4,%d15
80005cbe:	3b 00 e2 04 	mov %d0,20000
80005cc2:	4b f0 01 02 	div %e0,%d0,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005cc6:	0b 74 e0 40 	absdif %d4,%d4,%d7
80005cca:	7b c0 61 54 	movh %d5,17948

        if (bestError > error)
80005cce:	4b 04 41 41 	itof %d4,%d4
80005cd2:	1b 05 00 54 	addi %d5,%d5,16384
80005cd6:	4b 54 01 20 	cmp.f %d2,%d4,%d5
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005cda:	0b 70 e0 00 	absdif %d0,%d0,%d7
80005cde:	8f 42 00 21 	and %d2,%d2,4
80005ce2:	2b 54 50 42 	seln %d4,%d2,%d4,%d5

        if (bestError > error)
80005ce6:	4b 00 41 51 	itof %d5,%d0
80005cea:	82 26       	mov %d6,2
80005cec:	4b 45 01 20 	cmp.f %d2,%d5,%d4
80005cf0:	37 02 61 20 	extr.u %d2,%d2,0,1
80005cf4:	4b 45 01 10 	cmp.f %d1,%d5,%d4
80005cf8:	8f 41 00 11 	and %d1,%d1,4
80005cfc:	ab 16 80 22 	sel %d2,%d2,%d6,1
80005d00:	2b 45 50 b1 	seln %d11,%d1,%d5,%d4
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005d04:	df 23 84 00 	jeq %d3,2,80005e0c <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005d08:	3b 00 53 87 	mov %d8,30000
80005d0c:	4b f8 01 82 	div %e8,%d8,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005d10:	0b 78 e0 80 	absdif %d8,%d8,%d7

        if (bestError > error)
80005d14:	4b 08 41 81 	itof %d8,%d8
80005d18:	4b 8b 01 40 	cmp.f %d4,%d11,%d8
80005d1c:	4b 8b 01 00 	cmp.f %d0,%d11,%d8
80005d20:	87 44 a0 40 	or.t %d4,%d4,0,%d4,1
80005d24:	8f 40 00 01 	and %d0,%d0,4
80005d28:	ab 32 80 24 	sel %d2,%d4,%d2,3
80005d2c:	2b 8b 50 10 	seln %d1,%d0,%d11,%d8
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005d30:	df 33 6e 00 	jeq %d3,3,80005e0c <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005d34:	bb 00 c4 49 	mov.u %d4,40000
80005d38:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005d3c:	0b 74 e0 40 	absdif %d4,%d4,%d7

        if (bestError > error)
80005d40:	4b 04 41 51 	itof %d5,%d4
80005d44:	4b 15 01 40 	cmp.f %d4,%d5,%d1
80005d48:	4b 15 01 60 	cmp.f %d6,%d5,%d1
80005d4c:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005d50:	8f 46 00 61 	and %d6,%d6,4
80005d54:	ab 42 80 24 	sel %d2,%d4,%d2,4
80005d58:	2b 15 50 06 	seln %d0,%d6,%d5,%d1
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005d5c:	df 43 58 00 	jeq %d3,4,80005e0c <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005d60:	bb 00 35 4c 	mov.u %d4,50000
80005d64:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005d68:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80005d6c:	4b 05 41 51 	itof %d5,%d5
80005d70:	4b 05 01 40 	cmp.f %d4,%d5,%d0
80005d74:	4b 05 01 60 	cmp.f %d6,%d5,%d0
80005d78:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005d7c:	8f 46 00 61 	and %d6,%d6,4
80005d80:	ab 52 80 24 	sel %d2,%d4,%d2,5
80005d84:	2b 05 50 66 	seln %d6,%d6,%d5,%d0
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005d88:	df 53 42 00 	jeq %d3,5,80005e0c <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005d8c:	bb 00 a6 4e 	mov.u %d4,60000
80005d90:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005d94:	0b 74 e0 50 	absdif %d5,%d4,%d7

        if (bestError > error)
80005d98:	4b 05 41 51 	itof %d5,%d5
80005d9c:	4b 65 01 40 	cmp.f %d4,%d5,%d6
80005da0:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005da4:	ab 62 80 24 	sel %d2,%d4,%d2,6
80005da8:	4b 65 01 40 	cmp.f %d4,%d5,%d6
80005dac:	8f 44 00 41 	and %d4,%d4,4
80005db0:	2b 65 50 54 	seln %d5,%d4,%d5,%d6
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005db4:	df 63 2c 00 	jeq %d3,6,80005e0c <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005db8:	7b 10 00 00 	movh %d0,1
80005dbc:	1b 00 17 01 	addi %d0,%d0,4464
80005dc0:	4b f0 01 02 	div %e0,%d0,%d15
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005dc4:	8b 83 20 32 	ne %d3,%d3,8
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005dc8:	0b 70 e0 00 	absdif %d0,%d0,%d7

        if (bestError > error)
80005dcc:	4b 00 41 61 	itof %d6,%d0
80005dd0:	4b 56 01 40 	cmp.f %d4,%d6,%d5
80005dd4:	87 44 a2 40 	or.t %d4,%d4,2,%d4,1
80005dd8:	ab 72 80 24 	sel %d2,%d4,%d2,7
80005ddc:	4b 56 01 40 	cmp.f %d4,%d6,%d5
80005de0:	8f 44 00 41 	and %d4,%d4,4
80005de4:	2b 56 50 64 	seln %d6,%d4,%d6,%d5
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005de8:	df 03 12 80 	jne %d3,0,80005e0c <IfxMultican_Node_setFastBitTiming+0x4ba>
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005dec:	7b 10 00 40 	movh %d4,1
80005df0:	1b 04 88 43 	addi %d4,%d4,14464
80005df4:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005df8:	0b 74 e0 f0 	absdif %d15,%d4,%d7

        if (bestError > error)
80005dfc:	4b 0f 41 f1 	itof %d15,%d15
80005e00:	4b f6 01 70 	cmp.f %d7,%d6,%d15
80005e04:	87 77 a0 70 	or.t %d7,%d7,0,%d7,1
80005e08:	ab 82 80 27 	sel %d2,%d7,%d2,8
        }
    }

    {
        Ifx_CAN_N_FBTR nfbtr;
        nfbtr.U        = 0;
80005e0c:	82 0f       	mov %d15,0
        nfbtr.B.FBRP   = bestBRP - 1;
80005e0e:	37 cf 06 f0 	insert %d15,%d15,%d12,0,6
        nfbtr.B.FSJW   = bestSJW - 1;
80005e12:	c2 f2       	add %d2,-1
80005e14:	37 2f 02 f3 	insert %d15,%d15,%d2,6,2
        nfbtr.B.FTSEG1 = bestTSEG1 - 1;
80005e18:	37 af 04 f4 	insert %d15,%d15,%d10,8,4
        nfbtr.B.FTSEG2 = bestTSEG2 - 1;
80005e1c:	37 df 03 f6 	insert %d15,%d15,%d13,12,3

        hwNode->FBTR.U = nfbtr.U;
80005e20:	6c 4e       	st.w [%a4]56,%d15
80005e22:	00 90       	ret 
80005e24:	82 0c       	mov %d12,0
        bestBRP   = maxBRP;
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
80005e26:	df 0a df 7d 	jeq %d10,0,800059e4 <IfxMultican_Node_setFastBitTiming+0x92>
80005e2a:	c2 fa       	add %d10,-1
80005e2c:	8f fa 03 c1 	and %d12,%d10,63
80005e30:	02 bf       	mov %d15,%d11
80005e32:	1d ff d9 fd 	j 800059e4 <IfxMultican_Node_setFastBitTiming+0x92>
    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
80005e36:	82 33       	mov %d3,3
80005e38:	1d ff fe fe 	j 80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>
80005e3c:	82 2a       	mov %d10,2
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
    {
        bestTSEG1 = minTSEG1;
80005e3e:	82 33       	mov %d3,3
80005e40:	1d ff fe fe 	j 80005c3c <IfxMultican_Node_setFastBitTiming+0x2ea>
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
80005e44:	3b 00 01 30 	mov %d3,16
80005e48:	1d ff f6 fe 	j 80005c34 <IfxMultican_Node_setFastBitTiming+0x2e2>

80005e4c <IfxMultican_Node_setNominalBitTiming>:
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005e4c:	4b 05 61 51 	utof %d5,%d5
80005e50:	7b 00 f8 93 	movh %d9,16256
80005e54:	4b 59 51 90 	div.f %d9,%d9,%d5
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005e58:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005e5c:	7b d0 d4 83 	movh %d8,15693
80005e60:	1b d8 cc 8c 	addi %d8,%d8,-13107
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005e64:	7b d0 dc c3 	movh %d12,15821
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */
80005e68:	4b 85 41 80 	mul.f %d8,%d5,%d8
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
80005e6c:	3b 80 00 b0 	mov %d11,8
80005e70:	82 0a       	mov %d10,0
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
80005e72:	82 13       	mov %d3,1
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005e74:	1b dc cc cc 	addi %d12,%d12,-13107
    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = moduleFreq / tempBRP;
80005e78:	4b 03 41 21 	itof %d2,%d3
80005e7c:	4b 24 51 20 	div.f %d2,%d4,%d2
        tempTBAUD = Fquanta / baudrate;
80005e80:	4b 92 41 f0 	mul.f %d15,%d2,%d9
80005e84:	4b 0f 31 f1 	ftoiz %d15,%d15

        if (tempTBAUD == 0)
80005e88:	df 0f 98 00 	jeq %d15,0,80005fb8 <IfxMultican_Node_setNominalBitTiming+0x16c>
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
80005e8c:	4b 0f 41 01 	itof %d0,%d15
80005e90:	4b 02 51 20 	div.f %d2,%d2,%d0
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
80005e94:	8b 8f 80 02 	ge %d0,%d15,8
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);
80005e98:	6b 05 31 22 	sub.f %d2,%d2,%d5
80005e9c:	b7 02 81 2f 	insert %d2,%d2,0,31,1

        if (tempTBAUD < minTBAUD)
80005ea0:	df 00 8c 00 	jeq %d0,0,80005fb8 <IfxMultican_Node_setNominalBitTiming+0x16c>
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
80005ea4:	4b 28 01 00 	cmp.f %d0,%d8,%d2
80005ea8:	87 00 a2 00 	or.t %d0,%d0,2,%d0,1
80005eac:	8b 2f 46 12 	lt %d1,%d15,98
80005eb0:	26 10       	and %d0,%d1
80005eb2:	76 0a       	jz %d0,80005ec6 <IfxMultican_Node_setNominalBitTiming+0x7a>
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
80005eb4:	4b c2 01 10 	cmp.f %d1,%d2,%d12
80005eb8:	8b 5f 41 02 	lt %d0,%d15,21
80005ebc:	26 10       	and %d0,%d1
80005ebe:	f6 0d       	jnz %d0,80005ed8 <IfxMultican_Node_setNominalBitTiming+0x8c>

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = (float)error;
80005ec0:	02 28       	mov %d8,%d2
80005ec2:	0b 3f 10 a8 	mov %e10,%d15,%d3
     */

    /* search for best baudrate */
    bestError = baudrate * 0.05f; /* 5% tolerance in baudrate as max error */

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
80005ec6:	c2 13       	add %d3,1
80005ec8:	fd f0 d8 7f 	loop %a15,80005e78 <IfxMultican_Node_setNominalBitTiming+0x2c>
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
80005ecc:	f6 a4       	jnz %d10,80005ed4 <IfxMultican_Node_setNominalBitTiming+0x88>
80005ece:	3b f0 03 90 	mov %d9,63
80005ed2:	3c 06       	j 80005ede <IfxMultican_Node_setNominalBitTiming+0x92>
80005ed4:	02 bf       	mov %d15,%d11
80005ed6:	02 a3       	mov %d3,%d10
80005ed8:	c2 f3       	add %d3,-1
80005eda:	8f f3 03 91 	and %d9,%d3,63
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */
80005ede:	4b 06 41 41 	itof %d4,%d6
80005ee2:	7b a0 e1 23 	movh %d2,15898
80005ee6:	1b a2 99 29 	addi %d2,%d2,-26214
80005eea:	7b a0 00 00 	movh %d0,10
80005eee:	4b 24 41 40 	mul.f %d4,%d4,%d2
80005ef2:	1b 00 b1 0e 	addi %d0,%d0,-5360

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
80005ef6:	3b 00 04 10 	mov %d1,64
80005efa:	3b 00 04 50 	mov %d5,64
80005efe:	c5 0f 3d 00 	lea %a15,3d <_.+0x3c>
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
80005f02:	4b f0 01 22 	div %e2,%d0,%d15
80005f06:	02 28       	mov %d8,%d2
        sint32 error           = __abs(tempSamplePoint - samplePoint);
80005f08:	0b 62 e0 20 	absdif %d2,%d2,%d6

        if (bestError > error)
80005f0c:	4b 02 41 21 	itof %d2,%d2
80005f10:	4b 42 01 30 	cmp.f %d3,%d2,%d4
80005f14:	37 03 61 30 	extr.u %d3,%d3,0,1
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
80005f18:	2b 24 50 43 	seln %d4,%d3,%d4,%d2
80005f1c:	2b 15 50 53 	seln %d5,%d3,%d5,%d1
        }

        if (tempSamplePoint < samplePoint)
80005f20:	3f 68 0b 00 	jlt %d8,%d6,80005f36 <IfxMultican_Node_setNominalBitTiming+0xea>
    /* search for best sample point */
    bestError = samplePoint * 0.15f; /* 15% tolerance in sample point as max error */

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
80005f24:	c2 f1       	add %d1,-1
80005f26:	1b 00 8f 0d 	addi %d0,%d0,-10000
80005f2a:	fd f0 ec 7f 	loop %a15,80005f02 <IfxMultican_Node_setNominalBitTiming+0xb6>

            break;  /* least possible error has already occured */
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
80005f2e:	8b 05 04 22 	eq %d2,%d5,64
80005f32:	df 02 50 80 	jne %d2,0,80005fd2 <IfxMultican_Node_setNominalBitTiming+0x186>
80005f36:	1b f5 ff 8f 	addi %d8,%d5,-1
80005f3a:	8f f8 03 81 	and %d8,%d8,63
    {
        bestTSEG1 = minTSEG1;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;
80005f3e:	52 55       	sub %d5,%d15,%d5
80005f40:	c2 f5       	add %d5,-1

    if (bestTSEG2 > maxTSEG2)
80005f42:	8b 15 82 22 	ge %d2,%d5,33
80005f46:	df 02 41 80 	jne %d2,0,80005fc8 <IfxMultican_Node_setNominalBitTiming+0x17c>
80005f4a:	1b f5 ff af 	addi %d10,%d5,-1
80005f4e:	8f fa 01 a1 	and %d10,%d10,31
    {
        bestTSEG2 = maxTSEG2;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
80005f52:	ff 25 04 00 	jge %d5,2,80005f5a <IfxMultican_Node_setNominalBitTiming+0x10e>
80005f56:	82 1a       	mov %d10,1
    {
        bestTSEG2 = minTSEG2;
80005f58:	82 25       	mov %d5,2
80005f5a:	60 5f       	mov.a %a15,%d5
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best SJW */
    bestError = 10000;
80005f5c:	7b c0 61 24 	movh %d2,17948
80005f60:	1b 02 00 24 	addi %d2,%d2,16384
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = maxTSEG1 + maxTSEG2 + 1;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 0, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
80005f64:	82 10       	mov %d0,1
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005f66:	82 16       	mov %d6,1
80005f68:	3b 00 71 12 	mov %d1,10000
80005f6c:	b0 ff       	add.a %a15,-1
80005f6e:	73 16 0a 40 	mul %d4,%d6,%d1
    {
        sint32 tempSynchJumpWidth = (tempSJW * 10000) / bestTBAUD;
80005f72:	4b f4 01 42 	div %e4,%d4,%d15
        sint32 error              = __abs(tempSynchJumpWidth - synchJumpWidth);
80005f76:	0b 74 e0 40 	absdif %d4,%d4,%d7

        if (bestError > error)
80005f7a:	4b 04 41 31 	itof %d3,%d4
80005f7e:	4b 23 01 40 	cmp.f %d4,%d3,%d2
80005f82:	37 04 61 40 	extr.u %d4,%d4,0,1
80005f86:	2b 06 40 04 	sel %d0,%d4,%d6,%d0
80005f8a:	4b 23 01 40 	cmp.f %d4,%d3,%d2
80005f8e:	8f 44 00 41 	and %d4,%d4,4
80005f92:	2b 23 50 24 	seln %d2,%d4,%d3,%d2
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
80005f96:	c2 16       	add %d6,1
80005f98:	fd f0 eb 7f 	loop %a15,80005f6e <IfxMultican_Node_setNominalBitTiming+0x122>
        }
    }

    {
        Ifx_CAN_N_BTEVR nbtevr;
        nbtevr.U       = 0;
80005f9c:	82 0f       	mov %d15,0
        nbtevr.B.BRP   = bestBRP - 1;
80005f9e:	37 9f 06 f0 	insert %d15,%d15,%d9,0,6
        nbtevr.B.SJW   = bestSJW - 1;
80005fa2:	c2 f0       	add %d0,-1
80005fa4:	37 0f 04 f4 	insert %d15,%d15,%d0,8,4
        nbtevr.B.TSEG1 = bestTSEG1 - 1;
80005fa8:	37 8f 06 fb 	insert %d15,%d15,%d8,22,6
        nbtevr.B.TSEG2 = bestTSEG2 - 1;
80005fac:	37 af 05 f8 	insert %d15,%d15,%d10,16,5
        nbtevr.B.DIV8  = 0;
80005fb0:	b7 0f 81 f7 	insert %d15,%d15,0,15,1
        //nbtr.B.FTX = 0; /* TTCAN only */

        hwNode->BTEVR.U = nbtevr.U;
80005fb4:	6c 44       	st.w [%a4]16,%d15
80005fb6:	00 90       	ret 
80005fb8:	82 09       	mov %d9,0
        bestBRP   = maxBRP;
        bestTBAUD = tempTBAUD;
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
80005fba:	df 0a 92 7f 	jeq %d10,0,80005ede <IfxMultican_Node_setNominalBitTiming+0x92>
80005fbe:	c2 fa       	add %d10,-1
80005fc0:	8f fa 03 91 	and %d9,%d10,63
80005fc4:	02 bf       	mov %d15,%d11
80005fc6:	3c 8c       	j 80005ede <IfxMultican_Node_setNominalBitTiming+0x92>
80005fc8:	3b f0 01 a0 	mov %d10,31

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;
80005fcc:	3b 00 02 50 	mov %d5,32
80005fd0:	3c c5       	j 80005f5a <IfxMultican_Node_setNominalBitTiming+0x10e>
80005fd2:	82 28       	mov %d8,2
        }
    }

    if ((tempTSEG1 == (minTSEG1 - 1)) && (bestTSEG1 == maxTSEG1))
    {
        bestTSEG1 = minTSEG1;
80005fd4:	82 35       	mov %d5,3
80005fd6:	3c b4       	j 80005f3e <IfxMultican_Node_setNominalBitTiming+0xf2>

80005fd8 <IfxMultican_calcTimingFromBTR>:
void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
80005fd8:	37 05 64 04 	extr.u %d0,%d5,8,4
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
80005fdc:	37 05 63 f6 	extr.u %d15,%d5,12,3
void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
80005fe0:	c2 10       	add %d0,1
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;
80005fe2:	bb 00 00 68 	mov.u %d6,32768
80005fe6:	c2 2f       	add %d15,2


void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
80005fe8:	8f f5 03 71 	and %d7,%d5,63
    uint32        tempSJW   = 1U + nbtr.B.SJW;
80005fec:	37 05 62 33 	extr.u %d3,%d5,6,2
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;
80005ff0:	3b 80 00 20 	mov %d2,8
80005ff4:	26 65       	and %d5,%d6

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;
80005ff6:	42 0f       	add %d15,%d0
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
    uint32        tempTSEG1 = 1U + nbtr.B.TSEG1;
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;
80005ff8:	ab 12 80 65 	sel %d6,%d5,%d2,1
80005ffc:	03 f7 0a 5f 	madd %d5,%d15,%d7,%d15

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80006000:	e2 65       	mul %d5,%d6

void IfxMultican_calcTimingFromBTR(float32 moduleFreq, uint32 btr, uint32 *baudrate, uint16 *samplePoint, uint16 *synchJumpWidth)
{
    Ifx_CAN_N_BTR nbtr      = {.U = btr};
    uint32        tempBRP   = 1U + nbtr.B.BRP;
    uint32        tempSJW   = 1U + nbtr.B.SJW;
80006002:	c2 13       	add %d3,1
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
80006004:	7b c0 61 24 	movh %d2,17948
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80006008:	4b 05 41 51 	itof %d5,%d5
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
8000600c:	1b 02 00 24 	addi %d2,%d2,16384
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80006010:	4b 54 51 40 	div.f %d4,%d4,%d5
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80006014:	4b 03 41 31 	itof %d3,%d3
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80006018:	4b 04 71 51 	ftouz %d5,%d4
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
8000601c:	4b 00 41 41 	itof %d4,%d0
80006020:	4b 0f 41 f1 	itof %d15,%d15
80006024:	4b 24 41 40 	mul.f %d4,%d4,%d2
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80006028:	4b 23 41 20 	mul.f %d2,%d3,%d2
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
8000602c:	4b f4 51 40 	div.f %d4,%d4,%d15
    uint32        tempTSEG2 = 1U + nbtr.B.TSEG2;
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
80006030:	74 45       	st.w [%a4],%d5
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80006032:	4b f2 51 f0 	div.f %d15,%d2,%d15
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
80006036:	4b 04 71 41 	ftouz %d4,%d4
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
8000603a:	4b 0f 71 f1 	ftouz %d15,%d15
    uint32        tempDIV8  = (nbtr.B.DIV8 != 0) ? 8U : 1U;

    uint32        tempTSEG  = 1 + tempTSEG1 + tempTSEG2;

    *baudrate       = (uint32)(moduleFreq / (float32)(tempDIV8 * tempBRP * tempTSEG));
    *samplePoint    = (uint16)(((float32)tempTSEG1) * 10000 / ((float32)(tempTSEG)));
8000603e:	b4 54       	st.h [%a5],%d4
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
80006040:	ac 60       	st.h [%a6]0,%d15
80006042:	00 90       	ret 

80006044 <IfxMultican_deinit>:
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
80006044:	bb f0 ff 6f 	mov.u %d6,65535
    *synchJumpWidth = (uint16)(((float32)tempSJW) * 10000 / ((float32)(tempTSEG)));
}


void IfxMultican_deinit(Ifx_CAN *mcan)
{
80006048:	40 4f       	mov.aa %a15,%a4
8000604a:	82 03       	mov %d3,0
    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */

    hwObj->FCR.U   = 0x00000000UL;
    hwObj->FGPR.U  = 0x00000000UL;
    hwObj->IPR.U   = 0x00000000UL;
    hwObj->AMR.U   = 0x3FFFFFFFUL;
8000604c:	9b f6 ff 53 	addih %d5,%d6,16383
{
    // should use kernel reset functionality!
    uint16 i;

    /* Ifx_CAN.CLC is reset last */
    for (i = 0; i < IFXMULTICAN_NUM_MESSAGE_OBJECTS; i++)
80006050:	c5 03 3f 30 	lea %a3,ff <_.+0xfe>

void IfxMultican_setListCommand(Ifx_CAN *mcan, uint32 cmd, uint32 arg2, uint32 arg1)
{
    Ifx_CAN_PANCTR panctr;

    panctr.B.PANAR1 = arg1;
80006054:	37 32 08 28 	insert %d2,%d2,%d3,16,8
    panctr.B.PANAR2 = arg2;
80006058:	b7 02 08 2c 	insert %d2,%d2,0,24,8
    panctr.B.PANCMD = cmd;
8000605c:	b7 22 08 20 	insert %d2,%d2,2,0,8

    /** - write to CAN_PANCTR */
    mcan->PANCTR.U = panctr.U;
80006060:	59 f2 04 70 	st.w [%a15]452,%d2
}


IFX_INLINE void IfxMultican_waitListReady(Ifx_CAN *mcan)
{
    while (mcan->PANCTR.B.BUSY != 0)
80006064:	19 ff 04 70 	ld.w %d15,[%a15]452
80006068:	37 0f 61 f4 	extr.u %d15,%d15,8,1
8000606c:	ee fc       	jnz %d15,80006064 <IfxMultican_deinit+0x20>
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
8000606e:	8f 53 00 40 	sh %d4,%d3,5
80006072:	01 f4 00 26 	addsc.a %a2,%a15,%d4,0

    hwObj->FCR.U   = 0x00000000UL;
80006076:	1b 03 08 40 	addi %d4,%d3,128
8000607a:	8f 54 00 70 	sh %d7,%d4,5
8000607e:	01 f7 00 46 	addsc.a %a4,%a15,%d7,0
    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(mcan, msgObjId);
    /* Remove the message object from any node */
    /* Append message object to the end of the list */
    IfxMultican_setListCommand(mcan, 0x2, 0, msgObjId);

    hwObj->CTR.U   = 0x0000FFFFUL; /* to be written first */
80006082:	59 26 1c 01 	st.w [%a2]4124,%d6

    hwObj->FCR.U   = 0x00000000UL;
80006086:	6c 40       	st.w [%a4]0,%d15
    hwObj->FGPR.U  = 0x00000000UL;
80006088:	59 2f 04 01 	st.w [%a2]4100,%d15
    hwObj->IPR.U   = 0x00000000UL;
8000608c:	59 2f 08 01 	st.w [%a2]4104,%d15
    hwObj->AMR.U   = 0x3FFFFFFFUL;
80006090:	59 25 0c 01 	st.w [%a2]4108,%d5
    hwObj->DATAL.U = 0x00000000UL;
80006094:	59 2f 10 01 	st.w [%a2]4112,%d15
    hwObj->DATAH.U = 0x00000000UL;
80006098:	59 2f 14 01 	st.w [%a2]4116,%d15
    hwObj->AR.U    = 0x00000000UL;
8000609c:	59 2f 18 01 	st.w [%a2]4120,%d15
800060a0:	c2 13       	add %d3,1
{
    // should use kernel reset functionality!
    uint16 i;

    /* Ifx_CAN.CLC is reset last */
    for (i = 0; i < IFXMULTICAN_NUM_MESSAGE_OBJECTS; i++)
800060a2:	fd 30 d9 7f 	loop %a3,80006054 <IfxMultican_deinit+0x10>
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
800060a6:	82 19       	mov %d9,1
800060a8:	59 f9 00 80 	st.w [%a15]512,%d9
    hwNode->SR.U    = 0x00000000;
800060ac:	59 ff 04 80 	st.w [%a15]516,%d15
    hwNode->IPR.U   = 0x00000000;
800060b0:	59 ff 08 80 	st.w [%a15]520,%d15
    hwNode->PCR.U   = 0x00000000;
800060b4:	59 ff 0c 80 	st.w [%a15]524,%d15
    hwNode->BTEVR.U = 0x00000000;
800060b8:	59 ff 10 80 	st.w [%a15]528,%d15
    hwNode->ECNT.U  = 0x00600000;
800060bc:	7b 00 06 20 	movh %d2,96
800060c0:	59 f2 14 80 	st.w [%a15]532,%d2
    hwNode->FCR.U   = 0x00000000;
800060c4:	59 ff 18 80 	st.w [%a15]536,%d15
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
800060c8:	59 f9 00 c0 	st.w [%a15]768,%d9
    hwNode->SR.U    = 0x00000000;
800060cc:	59 ff 04 c0 	st.w [%a15]772,%d15
    hwNode->IPR.U   = 0x00000000;
800060d0:	59 ff 08 c0 	st.w [%a15]776,%d15
    hwNode->PCR.U   = 0x00000000;
800060d4:	59 ff 0c c0 	st.w [%a15]780,%d15
    hwNode->BTEVR.U = 0x00000000;
800060d8:	59 ff 10 c0 	st.w [%a15]784,%d15
    hwNode->ECNT.U  = 0x00600000;
800060dc:	59 f2 14 c0 	st.w [%a15]788,%d2
    hwNode->FCR.U   = 0x00000000;
800060e0:	59 ff 18 c0 	st.w [%a15]792,%d15
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
800060e4:	59 f9 40 00 	st.w [%a15]1024,%d9
    hwNode->SR.U    = 0x00000000;
800060e8:	59 ff 44 00 	st.w [%a15]1028,%d15
    hwNode->IPR.U   = 0x00000000;
800060ec:	59 ff 48 00 	st.w [%a15]1032,%d15
    hwNode->PCR.U   = 0x00000000;
800060f0:	59 ff 4c 00 	st.w [%a15]1036,%d15
    hwNode->BTEVR.U = 0x00000000;
800060f4:	59 ff 50 00 	st.w [%a15]1040,%d15
    hwNode->ECNT.U  = 0x00600000;
800060f8:	59 f2 54 00 	st.w [%a15]1044,%d2
    hwNode->FCR.U   = 0x00000000;
800060fc:	59 ff 58 00 	st.w [%a15]1048,%d15
}


void IfxMultican_Node_deinit(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U    = 0x00000001;
80006100:	59 f9 40 40 	st.w [%a15]1280,%d9
    hwNode->SR.U    = 0x00000000;
80006104:	59 ff 44 40 	st.w [%a15]1284,%d15
    hwNode->IPR.U   = 0x00000000;
80006108:	59 ff 48 40 	st.w [%a15]1288,%d15
    hwNode->PCR.U   = 0x00000000;
8000610c:	59 ff 4c 40 	st.w [%a15]1292,%d15
    hwNode->BTEVR.U = 0x00000000;
80006110:	59 ff 50 40 	st.w [%a15]1296,%d15
    hwNode->ECNT.U  = 0x00600000;
80006114:	59 f2 54 40 	st.w [%a15]1300,%d2
        IfxMultican_Node_deinit(hwNode);
    }

    for (i = 0; i < IFXMULTICAN_NUM_SRC; i++)
    {
        MODULE_SRC.CAN.CAN[0].INT[i].U = 0x00000000;
80006118:	91 40 00 2f 	movh.a %a2,61444
8000611c:	d9 22 00 08 	lea %a2,[%a2]-32768 <f0038000 <_SMALL_DATA4_+0x40030000>>
    hwNode->SR.U    = 0x00000000;
    hwNode->IPR.U   = 0x00000000;
    hwNode->PCR.U   = 0x00000000;
    hwNode->BTEVR.U = 0x00000000;
    hwNode->ECNT.U  = 0x00600000;
    hwNode->FCR.U   = 0x00000000;
80006120:	59 ff 58 40 	st.w [%a15]1304 <f0038000 <_SMALL_DATA4_+0x40030000>>,%d15
        IfxMultican_Node_deinit(hwNode);
    }

    for (i = 0; i < IFXMULTICAN_NUM_SRC; i++)
    {
        MODULE_SRC.CAN.CAN[0].INT[i].U = 0x00000000;
80006124:	59 2f 80 40 	st.w [%a2]2304 <f0040900 <_SMALL_DATA4_+0x40038900>>,%d15
80006128:	59 2f 84 40 	st.w [%a2]2308 <f0040904 <_SMALL_DATA4_+0x40038904>>,%d15
8000612c:	59 2f 88 40 	st.w [%a2]2312 <f0040908 <_SMALL_DATA4_+0x40038908>>,%d15
80006130:	59 2f 8c 40 	st.w [%a2]2316 <f004090c <_SMALL_DATA4_+0x4003890c>>,%d15
80006134:	59 2f 90 40 	st.w [%a2]2320 <f0040910 <_SMALL_DATA4_+0x40038910>>,%d15
80006138:	59 2f 94 40 	st.w [%a2]2324 <f0040914 <_SMALL_DATA4_+0x40038914>>,%d15
8000613c:	59 2f 98 40 	st.w [%a2]2328 <f0040918 <_SMALL_DATA4_+0x40038918>>,%d15
80006140:	59 2f 9c 40 	st.w [%a2]2332 <f004091c <_SMALL_DATA4_+0x4003891c>>,%d15
80006144:	59 2f a0 40 	st.w [%a2]2336 <f0040920 <_SMALL_DATA4_+0x40038920>>,%d15
80006148:	59 2f a4 40 	st.w [%a2]2340 <f0040924 <_SMALL_DATA4_+0x40038924>>,%d15
8000614c:	59 2f a8 40 	st.w [%a2]2344 <f0040928 <_SMALL_DATA4_+0x40038928>>,%d15
80006150:	59 2f ac 40 	st.w [%a2]2348 <f004092c <_SMALL_DATA4_+0x4003892c>>,%d15
80006154:	59 2f b0 40 	st.w [%a2]2352 <f0040930 <_SMALL_DATA4_+0x40038930>>,%d15
80006158:	59 2f b4 40 	st.w [%a2]2356 <f0040934 <_SMALL_DATA4_+0x40038934>>,%d15
8000615c:	59 2f b8 40 	st.w [%a2]2360 <f0040938 <_SMALL_DATA4_+0x40038938>>,%d15
80006160:	59 2f bc 40 	st.w [%a2]2364 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    }

    for (i = 0; i < 8; i++)
    {
        mcan->MSPND[i].U = 0x00000000;
80006164:	59 ff 00 50 	st.w [%a15]320 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
80006168:	59 ff 04 50 	st.w [%a15]324 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
8000616c:	59 ff 08 50 	st.w [%a15]328 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
80006170:	59 ff 0c 50 	st.w [%a15]332 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
80006174:	59 ff 10 50 	st.w [%a15]336 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
80006178:	59 ff 14 50 	st.w [%a15]340 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
8000617c:	59 ff 18 50 	st.w [%a15]344 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
80006180:	59 ff 1c 50 	st.w [%a15]348 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    }

    mcan->MSIMASK.U = 0x00000000;
80006184:	59 ff 00 70 	st.w [%a15]448 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    mcan->MCR.U     = 0x00000000;
80006188:	59 ff 08 70 	st.w [%a15]456 <f004093c <_SMALL_DATA4_+0x4003893c>>,%d15
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000618c:	6d 00 c0 21 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80006190:	02 24       	mov %d4,%d2
    }

    mcan->MSIMASK.U = 0x00000000;
    mcan->MCR.U     = 0x00000000;
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80006192:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80006194:	6d 00 be 20 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        mcan->FDR.U = 0x00000000;
        IfxScuWdt_setCpuEndinit(passwd);
80006198:	02 84       	mov %d4,%d8
    mcan->MSIMASK.U = 0x00000000;
    mcan->MCR.U     = 0x00000000;
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        mcan->FDR.U = 0x00000000;
8000619a:	68 3f       	st.w [%a15]12,%d15
        IfxScuWdt_setCpuEndinit(passwd);
8000619c:	6d 00 fe 22 	call 8000a798 <IfxScuWdt_setCpuEndinit>
        IfxScuWdt_clearCpuEndinit(passwd);
800061a0:	02 84       	mov %d4,%d8
800061a2:	6d 00 b7 20 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        mcan->CLC.U = 0x00000001;
800061a6:	68 09       	st.w [%a15]0,%d9
        IfxScuWdt_setCpuEndinit(passwd);
800061a8:	02 84       	mov %d4,%d8
800061aa:	1d 00 f7 22 	j 8000a798 <IfxScuWdt_setCpuEndinit>

800061ae <IfxMultican_getSrcPointer>:
}


volatile Ifx_SRC_SRCR *IfxMultican_getSrcPointer(Ifx_CAN *mcan, IfxMultican_SrcId srcId)
{
    return &(MODULE_SRC.CAN.CAN[0].INT[srcId]);
800061ae:	06 24       	sh %d4,2
800061b0:	60 4f       	mov.a %a15,%d4
800061b2:	d9 f2 80 48 	lea %a2,[%a15]-30464
}
800061b6:	11 42 00 2f 	addih.a %a2,%a2,61444
800061ba:	00 90       	ret 

800061bc <IfxMultican_resetModule>:


void IfxMultican_resetModule(Ifx_CAN *can)
{
800061bc:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800061be:	6d 00 a7 21 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800061c2:	02 24       	mov %d4,%d2
}


void IfxMultican_resetModule(Ifx_CAN *can)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800061c4:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800061c6:	6d 00 a5 20 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    can->KRST0.B.RST = 1;           /* Only if both Kernel reset bits are set a reset is executed */
800061ca:	19 ff 34 30 	ld.w %d15,[%a15]244
    can->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
800061ce:	02 84       	mov %d4,%d8
void IfxMultican_resetModule(Ifx_CAN *can)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    can->KRST0.B.RST = 1;           /* Only if both Kernel reset bits are set a reset is executed */
800061d0:	96 01       	or %d15,1
800061d2:	59 ff 34 30 	st.w [%a15]244,%d15
    can->KRST1.B.RST = 1;
800061d6:	19 ff 30 30 	ld.w %d15,[%a15]240
800061da:	96 01       	or %d15,1
800061dc:	59 ff 30 30 	st.w [%a15]240,%d15
    IfxScuWdt_setCpuEndinit(passwd);
800061e0:	6d 00 dc 22 	call 8000a798 <IfxScuWdt_setCpuEndinit>

    while (0 == can->KRST0.B.RSTSTAT)   /* Wait until reset is executed */
800061e4:	19 ff 34 30 	ld.w %d15,[%a15]244
800061e8:	6f 1f fe 7f 	jz.t %d15,1,800061e4 <IfxMultican_resetModule+0x28>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
800061ec:	02 84       	mov %d4,%d8
800061ee:	6d 00 91 20 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    can->KRSTCLR.B.CLR = 1;         /* Clear Kernel reset status bit */
800061f2:	19 ff 2c 30 	ld.w %d15,[%a15]236
    IfxScuWdt_setCpuEndinit(passwd);
800061f6:	02 84       	mov %d4,%d8
    while (0 == can->KRST0.B.RSTSTAT)   /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    can->KRSTCLR.B.CLR = 1;         /* Clear Kernel reset status bit */
800061f8:	96 01       	or %d15,1
800061fa:	59 ff 2c 30 	st.w [%a15]236,%d15
    IfxScuWdt_setCpuEndinit(passwd);
800061fe:	1d 00 cd 22 	j 8000a798 <IfxScuWdt_setCpuEndinit>

80006202 <IfxMultican_setListCommand>:

void IfxMultican_setListCommand(Ifx_CAN *mcan, uint32 cmd, uint32 arg2, uint32 arg1)
{
    Ifx_CAN_PANCTR panctr;

    panctr.B.PANAR1 = arg1;
80006202:	82 0f       	mov %d15,0
80006204:	37 6f 08 f8 	insert %d15,%d15,%d6,16,8
    panctr.B.PANAR2 = arg2;
80006208:	37 5f 08 fc 	insert %d15,%d15,%d5,24,8
    panctr.B.PANCMD = cmd;
8000620c:	37 4f 08 f0 	insert %d15,%d15,%d4,0,8

    /** - write to CAN_PANCTR */
    mcan->PANCTR.U = panctr.U;
80006210:	59 4f 04 70 	st.w [%a4]452,%d15
80006214:	19 4f 04 70 	ld.w %d15,[%a4]452
80006218:	6f 8f fe ff 	jnz.t %d15,8,80006214 <IfxMultican_setListCommand+0x12>

    IfxMultican_waitListReady(mcan);
}
8000621c:	00 90       	ret 

8000621e <IfxMultican_getIndex>:

    result = IfxMultican_Index_none;

    for (index = 0; index < IFXMULTICAN_NUM_MODULES; index++)
    {
        if (IfxMultican_cfg_indexMap[index].module == multican)
8000621e:	91 00 00 f8 	movh.a %a15,32768
80006222:	d9 f2 50 40 	lea %a2,[%a15]1296 <80000510 <IfxMultican_cfg_indexMap>>
80006226:	99 ff 50 40 	ld.a %a15,[%a15]1296 <80000510 <IfxMultican_cfg_indexMap>>
IfxMultican_Index IfxMultican_getIndex(Ifx_CAN *multican)
{
    uint32            index;
    IfxMultican_Index result;

    result = IfxMultican_Index_none;
8000622a:	82 f2       	mov %d2,-1

    for (index = 0; index < IFXMULTICAN_NUM_MODULES; index++)
    {
        if (IfxMultican_cfg_indexMap[index].module == multican)
8000622c:	7d 4f 03 00 	jeq.a %a15,%a4,80006232 <IfxMultican_getIndex+0x14>
            break;
        }
    }

    return result;
}
80006230:	00 90       	ret 

    for (index = 0; index < IFXMULTICAN_NUM_MODULES; index++)
    {
        if (IfxMultican_cfg_indexMap[index].module == multican)
        {
            result = (IfxMultican_Index)IfxMultican_cfg_indexMap[index].index;
80006232:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
        }
    }

    return result;
}
80006236:	00 90       	ret 

80006238 <IfxMultican_getAddress>:
    {
        module = (Ifx_CAN *)IfxMultican_cfg_indexMap[multican].module;
    }
    else
    {
        module = NULL_PTR;
80006238:	a0 02       	mov.a %a2,0

Ifx_CAN *IfxMultican_getAddress(IfxMultican_Index multican)
{
    Ifx_CAN *module;

    if (multican < IFXMULTICAN_NUM_MODULES)
8000623a:	4e 48       	jgtz %d4,8000624a <IfxMultican_getAddress+0x12>
    {
        module = (Ifx_CAN *)IfxMultican_cfg_indexMap[multican].module;
8000623c:	91 00 00 f8 	movh.a %a15,32768
80006240:	d9 ff 50 40 	lea %a15,[%a15]1296 <80000510 <IfxMultican_cfg_indexMap>>
80006244:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80006248:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
8000624a:	00 90       	ret 

8000624c <IfxMultican_Can_MsgObj_getConfig>:
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxMultican_Can_MsgObj_getConfig(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Can_MsgObjConfig *config)
{
    Ifx_CAN_MO    *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
8000624c:	cc 40       	ld.a %a15,[%a4]0
8000624e:	19 43 04 00 	ld.w %d3,[%a4]4
    config->control.extendedFrame       = ar.B.IDE;
    config->control.matchingId          = amr.B.MIDE;

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
    config->acceptanceMask              = amr.B.AM >> ((config->control.extendedFrame != 0) ? 0 : 18);
80006252:	82 06       	mov %d6,0
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxMultican_Can_MsgObj_getConfig(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Can_MsgObjConfig *config)
{
    Ifx_CAN_MO    *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
80006254:	4c f0       	ld.w %d15,[%a15]0

    Ifx_CAN_MO_AR  ar;
    Ifx_CAN_MO_AMR amr;
    Ifx_CAN_MO_FCR fcr;

    ar.U                                = hwObj->AR.U;
80006256:	13 03 22 2f 	madd %d2,%d15,%d3,32
    amr.U                               = hwObj->AMR.U;
    fcr.U                               = hwObj->FCR.U;
8000625a:	1b 03 08 30 	addi %d3,%d3,128
8000625e:	13 03 22 4f 	madd %d4,%d15,%d3,32

    Ifx_CAN_MO_AR  ar;
    Ifx_CAN_MO_AMR amr;
    Ifx_CAN_MO_FCR fcr;

    ar.U                                = hwObj->AR.U;
80006262:	60 2f       	mov.a %a15,%d2
    amr.U                               = hwObj->AMR.U;
    fcr.U                               = hwObj->FCR.U;
80006264:	60 42       	mov.a %a2,%d4

    Ifx_CAN_MO_AR  ar;
    Ifx_CAN_MO_AMR amr;
    Ifx_CAN_MO_FCR fcr;

    ar.U                                = hwObj->AR.U;
80006266:	19 f2 18 01 	ld.w %d2,[%a15]4120
    amr.U                               = hwObj->AMR.U;
8000626a:	19 f5 0c 01 	ld.w %d5,[%a15]4108
    fcr.U                               = hwObj->FCR.U;
8000626e:	54 23       	ld.w %d3,[%a2]

    config->frame                       = (hwObj->STAT.B.DIR != 0) ? IfxMultican_Frame_transmit : IfxMultican_Frame_receive;
80006270:	19 ff 1c 01 	ld.w %d15,[%a15]4124
    config->control.messageLen          = (IfxMultican_DataLengthCode)fcr.B.DLC;
    config->control.extendedFrame       = ar.B.IDE;
    config->control.matchingId          = amr.B.MIDE;

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
80006274:	8f 22 1e 40 	sh %d4,%d2,-30

    ar.U                                = hwObj->AR.U;
    amr.U                               = hwObj->AMR.U;
    fcr.U                               = hwObj->FCR.U;

    config->frame                       = (hwObj->STAT.B.DIR != 0) ? IfxMultican_Frame_transmit : IfxMultican_Frame_receive;
80006278:	37 0f e1 f5 	extr.u %d15,%d15,11,1
8000627c:	e9 5f 1c 00 	st.b [%a5]28,%d15

    config->control.singleDataTransfer  = fcr.B.SDT;
80006280:	0c 5c       	ld.bu %d15,[%a5]12
80006282:	67 3f 00 fb 	ins.t %d15,%d15,0,%d3,22
80006286:	2c 5c       	st.b [%a5]12,%d15
    config->control.messageLen          = (IfxMultican_DataLengthCode)fcr.B.DLC;
80006288:	37 03 64 fc 	extr.u %d15,%d3,24,4
8000628c:	2c 5d       	st.b [%a5]13,%d15
    config->control.extendedFrame       = ar.B.IDE;
8000628e:	0c 5e       	ld.bu %d15,[%a5]14
80006290:	67 2f 80 fe 	ins.t %d15,%d15,0,%d2,29
    config->control.matchingId          = amr.B.MIDE;
80006294:	67 5f 81 fe 	ins.t %d15,%d15,1,%d5,29
80006298:	2c 5e       	st.b [%a5]14,%d15

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
8000629a:	19 57 0c 00 	ld.w %d7,[%a5]12
8000629e:	b7 02 83 fe 	insert %d15,%d2,0,29,3
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
    config->acceptanceMask              = amr.B.AM >> ((config->control.extendedFrame != 0) ? 0 : 18);
800062a2:	37 05 7d 50 	extr.u %d5,%d5,0,29
    config->control.singleDataTransfer  = fcr.B.SDT;
    config->control.messageLen          = (IfxMultican_DataLengthCode)fcr.B.DLC;
    config->control.extendedFrame       = ar.B.IDE;
    config->control.matchingId          = amr.B.MIDE;

    config->messageId                   = ar.B.ID >> ((config->control.extendedFrame != 0) ? 0 : 18);
800062a6:	ef 07 08 80 	jnz.t %d7,16,800062b6 <IfxMultican_Can_MsgObj_getConfig+0x6a>
800062aa:	8f ef 3e f0 	sha %d15,%d15,-18
    config->priority                    = (IfxMultican_Priority)ar.B.PRI;
800062ae:	8f 22 1e 40 	sh %d4,%d2,-30
    config->acceptanceMask              = amr.B.AM >> ((config->control.extendedFrame != 0) ? 0 : 18);
800062b2:	3b 20 01 60 	mov %d6,18
800062b6:	6c 59       	st.w [%a5]36,%d15
800062b8:	8b 06 00 f1 	rsub %d15,%d6,0
800062bc:	0f f5 20 f0 	shas %d15,%d5,%d15
800062c0:	6c 58       	st.w [%a5]32,%d15
    config->control.singleTransmitTrial = fcr.B.STT;
800062c2:	0c 5c       	ld.bu %d15,[%a5]12
800062c4:	e9 54 28 00 	st.b [%a5]40,%d4
800062c8:	67 3f 81 fb 	ins.t %d15,%d15,1,%d3,23
800062cc:	2c 5c       	st.b [%a5]12,%d15
800062ce:	00 90       	ret 

800062d0 <IfxMultican_Can_MsgObj_init>:
}


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
    msgObj->node        = config->node;
800062d0:	d4 52       	ld.a %a2,[%a5]
    msgObj->msgObjId    = config->msgObjId;
    msgObj->msgObjCount = config->msgObjCount;
    msgObj->fifoPointer = 0;
800062d2:	82 0f       	mov %d15,0


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
    msgObj->node        = config->node;
    msgObj->msgObjId    = config->msgObjId;
800062d4:	19 5b 04 00 	ld.w %d11,[%a5]4
    msgObj->msgObjCount = config->msgObjCount;
800062d8:	b9 5c 08 00 	ld.hu %d12,[%a5]8
    msgObj->fifoPointer = 0;

    Ifx_CAN           *mcanSFR   = msgObj->node->mcan;
800062dc:	d4 2c       	ld.a %a12,[%a2]
IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
    msgObj->node        = config->node;
    msgObj->msgObjId    = config->msgObjId;
    msgObj->msgObjCount = config->msgObjCount;
    msgObj->fifoPointer = 0;
800062de:	6c 43       	st.w [%a4]12,%d15

    Ifx_CAN_MO        *hwObj     = IfxMultican_MsgObj_getPointer(mcanSFR, msgObj->msgObjId);

    IfxMultican_Status status    = IfxMultican_Status_ok;

    boolean            longFrame = (config->control.messageLen > IfxMultican_DataLengthCode_8) ? TRUE : FALSE;
800062e0:	0c 5d       	ld.bu %d15,[%a5]13
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
800062e2:	80 c2       	mov.d %d2,%a12
800062e4:	8b 9f a0 f2 	ge.u %d15,%d15,9
800062e8:	60 fd       	mov.a %a13,%d15

    /* check for the receive frame */
    boolean            receiveFrame = (config->frame == IfxMultican_Frame_receive) ||
800062ea:	39 5f 1c 00 	ld.bu %d15,[%a5]28
800062ee:	1b 0b 08 a0 	addi %d10,%d11,128
800062f2:	13 0a 22 82 	madd %d8,%d2,%d10,32
                                      (config->frame == IfxMultican_Frame_remoteAnswer) ||
800062f6:	92 e2       	add %d2,%d15,-2
800062f8:	8b 22 60 32 	lt.u %d3,%d2,2
800062fc:	8b 0f e0 34 	or.eq %d3,%d15,0
    config->control.singleTransmitTrial = fcr.B.STT;
}


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
80006300:	20 18       	sub.a %sp,24
    msgObj->node        = config->node;
80006302:	f4 42       	st.a [%a4],%a2
    msgObj->msgObjId    = config->msgObjId;
80006304:	59 4b 04 00 	st.w [%a4]4,%d11
    msgObj->msgObjCount = config->msgObjCount;
80006308:	f9 4c 08 00 	st.h [%a4]8,%d12
8000630c:	59 a3 04 00 	st.w [%sp]4,%d3
                                      (config->frame == IfxMultican_Frame_remoteAnswer) ||
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
80006310:	c2 ff       	add %d15,-1
    config->control.singleTransmitTrial = fcr.B.STT;
}


IfxMultican_Status IfxMultican_Can_MsgObj_init(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Can_MsgObjConfig *config)
{
80006312:	40 4e       	mov.aa %a14,%a4
80006314:	40 5f       	mov.aa %a15,%a5
                                      (config->frame == IfxMultican_Frame_remoteAnswer) ||
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
80006316:	bf 3f c6 82 	jlt.u %d15,3,800068a2 <IfxMultican_Can_MsgObj_init+0x5d2>
8000631a:	4c 5b       	ld.w %d15,[%a5]44
8000631c:	7b 10 00 20 	movh %d2,1
80006320:	26 f2       	and %d2,%d15
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;

    if (config->msgObjId == config->firstSlaveObjId)
80006322:	4c 5e       	ld.w %d15,[%a5]56
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;
80006324:	8b 02 20 d2 	ne %d13,%d2,0

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
80006328:	0b fb 00 31 	eq %d3,%d11,%d15
8000632c:	59 a3 14 00 	st.w [%sp]20,%d3
    if (config->msgObjId == config->firstSlaveObjId)
    {
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
80006330:	df 02 e6 02 	jeq %d2,0,800068fc <IfxMultican_Can_MsgObj_init+0x62c>
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
80006334:	82 03       	mov %d3,0
80006336:	8b 2c a0 22 	ge.u %d2,%d12,2
8000633a:	74 a3       	st.w [%sp],%d3
8000633c:	59 a3 08 00 	st.w [%sp]8,%d3

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;
80006340:	82 0e       	mov %d14,0
80006342:	59 a3 0c 00 	st.w [%sp]12,%d3
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
        transmitFifo = (config->msgObjCount > 1) && (transmitFrame);
    }

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);
80006346:	26 d2       	and %d2,%d13
    uint32 i;

    /* for standard and FIFO (Tx & Rx) base objects */
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006348:	60 84       	mov.a %a4,%d8
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
        transmitFifo = (config->msgObjCount > 1) && (transmitFrame);
    }

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);
8000634a:	59 a2 10 00 	st.w [%sp]16,%d2
    uint32 i;

    /* for standard and FIFO (Tx & Rx) base objects */
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
8000634e:	82 54       	mov %d4,5
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;

    /* select the first slave object */
    if (!config->firstSlaveObjId)
    {                              // if not selected
        firstSlaveObjId = config->msgObjId + 1;
80006350:	1b 1b 00 20 	addi %d2,%d11,1
80006354:	6a 2f       	cmovn %d15,%d15,%d2
    uint32 i;

    /* for standard and FIFO (Tx & Rx) base objects */
    {
        /* MSGVAL: Set message as not valid */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006356:	6d ff e3 f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RXPND */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
8000635a:	60 84       	mov.a %a4,%d8
8000635c:	82 04       	mov %d4,0
8000635e:	6d ff df f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset TXPND */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitPending);
80006362:	60 84       	mov.a %a4,%d8
80006364:	82 14       	mov %d4,1
80006366:	6d ff db f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RXUPD */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveUpdating);
8000636a:	60 84       	mov.a %a4,%d8
8000636c:	82 24       	mov %d4,2
8000636e:	6d ff d7 f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset NEWDAT */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);
80006372:	60 84       	mov.a %a4,%d8
80006374:	82 34       	mov %d4,3
80006376:	6d ff d3 f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset MSGLST */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
8000637a:	60 84       	mov.a %a4,%d8
8000637c:	82 44       	mov %d4,4
8000637e:	6d ff cf f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RTSEL */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveTransmitSelected);
80006382:	60 84       	mov.a %a4,%d8
80006384:	82 64       	mov %d4,6
80006386:	6d ff cb f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

        /*  reset RXPND */
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
8000638a:	60 84       	mov.a %a4,%d8
8000638c:	3b 80 00 40 	mov %d4,8
80006390:	6d ff c6 f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>
        /* Configuration of the CAN Message Object List Structure */
        /* Allocate MO for the node associated list */
        {
            /* for standard, gateway and FIFO (Tx & Rx) base objects  */
            /* Append message object to the end of the list */
            IfxMultican_setListCommand(mcanSFR, 0x2, msgObj->node->nodeId + 1, msgObj->msgObjId);
80006394:	d4 e2       	ld.a %a2,[%a14]
80006396:	40 c4       	mov.aa %a4,%a12
80006398:	82 24       	mov %d4,2
8000639a:	79 25 08 00 	ld.b %d5,[%a2]8
8000639e:	19 e6 04 00 	ld.w %d6,[%a14]4
800063a2:	c2 15       	add %d5,1
800063a4:	6d ff 2f ff 	call 80006202 <IfxMultican_setListCommand>

            /* long frame CAN FD */
            if (longFrame)
800063a8:	bd 0d 37 83 	jnz.a %a13,80006a16 <IfxMultican_Can_MsgObj_init+0x746>
            }

            /* for all standard FIFO (Tx and Rx) and gateway FIFO slave objects */
            if (config->msgObjCount > 1)
            {
                for (i = 0; i < config->msgObjCount; i++)
800063ac:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800063b0:	82 09       	mov %d9,0
800063b2:	bf 22 10 80 	jlt.u %d2,2,800063d2 <IfxMultican_Can_MsgObj_init+0x102>
                {
                    objId = firstSlaveObjId + i;

                    IfxMultican_setListCommand(mcanSFR, 0x2, msgObj->node->nodeId + 1, objId);
800063b6:	d4 e2       	ld.a %a2,[%a14]
800063b8:	12 96       	add %d6,%d15,%d9
800063ba:	40 c4       	mov.aa %a4,%a12
800063bc:	79 25 08 00 	ld.b %d5,[%a2]8
800063c0:	82 24       	mov %d4,2
800063c2:	c2 15       	add %d5,1
800063c4:	6d ff 1f ff 	call 80006202 <IfxMultican_setListCommand>
            }

            /* for all standard FIFO (Tx and Rx) and gateway FIFO slave objects */
            if (config->msgObjCount > 1)
            {
                for (i = 0; i < config->msgObjCount; i++)
800063c8:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800063cc:	c2 19       	add %d9,1
800063ce:	3f 29 f4 ff 	jlt.u %d9,%d2,800063b6 <IfxMultican_Can_MsgObj_init+0xe6>
                    IfxMultican_setListCommand(mcanSFR, 0x2, msgObj->node->nodeId + 1, objId);
                }
            }
        }

        if ((config->frame == IfxMultican_Frame_receive) || (config->frame == IfxMultican_Frame_remoteAnswer))
800063d2:	39 f2 1c 00 	ld.bu %d2,[%a15]28
800063d6:	8b 32 00 32 	eq %d3,%d2,3
800063da:	8b 02 e0 34 	or.eq %d3,%d2,0
800063de:	df 03 16 83 	jne %d3,0,80006a0a <IfxMultican_Can_MsgObj_init+0x73a>
            /*  set RXEN, in case of recieve frame or remote answer*/
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveEnable);
        }

        /*  in case of transmit frame */
        if ((transmitFrame) && (config->gatewayTransfers != 1))
800063e2:	19 a2 08 00 	ld.w %d2,[%sp]8
800063e6:	df 02 3a 02 	jeq %d2,0,8000685a <IfxMultican_Can_MsgObj_init+0x58a>
800063ea:	48 b2       	ld.w %d2,[%a15]44
800063ec:	ef 02 25 02 	jz.t %d2,16,80006836 <IfxMultican_Can_MsgObj_init+0x566>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
        }
        else
        {
            /*  clear DIR, in case of receive frame or gateway transfers*/
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
800063f0:	60 84       	mov.a %a4,%d8
800063f2:	3b b0 00 40 	mov %d4,11
800063f6:	6d ff 93 f5 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>
        }
    }
    {
        /* for standard message object */
        if (config->msgObjCount == 1)
800063fa:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800063fe:	df 12 40 02 	jeq %d2,1,8000687e <IfxMultican_Can_MsgObj_init+0x5ae>
                /* select standard object for FCR.MMC */
                IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_standard);
            }
        }
        /* for receive FIFO base object */
        else if (receiveFifo)
80006402:	19 a3 0c 00 	ld.w %d3,[%sp]12
80006406:	df 03 69 02 	jeq %d3,0,800068d8 <IfxMultican_Can_MsgObj_init+0x608>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
8000640a:	8f 5a 00 40 	sh %d4,%d10,5
8000640e:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80006412:	82 04       	mov %d4,0
80006414:	54 22       	ld.w %d2,[%a2]
80006416:	b7 12 04 20 	insert %d2,%d2,1,0,4
8000641a:	74 22       	st.w [%a2],%d2
        else
        {}

        /* for standard and FIFO (Tx & Rx) base objects  */
        /* enable receive interrupt FCR.RXIE if choosen in case of receive frame */
        boolean receiveInterruptEnabled = (config->rxInterrupt.enabled) && (receiveFrame);
8000641c:	39 f2 2a 00 	ld.bu %d2,[%a15]42
}


IFX_INLINE void IfxMultican_MsgObj_setReceiveInterrupt(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.RXIE = enabled ? 1 : 0;
80006420:	19 a3 04 00 	ld.w %d3,[%sp]4
80006424:	8f 5a 00 50 	sh %d5,%d10,5
80006428:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
8000642c:	8b 02 20 22 	ne %d2,%d2,0
80006430:	26 32       	and %d2,%d3
80006432:	8f 02 01 30 	sh %d3,%d2,16
80006436:	54 22       	ld.w %d2,[%a2]
80006438:	b7 02 01 28 	insert %d2,%d2,0,16,1
8000643c:	a6 32       	or %d2,%d3
8000643e:	74 22       	st.w [%a2],%d2
        IfxMultican_MsgObj_setReceiveInterrupt(hwObj, receiveInterruptEnabled);

        /* enable transmit interrupt FCR.TXIE if choosen in case of transmit frame */
        boolean transmitInterruptEnabled = (config->txInterrupt.enabled) && (transmitFrame);
80006440:	39 f2 2c 00 	ld.bu %d2,[%a15]44
}


IFX_INLINE void IfxMultican_MsgObj_setTransmitInterrupt(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.TXIE = enabled ? 1 : 0;
80006444:	54 a3       	ld.w %d3,[%sp]
80006446:	8b 02 20 22 	ne %d2,%d2,0
8000644a:	26 32       	and %d2,%d3
8000644c:	8f 12 01 30 	sh %d3,%d2,17
80006450:	54 22       	ld.w %d2,[%a2]
80006452:	b7 02 81 28 	insert %d2,%d2,0,17,1
80006456:	a6 32       	or %d2,%d3
80006458:	74 22       	st.w [%a2],%d2
        IfxMultican_MsgObj_setTransmitInterrupt(hwObj, transmitInterruptEnabled);

        /* set FCR.RMM in case of remote answer */
        boolean remoteMonitoringEnabled = (config->frame == IfxMultican_Frame_remoteAnswer);
8000645a:	39 f2 1c 00 	ld.bu %d2,[%a15]28
}


IFX_INLINE void IfxMultican_MsgObj_setRemoteMonitoring(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.RMM = enabled ? 1 : 0;
8000645e:	8b 32 00 22 	eq %d2,%d2,3
80006462:	8f 52 01 30 	sh %d3,%d2,21
80006466:	54 22       	ld.w %d2,[%a2]
80006468:	b7 02 81 2a 	insert %d2,%d2,0,21,1
8000646c:	a6 32       	or %d2,%d3
8000646e:	74 22       	st.w [%a2],%d2
        IfxMultican_MsgObj_setRemoteMonitoring(hwObj, remoteMonitoringEnabled);

        /* only in case of transmit frame; in receive frame case these bits will be set by the hardware */
        if (transmitFrame)
80006470:	54 a2       	ld.w %d2,[%sp]
80006472:	df 02 19 00 	jeq %d2,0,800064a4 <IfxMultican_Can_MsgObj_init+0x1d4>
        {
            /* long frame CAN FD */
            /* FDEN = 1, EDL = 1 and BRS = 0/1 */
            /* in case of recieve Msg Obj, it recieves long and long+fast frames */
            if (config->node->fastNode && longFrame)
80006476:	c8 03       	ld.a %a3,[%a15]0
80006478:	80 d3       	mov.d %d3,%a13
8000647a:	39 32 09 00 	ld.bu %d2,[%a3]9
8000647e:	8b 02 20 22 	ne %d2,%d2,0
80006482:	26 32       	and %d2,%d3
80006484:	df 02 b2 02 	jeq %d2,0,800069e8 <IfxMultican_Can_MsgObj_init+0x718>
}


IFX_INLINE void IfxMultican_MsgObj_setExtendedDataLength(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.FDF = enabled ? 1 : 0;
80006488:	54 22       	ld.w %d2,[%a2]
8000648a:	8f 02 44 21 	or %d2,%d2,64
8000648e:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80006490:	54 23       	ld.w %d3,[%a2]
80006492:	08 d2       	ld.bu %d2,[%a15]13
80006494:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
80006498:	74 22       	st.w [%a2],%d2

                /* set data length code FCR.DLC */
                IfxMultican_MsgObj_setDataLengthCode(hwObj, config->control.messageLen);

                /* set bit rate switch (fast bit rate enable/disable) */
                IfxMultican_MsgObj_setBitRateSwitch(hwObj, config->control.fastBitRate);
8000649a:	48 63       	ld.w %d3,[%a15]24
}


IFX_INLINE void IfxMultican_MsgObj_setBitRateSwitch(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.BRS = enabled ? 1 : 0;
8000649c:	54 22       	ld.w %d2,[%a2]
8000649e:	67 32 05 20 	ins.t %d2,%d2,5,%d3,0
800064a2:	74 22       	st.w [%a2],%d2
                IfxMultican_MsgObj_setDataLengthCode(hwObj, config->control.messageLen);
            }
        }

        /* only for standard message object */
        if ((config->msgObjCount == 1) && (!gatewaySourceObj))
800064a4:	b9 f3 08 00 	ld.hu %d3,[%a15]8
800064a8:	07 dd 00 20 	nand.t %d2,%d13,0,%d13,0
800064ac:	8b 13 00 24 	and.eq %d2,%d3,1
800064b0:	df 02 63 02 	jeq %d2,0,80006976 <IfxMultican_Can_MsgObj_init+0x6a6>
        {
            /* set single transmit trial FCR.STT if choosen */
            IfxMultican_MsgObj_setSingleTransmitTrial(hwObj, config->control.singleTransmitTrial);
800064b4:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setSingleTransmitTrial(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.STT = enabled ? 1 : 0;
800064b6:	8f 5a 00 50 	sh %d5,%d10,5
800064ba:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
800064be:	37 02 e1 20 	extr.u %d2,%d2,1,1
800064c2:	8f 72 01 30 	sh %d3,%d2,23
800064c6:	54 22       	ld.w %d2,[%a2]
800064c8:	b7 02 81 2b 	insert %d2,%d2,0,23,1
800064cc:	a6 32       	or %d2,%d3
800064ce:	74 22       	st.w [%a2],%d2

            /* set single data transfer FCR.SDT if choosen */
            IfxMultican_MsgObj_setSingleDataTransfer(hwObj, config->control.singleDataTransfer);
800064d0:	48 33       	ld.w %d3,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setSingleDataTransfer(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.SDT = enabled ? 1 : 0;
800064d2:	54 22       	ld.w %d2,[%a2]
800064d4:	67 32 16 20 	ins.t %d2,%d2,22,%d3,0
800064d8:	74 22       	st.w [%a2],%d2
        }
    }

    {
        /* for standard message object */
        if (config->msgObjCount == 1)
800064da:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800064de:	df 12 5c 02 	jeq %d2,1,80006996 <IfxMultican_Can_MsgObj_init+0x6c6>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
800064e2:	06 5b       	sh %d11,5
800064e4:	01 cb 00 26 	addsc.a %a2,%a12,%d11,0
800064e8:	59 ab 04 00 	st.w [%sp]4,%d11
800064ec:	19 23 04 01 	ld.w %d3,[%a2]4100
800064f0:	8f ff 0f 21 	and %d2,%d15,255
800064f4:	8f f3 cf 31 	andn %d3,%d3,255
800064f8:	a6 23       	or %d3,%d2
800064fa:	59 23 04 01 	st.w [%a2]4100,%d3
        {
            /* set bottom pointer FGPR.BOT, to the next message object (first FIFO slave object) */
            IfxMultican_MsgObj_setBottomObjectPointer(hwObj, firstSlaveObjId);

            /* store the first slave object Id as the fifoPointer in msgObj structure for FIFO transfers */
            msgObj->fifoPointer = firstSlaveObjId;
800064fe:	6c e3       	st.w [%a14]12,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80006500:	19 23 04 01 	ld.w %d3,[%a2]4100
    {
        firstSlaveObjId = config->firstSlaveObjId;
    }

    /* select the last slave object */
    lastSlaveObjId = firstSlaveObjId + (config->msgObjCount - 1);
80006504:	c2 fc       	add %d12,-1
80006506:	42 fc       	add %d12,%d15
80006508:	37 c3 08 34 	insert %d3,%d3,%d12,8,8
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
8000650c:	8f 02 01 20 	sh %d2,%d2,16
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80006510:	59 23 04 01 	st.w [%a2]4100,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
80006514:	19 23 04 01 	ld.w %d3,[%a2]4100
80006518:	b7 03 08 38 	insert %d3,%d3,0,16,8
8000651c:	a6 32       	or %d2,%d3
8000651e:	59 22 04 01 	st.w [%a2]4100,%d2
            /* set start of FIFO (current pointer) FGPR.CUR, to first FIFO slave object (bottom pointer) */
            IfxMultican_MsgObj_setCurrentObjectPointer(hwObj, firstSlaveObjId);

            bottomEqualsCurrent = TRUE; /*S/w Flag*/

            if (receiveFifo || transmitFifo)
80006522:	19 a2 0c 00 	ld.w %d2,[%sp]12
            IfxMultican_MsgObj_setTopObjectPointer(hwObj, lastSlaveObjId);

            /* set start of FIFO (current pointer) FGPR.CUR, to first FIFO slave object (bottom pointer) */
            IfxMultican_MsgObj_setCurrentObjectPointer(hwObj, firstSlaveObjId);

            bottomEqualsCurrent = TRUE; /*S/w Flag*/
80006526:	82 13       	mov %d3,1

            if (receiveFifo || transmitFifo)
80006528:	a6 e2       	or %d2,%d14
8000652a:	8f f2 0f 21 	and %d2,%d2,255
            IfxMultican_MsgObj_setTopObjectPointer(hwObj, lastSlaveObjId);

            /* set start of FIFO (current pointer) FGPR.CUR, to first FIFO slave object (bottom pointer) */
            IfxMultican_MsgObj_setCurrentObjectPointer(hwObj, firstSlaveObjId);

            bottomEqualsCurrent = TRUE; /*S/w Flag*/
8000652e:	59 a3 08 00 	st.w [%sp]8,%d3

            if (receiveFifo || transmitFifo)
80006532:	76 28       	jz %d2,80006542 <IfxMultican_Can_MsgObj_init+0x272>
}


IFX_INLINE void IfxMultican_MsgObj_setSelectObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.SEL = objNumber;
80006534:	19 22 04 01 	ld.w %d2,[%a2]4100
            {
                /* set select object pointer FGPR.SEL to one object before last FIFO slave object */
                IfxMultican_MsgObj_setSelectObjectPointer(hwObj, lastSlaveObjId - 1);
80006538:	c2 fc       	add %d12,-1
8000653a:	37 c2 08 cc 	insert %d12,%d2,%d12,24,8
8000653e:	59 2c 04 01 	st.w [%a2]4100,%d12
    }

    {
        /* for standard, gateway and FIFO (Tx & Rx) base objects  */
        /* set the given acceptance mask */
        IfxMultican_MsgObj_setAcceptanceMask(hwObj, config->acceptanceMask, config->control.extendedFrame);
80006542:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setAcceptanceMask(Ifx_CAN_MO *hwObj, uint32 mask, boolean extendedFrame)
{
    hwObj->AMR.B.AM = mask << ((extendedFrame != 0) ? 0 : 18);
80006544:	19 a5 04 00 	ld.w %d5,[%sp]4
80006548:	48 84       	ld.w %d4,[%a15]32
8000654a:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
8000654e:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
80006552:	ab 22 a1 22 	seln %d2,%d2,%d2,18
80006556:	0f 24 00 20 	sh %d2,%d4,%d2
8000655a:	19 24 0c 01 	ld.w %d4,[%a2]4108
8000655e:	82 03       	mov %d3,0
80006560:	37 24 1d 20 	insert %d2,%d4,%d2,0,29
80006564:	59 22 0c 01 	st.w [%a2]4108,%d2

        /* enable matching ID if choosen */
        IfxMultican_MsgObj_setMatchingId(hwObj, config->control.matchingId);
80006568:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setMatchingId(Ifx_CAN_MO *hwObj, boolean matchingId)
{
    hwObj->AMR.B.MIDE = matchingId;
8000656a:	37 02 e1 28 	extr.u %d2,%d2,17,1
8000656e:	8f d2 01 40 	sh %d4,%d2,29
80006572:	19 22 0c 01 	ld.w %d2,[%a2]4108
80006576:	b7 02 81 2e 	insert %d2,%d2,0,29,1
8000657a:	a6 42       	or %d2,%d4
8000657c:	59 22 0c 01 	st.w [%a2]4108,%d2
    }

    {
        /* for standard, gateway  and FIFO (Tx & Rx) base objects  */
        /* set message ID */
        IfxMultican_MsgObj_setMessageId(hwObj, config->messageId, config->control.extendedFrame);
80006580:	48 32       	ld.w %d2,[%a15]12
80006582:	48 94       	ld.w %d4,[%a15]36
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80006584:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
80006588:	ab 22 a1 22 	seln %d2,%d2,%d2,18
8000658c:	0f 24 00 20 	sh %d2,%d4,%d2
80006590:	19 24 18 01 	ld.w %d4,[%a2]4120
80006594:	37 24 1d 20 	insert %d2,%d4,%d2,0,29
80006598:	59 22 18 01 	st.w [%a2]4120,%d2

        /* set identifier extension if extended frame is choosen */
        IfxMultican_MsgObj_setIdentifierExtension(hwObj, config->control.extendedFrame);
8000659c:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setIdentifierExtension(Ifx_CAN_MO *hwObj, boolean extension)
{
    hwObj->AR.B.IDE = extension;
8000659e:	37 02 61 28 	extr.u %d2,%d2,16,1
800065a2:	8f d2 01 40 	sh %d4,%d2,29
800065a6:	19 22 18 01 	ld.w %d2,[%a2]4120
800065aa:	b7 02 81 2e 	insert %d2,%d2,0,29,1
800065ae:	a6 42       	or %d2,%d4
800065b0:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setPriorityClass(Ifx_CAN_MO *hwObj, IfxMultican_Priority priority)
{
    hwObj->AR.B.PRI = priority;
800065b4:	19 24 18 01 	ld.w %d4,[%a2]4120
800065b8:	39 f2 28 00 	ld.bu %d2,[%a15]40
800065bc:	37 24 02 2f 	insert %d2,%d4,%d2,30,2
800065c0:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
800065c4:	59 23 10 01 	st.w [%a2]4112,%d3
    hwObj->DATAH.U = 0;
800065c8:	59 23 14 01 	st.w [%a2]4116,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setReceiveInterruptNodePointer(Ifx_CAN_MO *hwObj, IfxMultican_SrcId srcId)
{
    hwObj->IPR.B.RXINP = srcId;
800065cc:	19 23 08 01 	ld.w %d3,[%a2]4104
800065d0:	39 f2 2b 00 	ld.bu %d2,[%a15]43
800065d4:	37 23 04 20 	insert %d2,%d3,%d2,0,4
800065d8:	59 22 08 01 	st.w [%a2]4104,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setTransmitInterruptNodePointer(Ifx_CAN_MO *hwObj, IfxMultican_SrcId srcId)
{
    hwObj->IPR.B.TXINP = srcId;
800065dc:	19 23 08 01 	ld.w %d3,[%a2]4104
800065e0:	39 f2 2d 00 	ld.bu %d2,[%a15]45
800065e4:	37 23 04 22 	insert %d2,%d3,%d2,4,4
800065e8:	59 22 08 01 	st.w [%a2]4104,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessagePendingNumber(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjId messageNumber)
{
    hwObj->IPR.B.MPN = messageNumber;
800065ec:	39 e2 04 00 	ld.bu %d2,[%a14]4
800065f0:	8f 82 00 30 	sh %d3,%d2,8
800065f4:	19 22 08 01 	ld.w %d2,[%a2]4104
800065f8:	b7 02 08 24 	insert %d2,%d2,0,8,8
800065fc:	a6 32       	or %d2,%d3
800065fe:	59 22 08 01 	st.w [%a2]4104,%d2
        /* set IPR.MNP */
        IfxMultican_MsgObj_setMessagePendingNumber(hwObj, msgObj->msgObjId);
    }

    /* for each receive FIFO slave object */
    if (receiveFifo)
80006602:	19 a2 0c 00 	ld.w %d2,[%sp]12
80006606:	df 02 25 00 	jeq %d2,0,80006650 <IfxMultican_Can_MsgObj_init+0x380>
    {
        for (i = 0; i < config->msgObjCount; i++)
8000660a:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000660e:	df 02 b0 00 	jeq %d2,0,8000676e <IfxMultican_Can_MsgObj_init+0x49e>
80006612:	82 09       	mov %d9,0
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80006614:	82 0b       	mov %d11,0
80006616:	12 9c       	add %d12,%d15,%d9
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006618:	1b 0c 08 20 	addi %d2,%d12,128
8000661c:	8f 52 00 30 	sh %d3,%d2,5
80006620:	01 c3 00 d6 	addsc.a %a13,%a12,%d3,0
            objId = firstSlaveObjId + i; /* increment the message object ID */

            Ifx_CAN_MO *hwSlaveObj = IfxMultican_MsgObj_getPointer(mcanSFR, objId);

            /* clear all RXEN flag */
            IfxMultican_MsgObj_clearStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_receiveEnable);
80006624:	82 74       	mov %d4,7
80006626:	40 d4       	mov.aa %a4,%a13
80006628:	6d ff 7a f4 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
8000662c:	08 d2       	ld.bu %d2,[%a15]13
8000662e:	54 d3       	ld.w %d3,[%a13]
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80006630:	8f 5c 00 40 	sh %d4,%d12,5
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
80006634:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80006638:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
8000663c:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
8000663e:	59 2b 10 01 	st.w [%a2]4112,%d11
    hwObj->DATAH.U = 0;
80006642:	59 2b 14 01 	st.w [%a2]4116,%d11
    }

    /* for each receive FIFO slave object */
    if (receiveFifo)
    {
        for (i = 0; i < config->msgObjCount; i++)
80006646:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000664a:	c2 19       	add %d9,1
8000664c:	3f 29 e5 ff 	jlt.u %d9,%d2,80006616 <IfxMultican_Can_MsgObj_init+0x346>
            IfxMultican_MsgObj_clearDataRegisters(hwSlaveObj);
        }
    }

    /* for each transmit FIFO slave object */
    if (transmitFifo)
80006650:	df 0e 8f 00 	jeq %d14,0,8000676e <IfxMultican_Can_MsgObj_init+0x49e>
    {
        /* configure each transmit FIFO slave object as an independent transmit object */
        for (i = 0; i < config->msgObjCount; i++)
80006654:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006658:	df 02 8b 00 	jeq %d2,0,8000676e <IfxMultican_Can_MsgObj_init+0x49e>
8000665c:	02 f9       	mov %d9,%d15
8000665e:	82 0b       	mov %d11,0
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
80006660:	82 0c       	mov %d12,0
80006662:	3c 07       	j 80006670 <IfxMultican_Can_MsgObj_init+0x3a0>
80006664:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006668:	c2 1b       	add %d11,1
8000666a:	c2 19       	add %d9,1
8000666c:	7f 2b 81 80 	jge.u %d11,%d2,8000676e <IfxMultican_Can_MsgObj_init+0x49e>
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006670:	1b 09 08 20 	addi %d2,%d9,128
80006674:	8f 52 00 50 	sh %d5,%d2,5
80006678:	01 c5 00 d6 	addsc.a %a13,%a12,%d5,0

            /* set filtering priority */
            IfxMultican_MsgObj_setPriorityClass(hwSlaveObj, config->priority);

            /*  set TXEN0  */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
8000667c:	3b 90 00 40 	mov %d4,9
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006680:	54 d2       	ld.w %d2,[%a13]
80006682:	40 d4       	mov.aa %a4,%a13
80006684:	b7 32 04 20 	insert %d2,%d2,3,0,4
80006688:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
8000668a:	39 e2 04 00 	ld.bu %d2,[%a14]4
8000668e:	8f 02 01 30 	sh %d3,%d2,16
80006692:	8f 59 00 20 	sh %d2,%d9,5
80006696:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
8000669a:	19 22 04 01 	ld.w %d2,[%a2]4100
8000669e:	b7 02 08 28 	insert %d2,%d2,0,16,8
800066a2:	a6 32       	or %d2,%d3
800066a4:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
800066a8:	54 d3       	ld.w %d3,[%a13]
800066aa:	08 d2       	ld.bu %d2,[%a15]13
800066ac:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800066b0:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_clearDataRegisters(Ifx_CAN_MO *hwObj)
{
    hwObj->DATAL.U = 0;
800066b2:	59 2c 10 01 	st.w [%a2]4112,%d12
    hwObj->DATAH.U = 0;
800066b6:	59 2c 14 01 	st.w [%a2]4116,%d12

            /* clear DATAL and DATAH registers */
            IfxMultican_MsgObj_clearDataRegisters(hwSlaveObj);

            /* set the given acceptance mask */
            IfxMultican_MsgObj_setAcceptanceMask(hwSlaveObj, config->acceptanceMask, config->control.extendedFrame);
800066ba:	48 32       	ld.w %d2,[%a15]12
800066bc:	48 83       	ld.w %d3,[%a15]32
}


IFX_INLINE void IfxMultican_MsgObj_setAcceptanceMask(Ifx_CAN_MO *hwObj, uint32 mask, boolean extendedFrame)
{
    hwObj->AMR.B.AM = mask << ((extendedFrame != 0) ? 0 : 18);
800066be:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
800066c2:	ab 22 a1 22 	seln %d2,%d2,%d2,18
800066c6:	0f 23 00 20 	sh %d2,%d3,%d2
800066ca:	19 23 0c 01 	ld.w %d3,[%a2]4108
800066ce:	37 23 1d 20 	insert %d2,%d3,%d2,0,29
800066d2:	59 22 0c 01 	st.w [%a2]4108,%d2

            /* enable matching ID if choosen */
            IfxMultican_MsgObj_setMatchingId(hwSlaveObj, config->control.matchingId);
800066d6:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setMatchingId(Ifx_CAN_MO *hwObj, boolean matchingId)
{
    hwObj->AMR.B.MIDE = matchingId;
800066d8:	37 02 e1 28 	extr.u %d2,%d2,17,1
800066dc:	8f d2 01 30 	sh %d3,%d2,29
800066e0:	19 22 0c 01 	ld.w %d2,[%a2]4108
800066e4:	b7 02 81 2e 	insert %d2,%d2,0,29,1
800066e8:	a6 32       	or %d2,%d3
800066ea:	59 22 0c 01 	st.w [%a2]4108,%d2

            /* set message ID */
            IfxMultican_MsgObj_setMessageId(hwSlaveObj, config->messageId, config->control.extendedFrame);
800066ee:	48 32       	ld.w %d2,[%a15]12
800066f0:	48 93       	ld.w %d3,[%a15]36
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
800066f2:	87 22 50 28 	nor.t %d2,%d2,16,%d2,16
800066f6:	ab 22 a1 22 	seln %d2,%d2,%d2,18
800066fa:	0f 23 00 20 	sh %d2,%d3,%d2
800066fe:	19 23 18 01 	ld.w %d3,[%a2]4120
80006702:	37 23 1d 20 	insert %d2,%d3,%d2,0,29
80006706:	59 22 18 01 	st.w [%a2]4120,%d2

            /* set identifier extension if extended frame is choosen */
            IfxMultican_MsgObj_setIdentifierExtension(hwSlaveObj, config->control.extendedFrame);
8000670a:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE void IfxMultican_MsgObj_setIdentifierExtension(Ifx_CAN_MO *hwObj, boolean extension)
{
    hwObj->AR.B.IDE = extension;
8000670c:	37 02 61 28 	extr.u %d2,%d2,16,1
80006710:	8f d2 01 30 	sh %d3,%d2,29
80006714:	19 22 18 01 	ld.w %d2,[%a2]4120
80006718:	b7 02 81 2e 	insert %d2,%d2,0,29,1
8000671c:	a6 32       	or %d2,%d3
8000671e:	59 22 18 01 	st.w [%a2]4120,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setPriorityClass(Ifx_CAN_MO *hwObj, IfxMultican_Priority priority)
{
    hwObj->AR.B.PRI = priority;
80006722:	19 23 18 01 	ld.w %d3,[%a2]4120
80006726:	39 f2 28 00 	ld.bu %d2,[%a15]40
8000672a:	37 23 02 2f 	insert %d2,%d3,%d2,30,2
8000672e:	59 22 18 01 	st.w [%a2]4120,%d2

            /* set filtering priority */
            IfxMultican_MsgObj_setPriorityClass(hwSlaveObj, config->priority);

            /*  set TXEN0  */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
80006732:	6d ff 1f f6 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

            /* MSGVAL: Set message as valid */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006736:	40 d4       	mov.aa %a4,%a13
80006738:	82 54       	mov %d4,5
8000673a:	6d ff 1b f6 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

            /* clear all TXEN1 flags expect for the slave object in the FGPR.CUR of the base FIFO object */
            if (objId == firstSlaveObjId)
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
8000673e:	40 d4       	mov.aa %a4,%a13
80006740:	3b a0 00 40 	mov %d4,10

            /* MSGVAL: Set message as valid */
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);

            /* clear all TXEN1 flags expect for the slave object in the FGPR.CUR of the base FIFO object */
            if (objId == firstSlaveObjId)
80006744:	5f 9f f8 00 	jeq %d15,%d9,80006934 <IfxMultican_Can_MsgObj_init+0x664>
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
            }
            else
            {
                IfxMultican_MsgObj_clearStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80006748:	6d ff ea f3 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>
            }

            /*  set DIR, in case of transmit frame or remote answer*/
            if ((config->frame == IfxMultican_Frame_transmit) || (config->frame == IfxMultican_Frame_remoteAnswer))
8000674c:	39 f2 1c 00 	ld.bu %d2,[%a15]28
80006750:	8f d2 0f 21 	and %d2,%d2,253
80006754:	df 12 88 ff 	jne %d2,1,80006664 <IfxMultican_Can_MsgObj_init+0x394>
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageDirection);
80006758:	40 d4       	mov.aa %a4,%a13
8000675a:	3b b0 00 40 	mov %d4,11
8000675e:	6d ff 09 f6 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

    /* for each transmit FIFO slave object */
    if (transmitFifo)
    {
        /* configure each transmit FIFO slave object as an independent transmit object */
        for (i = 0; i < config->msgObjCount; i++)
80006762:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006766:	c2 1b       	add %d11,1
80006768:	c2 19       	add %d9,1
8000676a:	3f 2b 83 ff 	jlt.u %d11,%d2,80006670 <IfxMultican_Can_MsgObj_init+0x3a0>
            }
        }
    }

    /* for standard and receive FIFO base objects */
    if (config->frame == IfxMultican_Frame_receive)
8000676e:	39 f2 1c 00 	ld.bu %d2,[%a15]28
80006772:	df 02 42 01 	jeq %d2,0,800069f6 <IfxMultican_Can_MsgObj_init+0x726>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006776:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000677a:	bf 22 33 80 	jlt.u %d2,2,800067e0 <IfxMultican_Can_MsgObj_init+0x510>
8000677e:	df 0e 90 01 	jeq %d14,0,80006a9e <IfxMultican_Can_MsgObj_init+0x7ce>
80006782:	19 a3 10 00 	ld.w %d3,[%sp]16
80006786:	df 03 2d 80 	jne %d3,0,800067e0 <IfxMultican_Can_MsgObj_init+0x510>
8000678a:	19 a3 14 00 	ld.w %d3,[%sp]20
8000678e:	df 03 d7 00 	jeq %d3,0,8000693c <IfxMultican_Can_MsgObj_init+0x66c>
80006792:	19 a3 08 00 	ld.w %d3,[%sp]8
80006796:	df 03 16 82 	jne %d3,0,80006bc2 <IfxMultican_Can_MsgObj_init+0x8f2>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
8000679a:	8f 5a 00 40 	sh %d4,%d10,5
8000679e:	01 c4 00 36 	addsc.a %a3,%a12,%d4,0
800067a2:	12 34       	add %d4,%d15,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
800067a4:	8f 54 00 50 	sh %d5,%d4,5
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
800067a8:	c2 f2       	add %d2,-1
800067aa:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
800067ae:	1b 14 00 60 	addi %d6,%d4,1
800067b2:	0b 23 00 21 	eq %d2,%d3,%d2
800067b6:	2b 6f 40 22 	sel %d2,%d2,%d15,%d6
800067ba:	8f f2 0f 51 	and %d5,%d2,255
800067be:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
800067c2:	c2 13       	add %d3,1
800067c4:	8f f2 cf 41 	andn %d4,%d2,255
800067c8:	0f 54 a0 20 	or %d2,%d4,%d5
800067cc:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
800067d0:	54 32       	ld.w %d2,[%a3]
800067d2:	b7 22 04 20 	insert %d2,%d2,2,0,4
800067d6:	74 32       	st.w [%a3],%d2
800067d8:	b9 f2 08 00 	ld.hu %d2,[%a15]8
800067dc:	3f 23 e3 ff 	jlt.u %d3,%d2,800067a2 <IfxMultican_Can_MsgObj_init+0x4d2>
                }
            }
        }
    }

    if (gatewaySourceObj)
800067e0:	df 0d 29 00 	jeq %d13,0,80006832 <IfxMultican_Can_MsgObj_init+0x562>
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCodeCopy(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.DLCC = enabled ? 1 : 0;
800067e4:	8f 5a 00 50 	sh %d5,%d10,5
800067e8:	01 c5 00 c6 	addsc.a %a12,%a12,%d5,0
    {
        /* set FCR.DLCC if chosen*/
        IfxMultican_MsgObj_setDataLengthCodeCopy(hwObj, config->gatewayConfig.copyDataLengthCode);
800067ec:	48 c2       	ld.w %d2,[%a15]48
800067ee:	4c c0       	ld.w %d15,[%a12]0
800067f0:	67 2f 0a f0 	ins.t %d15,%d15,10,%d2,0
800067f4:	6c c0       	st.w [%a12]0,%d15

        /* set FCR.DATC if chosen*/
        IfxMultican_MsgObj_setDataCopy(hwObj, config->gatewayConfig.copyData);
800067f6:	4c fc       	ld.w %d15,[%a15]48
}


IFX_INLINE void IfxMultican_MsgObj_setDataCopy(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.DATC = enabled ? 1 : 0;
800067f8:	37 0f e1 f0 	extr.u %d15,%d15,1,1
800067fc:	8f bf 00 20 	sh %d2,%d15,11
80006800:	4c c0       	ld.w %d15,[%a12]0
80006802:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80006806:	a6 2f       	or %d15,%d2
80006808:	6c c0       	st.w [%a12]0,%d15

        /* set FCR.IDC if chosen*/
        IfxMultican_MsgObj_setIdentifierCopy(hwObj, config->gatewayConfig.copyId);
8000680a:	4c fc       	ld.w %d15,[%a15]48
}


IFX_INLINE void IfxMultican_MsgObj_setIdentifierCopy(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.IDC = enabled ? 1 : 0;
8000680c:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80006810:	8f 9f 00 20 	sh %d2,%d15,9
80006814:	4c c0       	ld.w %d15,[%a12]0
80006816:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
8000681a:	a6 2f       	or %d15,%d2
8000681c:	6c c0       	st.w [%a12]0,%d15

        /* set FCR.GDFS if chosen*/
        IfxMultican_MsgObj_setGatewayDataFrameSend(hwObj, config->gatewayConfig.enableTransmit);
8000681e:	4c fc       	ld.w %d15,[%a15]48
}


IFX_INLINE void IfxMultican_MsgObj_setGatewayDataFrameSend(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.GDFS = enabled ? 1 : 0;
80006820:	37 0f e1 f1 	extr.u %d15,%d15,3,1
80006824:	8f 8f 00 20 	sh %d2,%d15,8
80006828:	4c c0       	ld.w %d15,[%a12]0
8000682a:	8f 0f d0 f1 	andn %d15,%d15,256
8000682e:	a6 2f       	or %d15,%d2
80006830:	6c c0       	st.w [%a12]0,%d15
    }

    return status;
}
80006832:	82 02       	mov %d2,0
80006834:	00 90       	ret 

        /*  in case of transmit frame */
        if ((transmitFrame) && (config->gatewayTransfers != 1))
        {
            /*  set TXEN0  */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
80006836:	60 84       	mov.a %a4,%d8
80006838:	3b 90 00 40 	mov %d4,9
8000683c:	6d ff 9a f5 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

            /*  set TXEN1  */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80006840:	60 84       	mov.a %a4,%d8
80006842:	3b a0 00 40 	mov %d4,10
80006846:	6d ff 95 f5 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

            /*  reset RTSEL */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveTransmitSelected);
8000684a:	60 84       	mov.a %a4,%d8
8000684c:	82 64       	mov %d4,6
8000684e:	6d ff 91 f5 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

            /* MSGVAL: Set message as valid */
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006852:	60 84       	mov.a %a4,%d8
80006854:	82 54       	mov %d4,5
80006856:	6d ff 8d f5 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
        }

        if (((config->frame == IfxMultican_Frame_transmit) || (config->frame == IfxMultican_Frame_remoteAnswer)) && (config->gatewayTransfers != 1))
8000685a:	39 f2 1c 00 	ld.bu %d2,[%a15]28
8000685e:	8f d2 0f 21 	and %d2,%d2,253
80006862:	df 12 c7 fd 	jne %d2,1,800063f0 <IfxMultican_Can_MsgObj_init+0x120>
80006866:	48 b2       	ld.w %d2,[%a15]44
80006868:	ef 02 c4 fd 	jnz.t %d2,16,800063f0 <IfxMultican_Can_MsgObj_init+0x120>
        {
            /*  set DIR, in case of transmit frame or remote answer*/
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
8000686c:	60 84       	mov.a %a4,%d8
8000686e:	3b b0 00 40 	mov %d4,11
80006872:	6d ff 7f f5 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageDirection);
        }
    }
    {
        /* for standard message object */
        if (config->msgObjCount == 1)
80006876:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000687a:	df 12 c4 fd 	jne %d2,1,80006402 <IfxMultican_Can_MsgObj_init+0x132>
        {
            /* gateway transfers */
            if (gatewaySourceObj)
8000687e:	df 0d fc 00 	jeq %d13,0,80006a76 <IfxMultican_Can_MsgObj_init+0x7a6>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006882:	8f 5a 00 30 	sh %d3,%d10,5
80006886:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
8000688a:	54 22       	ld.w %d2,[%a2]
8000688c:	b7 42 04 20 	insert %d2,%d2,4,0,4
80006890:	74 22       	st.w [%a2],%d2
            {
                /* select Gateway Source mode for FCR.MMC */
                IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_gatewaySource);

                /* select the gateway destination object as the next object if not selected */
                if (!config->gatewayConfig.gatewayDstObjId)
80006892:	48 d4       	ld.w %d4,[%a15]52
80006894:	df 04 c4 fd 	jne %d4,0,8000641c <IfxMultican_Can_MsgObj_init+0x14c>
                {
                    gatewayDstObjId = msgObj->msgObjId + 1;
80006898:	19 e4 04 00 	ld.w %d4,[%a14]4
8000689c:	c2 14       	add %d4,1
8000689e:	1d ff bf fd 	j 8000641c <IfxMultican_Can_MsgObj_init+0x14c>

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);
800068a2:	4c 5b       	ld.w %d15,[%a5]44
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
800068a4:	ef 0f 40 80 	jnz.t %d15,16,80006924 <IfxMultican_Can_MsgObj_init+0x654>
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;

    if (config->msgObjId == config->firstSlaveObjId)
800068a8:	4c 5e       	ld.w %d15,[%a5]56
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
800068aa:	82 13       	mov %d3,1
800068ac:	0b fb 00 21 	eq %d2,%d11,%d15
800068b0:	59 a2 14 00 	st.w [%sp]20,%d2
800068b4:	74 a3       	st.w [%sp],%d3
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
800068b6:	82 12       	mov %d2,1
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
800068b8:	19 a3 04 00 	ld.w %d3,[%sp]4
                                      (config->frame == IfxMultican_Frame_remoteRequest);

    /* check for the transmit frame */
    boolean transmitFrame = ((config->frame == IfxMultican_Frame_transmit) ||
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
800068bc:	59 a2 08 00 	st.w [%sp]8,%d2
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
800068c0:	8b 2c a0 22 	ge.u %d2,%d12,2
800068c4:	26 23       	and %d3,%d2
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;
800068c6:	82 0d       	mov %d13,0
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
800068c8:	df 03 26 00 	jeq %d3,0,80006914 <IfxMultican_Can_MsgObj_init+0x644>
800068cc:	82 13       	mov %d3,1
800068ce:	59 a3 0c 00 	st.w [%sp]12,%d3
800068d2:	54 ae       	ld.w %d14,[%sp]
800068d4:	1d ff 39 fd 	j 80006346 <IfxMultican_Can_MsgObj_init+0x76>
        {
            /* select receive FIFO base object for FCR.MMC */
            IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_receiveFifoBase);
        }
        /* for transmit FIFO base object */
        else if (transmitFifo)
800068d8:	df 0e ab 80 	jne %d14,0,80006a2e <IfxMultican_Can_MsgObj_init+0x75e>
        {
            /* select transmit FIFO base object for FCR.MMC */
            IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_transmitFifoBase);
        }
        /* for gateway FIFO source object */
        else if (gatewayFifo)
800068dc:	19 a2 10 00 	ld.w %d2,[%sp]16

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
800068e0:	82 04       	mov %d4,0
        {
            /* select transmit FIFO base object for FCR.MMC */
            IfxMultican_MsgObj_setMessageMode(hwObj, IfxMultican_MsgObjMode_transmitFifoBase);
        }
        /* for gateway FIFO source object */
        else if (gatewayFifo)
800068e2:	df 02 9d 7d 	jeq %d2,0,8000641c <IfxMultican_Can_MsgObj_init+0x14c>
800068e6:	8f 5a 00 30 	sh %d3,%d10,5
800068ea:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
800068ee:	02 e4       	mov %d4,%d14
800068f0:	54 22       	ld.w %d2,[%a2]
800068f2:	b7 42 04 20 	insert %d2,%d2,4,0,4
800068f6:	74 22       	st.w [%a2],%d2
800068f8:	1d ff 92 fd 	j 8000641c <IfxMultican_Can_MsgObj_init+0x14c>
800068fc:	82 03       	mov %d3,0
800068fe:	82 02       	mov %d2,0
80006900:	59 a3 08 00 	st.w [%sp]8,%d3
        exception = TRUE;
    }

    if (config->gatewayTransfers != 1)
    {
        receiveFifo  = (config->msgObjCount > 1) && (receiveFrame);
80006904:	19 a3 04 00 	ld.w %d3,[%sp]4
80006908:	74 a2       	st.w [%sp],%d2
8000690a:	8b 2c a0 22 	ge.u %d2,%d12,2
8000690e:	26 23       	and %d3,%d2
80006910:	df 03 de ff 	jne %d3,0,800068cc <IfxMultican_Can_MsgObj_init+0x5fc>
80006914:	59 a3 0c 00 	st.w [%sp]12,%d3
80006918:	82 0e       	mov %d14,0
        transmitFifo = (config->msgObjCount > 1) && (transmitFrame);
8000691a:	df 02 16 7d 	jeq %d2,0,80006346 <IfxMultican_Can_MsgObj_init+0x76>
8000691e:	54 ae       	ld.w %d14,[%sp]
80006920:	1d ff 13 fd 	j 80006346 <IfxMultican_Can_MsgObj_init+0x76>
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;

    if (config->msgObjId == config->firstSlaveObjId)
80006924:	4c 5e       	ld.w %d15,[%a5]56
                             (config->frame == IfxMultican_Frame_remoteAnswer) ||
                             (config->frame == IfxMultican_Frame_remoteRequest)) &&
                            (config->gatewayTransfers != 1);

    /* check for gateway source object */
    boolean gatewaySourceObj = (config->gatewayTransfers != 0) ? TRUE : FALSE;
80006926:	82 1d       	mov %d13,1

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
80006928:	0b fb 00 31 	eq %d3,%d11,%d15
8000692c:	59 a3 14 00 	st.w [%sp]20,%d3
80006930:	1d ff 02 fd 	j 80006334 <IfxMultican_Can_MsgObj_init+0x64>
            IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);

            /* clear all TXEN1 flags expect for the slave object in the FGPR.CUR of the base FIFO object */
            if (objId == firstSlaveObjId)
            {
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_transmitEnable1);
80006934:	6d ff 1e f5 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
80006938:	1d ff 0a ff 	j 8000674c <IfxMultican_Can_MsgObj_init+0x47c>
8000693c:	12 34       	add %d4,%d15,%d3
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
8000693e:	8f 54 00 50 	sh %d5,%d4,5
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006942:	c2 f2       	add %d2,-1
80006944:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80006948:	1b 14 00 60 	addi %d6,%d4,1
8000694c:	0b 32 00 21 	eq %d2,%d2,%d3
80006950:	2b 6f 40 22 	sel %d2,%d2,%d15,%d6
80006954:	8f f2 0f 51 	and %d5,%d2,255
80006958:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
8000695c:	c2 13       	add %d3,1
8000695e:	8f f2 cf 41 	andn %d4,%d2,255
80006962:	0f 54 a0 20 	or %d2,%d4,%d5
80006966:	59 22 04 01 	st.w [%a2]4100,%d2
8000696a:	b9 f2 08 00 	ld.hu %d2,[%a15]8
8000696e:	3f 23 e7 ff 	jlt.u %d3,%d2,8000693c <IfxMultican_Can_MsgObj_init+0x66c>
80006972:	1d ff 37 ff 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
}


IFX_INLINE void IfxMultican_MsgObj_setSingleTransmitTrial(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.STT = enabled ? 1 : 0;
80006976:	8f 5a 00 20 	sh %d2,%d10,5
8000697a:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
8000697e:	54 22       	ld.w %d2,[%a2]
80006980:	b7 02 81 2b 	insert %d2,%d2,0,23,1
80006984:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setSingleDataTransfer(Ifx_CAN_MO *hwObj, boolean enabled)
{
    hwObj->FCR.B.SDT = enabled ? 1 : 0;
80006986:	54 22       	ld.w %d2,[%a2]
80006988:	b7 02 01 2b 	insert %d2,%d2,0,22,1
8000698c:	74 22       	st.w [%a2],%d2
        }
    }

    {
        /* for standard message object */
        if (config->msgObjCount == 1)
8000698e:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006992:	df 12 a8 fd 	jne %d2,1,800064e2 <IfxMultican_Can_MsgObj_init+0x212>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006996:	06 5b       	sh %d11,5
80006998:	59 ab 04 00 	st.w [%sp]4,%d11
8000699c:	01 cb 00 26 	addsc.a %a2,%a12,%d11,0
        {
            /* long frame CAN FD */
            if (longFrame)
800069a0:	bd 0d 52 80 	jnz.a %a13,80006a44 <IfxMultican_Can_MsgObj_init+0x774>

                /* set top pointer FGPR.TOP */
                IfxMultican_MsgObj_setTopObjectPointer(hwObj, config->control.topMsgObjId);
            }
            /* standard gateway transfers */
            else if (gatewaySourceObj)
800069a4:	df 0d 08 01 	jeq %d13,0,80006bb4 <IfxMultican_Can_MsgObj_init+0x8e4>
800069a8:	19 22 04 01 	ld.w %d2,[%a2]4100
800069ac:	8f f4 0f 41 	and %d4,%d4,255
800069b0:	8f f2 cf 21 	andn %d2,%d2,255
800069b4:	a6 42       	or %d2,%d4
800069b6:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
800069ba:	19 22 04 01 	ld.w %d2,[%a2]4100
800069be:	8f 84 00 30 	sh %d3,%d4,8
800069c2:	b7 02 08 24 	insert %d2,%d2,0,8,8
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
800069c6:	8f 04 01 40 	sh %d4,%d4,16
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
800069ca:	a6 32       	or %d2,%d3
800069cc:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setCurrentObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.CUR = objNumber;
800069d0:	19 22 04 01 	ld.w %d2,[%a2]4100

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;
800069d4:	82 05       	mov %d5,0
800069d6:	b7 02 08 28 	insert %d2,%d2,0,16,8
800069da:	a6 24       	or %d4,%d2
800069dc:	59 24 04 01 	st.w [%a2]4100,%d4
800069e0:	59 a5 08 00 	st.w [%sp]8,%d5
800069e4:	1d ff af fd 	j 80006542 <IfxMultican_Can_MsgObj_init+0x272>
}


IFX_INLINE void IfxMultican_MsgObj_setDataLengthCode(Ifx_CAN_MO *hwObj, IfxMultican_DataLengthCode code)
{
    hwObj->FCR.B.DLC = code;
800069e8:	08 d2       	ld.bu %d2,[%a15]13
800069ea:	54 23       	ld.w %d3,[%a2]
800069ec:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800069f0:	74 22       	st.w [%a2],%d2
800069f2:	1d ff 59 fd 	j 800064a4 <IfxMultican_Can_MsgObj_init+0x1d4>

    /* for standard and receive FIFO base objects */
    if (config->frame == IfxMultican_Frame_receive)
    {
        /*  set RTSEL */
        IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveTransmitSelected);
800069f6:	60 84       	mov.a %a4,%d8
800069f8:	82 64       	mov %d4,6
800069fa:	6d ff bb f4 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>

        /* MSGVAL: Set message as valid */
        IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
800069fe:	60 84       	mov.a %a4,%d8
80006a00:	82 54       	mov %d4,5
80006a02:	6d ff b7 f4 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
80006a06:	1d ff b8 fe 	j 80006776 <IfxMultican_Can_MsgObj_init+0x4a6>
        }

        if ((config->frame == IfxMultican_Frame_receive) || (config->frame == IfxMultican_Frame_remoteAnswer))
        {
            /*  set RXEN, in case of recieve frame or remote answer*/
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receiveEnable);
80006a0a:	60 84       	mov.a %a4,%d8
80006a0c:	82 74       	mov %d4,7
80006a0e:	6d ff b1 f4 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
80006a12:	1d ff e8 fc 	j 800063e2 <IfxMultican_Can_MsgObj_init+0x112>
            /* long frame CAN FD */
            if (longFrame)
            {
                /* Allocate MO with extended Data fields slected by FGPR.B.TOP and FGPR.B.BOT, for the unallocated list (0) */
                /* Append message object to the end of the list(0) */
                IfxMultican_setListCommand(mcanSFR, 0x2, 0, config->control.topMsgObjId);
80006a16:	40 c4       	mov.aa %a4,%a12
80006a18:	48 46       	ld.w %d6,[%a15]16
80006a1a:	d2 24       	mov %e4,2
80006a1c:	6d ff f3 fb 	call 80006202 <IfxMultican_setListCommand>
                IfxMultican_setListCommand(mcanSFR, 0x2, 0, config->control.bottomMsgObjId);
80006a20:	40 c4       	mov.aa %a4,%a12
80006a22:	d2 24       	mov %e4,2
80006a24:	48 56       	ld.w %d6,[%a15]20
80006a26:	6d ff ee fb 	call 80006202 <IfxMultican_setListCommand>
80006a2a:	1d ff c1 fc 	j 800063ac <IfxMultican_Can_MsgObj_init+0xdc>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006a2e:	8f 5a 00 50 	sh %d5,%d10,5
80006a32:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80006a36:	82 04       	mov %d4,0
80006a38:	54 22       	ld.w %d2,[%a2]
80006a3a:	b7 22 04 20 	insert %d2,%d2,2,0,4
80006a3e:	74 22       	st.w [%a2],%d2
80006a40:	1d ff ee fc 	j 8000641c <IfxMultican_Can_MsgObj_init+0x14c>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006a44:	19 22 04 01 	ld.w %d2,[%a2]4100
80006a48:	39 f3 14 00 	ld.bu %d3,[%a15]20
80006a4c:	8f f2 cf 21 	andn %d2,%d2,255
80006a50:	a6 32       	or %d2,%d3
80006a52:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setTopObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.TOP = objNumber;
80006a56:	39 f2 10 00 	ld.bu %d2,[%a15]16
80006a5a:	8f 82 00 30 	sh %d3,%d2,8
80006a5e:	19 22 04 01 	ld.w %d2,[%a2]4100
80006a62:	b7 02 08 24 	insert %d2,%d2,0,8,8
80006a66:	a6 32       	or %d2,%d3
80006a68:	59 22 04 01 	st.w [%a2]4100,%d2

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;
80006a6c:	82 03       	mov %d3,0
80006a6e:	59 a3 08 00 	st.w [%sp]8,%d3
80006a72:	1d ff 68 fd 	j 80006542 <IfxMultican_Can_MsgObj_init+0x272>
                    gatewayDstObjId = config->gatewayConfig.gatewayDstObjId;
                }
            }
            /* long frame CAN FD */
            /* FDEN = 1, EDL = 1 and BRS = 0/1 */
            else if (config->node->fastNode && longFrame)
80006a76:	c8 02       	ld.a %a2,[%a15]0
80006a78:	80 d4       	mov.d %d4,%a13
80006a7a:	39 22 09 00 	ld.bu %d2,[%a2]9
80006a7e:	8b 02 20 22 	ne %d2,%d2,0
80006a82:	26 42       	and %d2,%d4
80006a84:	df 02 49 00 	jeq %d2,0,80006b16 <IfxMultican_Can_MsgObj_init+0x846>
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006a88:	8f 5a 00 50 	sh %d5,%d10,5
80006a8c:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80006a90:	82 04       	mov %d4,0
80006a92:	54 22       	ld.w %d2,[%a2]
80006a94:	b7 52 04 20 	insert %d2,%d2,5,0,4
80006a98:	74 22       	st.w [%a2],%d2
80006a9a:	1d ff c1 fc 	j 8000641c <IfxMultican_Can_MsgObj_init+0x14c>
80006a9e:	19 a2 08 00 	ld.w %d2,[%sp]8
80006aa2:	df 02 45 80 	jne %d2,0,80006b2c <IfxMultican_Can_MsgObj_init+0x85c>
80006aa6:	19 a3 10 00 	ld.w %d3,[%sp]16
80006aaa:	df 03 33 81 	jne %d3,0,80006d10 <IfxMultican_Can_MsgObj_init+0xa40>
80006aae:	19 a2 14 00 	ld.w %d2,[%sp]20
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006ab2:	82 08       	mov %d8,0
80006ab4:	df 02 07 01 	jeq %d2,0,80006cc2 <IfxMultican_Can_MsgObj_init+0x9f2>
80006ab8:	8f 5a 00 50 	sh %d5,%d10,5
80006abc:	01 c5 00 d6 	addsc.a %a13,%a12,%d5,0
80006ac0:	12 89       	add %d9,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006ac2:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006ac6:	8f 52 00 30 	sh %d3,%d2,5
80006aca:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80006ace:	82 54       	mov %d4,5
80006ad0:	6d ff 50 f4 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006ad4:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006ad8:	1b 19 00 40 	addi %d4,%d9,1
80006adc:	c2 f2       	add %d2,-1
80006ade:	0b 82 10 21 	ne %d2,%d2,%d8
80006ae2:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006ae6:	8f 59 00 40 	sh %d4,%d9,5
80006aea:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80006aee:	8f f2 0f 31 	and %d3,%d2,255
80006af2:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006af6:	c2 18       	add %d8,1
80006af8:	8f f2 cf 21 	andn %d2,%d2,255
80006afc:	a6 32       	or %d2,%d3
80006afe:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006b02:	54 d2       	ld.w %d2,[%a13]
80006b04:	b7 22 04 20 	insert %d2,%d2,2,0,4
80006b08:	74 d2       	st.w [%a13],%d2
80006b0a:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006b0e:	3f 28 d9 ff 	jlt.u %d8,%d2,80006ac0 <IfxMultican_Can_MsgObj_init+0x7f0>
80006b12:	1d ff 67 fe 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
80006b16:	8f 5a 00 20 	sh %d2,%d10,5
80006b1a:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0

    /* check for the gateway FIFO */
    boolean              gatewayFifo = (config->msgObjCount > 1) && (gatewaySourceObj);

    /* will be used for Fifo slave objects */
    IfxMultican_MsgObjId objId, firstSlaveObjId, lastSlaveObjId, gatewayDstObjId = 0;
80006b1e:	82 04       	mov %d4,0
80006b20:	54 22       	ld.w %d2,[%a2]
80006b22:	8f f2 c0 21 	andn %d2,%d2,15
80006b26:	74 22       	st.w [%a2],%d2
80006b28:	1d ff 7a fc 	j 8000641c <IfxMultican_Can_MsgObj_init+0x14c>
80006b2c:	19 a2 14 00 	ld.w %d2,[%sp]20
80006b30:	df 02 8c 00 	jeq %d2,0,80006c48 <IfxMultican_Can_MsgObj_init+0x978>
80006b34:	19 a2 10 00 	ld.w %d2,[%sp]16
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006b38:	82 08       	mov %d8,0
80006b3a:	df 02 76 80 	jne %d2,0,80006c26 <IfxMultican_Can_MsgObj_init+0x956>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006b3e:	19 a5 04 00 	ld.w %d5,[%sp]4
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006b42:	8f 5a 00 40 	sh %d4,%d10,5
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006b46:	01 c5 00 e6 	addsc.a %a14,%a12,%d5,0
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006b4a:	01 c4 00 d6 	addsc.a %a13,%a12,%d4,0
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006b4e:	d9 ee 04 01 	lea %a14,[%a14]4100
80006b52:	12 89       	add %d9,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006b54:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006b58:	8f 52 00 30 	sh %d3,%d2,5
80006b5c:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80006b60:	82 54       	mov %d4,5
80006b62:	6d ff 07 f4 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006b66:	b9 f2 08 00 	ld.hu %d2,[%a15]8
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80006b6a:	1b 19 00 40 	addi %d4,%d9,1
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006b6e:	c2 f2       	add %d2,-1
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80006b70:	0b 82 10 21 	ne %d2,%d2,%d8
80006b74:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006b78:	8f 59 00 40 	sh %d4,%d9,5
80006b7c:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80006b80:	8f f2 0f 31 	and %d3,%d2,255
80006b84:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006b88:	c2 18       	add %d8,1
80006b8a:	8f f2 cf 21 	andn %d2,%d2,255
80006b8e:	a6 32       	or %d2,%d3
80006b90:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006b94:	54 d2       	ld.w %d2,[%a13]
80006b96:	b7 22 04 20 	insert %d2,%d2,2,0,4
80006b9a:	74 d2       	st.w [%a13],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006b9c:	54 e2       	ld.w %d2,[%a14]
80006b9e:	08 43       	ld.bu %d3,[%a15]4
80006ba0:	8f f2 cf 21 	andn %d2,%d2,255
80006ba4:	a6 32       	or %d2,%d3
80006ba6:	74 e2       	st.w [%a14],%d2
80006ba8:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006bac:	3f 28 d3 ff 	jlt.u %d8,%d2,80006b52 <IfxMultican_Can_MsgObj_init+0x882>
80006bb0:	1d ff 18 fe 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>

    /* check for the receive FIFO and trabsmit FIFO */
    boolean receiveFifo         = FALSE, transmitFifo = FALSE;

    boolean exception           = FALSE;
    boolean bottomEqualsCurrent = FALSE;
80006bb4:	82 02       	mov %d2,0
}


IFX_INLINE void IfxMultican_MsgObj_clearFifoGatewayPointers(Ifx_CAN_MO *hwObj)
{
    hwObj->FGPR.U = 0x0000000U;
80006bb6:	59 2d 04 01 	st.w [%a2]4100,%d13
80006bba:	59 a2 08 00 	st.w [%sp]8,%d2
80006bbe:	1d ff c2 fc 	j 80006542 <IfxMultican_Can_MsgObj_init+0x272>
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006bc2:	19 a5 04 00 	ld.w %d5,[%sp]4
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006bc6:	8f 5a 00 40 	sh %d4,%d10,5
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006bca:	01 c5 00 46 	addsc.a %a4,%a12,%d5,0
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006bce:	01 c4 00 36 	addsc.a %a3,%a12,%d4,0
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006bd2:	82 03       	mov %d3,0
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006bd4:	d9 44 04 01 	lea %a4,[%a4]4100
80006bd8:	12 34       	add %d4,%d15,%d3
80006bda:	8f 54 00 50 	sh %d5,%d4,5
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006bde:	c2 f2       	add %d2,-1
80006be0:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80006be4:	1b 14 00 60 	addi %d6,%d4,1
80006be8:	0b 23 00 21 	eq %d2,%d3,%d2
80006bec:	2b 6f 40 22 	sel %d2,%d2,%d15,%d6
80006bf0:	8f f2 0f 51 	and %d5,%d2,255
80006bf4:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006bf8:	c2 13       	add %d3,1
80006bfa:	8f f2 cf 41 	andn %d4,%d2,255
80006bfe:	0f 54 a0 20 	or %d2,%d4,%d5
80006c02:	59 22 04 01 	st.w [%a2]4100,%d2
}


IFX_INLINE void IfxMultican_MsgObj_setMessageMode(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjMode mode)
{
    hwObj->FCR.B.MMC = mode;
80006c06:	54 32       	ld.w %d2,[%a3]
80006c08:	b7 22 04 20 	insert %d2,%d2,2,0,4
80006c0c:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006c0e:	54 42       	ld.w %d2,[%a4]
80006c10:	08 44       	ld.bu %d4,[%a15]4
80006c12:	8f f2 cf 21 	andn %d2,%d2,255
80006c16:	a6 42       	or %d2,%d4
80006c18:	74 42       	st.w [%a4],%d2
80006c1a:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006c1e:	3f 23 dd ff 	jlt.u %d3,%d2,80006bd8 <IfxMultican_Can_MsgObj_init+0x908>
80006c22:	1d ff df fd 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
80006c26:	12 82       	add %d2,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006c28:	1b 02 08 20 	addi %d2,%d2,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006c2c:	8f 52 00 30 	sh %d3,%d2,5
80006c30:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80006c34:	82 54       	mov %d4,5
80006c36:	6d ff 9d f3 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006c3a:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006c3e:	c2 18       	add %d8,1
80006c40:	3f 28 f3 ff 	jlt.u %d8,%d2,80006c26 <IfxMultican_Can_MsgObj_init+0x956>
80006c44:	1d ff ce fd 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
80006c48:	19 a3 10 00 	ld.w %d3,[%sp]16
80006c4c:	82 08       	mov %d8,0
80006c4e:	df 03 13 00 	jeq %d3,0,80006c74 <IfxMultican_Can_MsgObj_init+0x9a4>
80006c52:	12 82       	add %d2,%d15,%d8
80006c54:	1b 02 08 20 	addi %d2,%d2,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006c58:	8f 52 00 40 	sh %d4,%d2,5
80006c5c:	01 c4 00 46 	addsc.a %a4,%a12,%d4,0
80006c60:	82 54       	mov %d4,5
80006c62:	6d ff 87 f3 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006c66:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006c6a:	c2 18       	add %d8,1
80006c6c:	3f 28 f3 ff 	jlt.u %d8,%d2,80006c52 <IfxMultican_Can_MsgObj_init+0x982>
80006c70:	1d ff b8 fd 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
80006c74:	12 89       	add %d9,%d15,%d8
80006c76:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006c7a:	8f 52 00 50 	sh %d5,%d2,5
80006c7e:	01 c5 00 46 	addsc.a %a4,%a12,%d5,0
80006c82:	82 54       	mov %d4,5
80006c84:	6d ff 76 f3 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006c88:	b9 f2 08 00 	ld.hu %d2,[%a15]8
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006c8c:	8f 59 00 30 	sh %d3,%d9,5
80006c90:	c2 f2       	add %d2,-1
80006c92:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80006c96:	0b 82 10 21 	ne %d2,%d2,%d8
80006c9a:	1b 19 00 40 	addi %d4,%d9,1
80006c9e:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
80006ca2:	8f f2 0f 31 	and %d3,%d2,255
80006ca6:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006caa:	c2 18       	add %d8,1
80006cac:	8f f2 cf 21 	andn %d2,%d2,255
80006cb0:	a6 32       	or %d2,%d3
80006cb2:	59 22 04 01 	st.w [%a2]4100,%d2
80006cb6:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006cba:	3f 28 dd ff 	jlt.u %d8,%d2,80006c74 <IfxMultican_Can_MsgObj_init+0x9a4>
80006cbe:	1d ff 91 fd 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
80006cc2:	12 89       	add %d9,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006cc4:	1b 09 08 20 	addi %d2,%d9,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006cc8:	8f 52 00 30 	sh %d3,%d2,5
80006ccc:	01 c3 00 46 	addsc.a %a4,%a12,%d3,0
80006cd0:	82 54       	mov %d4,5
80006cd2:	6d ff 4f f3 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006cd6:	b9 f2 08 00 	ld.hu %d2,[%a15]8
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80006cda:	1b 19 00 40 	addi %d4,%d9,1
            /* for transmit FIFO and receive FIFO */
            if (!gatewayFifo)
            {
                /* store the next FIFO object number in the bottom pointer (FGPR.BOT) of the current FIFO object (for ease of use in transfers)*/
                /* if it is the last FIFO object */
                if (i == (config->msgObjCount - 1))
80006cde:	c2 f2       	add %d2,-1
                {            /* wrap around the FIFO by making the next pointer of last object as the first FIFO object */
                    nextFifoObj = firstSlaveObjId;
                }
                else
                {
                    nextFifoObj = objId + 1;
80006ce0:	0b 82 10 21 	ne %d2,%d2,%d8
80006ce4:	2b f4 40 22 	sel %d2,%d2,%d4,%d15
}


IFX_INLINE void IfxMultican_MsgObj_setBottomObjectPointer(Ifx_CAN_MO *hwObj, sint32 objNumber)
{
    hwObj->FGPR.B.BOT = objNumber;
80006ce8:	8f 59 00 40 	sh %d4,%d9,5
80006cec:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80006cf0:	8f f2 0f 31 	and %d3,%d2,255
80006cf4:	19 22 04 01 	ld.w %d2,[%a2]4100
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006cf8:	c2 18       	add %d8,1
80006cfa:	8f f2 cf 21 	andn %d2,%d2,255
80006cfe:	a6 32       	or %d2,%d3
80006d00:	59 22 04 01 	st.w [%a2]4100,%d2
80006d04:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006d08:	3f 28 dd ff 	jlt.u %d8,%d2,80006cc2 <IfxMultican_Can_MsgObj_init+0x9f2>
80006d0c:	1d ff 6a fd 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>
80006d10:	82 08       	mov %d8,0
80006d12:	12 82       	add %d2,%d15,%d8
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006d14:	1b 02 08 20 	addi %d2,%d2,128

            /* for receive FIFO and gateway FIFO */
            if (!transmitFifo)
            {
                /* MSGVAL: Set message as valid */
                IfxMultican_MsgObj_setStatusFlag(hwSlaveObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006d18:	8f 52 00 40 	sh %d4,%d2,5
80006d1c:	01 c4 00 46 	addsc.a %a4,%a12,%d4,0
80006d20:	82 54       	mov %d4,5
80006d22:	6d ff 27 f3 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
    /* for each receive FIFO slave object */
    if (config->msgObjCount > 1)
    {
        IfxMultican_MsgObjId nextFifoObj;

        for (i = 0; i < config->msgObjCount; i++)
80006d26:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006d2a:	c2 18       	add %d8,1
80006d2c:	3f 28 f3 ff 	jlt.u %d8,%d2,80006d12 <IfxMultican_Can_MsgObj_init+0xa42>
80006d30:	1d ff 58 fd 	j 800067e0 <IfxMultican_Can_MsgObj_init+0x510>

80006d34 <IfxMultican_Can_MsgObj_initConfig>:
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
    config->msgObjId                         = 0;
    config->msgObjCount                      = 1;
80006d34:	82 12       	mov %d2,1
80006d36:	f9 42 08 00 	st.h [%a4]8,%d2

    config->control.messageLen               = IfxMultican_DataLengthCode_8;
80006d3a:	3b 80 00 20 	mov %d2,8
80006d3e:	e9 42 0d 00 	st.b [%a4]13,%d2

    config->control.topMsgObjId              = 252;
80006d42:	3b c0 0f 20 	mov %d2,252
80006d46:	59 42 10 00 	st.w [%a4]16,%d2
    config->control.bottomMsgObjId           = 253;
80006d4a:	3b d0 0f 20 	mov %d2,253
80006d4e:	59 42 14 00 	st.w [%a4]20,%d2
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */
80006d52:	39 42 18 00 	ld.bu %d2,[%a4]24
void IfxMultican_Can_MsgObj_initConfig(IfxMultican_Can_MsgObjConfig *config, IfxMultican_Can_Node *node)
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
    config->msgObjId                         = 0;
80006d56:	82 0f       	mov %d15,0

    config->control.messageLen               = IfxMultican_DataLengthCode_8;

    config->control.topMsgObjId              = 252;
    config->control.bottomMsgObjId           = 253;
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */
80006d58:	8f 12 c0 21 	andn %d2,%d2,1
80006d5c:	e9 42 18 00 	st.b [%a4]24,%d2

    config->control.extendedFrame            = FALSE;
80006d60:	39 42 0e 00 	ld.bu %d2,[%a4]14

void IfxMultican_Can_MsgObj_initConfig(IfxMultican_Can_MsgObjConfig *config, IfxMultican_Can_Node *node)
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
80006d64:	f4 45       	st.a [%a4],%a5
    config->control.topMsgObjId              = 252;
    config->control.bottomMsgObjId           = 253;
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */

    config->control.extendedFrame            = FALSE;
    config->control.matchingId               = FALSE;
80006d66:	8f 32 c0 21 	andn %d2,%d2,3
80006d6a:	e9 42 0e 00 	st.b [%a4]14,%d2
    config->control.singleDataTransfer       = FALSE;
80006d6e:	39 42 0c 00 	ld.bu %d2,[%a4]12
void IfxMultican_Can_MsgObj_initConfig(IfxMultican_Can_MsgObjConfig *config, IfxMultican_Can_Node *node)
{
//    @$GENTABLE(MsgObjConfig,defaultConfig);

    config->node                             = node;
    config->msgObjId                         = 0;
80006d72:	6c 41       	st.w [%a4]4,%d15
    config->control.fastBitRate              = FALSE; /* fast bit rate enable/disable */

    config->control.extendedFrame            = FALSE;
    config->control.matchingId               = FALSE;
    config->control.singleDataTransfer       = FALSE;
    config->control.singleTransmitTrial      = FALSE;
80006d74:	8f 32 c0 21 	andn %d2,%d2,3
80006d78:	e9 42 0c 00 	st.b [%a4]12,%d2
    config->acceptanceMask                   = 0x7FFFFFFFUL;
80006d7c:	82 f2       	mov %d2,-1
80006d7e:	06 f2       	sh %d2,-1
80006d80:	59 42 20 00 	st.w [%a4]32,%d2
    config->messageId                        = 0;

    config->frame                            = IfxMultican_Frame_receive;
    config->priority                         = IfxMultican_Priority_CAN_ID;
80006d84:	82 22       	mov %d2,2
80006d86:	e9 42 28 00 	st.b [%a4]40,%d2
    config->txInterrupt.enabled              = FALSE;
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;

    config->firstSlaveObjId                  = 0;

    config->gatewayTransfers                 = FALSE;
80006d8a:	39 42 2e 00 	ld.bu %d2,[%a4]46
    config->control.extendedFrame            = FALSE;
    config->control.matchingId               = FALSE;
    config->control.singleDataTransfer       = FALSE;
    config->control.singleTransmitTrial      = FALSE;
    config->acceptanceMask                   = 0x7FFFFFFFUL;
    config->messageId                        = 0;
80006d8e:	6c 49       	st.w [%a4]36,%d15
    config->txInterrupt.enabled              = FALSE;
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;

    config->firstSlaveObjId                  = 0;

    config->gatewayTransfers                 = FALSE;
80006d90:	8f 12 c0 21 	andn %d2,%d2,1
80006d94:	e9 42 2e 00 	st.b [%a4]46,%d2
    config->gatewayConfig.copyDataLengthCode = TRUE;
80006d98:	39 42 30 00 	ld.bu %d2,[%a4]48
    config->control.singleDataTransfer       = FALSE;
    config->control.singleTransmitTrial      = FALSE;
    config->acceptanceMask                   = 0x7FFFFFFFUL;
    config->messageId                        = 0;

    config->frame                            = IfxMultican_Frame_receive;
80006d9c:	e9 4f 1c 00 	st.b [%a4]28,%d15
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;

    config->firstSlaveObjId                  = 0;

    config->gatewayTransfers                 = FALSE;
    config->gatewayConfig.copyDataLengthCode = TRUE;
80006da0:	b7 12 01 20 	insert %d2,%d2,1,0,1
    config->gatewayConfig.copyData           = TRUE;
80006da4:	b7 12 81 20 	insert %d2,%d2,1,1,1
    config->gatewayConfig.copyId             = TRUE;
80006da8:	b7 12 01 21 	insert %d2,%d2,1,2,1
    config->gatewayConfig.enableTransmit     = TRUE;
80006dac:	b7 12 81 21 	insert %d2,%d2,1,3,1
    config->acceptanceMask                   = 0x7FFFFFFFUL;
    config->messageId                        = 0;

    config->frame                            = IfxMultican_Frame_receive;
    config->priority                         = IfxMultican_Priority_CAN_ID;
    config->rxInterrupt.enabled              = FALSE;
80006db0:	e9 4f 2a 00 	st.b [%a4]42,%d15
    config->rxInterrupt.srcId                = IfxMultican_SrcId_0;
80006db4:	e9 4f 2b 00 	st.b [%a4]43,%d15
    config->txInterrupt.enabled              = FALSE;
80006db8:	e9 4f 2c 00 	st.b [%a4]44,%d15
    config->txInterrupt.srcId                = IfxMultican_SrcId_0;
80006dbc:	e9 4f 2d 00 	st.b [%a4]45,%d15

    config->firstSlaveObjId                  = 0;
80006dc0:	6c 4e       	st.w [%a4]56,%d15

    config->gatewayTransfers                 = FALSE;
    config->gatewayConfig.copyDataLengthCode = TRUE;
    config->gatewayConfig.copyData           = TRUE;
    config->gatewayConfig.copyId             = TRUE;
    config->gatewayConfig.enableTransmit     = TRUE;
80006dc2:	e9 42 30 00 	st.b [%a4]48,%d2
    config->gatewayConfig.gatewayDstObjId    = 0;
80006dc6:	6c 4d       	st.w [%a4]52,%d15
80006dc8:	00 90       	ret 

80006dca <IfxMultican_Can_MsgObj_isRxPending>:
}


boolean IfxMultican_Can_MsgObj_isRxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006dca:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->fifoPointer);
80006dce:	cc 40       	ld.a %a15,[%a4]0
}


boolean IfxMultican_Can_MsgObj_isRxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006dd0:	bf 2f 0f 80 	jlt.u %d15,2,80006dee <IfxMultican_Can_MsgObj_isRxPending+0x24>
80006dd4:	4c 43       	ld.w %d15,[%a4]12
80006dd6:	c8 04       	ld.a %a4,[%a15]0
80006dd8:	1b 0f 08 f0 	addi %d15,%d15,128
}


IFX_INLINE boolean IfxMultican_MsgObj_isRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat msgStatus = IfxMultican_MsgObj_getStatus(hwObj);
80006ddc:	8f 5f 00 20 	sh %d2,%d15,5
80006de0:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
80006de4:	6d ff df f0 	call 80004fa2 <IfxMultican_MsgObj_getStatus>
    return msgStatus.B.RXPND ? TRUE : FALSE;
80006de8:	8f 12 00 21 	and %d2,%d2,1
    else
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
        return IfxMultican_MsgObj_isRxPending(hwObj);
    }
}
80006dec:	00 90       	ret 
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006dee:	4c 41       	ld.w %d15,[%a4]4
80006df0:	3c f3       	j 80006dd6 <IfxMultican_Can_MsgObj_isRxPending+0xc>

80006df2 <IfxMultican_Can_MsgObj_isTransmitRequested>:


boolean IfxMultican_Can_MsgObj_isTransmitRequested(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006df2:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->fifoPointer);
80006df6:	cc 40       	ld.a %a15,[%a4]0
}


boolean IfxMultican_Can_MsgObj_isTransmitRequested(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006df8:	bf 2f 0f 80 	jlt.u %d15,2,80006e16 <IfxMultican_Can_MsgObj_isTransmitRequested+0x24>
80006dfc:	4c 43       	ld.w %d15,[%a4]12
80006dfe:	c8 04       	ld.a %a4,[%a15]0
80006e00:	1b 0f 08 f0 	addi %d15,%d15,128
}


IFX_INLINE boolean IfxMultican_MsgObj_isTransmitRequested(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat msgStatus = IfxMultican_MsgObj_getStatus(hwObj);
80006e04:	8f 5f 00 20 	sh %d2,%d15,5
80006e08:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
80006e0c:	6d ff cb f0 	call 80004fa2 <IfxMultican_MsgObj_getStatus>
    return msgStatus.B.TXRQ ? TRUE : FALSE;
80006e10:	37 02 61 24 	extr.u %d2,%d2,8,1
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);

        return IfxMultican_MsgObj_isTransmitRequested(hwObj);
    }
}
80006e14:	00 90       	ret 
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006e16:	4c 41       	ld.w %d15,[%a4]4
80006e18:	3c f3       	j 80006dfe <IfxMultican_Can_MsgObj_isTransmitRequested+0xc>

80006e1a <IfxMultican_Can_MsgObj_isTxPending>:


boolean IfxMultican_Can_MsgObj_isTxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006e1a:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->fifoPointer);
80006e1e:	cc 40       	ld.a %a15,[%a4]0
}


boolean IfxMultican_Can_MsgObj_isTxPending(IfxMultican_Can_MsgObj *msgObj)
{
    if (msgObj->msgObjCount > 1)
80006e20:	bf 2f 0f 80 	jlt.u %d15,2,80006e3e <IfxMultican_Can_MsgObj_isTxPending+0x24>
80006e24:	4c 43       	ld.w %d15,[%a4]12
80006e26:	c8 04       	ld.a %a4,[%a15]0
80006e28:	1b 0f 08 f0 	addi %d15,%d15,128
}


IFX_INLINE boolean IfxMultican_MsgObj_isTxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObjStat msgStatus = IfxMultican_MsgObj_getStatus(hwObj);
80006e2c:	8f 5f 00 20 	sh %d2,%d15,5
80006e30:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
80006e34:	6d ff b7 f0 	call 80004fa2 <IfxMultican_MsgObj_getStatus>
    return msgStatus.B.TXPND ? TRUE : FALSE;
80006e38:	37 02 e1 20 	extr.u %d2,%d2,1,1
    {
        Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);

        return IfxMultican_MsgObj_isTxPending(hwObj);
    }
}
80006e3c:	00 90       	ret 
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006e3e:	4c 41       	ld.w %d15,[%a4]4
80006e40:	3c f3       	j 80006e26 <IfxMultican_Can_MsgObj_isTxPending+0xc>

80006e42 <IfxMultican_Can_MsgObj_readMessage>:
IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
80006e42:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
80006e46:	80 44       	mov.d %d4,%a4
80006e48:	80 43       	mov.d %d3,%a4
80006e4a:	1b c4 00 20 	addi %d2,%d4,12
80006e4e:	c2 43       	add %d3,4
80006e50:	8b 2f 60 f2 	lt.u %d15,%d15,2
80006e54:	2b 23 40 ff 	sel %d15,%d15,%d3,%d2
80006e58:	60 f2       	mov.a %a2,%d15
    }
}


IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
80006e5a:	40 4f       	mov.aa %a15,%a4
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
80006e5c:	54 28       	ld.w %d8,[%a2]
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006e5e:	d4 42       	ld.a %a2,[%a4]
80006e60:	1b 08 08 20 	addi %d2,%d8,128
}


IFX_INLINE void IfxMultican_MsgObj_clearRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
80006e64:	82 04       	mov %d4,0
80006e66:	4c 20       	ld.w %d15,[%a2]0
    }
}


IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
80006e68:	40 5d       	mov.aa %a13,%a5
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006e6a:	13 02 22 3f 	madd %d3,%d15,%d2,32
}


IFX_INLINE void IfxMultican_MsgObj_clearRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
80006e6e:	60 34       	mov.a %a4,%d3
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006e70:	60 3c       	mov.a %a12,%d3
}


IFX_INLINE void IfxMultican_MsgObj_clearRxPending(Ifx_CAN_MO *hwObj)
{
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
80006e72:	6d ff 55 f0 	call 80004f1c <IfxMultican_MsgObj_clearStatusFlag>

    /* clear pending flag */
    IfxMultican_MsgObj_clearRxPending(hwObj);

    /* read the message object */
    status = IfxMultican_MsgObj_readMessage(hwObj, msg);
80006e76:	40 c4       	mov.aa %a4,%a12
80006e78:	40 d5       	mov.aa %a5,%a13
80006e7a:	6d ff dd f0 	call 80005034 <IfxMultican_MsgObj_readMessage>

    /* if successfull: */
    if (status & IfxMultican_Status_newData)
80006e7e:	6f 82 0d 00 	jz.t %d2,8,80006e98 <IfxMultican_Can_MsgObj_readMessage+0x56>
    {
        if (msgObj->msgObjCount > 1)
80006e82:	b9 f3 08 00 	ld.hu %d3,[%a15]8
80006e86:	bf 23 09 80 	jlt.u %d3,2,80006e98 <IfxMultican_Can_MsgObj_readMessage+0x56>
}


IFX_INLINE IfxMultican_MsgObjId IfxMultican_MsgObj_getBottomObjectPointer(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_MsgObjId)(hwObj->FGPR.B.BOT);
80006e8a:	13 08 22 4f 	madd %d4,%d15,%d8,32
80006e8e:	60 42       	mov.a %a2,%d4
80006e90:	19 2f 04 01 	ld.w %d15,[%a2]4100
80006e94:	16 ff       	and %d15,255
80006e96:	68 3f       	st.w [%a15]12,%d15
        else
        {}
    }

    return status;
}
80006e98:	00 90       	ret 

80006e9a <IfxMultican_Can_MsgObj_sendMessage>:
IfxMultican_Status IfxMultican_Can_MsgObj_sendMessage(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Message *msg)
{
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
80006e9a:	b9 4f 08 00 	ld.hu %d15,[%a4]8
    return status;
}


IfxMultican_Status IfxMultican_Can_MsgObj_sendMessage(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Message *msg)
{
80006e9e:	40 4f       	mov.aa %a15,%a4
80006ea0:	40 5c       	mov.aa %a12,%a5
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
80006ea2:	bf 2f 2c 80 	jlt.u %d15,2,80006efa <IfxMultican_Can_MsgObj_sendMessage+0x60>
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006ea6:	19 42 04 00 	ld.w %d2,[%a4]4
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;

        Ifx_CAN_MO *hwBaseObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
80006eaa:	d4 42       	ld.a %a2,[%a4]
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
80006eac:	19 48 0c 00 	ld.w %d8,[%a4]12
80006eb0:	d4 24       	ld.a %a4,[%a2]
80006eb2:	1b 02 08 f0 	addi %d15,%d2,128

        Ifx_CAN_MO *hwBaseObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);

        /* set message as valid, in case of FIFO MSGVAL of base object has to be set before setting it to each slave object */
        IfxMultican_MsgObj_setStatusFlag(hwBaseObj, IfxMultican_MsgObjStatusFlag_messageValid);
80006eb6:	8f 5f 00 30 	sh %d3,%d15,5
80006eba:	01 43 00 46 	addsc.a %a4,%a4,%d3,0
80006ebe:	82 54       	mov %d4,5
80006ec0:	6d ff 58 f2 	call 80005370 <IfxMultican_MsgObj_setStatusFlag>
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006ec4:	c8 02       	ld.a %a2,[%a15]0
80006ec6:	1b 08 08 20 	addi %d2,%d8,128
80006eca:	4c 20       	ld.w %d15,[%a2]0
80006ecc:	13 02 22 3f 	madd %d3,%d15,%d2,32

    if (msgObj->msgObjCount > 1)
80006ed0:	b9 f2 08 00 	ld.hu %d2,[%a15]8
80006ed4:	60 34       	mov.a %a4,%d3
80006ed6:	bf 22 1b 80 	jlt.u %d2,2,80006f0c <IfxMultican_Can_MsgObj_sendMessage+0x72>
    {
        /* send the message */
        status = IfxMultican_MsgObj_writeTxfifo(hwObj, msg);
80006eda:	40 c5       	mov.aa %a5,%a12
80006edc:	6d ff f3 f1 	call 800052c2 <IfxMultican_MsgObj_writeTxfifo>
        /* send the message */
        status = IfxMultican_MsgObj_sendMessage(hwObj, msg);
    }

    /* if successfull: */
    if (status == IfxMultican_Status_ok)
80006ee0:	f6 2c       	jnz %d2,80006ef8 <IfxMultican_Can_MsgObj_sendMessage+0x5e>
    {
        if (msgObj->msgObjCount > 1)
80006ee2:	b9 f3 08 00 	ld.hu %d3,[%a15]8
80006ee6:	bf 23 09 80 	jlt.u %d3,2,80006ef8 <IfxMultican_Can_MsgObj_sendMessage+0x5e>
}


IFX_INLINE IfxMultican_MsgObjId IfxMultican_MsgObj_getBottomObjectPointer(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_MsgObjId)(hwObj->FGPR.B.BOT);
80006eea:	13 08 22 3f 	madd %d3,%d15,%d8,32
80006eee:	60 32       	mov.a %a2,%d3
80006ef0:	19 2f 04 01 	ld.w %d15,[%a2]4100
80006ef4:	16 ff       	and %d15,255
80006ef6:	68 3f       	st.w [%a15]12,%d15
        else
        {}
    }

    return status;
}
80006ef8:	00 90       	ret 
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006efa:	d4 42       	ld.a %a2,[%a4]
        IfxMultican_MsgObj_setStatusFlag(hwBaseObj, IfxMultican_MsgObjStatusFlag_messageValid);
    }
    else
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
80006efc:	19 48 04 00 	ld.w %d8,[%a4]4
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
80006f00:	4c 20       	ld.w %d15,[%a2]0
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
80006f02:	1b 08 08 20 	addi %d2,%d8,128
80006f06:	13 02 22 3f 	madd %d3,%d15,%d2,32
80006f0a:	60 34       	mov.a %a4,%d3
        status = IfxMultican_MsgObj_writeTxfifo(hwObj, msg);
    }
    else
    {
        /* send the message */
        status = IfxMultican_MsgObj_sendMessage(hwObj, msg);
80006f0c:	40 c5       	mov.aa %a5,%a12
80006f0e:	6d ff ab f1 	call 80005264 <IfxMultican_MsgObj_sendMessage>
80006f12:	3c e7       	j 80006ee0 <IfxMultican_Can_MsgObj_sendMessage+0x46>

80006f14 <IfxMultican_Can_Node_getConfig>:
{
    Ifx_CAN_N      *hwNode = node->node;

    IfxMultican_Can mcan;

    mcan.mcan = node->mcan;
80006f14:	d4 4d       	ld.a %a13,[%a4]
    return status;
}


void IfxMultican_Can_Node_getConfig(IfxMultican_Can_Node *node, IfxMultican_Can_NodeConfig *config)
{
80006f16:	40 5f       	mov.aa %a15,%a5
    Ifx_CAN_N      *hwNode = node->node;
80006f18:	99 4c 04 00 	ld.a %a12,[%a4]4
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
80006f1c:	19 df 08 70 	ld.w %d15,[%a13]456
80006f20:	16 0f       	and %d15,15

void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
80006f22:	9e 1c       	jeq %d15,1,80006f5a <IfxMultican_Can_Node_getConfig+0x46>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
80006f24:	df 2f 42 00 	jeq %d15,2,80006fa8 <IfxMultican_Can_Node_getConfig+0x94>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
80006f28:	9e 45       	jeq %d15,4,80006f52 <IfxMultican_Can_Node_getConfig+0x3e>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
80006f2a:	82 04       	mov %d4,0

    mcan.mcan = node->mcan;

    float32         fcan = IfxMultican_Can_getModuleFrequency(&mcan);

    IfxMultican_calcTimingFromBTR(fcan, hwNode->BTR.U, &config->baudrate, &config->samplePoint, &config->synchJumpWidth);
80006f2c:	19 c5 10 00 	ld.w %d5,[%a12]16
80006f30:	d9 f4 08 00 	lea %a4,[%a15]8
80006f34:	d9 f5 0c 00 	lea %a5,[%a15]12
80006f38:	d9 f6 0e 00 	lea %a6,[%a15]14
80006f3c:	6d ff 4e f8 	call 80005fd8 <IfxMultican_calcTimingFromBTR>

    config->loopBackMode = (hwNode->PCR.B.LBM != 0) ? TRUE : FALSE;
80006f40:	4c c3       	ld.w %d15,[%a12]12
80006f42:	37 0f 61 f4 	extr.u %d15,%d15,8,1
80006f46:	28 6f       	st.b [%a15]6,%d15
    config->analyzerMode = (hwNode->CR.B.CALM != 0) ? TRUE : FALSE;
80006f48:	4c c0       	ld.w %d15,[%a12]0
80006f4a:	37 0f e1 f3 	extr.u %d15,%d15,7,1
80006f4e:	28 5f       	st.b [%a15]5,%d15
80006f50:	00 90       	ret 
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
80006f52:	6d 00 e4 0d 	call 80008b1a <IfxScuCcu_getPllErayFrequency>
80006f56:	02 24       	mov %d4,%d2
80006f58:	3c ea       	j 80006f2c <IfxMultican_Can_Node_getConfig+0x18>
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006f5a:	6d 00 f2 0e 	call 80008d3e <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
80006f5e:	91 30 00 2f 	movh.a %a2,61443
80006f62:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006f66:	54 23       	ld.w %d3,[%a2]
    {
        canFrequency = 0.0f;
80006f68:	82 0f       	mov %d15,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
80006f6a:	8f f3 00 31 	and %d3,%d3,15
80006f6e:	76 38       	jz %d3,80006f7e <IfxMultican_Can_Node_getConfig+0x6a>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
80006f70:	54 24       	ld.w %d4,[%a2]
80006f72:	8f f4 00 41 	and %d4,%d4,15
80006f76:	4b 04 41 41 	itof %d4,%d4
80006f7a:	4b 42 51 f0 	div.f %d15,%d2,%d4
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
80006f7e:	19 d2 0c 00 	ld.w %d2,[%a13]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80006f82:	19 d4 0c 00 	ld.w %d4,[%a13]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
80006f86:	37 02 62 27 	extr.u %d2,%d2,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80006f8a:	b7 04 16 45 	insert %d4,%d4,0,10,22
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
80006f8e:	df 12 11 00 	jeq %d2,1,80006fb0 <IfxMultican_Can_Node_getConfig+0x9c>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
80006f92:	4b 04 41 41 	itof %d4,%d4
80006f96:	7b 00 a8 33 	movh %d3,14976
80006f9a:	4b 34 41 40 	mul.f %d4,%d4,%d3
80006f9e:	4b f4 41 40 	mul.f %d4,%d4,%d15

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
80006fa2:	df 22 c4 ff 	jne %d2,2,80006f2a <IfxMultican_Can_Node_getConfig+0x16>
80006fa6:	3c c3       	j 80006f2c <IfxMultican_Can_Node_getConfig+0x18>
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
80006fa8:	6d 00 99 0d 	call 80008ada <IfxScuCcu_getOsc0Frequency>
80006fac:	02 24       	mov %d4,%d2
80006fae:	3c bf       	j 80006f2c <IfxMultican_Can_Node_getConfig+0x18>
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
80006fb0:	3b 00 40 20 	mov %d2,1024
80006fb4:	0b 42 80 40 	sub %d4,%d2,%d4
80006fb8:	4b 04 41 41 	itof %d4,%d4
80006fbc:	4b 4f 51 40 	div.f %d4,%d15,%d4
80006fc0:	3c b6       	j 80006f2c <IfxMultican_Can_Node_getConfig+0x18>

80006fc2 <IfxMultican_Can_Node_init>:
}


IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
80006fc2:	79 5f 04 00 	ld.b %d15,[%a5]4
80006fc6:	d4 5e       	ld.a %a14,[%a5]
}


IFX_INLINE Ifx_CAN_N *IfxMultican_Node_getPointer(Ifx_CAN *mcan, IfxMultican_NodeId node)
{
    return &(mcan->N[node]);
80006fc8:	92 29       	add %d9,%d15,2
80006fca:	8f 89 00 20 	sh %d2,%d9,8
80006fce:	01 e2 00 c6 	addsc.a %a12,%a14,%d2,0
    IfxMultican_Status status = IfxMultican_Status_ok;

    node->mcan     = config->module;
    node->node     = hwNode;
    node->nodeId   = config->nodeId;
    node->fastNode = FALSE;
80006fd2:	82 02       	mov %d2,0
80006fd4:	e9 42 09 00 	st.b [%a4]9,%d2
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
    IfxMultican_Status status = IfxMultican_Status_ok;

    node->mcan     = config->module;
    node->node     = hwNode;
    node->nodeId   = config->nodeId;
80006fd8:	2c 48       	st.b [%a4]8,%d15
IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
    IfxMultican_Status status = IfxMultican_Status_ok;

    node->mcan     = config->module;
80006fda:	f4 4e       	st.a [%a4],%a14
    node->node     = hwNode;
80006fdc:	b5 4c 04 00 	st.a [%a4]4,%a12
}


IFX_INLINE void IfxMultican_Node_resetControlRegister(Ifx_CAN_N *hwNode)
{
    hwNode->CR.U = 0x00000041U;
80006fe0:	3b 10 04 20 	mov %d2,65
80006fe4:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setTransferInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.TRIE = enabled ? 1 : 0;
80006fe6:	39 52 36 00 	ld.bu %d2,[%a5]54
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
80006fea:	8f 8f 00 a0 	sh %d10,%d15,8
}


IFX_INLINE void IfxMultican_Node_setTransferInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.TRIE = enabled ? 1 : 0;
80006fee:	ab 22 a0 32 	seln %d3,%d2,%d2,2
80006ff2:	54 c2       	ld.w %d2,[%a12]
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
80006ff4:	01 ea 00 26 	addsc.a %a2,%a14,%d10,0
}


IFX_INLINE void IfxMultican_Node_setTransferInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.TRIE = enabled ? 1 : 0;
80006ff8:	8f 22 c0 21 	andn %d2,%d2,2
80006ffc:	a6 32       	or %d2,%d3
80006ffe:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setLastErrorCodeInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.LECIE = enabled ? 1 : 0;
80007000:	39 52 38 00 	ld.bu %d2,[%a5]56
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
80007004:	82 0f       	mov %d15,0
}


IFX_INLINE void IfxMultican_Node_setLastErrorCodeInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.LECIE = enabled ? 1 : 0;
80007006:	ab 42 a0 32 	seln %d3,%d2,%d2,4
8000700a:	54 c2       	ld.w %d2,[%a12]
    config->analyzerMode = (hwNode->CR.B.CALM != 0) ? TRUE : FALSE;
}


IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
8000700c:	40 5f       	mov.aa %a15,%a5
8000700e:	8f 42 c0 21 	andn %d2,%d2,4
80007012:	a6 32       	or %d2,%d3
80007014:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setAlertInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.ALIE = enabled ? 1 : 0;
80007016:	39 52 3a 00 	ld.bu %d2,[%a5]58
8000701a:	20 08       	sub.a %sp,8
8000701c:	ab 82 a0 32 	seln %d3,%d2,%d2,8
80007020:	54 c2       	ld.w %d2,[%a12]
80007022:	40 4d       	mov.aa %a13,%a4
80007024:	8f 82 c0 21 	andn %d2,%d2,8
80007028:	a6 32       	or %d2,%d3
8000702a:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_setAnalyzerMode(Ifx_CAN_N *hwNode, boolean mode)
{
    hwNode->CR.B.CALM = mode != FALSE;
8000702c:	39 52 05 00 	ld.bu %d2,[%a5]5
80007030:	ab 02 a8 32 	seln %d3,%d2,%d2,128
80007034:	54 c2       	ld.w %d2,[%a12]
80007036:	8f 02 c8 21 	andn %d2,%d2,128
8000703a:	a6 32       	or %d2,%d3
8000703c:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_activate(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.INIT = 0;
8000703e:	54 c2       	ld.w %d2,[%a12]
80007040:	8f 12 c0 21 	andn %d2,%d2,1
80007044:	74 c2       	st.w [%a12],%d2
}


IFX_INLINE void IfxMultican_Node_resetInterruptPointers(Ifx_CAN_N *hwNode)
{
    hwNode->IPR.U = 0x00000000U;
80007046:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setTransferInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.TRINP = srcId;
8000704a:	19 22 08 80 	ld.w %d2,[%a2]520
8000704e:	39 5f 37 00 	ld.bu %d15,[%a5]55
80007052:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
80007056:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setLastErrorCodeInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.LECINP = srcId;
8000705a:	19 22 08 80 	ld.w %d2,[%a2]520
8000705e:	39 5f 39 00 	ld.bu %d15,[%a5]57
80007062:	37 f2 04 f2 	insert %d15,%d2,%d15,4,4
80007066:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setAlertInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.ALINP = srcId;
8000706a:	39 5f 3b 00 	ld.bu %d15,[%a5]59
8000706e:	19 22 08 80 	ld.w %d2,[%a2]520
80007072:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
80007076:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setFrameCounterInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.CFCINP = srcId;
8000707a:	39 5f 3d 00 	ld.bu %d15,[%a5]61
8000707e:	19 22 08 80 	ld.w %d2,[%a2]520
80007082:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
80007086:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_setTimerEventInterruptPointer(Ifx_CAN_N *hwNode, IfxMultican_SrcId srcId)
{
    hwNode->IPR.B.TEINP = srcId;
8000708a:	19 22 08 80 	ld.w %d2,[%a2]520
8000708e:	39 5f 3f 00 	ld.bu %d15,[%a5]63
80007092:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
80007096:	59 2f 08 80 	st.w [%a2]520,%d15
}


IFX_INLINE void IfxMultican_Node_resetErrorCounters(Ifx_CAN_N *hwNode)
{
    hwNode->ECNT.U = 0x00600000U;
8000709a:	7b 00 06 f0 	movh %d15,96
8000709e:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setReceiveErrorCounter(Ifx_CAN_N *hwNode, uint8 value)
{
    hwNode->ECNT.B.REC = value;
800070a2:	19 2f 14 80 	ld.w %d15,[%a2]532
800070a6:	8f ff cf f1 	andn %d15,%d15,255
800070aa:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setTransmitErrorCounter(Ifx_CAN_N *hwNode, uint8 value)
{
    hwNode->ECNT.B.TEC = value;
800070ae:	19 2f 14 80 	ld.w %d15,[%a2]532
800070b2:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
800070b6:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setErrorWarningLevel(Ifx_CAN_N *hwNode, uint8 level)
{
    hwNode->ECNT.B.EWRNLVL = level;
800070ba:	39 5f 35 00 	ld.bu %d15,[%a5]53
800070be:	8f 0f 01 20 	sh %d2,%d15,16
800070c2:	19 2f 14 80 	ld.w %d15,[%a2]532
800070c6:	b7 0f 08 f8 	insert %d15,%d15,0,16,8
800070ca:	a6 2f       	or %d15,%d2
800070cc:	59 2f 14 80 	st.w [%a2]532,%d15
}


IFX_INLINE void IfxMultican_Node_setLoopBackMode(Ifx_CAN_N *hwNode, boolean mode)
{
    hwNode->PCR.B.LBM = mode != FALSE;
800070d0:	39 52 06 00 	ld.bu %d2,[%a5]6
800070d4:	3b 00 10 f0 	mov %d15,256
800070d8:	ab 0f 80 22 	sel %d2,%d2,%d15,0
800070dc:	19 2f 0c 80 	ld.w %d15,[%a2]524
800070e0:	8f 0f d0 f1 	andn %d15,%d15,256
800070e4:	a6 2f       	or %d15,%d2
800070e6:	59 2f 0c 80 	st.w [%a2]524,%d15
    }

    {                           /* NPCR write enabled only of NCR.CCE set */
        IfxMultican_Node_setLoopBackMode(hwNode, config->loopBackMode);

        if (config->txPin != NULL_PTR)
800070ea:	99 55 30 00 	ld.a %a5,[%a5]48


IfxMultican_Status IfxMultican_Can_Node_init(IfxMultican_Can_Node *node, const IfxMultican_Can_NodeConfig *config)
{
    Ifx_CAN_N         *hwNode = IfxMultican_Node_getPointer(config->module, config->nodeId);
    IfxMultican_Status status = IfxMultican_Status_ok;
800070ee:	82 0f       	mov %d15,0
    }

    {                           /* NPCR write enabled only of NCR.CCE set */
        IfxMultican_Node_setLoopBackMode(hwNode, config->loopBackMode);

        if (config->txPin != NULL_PTR)
800070f0:	bc 5a       	jz.a %a5,80007104 <IfxMultican_Can_Node_init+0x142>
        {
            status |= (IfxMultican_Node_initTxPin(hwNode, config->txPin, config->txPinMode, config->pinDriver) ? IfxMultican_Status_ok : IfxMultican_Status_wrongPin);
800070f2:	40 c4       	mov.aa %a4,%a12
800070f4:	39 f4 34 00 	ld.bu %d4,[%a15]52
800070f8:	39 f5 00 10 	ld.bu %d5,[%a15]64
800070fc:	6d ff 67 f1 	call 800053ca <IfxMultican_Node_initTxPin>
80007100:	ab 4f 80 f2 	sel %d15,%d2,%d15,4
        }

        if (config->rxPin != NULL_PTR)
80007104:	c8 a5       	ld.a %a5,[%a15]40
80007106:	bc 5e       	jz.a %a5,80007122 <IfxMultican_Can_Node_init+0x160>
        {
            status |= (IfxMultican_Node_initRxPin(hwNode, config->rxPin, config->rxPinMode, config->pinDriver) ? IfxMultican_Status_ok : IfxMultican_Status_wrongPin);
80007108:	40 c4       	mov.aa %a4,%a12
8000710a:	79 f4 2c 00 	ld.b %d4,[%a15]44
8000710e:	39 f5 00 10 	ld.bu %d5,[%a15]64
80007112:	6d ff 43 f1 	call 80005398 <IfxMultican_Node_initRxPin>
80007116:	82 03       	mov %d3,0
80007118:	ab 43 20 22 	caddn %d2,%d2,%d3,4
8000711c:	a6 2f       	or %d15,%d2
8000711e:	37 0f 70 f0 	extr.u %d15,%d15,0,16
        }
    }

    {
        IfxMultican_Can mcan;
        mcan.mcan = node->mcan;
80007122:	d4 d2       	ld.a %a2,[%a13]
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
80007124:	19 22 08 70 	ld.w %d2,[%a2]456
80007128:	8f f2 00 21 	and %d2,%d2,15

void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
8000712c:	df 12 6e 00 	jeq %d2,1,80007208 <IfxMultican_Can_Node_init+0x246>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
80007130:	df 22 98 00 	jeq %d2,2,80007260 <IfxMultican_Can_Node_init+0x29e>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
80007134:	df 42 66 00 	jeq %d2,4,80007200 <IfxMultican_Can_Node_init+0x23e>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
80007138:	82 08       	mov %d8,0
        IfxMultican_Can mcan;
        mcan.mcan = node->mcan;

        float32         fcan = IfxMultican_Can_getModuleFrequency(&mcan);

        if (!config->flexibleDataRate)
8000713a:	39 f2 10 00 	ld.bu %d2,[%a15]16
8000713e:	df 02 57 00 	jeq %d2,0,800071ec <IfxMultican_Can_Node_init+0x22a>
}


IFX_INLINE void IfxMultican_Node_setFastNode(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->CR.B.INIT = 1;
80007142:	8f 89 00 20 	sh %d2,%d9,8
80007146:	01 e2 00 36 	addsc.a %a3,%a14,%d2,0
        else
        {
            IfxMultican_Node_setFastNode(hwNode, TRUE);
            node->fastNode = TRUE;

            IfxMultican_Node_setNominalBitTiming(hwNode, fcan, config->fdConfig.nominalBaudrate, config->fdConfig.nominalSamplePoint, config->fdConfig.nominalSynchJumpWidth);
8000714a:	40 c4       	mov.aa %a4,%a12
8000714c:	54 32       	ld.w %d2,[%a3]
8000714e:	02 84       	mov %d4,%d8
80007150:	8f 12 40 21 	or %d2,%d2,1
80007154:	74 32       	st.w [%a3],%d2
    hwNode->CR.B.FDEN = enabled ? 1 : 0;
80007156:	54 32       	ld.w %d2,[%a3]
80007158:	b7 f2 81 24 	insert %d2,%d2,15,9,1
8000715c:	74 32       	st.w [%a3],%d2
    hwNode->CR.B.INIT = 0;
8000715e:	54 32       	ld.w %d2,[%a3]
80007160:	8f 12 c0 21 	andn %d2,%d2,1
80007164:	74 32       	st.w [%a3],%d2
            IfxMultican_Node_setBitTiming(hwNode, fcan, config->baudrate, config->samplePoint, config->synchJumpWidth);
        }
        else
        {
            IfxMultican_Node_setFastNode(hwNode, TRUE);
            node->fastNode = TRUE;
80007166:	82 12       	mov %d2,1
80007168:	e9 d2 09 00 	st.b [%a13]9,%d2

            IfxMultican_Node_setNominalBitTiming(hwNode, fcan, config->fdConfig.nominalBaudrate, config->fdConfig.nominalSamplePoint, config->fdConfig.nominalSynchJumpWidth);
8000716c:	48 55       	ld.w %d5,[%a15]20
8000716e:	b9 f6 1a 00 	ld.hu %d6,[%a15]26
80007172:	b9 f7 18 00 	ld.hu %d7,[%a15]24
80007176:	6d ff 6b f6 	call 80005e4c <IfxMultican_Node_setNominalBitTiming>
            IfxMultican_Node_setFastBitTiming(hwNode, fcan, config->fdConfig.fastBaudrate, config->fdConfig.fastSamplePoint, config->fdConfig.fastSynchJumpWidth);
8000717a:	40 c4       	mov.aa %a4,%a12
8000717c:	02 84       	mov %d4,%d8
8000717e:	48 75       	ld.w %d5,[%a15]28
80007180:	b9 f6 22 00 	ld.hu %d6,[%a15]34
80007184:	b9 f7 20 00 	ld.hu %d7,[%a15]32
80007188:	6d ff e5 f3 	call 80005952 <IfxMultican_Node_setFastBitTiming>

            if (config->fdConfig.loopDelayOffset)
8000718c:	b9 f2 24 00 	ld.hu %d2,[%a15]36
80007190:	76 2f       	jz %d2,800071ae <IfxMultican_Can_Node_init+0x1ec>
}


IFX_INLINE void IfxMultican_Node_setTransceiverDelayCompensationOffset(Ifx_CAN_N *hwNode, uint16 value)
{
    hwNode->TDCR.B.TDCO = value;
80007192:	01 ea 00 36 	addsc.a %a3,%a14,%d10,0
80007196:	19 33 3c 80 	ld.w %d3,[%a3]572
8000719a:	37 23 04 24 	insert %d2,%d3,%d2,8,4
8000719e:	59 32 3c 80 	st.w [%a3]572,%d2
}


IFX_INLINE void IfxMultican_Node_setTransceiverDelayCompensation(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->TDCR.B.TDC = enabled ? 1 : 0;
800071a2:	19 32 3c 80 	ld.w %d2,[%a3]572
800071a6:	b7 f2 81 27 	insert %d2,%d2,15,15,1
800071aa:	59 32 3c 80 	st.w [%a3]572,%d2
}


IFX_INLINE void IfxMultican_Node_setFrameCounterMode(Ifx_CAN_N *hwNode, IfxMultican_FrameCounterMode mode)
{
    hwNode->FCR.B.CFMOD = mode;
800071ae:	01 ea 00 26 	addsc.a %a2,%a14,%d10,0
}


IFX_INLINE void IfxMultican_Node_disableConfigurationChange(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.CCE = 0U;
800071b2:	8f 89 00 90 	sh %d9,%d9,8
}


IFX_INLINE void IfxMultican_Node_setFrameCounterMode(Ifx_CAN_N *hwNode, IfxMultican_FrameCounterMode mode)
{
    hwNode->FCR.B.CFMOD = mode;
800071b6:	19 22 18 80 	ld.w %d2,[%a2]536
}


IFX_INLINE void IfxMultican_Node_disableConfigurationChange(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.CCE = 0U;
800071ba:	01 e9 00 e6 	addsc.a %a14,%a14,%d9,0
}


IFX_INLINE void IfxMultican_Node_setFrameCounterMode(Ifx_CAN_N *hwNode, IfxMultican_FrameCounterMode mode)
{
    hwNode->FCR.B.CFMOD = mode;
800071be:	b7 12 82 29 	insert %d2,%d2,1,19,2
800071c2:	59 22 18 80 	st.w [%a2]536,%d2
}


IFX_INLINE void IfxMultican_Node_setFrameCounterInterrupt(Ifx_CAN_N *hwNode, boolean enabled)
{
    hwNode->FCR.B.CFCIE = enabled ? 1 : 0;
800071c6:	39 f3 3c 00 	ld.bu %d3,[%a15]60
800071ca:	7b 00 04 20 	movh %d2,64
800071ce:	ab 02 80 33 	sel %d3,%d3,%d2,0
800071d2:	19 22 18 80 	ld.w %d2,[%a2]536
800071d6:	b7 02 01 2b 	insert %d2,%d2,0,22,1
800071da:	a6 32       	or %d2,%d3
800071dc:	59 22 18 80 	st.w [%a2]536,%d2
}


IFX_INLINE void IfxMultican_Node_disableConfigurationChange(Ifx_CAN_N *hwNode)
{
    hwNode->CR.B.CCE = 0U;
800071e0:	54 e2       	ld.w %d2,[%a14]
800071e2:	8f 02 c4 21 	andn %d2,%d2,64
800071e6:	74 e2       	st.w [%a14],%d2

    IfxMultican_Node_disableConfigurationChange(hwNode);
    /* Configuration of the TTCAN Functionality: Not implemented */

    return status;
}
800071e8:	02 f2       	mov %d2,%d15
800071ea:	00 90       	ret 

        float32         fcan = IfxMultican_Can_getModuleFrequency(&mcan);

        if (!config->flexibleDataRate)
        {
            IfxMultican_Node_setBitTiming(hwNode, fcan, config->baudrate, config->samplePoint, config->synchJumpWidth);
800071ec:	40 c4       	mov.aa %a4,%a12
800071ee:	02 84       	mov %d4,%d8
800071f0:	48 25       	ld.w %d5,[%a15]8
800071f2:	b9 f6 0c 00 	ld.hu %d6,[%a15]12
800071f6:	b9 f7 0e 00 	ld.hu %d7,[%a15]14
800071fa:	6d ff 2f f1 	call 80005458 <IfxMultican_Node_setBitTiming>
800071fe:	3c d8       	j 800071ae <IfxMultican_Can_Node_init+0x1ec>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
80007200:	6d 00 8d 0c 	call 80008b1a <IfxScuCcu_getPllErayFrequency>
80007204:	02 28       	mov %d8,%d2
80007206:	3c 9a       	j 8000713a <IfxMultican_Can_Node_init+0x178>
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80007208:	b5 a2 04 00 	st.a [%sp]4,%a2
8000720c:	6d 00 99 0d 	call 80008d3e <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
80007210:	91 30 00 3f 	movh.a %a3,61443
80007214:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007218:	54 34       	ld.w %d4,[%a3]
    {
        canFrequency = 0.0f;
8000721a:	82 03       	mov %d3,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
8000721c:	8f f4 00 41 	and %d4,%d4,15
80007220:	99 a2 04 00 	ld.a %a2,[%sp]4
80007224:	76 48       	jz %d4,80007234 <IfxMultican_Can_Node_init+0x272>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
80007226:	54 38       	ld.w %d8,[%a3]
80007228:	8f f8 00 81 	and %d8,%d8,15
8000722c:	4b 08 41 81 	itof %d8,%d8
80007230:	4b 82 51 30 	div.f %d3,%d2,%d8
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
80007234:	19 22 0c 00 	ld.w %d2,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80007238:	19 28 0c 00 	ld.w %d8,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
8000723c:	37 02 62 27 	extr.u %d2,%d2,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80007240:	b7 08 16 85 	insert %d8,%d8,0,10,22
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
80007244:	df 12 13 00 	jeq %d2,1,8000726a <IfxMultican_Can_Node_init+0x2a8>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
80007248:	4b 08 41 81 	itof %d8,%d8
8000724c:	7b 00 a8 43 	movh %d4,14976
80007250:	4b 48 41 80 	mul.f %d8,%d8,%d4
80007254:	4b 38 41 80 	mul.f %d8,%d8,%d3

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
80007258:	df 22 70 ff 	jne %d2,2,80007138 <IfxMultican_Can_Node_init+0x176>
8000725c:	1d ff 6f ff 	j 8000713a <IfxMultican_Can_Node_init+0x178>
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
80007260:	6d 00 3d 0c 	call 80008ada <IfxScuCcu_getOsc0Frequency>
80007264:	02 28       	mov %d8,%d2
80007266:	1d ff 6a ff 	j 8000713a <IfxMultican_Can_Node_init+0x178>
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
8000726a:	3b 00 40 20 	mov %d2,1024
8000726e:	0b 82 80 80 	sub %d8,%d2,%d8
80007272:	4b 08 41 81 	itof %d8,%d8
80007276:	4b 83 51 80 	div.f %d8,%d3,%d8
8000727a:	1d ff 60 ff 	j 8000713a <IfxMultican_Can_Node_init+0x178>

8000727e <IfxMultican_Can_Node_initConfig>:
}


void IfxMultican_Can_Node_initConfig(IfxMultican_Can_NodeConfig *config, IfxMultican_Can *mcan)
{
    config->module                         = mcan->mcan;
8000727e:	4c 50       	ld.w %d15,[%a5]0
    config->nodeId                         = IfxMultican_NodeId_0;

    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
80007280:	7b 80 00 40 	movh %d4,8
    config->samplePoint                    = 8000;
80007284:	3b 00 f4 21 	mov %d2,8000
    config->nodeId                         = IfxMultican_NodeId_0;

    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
80007288:	1b 04 12 4a 	addi %d4,%d4,-24288
}


void IfxMultican_Can_Node_initConfig(IfxMultican_Can_NodeConfig *config, IfxMultican_Can *mcan)
{
    config->module                         = mcan->mcan;
8000728c:	6c 40       	st.w [%a4]0,%d15

    config->nodeId                         = IfxMultican_NodeId_0;
8000728e:	82 0f       	mov %d15,0
80007290:	2c 44       	st.b [%a4]4,%d15

    config->loopBackMode                   = FALSE;
80007292:	2c 46       	st.b [%a4]6,%d15
    config->analyzerMode                   = FALSE;
80007294:	2c 45       	st.b [%a4]5,%d15

    config->baudrate                       = 500000;
    config->samplePoint                    = 8000;
80007296:	f9 42 0c 00 	st.h [%a4]12,%d2
    config->synchJumpWidth                 = 2000;

    config->flexibleDataRate               = FALSE;
8000729a:	e9 4f 10 00 	st.b [%a4]16,%d15

    config->fdConfig.nominalBaudrate       = 500000;
    config->fdConfig.nominalSynchJumpWidth = 2000;
    config->fdConfig.nominalSamplePoint    = 8000;
8000729e:	f9 42 1a 00 	st.h [%a4]26,%d2
    config->fdConfig.fastBaudrate          = 1000000;
800072a2:	8f 14 00 f0 	sh %d15,%d4,1
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
800072a6:	f9 42 22 00 	st.h [%a4]34,%d2
    config->fdConfig.loopDelayOffset       = 0;

    config->rxPin                          = NULL_PTR;
800072aa:	82 02       	mov %d2,0
    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
    config->samplePoint                    = 8000;
    config->synchJumpWidth                 = 2000;
800072ac:	3b 00 7d 30 	mov %d3,2000
    config->flexibleDataRate               = FALSE;

    config->fdConfig.nominalBaudrate       = 500000;
    config->fdConfig.nominalSynchJumpWidth = 2000;
    config->fdConfig.nominalSamplePoint    = 8000;
    config->fdConfig.fastBaudrate          = 1000000;
800072b0:	6c 47       	st.w [%a4]28,%d15
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;

    config->rxPin                          = NULL_PTR;
800072b2:	59 42 28 00 	st.w [%a4]40,%d2
    config->fdConfig.nominalSynchJumpWidth = 2000;
    config->fdConfig.nominalSamplePoint    = 8000;
    config->fdConfig.fastBaudrate          = 1000000;
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;
800072b6:	82 0f       	mov %d15,0

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
    config->txPin                          = NULL_PTR;
800072b8:	59 42 30 00 	st.w [%a4]48,%d2
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
800072bc:	3b 00 f8 2f 	mov %d2,-128
    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
    config->samplePoint                    = 8000;
    config->synchJumpWidth                 = 2000;
800072c0:	f9 43 0e 00 	st.h [%a4]14,%d3

    config->flexibleDataRate               = FALSE;

    config->fdConfig.nominalBaudrate       = 500000;
    config->fdConfig.nominalSynchJumpWidth = 2000;
800072c4:	f9 43 18 00 	st.h [%a4]24,%d3
    config->fdConfig.nominalSamplePoint    = 8000;
    config->fdConfig.fastBaudrate          = 1000000;
    config->fdConfig.fastSynchJumpWidth    = 2000;
800072c8:	f9 43 20 00 	st.h [%a4]32,%d3
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;
800072cc:	f9 4f 24 00 	st.h [%a4]36,%d15

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
800072d0:	3b 00 01 30 	mov %d3,16
    config->txPin                          = NULL_PTR;
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
800072d4:	e9 42 34 00 	st.b [%a4]52,%d2
    config->pinDriver                      = IfxPort_PadDriver_cmosAutomotiveSpeed2; //previously hardcoded as this value for Tx pins.Now pad driver option is being given in IfxMultican_Node_initRxPin() and IfxMultican_Node_initTxPin()

    config->transferInterrupt.enabled      = FALSE;
800072d8:	e9 4f 36 00 	st.b [%a4]54,%d15

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
    config->txPin                          = NULL_PTR;
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
    config->pinDriver                      = IfxPort_PadDriver_cmosAutomotiveSpeed2; //previously hardcoded as this value for Tx pins.Now pad driver option is being given in IfxMultican_Node_initRxPin() and IfxMultican_Node_initTxPin()
800072dc:	82 12       	mov %d2,1

    config->transferInterrupt.enabled      = FALSE;
    config->transferInterrupt.srcId        = IfxMultican_SrcId_0;
800072de:	e9 4f 37 00 	st.b [%a4]55,%d15

    config->lastErrorCodeInterrupt.enabled = FALSE;
800072e2:	e9 4f 38 00 	st.b [%a4]56,%d15
    config->lastErrorCodeInterrupt.srcId   = IfxMultican_SrcId_0;
800072e6:	e9 4f 39 00 	st.b [%a4]57,%d15

    config->alertInterrupt.enabled         = FALSE;
800072ea:	e9 4f 3a 00 	st.b [%a4]58,%d15
    config->alertInterrupt.srcId           = IfxMultican_SrcId_0;
800072ee:	e9 4f 3b 00 	st.b [%a4]59,%d15

    config->frameCounterInterrupt.enabled  = FALSE;
800072f2:	e9 4f 3c 00 	st.b [%a4]60,%d15
    config->frameCounterInterrupt.srcId    = IfxMultican_SrcId_0;
800072f6:	e9 4f 3d 00 	st.b [%a4]61,%d15

    config->timerInterrupt.enabled         = FALSE;
800072fa:	e9 4f 3e 00 	st.b [%a4]62,%d15
    config->timerInterrupt.srcId           = IfxMultican_SrcId_0;
800072fe:	e9 4f 3f 00 	st.b [%a4]63,%d15

    config->errorWarningLevel              = 96;
80007302:	da 60       	mov %d15,96
    config->nodeId                         = IfxMultican_NodeId_0;

    config->loopBackMode                   = FALSE;
    config->analyzerMode                   = FALSE;

    config->baudrate                       = 500000;
80007304:	59 44 08 00 	st.w [%a4]8,%d4
    config->samplePoint                    = 8000;
    config->synchJumpWidth                 = 2000;

    config->flexibleDataRate               = FALSE;

    config->fdConfig.nominalBaudrate       = 500000;
80007308:	59 44 14 00 	st.w [%a4]20,%d4
    config->fdConfig.fastSynchJumpWidth    = 2000;
    config->fdConfig.fastSamplePoint       = 8000;
    config->fdConfig.loopDelayOffset       = 0;

    config->rxPin                          = NULL_PTR;
    config->rxPinMode                      = IfxPort_InputMode_pullUp;
8000730c:	e9 43 2c 00 	st.b [%a4]44,%d3
    config->txPin                          = NULL_PTR;
    config->txPinMode                      = IfxPort_OutputMode_pushPull;
    config->pinDriver                      = IfxPort_PadDriver_cmosAutomotiveSpeed2; //previously hardcoded as this value for Tx pins.Now pad driver option is being given in IfxMultican_Node_initRxPin() and IfxMultican_Node_initTxPin()
80007310:	e9 42 00 10 	st.b [%a4]64,%d2
    config->frameCounterInterrupt.srcId    = IfxMultican_SrcId_0;

    config->timerInterrupt.enabled         = FALSE;
    config->timerInterrupt.srcId           = IfxMultican_SrcId_0;

    config->errorWarningLevel              = 96;
80007314:	e9 4f 35 00 	st.b [%a4]53,%d15
80007318:	00 90       	ret 

8000731a <IfxMultican_Can_Node_sendToBusOff>:
{
    uint32 i, counter;

    for (counter = 1; counter < 256; counter = counter * 2)
    {
        node->node->ECNT.B.TEC = counter;
8000731a:	cc 41       	ld.a %a15,[%a4]4
8000731c:	4c f5       	ld.w %d15,[%a15]20
8000731e:	b7 1f 08 f4 	insert %d15,%d15,1,8,8
80007322:	68 5f       	st.w [%a15]20,%d15
80007324:	cc 41       	ld.a %a15,[%a4]4
80007326:	4c f5       	ld.w %d15,[%a15]20
80007328:	b7 2f 08 f4 	insert %d15,%d15,2,8,8
8000732c:	68 5f       	st.w [%a15]20,%d15
8000732e:	cc 41       	ld.a %a15,[%a4]4
80007330:	4c f5       	ld.w %d15,[%a15]20
80007332:	b7 4f 08 f4 	insert %d15,%d15,4,8,8
80007336:	68 5f       	st.w [%a15]20,%d15
80007338:	cc 41       	ld.a %a15,[%a4]4
8000733a:	4c f5       	ld.w %d15,[%a15]20
8000733c:	b7 8f 08 f4 	insert %d15,%d15,8,8,8
80007340:	68 5f       	st.w [%a15]20,%d15
80007342:	cc 41       	ld.a %a15,[%a4]4
80007344:	4c f5       	ld.w %d15,[%a15]20
80007346:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
8000734a:	b7 ff 01 f6 	insert %d15,%d15,15,12,1
8000734e:	68 5f       	st.w [%a15]20,%d15
80007350:	cc 41       	ld.a %a15,[%a4]4
80007352:	4c f5       	ld.w %d15,[%a15]20
80007354:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
80007358:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
8000735c:	68 5f       	st.w [%a15]20,%d15
8000735e:	cc 41       	ld.a %a15,[%a4]4
80007360:	4c f5       	ld.w %d15,[%a15]20
80007362:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
80007366:	b7 ff 01 f7 	insert %d15,%d15,15,14,1
8000736a:	68 5f       	st.w [%a15]20,%d15
8000736c:	cc 41       	ld.a %a15,[%a4]4
8000736e:	4c f5       	ld.w %d15,[%a15]20
80007370:	b7 0f 08 f4 	insert %d15,%d15,0,8,8
80007374:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
80007378:	68 5f       	st.w [%a15]20,%d15
    }

    for (i = 0; i < 10; ++i)
    {
        node->node->ECNT.B.TEC = ++counter;
8000737a:	cc 41       	ld.a %a15,[%a4]4
8000737c:	4c f5       	ld.w %d15,[%a15]20
8000737e:	b7 1f 08 f4 	insert %d15,%d15,1,8,8
80007382:	68 5f       	st.w [%a15]20,%d15
80007384:	cc 41       	ld.a %a15,[%a4]4
80007386:	4c f5       	ld.w %d15,[%a15]20
80007388:	b7 2f 08 f4 	insert %d15,%d15,2,8,8
8000738c:	68 5f       	st.w [%a15]20,%d15
8000738e:	cc 41       	ld.a %a15,[%a4]4
80007390:	4c f5       	ld.w %d15,[%a15]20
80007392:	b7 3f 08 f4 	insert %d15,%d15,3,8,8
80007396:	68 5f       	st.w [%a15]20,%d15
80007398:	cc 41       	ld.a %a15,[%a4]4
8000739a:	4c f5       	ld.w %d15,[%a15]20
8000739c:	b7 4f 08 f4 	insert %d15,%d15,4,8,8
800073a0:	68 5f       	st.w [%a15]20,%d15
800073a2:	cc 41       	ld.a %a15,[%a4]4
800073a4:	4c f5       	ld.w %d15,[%a15]20
800073a6:	b7 5f 08 f4 	insert %d15,%d15,5,8,8
800073aa:	68 5f       	st.w [%a15]20,%d15
800073ac:	cc 41       	ld.a %a15,[%a4]4
800073ae:	4c f5       	ld.w %d15,[%a15]20
800073b0:	b7 6f 08 f4 	insert %d15,%d15,6,8,8
800073b4:	68 5f       	st.w [%a15]20,%d15
800073b6:	cc 41       	ld.a %a15,[%a4]4
800073b8:	4c f5       	ld.w %d15,[%a15]20
800073ba:	b7 7f 08 f4 	insert %d15,%d15,7,8,8
800073be:	68 5f       	st.w [%a15]20,%d15
800073c0:	cc 41       	ld.a %a15,[%a4]4
800073c2:	4c f5       	ld.w %d15,[%a15]20
800073c4:	b7 8f 08 f4 	insert %d15,%d15,8,8,8
800073c8:	68 5f       	st.w [%a15]20,%d15
800073ca:	cc 41       	ld.a %a15,[%a4]4
800073cc:	4c f5       	ld.w %d15,[%a15]20
800073ce:	b7 9f 08 f4 	insert %d15,%d15,9,8,8
800073d2:	68 5f       	st.w [%a15]20,%d15
800073d4:	cc 41       	ld.a %a15,[%a4]4
800073d6:	4c f5       	ld.w %d15,[%a15]20
800073d8:	b7 af 08 f4 	insert %d15,%d15,10,8,8
800073dc:	68 5f       	st.w [%a15]20,%d15
800073de:	00 90       	ret 

800073e0 <IfxMultican_Can_getConfig>:
}


void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);
800073e0:	d4 42       	ld.a %a2,[%a4]
    }
}


void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
800073e2:	20 08       	sub.a %sp,8
800073e4:	40 5f       	mov.aa %a15,%a5
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
800073e6:	19 2f 08 70 	ld.w %d15,[%a2]456
800073ea:	16 0f       	and %d15,15
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);
800073ec:	2c 54       	st.b [%a5]4,%d15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
800073ee:	1e 18       	jeq %d15,1,800073fe <IfxMultican_Can_getConfig+0x1e>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
800073f0:	df 2f 33 00 	jeq %d15,2,80007456 <IfxMultican_Can_getConfig+0x76>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
800073f4:	df 4f 35 00 	jeq %d15,4,8000745e <IfxMultican_Can_getConfig+0x7e>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
800073f8:	82 0f       	mov %d15,0
800073fa:	68 2f       	st.w [%a15]8,%d15
800073fc:	00 90       	ret 
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800073fe:	b5 a4 04 00 	st.a [%sp]4,%a4
80007402:	6d 00 9e 0c 	call 80008d3e <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
80007406:	91 30 00 2f 	movh.a %a2,61443
8000740a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000740e:	54 23       	ld.w %d3,[%a2]
    {
        canFrequency = 0.0f;
80007410:	82 0f       	mov %d15,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
80007412:	8f f3 00 31 	and %d3,%d3,15
80007416:	99 a4 04 00 	ld.a %a4,[%sp]4
8000741a:	76 37       	jz %d3,80007428 <IfxMultican_Can_getConfig+0x48>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
8000741c:	4c 20       	ld.w %d15,[%a2]0
8000741e:	16 0f       	and %d15,15
80007420:	4b 0f 41 f1 	itof %d15,%d15
80007424:	4b f2 51 f0 	div.f %d15,%d2,%d15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
    {
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
80007428:	d4 42       	ld.a %a2,[%a4]
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
8000742a:	19 22 0c 00 	ld.w %d2,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
8000742e:	19 23 0c 00 	ld.w %d3,[%a2]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
80007432:	37 02 62 27 	extr.u %d2,%d2,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
80007436:	b7 03 16 35 	insert %d3,%d3,0,10,22
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
8000743a:	df 12 16 00 	jeq %d2,1,80007466 <IfxMultican_Can_getConfig+0x86>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
8000743e:	df 22 dd ff 	jne %d2,2,800073f8 <IfxMultican_Can_getConfig+0x18>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
80007442:	4b 03 41 31 	itof %d3,%d3
80007446:	7b 00 a8 23 	movh %d2,14976
8000744a:	4b 23 41 30 	mul.f %d3,%d3,%d2
8000744e:	4b f3 41 f0 	mul.f %d15,%d3,%d15
80007452:	68 2f       	st.w [%a15]8,%d15
80007454:	00 90       	ret 
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
80007456:	6d 00 42 0b 	call 80008ada <IfxScuCcu_getOsc0Frequency>
8000745a:	68 22       	st.w [%a15]8,%d2
8000745c:	00 90       	ret 
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
8000745e:	6d 00 5e 0b 	call 80008b1a <IfxScuCcu_getPllErayFrequency>
80007462:	68 22       	st.w [%a15]8,%d2
80007464:	00 90       	ret 
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
80007466:	3b 00 40 20 	mov %d2,1024
8000746a:	0b 32 80 30 	sub %d3,%d2,%d3
8000746e:	4b 03 41 31 	itof %d3,%d3
80007472:	4b 3f 51 f0 	div.f %d15,%d15,%d3
80007476:	68 2f       	st.w [%a15]8,%d15
80007478:	00 90       	ret 

8000747a <IfxMultican_Can_getModuleFrequency>:
}


void IfxMultican_Can_getConfig(IfxMultican_Can *mcan, IfxMultican_Can_Config *config)
{
    config->clockSelect = IfxMultican_getInputClock(mcan->mcan);
8000747a:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE IfxMultican_ClockSelect IfxMultican_getInputClock(Ifx_CAN *mcan)
{
    return (IfxMultican_ClockSelect)mcan->MCR.B.CLKSEL;
8000747c:	19 ff 08 70 	ld.w %d15,[%a15]456
80007480:	16 0f       	and %d15,15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
80007482:	1e 17       	jeq %d15,1,80007490 <IfxMultican_Can_getModuleFrequency+0x16>
        else
        {
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
80007484:	df 2f 2c 00 	jeq %d15,2,800074dc <IfxMultican_Can_getModuleFrequency+0x62>
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
80007488:	df 4f 2c 00 	jeq %d15,4,800074e0 <IfxMultican_Can_getModuleFrequency+0x66>
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
        }
        else
        {
            config->moduleFreq = 0;
8000748c:	82 02       	mov %d2,0
8000748e:	00 90       	ret 
80007490:	40 4f       	mov.aa %a15,%a4
IFX_INLINE float32 IfxScuCcu_getCanFrequency(void)
{
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80007492:	6d 00 56 0c 	call 80008d3e <IfxScuCcu_getSourceFrequency>

    if (SCU_CCUCON1.B.CANDIV == 0)
80007496:	91 30 00 2f 	movh.a %a2,61443
8000749a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000749e:	54 23       	ld.w %d3,[%a2]
    {
        canFrequency = 0.0f;
800074a0:	82 0f       	mov %d15,0
    float32 canFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    if (SCU_CCUCON1.B.CANDIV == 0)
800074a2:	8f f3 00 31 	and %d3,%d3,15
800074a6:	76 37       	jz %d3,800074b4 <IfxMultican_Can_getModuleFrequency+0x3a>
    {
        canFrequency = 0.0f;
    }
    else
    {
        canFrequency = sourceFrequency / SCU_CCUCON1.B.CANDIV;
800074a8:	4c 20       	ld.w %d15,[%a2]0
800074aa:	16 0f       	and %d15,15
800074ac:	4b 0f 41 f1 	itof %d15,%d15
800074b0:	4b f2 51 f0 	div.f %d15,%d2,%d15

    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
    {
        float32 fcan        = IfxScuCcu_getCanFrequency();

        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
800074b4:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
800074b6:	48 33       	ld.w %d3,[%a15]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
800074b8:	48 32       	ld.w %d2,[%a15]12
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerMode(Ifx_CAN *mcan)
{
    return mcan->FDR.B.DM;
800074ba:	37 03 62 37 	extr.u %d3,%d3,14,2
}


IFX_INLINE uint16 IfxMultican_getFractionalDividerStepValue(Ifx_CAN *mcan)
{
    return mcan->FDR.B.STEP;
800074be:	b7 02 16 25 	insert %d2,%d2,0,10,22
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
800074c2:	df 13 11 00 	jeq %d3,1,800074e4 <IfxMultican_Can_getModuleFrequency+0x6a>
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
        {
            config->moduleFreq = (fcan * stepValue) / 1024;
800074c6:	4b 02 41 21 	itof %d2,%d2
800074ca:	7b 00 a8 43 	movh %d4,14976
800074ce:	4b 42 41 20 	mul.f %d2,%d2,%d4
800074d2:	4b f2 41 20 	mul.f %d2,%d2,%d15

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
        }
        else if (dividerMode == 2)
800074d6:	df 23 db ff 	jne %d3,2,8000748c <IfxMultican_Can_getModuleFrequency+0x12>
    IfxMultican_Can_Config config;

    IfxMultican_Can_getConfig(mcan, &config);

    return config.moduleFreq;
}
800074da:	00 90       	ret 
            config->moduleFreq = 0;
        }
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fosc0)
    {
        config->moduleFreq = IfxScuCcu_getOsc0Frequency();
800074dc:	1d 00 ff 0a 	j 80008ada <IfxScuCcu_getOsc0Frequency>
    }
    else if (config->clockSelect == IfxMultican_ClockSelect_fErayPll)
    {
        config->moduleFreq = IfxScuCcu_getPllErayFrequency();
800074e0:	1d 00 1d 0b 	j 80008b1a <IfxScuCcu_getPllErayFrequency>
        uint16  dividerMode = IfxMultican_getFractionalDividerMode(mcan->mcan);
        uint16  stepValue   = IfxMultican_getFractionalDividerStepValue(mcan->mcan);

        if (dividerMode == 1)
        {
            config->moduleFreq = fcan / (1024 - stepValue);
800074e4:	3b 00 40 30 	mov %d3,1024
800074e8:	0b 23 80 20 	sub %d2,%d3,%d2
800074ec:	4b 02 41 21 	itof %d2,%d2
800074f0:	4b 2f 51 20 	div.f %d2,%d15,%d2
800074f4:	00 90       	ret 

800074f6 <IfxMultican_Can_initModule>:
}


IfxMultican_Status IfxMultican_Can_initModule(IfxMultican_Can *mcan, const IfxMultican_Can_Config *config)
{
    Ifx_CAN *mcanSFR = config->module;
800074f6:	cc 50       	ld.a %a15,[%a5]0
    mcan->mcan = mcanSFR;

    uint16   stepValue, dividerMode, i;

    /* currently supports only fclc */
    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
800074f8:	0c 54       	ld.bu %d15,[%a5]4
    return config.moduleFreq;
}


IfxMultican_Status IfxMultican_Can_initModule(IfxMultican_Can *mcan, const IfxMultican_Can_Config *config)
{
800074fa:	40 4d       	mov.aa %a13,%a4
    Ifx_CAN *mcanSFR = config->module;

    mcan->mcan = mcanSFR;
800074fc:	ec 40       	st.a [%a4]0,%a15
    return config.moduleFreq;
}


IfxMultican_Status IfxMultican_Can_initModule(IfxMultican_Can *mcan, const IfxMultican_Can_Config *config)
{
800074fe:	40 5c       	mov.aa %a12,%a5
    Ifx_CAN *mcanSFR = config->module;
80007500:	40 f2       	mov.aa %a2,%a15
    mcan->mcan = mcanSFR;

    uint16   stepValue, dividerMode, i;

    /* currently supports only fclc */
    if (config->clockSelect == IfxMultican_ClockSelect_fclc)
80007502:	df 1f 51 00 	jeq %d15,1,800075a4 <IfxMultican_Can_initModule+0xae>
}


IFX_INLINE void IfxMultican_waitListReady(Ifx_CAN *mcan)
{
    while (mcan->PANCTR.B.BUSY != 0)
80007506:	19 2f 04 70 	ld.w %d15,[%a2]452
8000750a:	37 0f 61 f4 	extr.u %d15,%d15,8,1
8000750e:	ee fc       	jnz %d15,80007506 <IfxMultican_Can_initModule+0x10>
}


IFX_INLINE void IfxMultican_clearPendingMessageNotification(Ifx_CAN *mcan, uint16 list)
{
    mcan->MSPND[list].U = 0x0;
80007510:	59 ff 00 50 	st.w [%a15]320,%d15
80007514:	59 ff 04 50 	st.w [%a15]324,%d15
80007518:	59 ff 08 50 	st.w [%a15]328,%d15
8000751c:	59 ff 0c 50 	st.w [%a15]332,%d15
80007520:	59 ff 10 50 	st.w [%a15]336,%d15
80007524:	59 ff 14 50 	st.w [%a15]340,%d15
80007528:	59 ff 18 50 	st.w [%a15]344,%d15
8000752c:	59 ff 1c 50 	st.w [%a15]348,%d15
}


IFX_INLINE void IfxMultican_clearMessagePendingSeletor(Ifx_CAN *mcan)
{
    mcan->MCR.B.MPSEL = 0x0U;
80007530:	19 ff 08 70 	ld.w %d15,[%a15]456
80007534:	b7 0f 04 f6 	insert %d15,%d15,0,12,4
80007538:	59 ff 08 70 	st.w [%a15]456,%d15
}


IFX_INLINE void IfxMultican_setMessageIndexMask(Ifx_CAN *mcan, uint32 mask)
{
    mcan->MSIMASK.U = mask;
8000753c:	82 ff       	mov %d15,-1
8000753e:	59 ff 00 70 	st.w [%a15]448,%d15
80007542:	82 0f       	mov %d15,0
80007544:	3c 0a       	j 80007558 <IfxMultican_Can_initModule+0x62>
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007546:	54 22       	ld.w %d2,[%a2]
80007548:	c2 1f       	add %d15,1
8000754a:	b7 f2 01 25 	insert %d2,%d2,15,10,1
8000754e:	74 22       	st.w [%a2],%d2
    IfxMultican_setMessageIndexMask(mcanSFR, 0xFFFFFFFF);

    /* Configure interrupt node pointers */
    IfxMultican_SrcId srcId;

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
80007550:	8b 0f 21 22 	ne %d2,%d15,16
80007554:	df 02 26 00 	jeq %d2,0,800075a0 <IfxMultican_Can_initModule+0xaa>
    {
        volatile Ifx_SRC_SRCR *srcPointer = IfxMultican_getSrcPointer(mcanSFR, srcId);
80007558:	8f ff 0f 41 	and %d4,%d15,255
8000755c:	40 f4       	mov.aa %a4,%a15
8000755e:	6d ff 28 f6 	call 800061ae <IfxMultican_getSrcPointer>
80007562:	90 c3       	addsc.a %a3,%a12,%d15,2
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007564:	54 24       	ld.w %d4,[%a2]
        IfxSrc_init(srcPointer, config->nodePointer[srcId].typeOfService, config->nodePointer[srcId].priority);
80007566:	b9 32 0c 00 	ld.hu %d2,[%a3]12
8000756a:	8f f4 cf 41 	andn %d4,%d4,255
8000756e:	8f f2 0f 51 	and %d5,%d2,255
80007572:	a6 54       	or %d4,%d5
80007574:	39 33 0e 00 	ld.bu %d3,[%a3]14
80007578:	74 24       	st.w [%a2],%d4
    src->B.TOS  = typOfService;
8000757a:	54 24       	ld.w %d4,[%a2]
8000757c:	37 34 82 35 	insert %d3,%d4,%d3,11,2
80007580:	74 23       	st.w [%a2],%d3
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007582:	54 23       	ld.w %d3,[%a2]
80007584:	b7 f3 81 3c 	insert %d3,%d3,15,25,1
80007588:	74 23       	st.w [%a2],%d3

        if (config->nodePointer[srcId].priority)
8000758a:	df 02 de ff 	jne %d2,0,80007546 <IfxMultican_Can_initModule+0x50>
}


IFX_INLINE void IfxSrc_disable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 0;
8000758e:	54 22       	ld.w %d2,[%a2]
80007590:	c2 1f       	add %d15,1
80007592:	b7 02 01 25 	insert %d2,%d2,0,10,1
80007596:	74 22       	st.w [%a2],%d2
    IfxMultican_setMessageIndexMask(mcanSFR, 0xFFFFFFFF);

    /* Configure interrupt node pointers */
    IfxMultican_SrcId srcId;

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
80007598:	8b 0f 21 22 	ne %d2,%d15,16
8000759c:	df 02 de ff 	jne %d2,0,80007558 <IfxMultican_Can_initModule+0x62>
            IfxSrc_disable(srcPointer);
        }
    }

    return IfxMultican_Status_ok;
}
800075a0:	82 02       	mov %d2,0
800075a2:	00 90       	ret 
        {
            uint16  stepN, stepF;
            boolean normalDiv;
            float32 freqN, freqF;

            float32 fsys = IfxScuCcu_getSpbFrequency();
800075a4:	6d 00 28 0c 	call 80008df4 <IfxScuCcu_getSpbFrequency>

            /* Normal divider mode */
            stepN = (uint16)__minf(__maxf(0, 1024.0f - (fsys / config->moduleFreq)), 1023);
800075a8:	19 c3 08 00 	ld.w %d3,[%a12]8
800075ac:	7b 00 48 64 	movh %d6,17536
800075b0:	4b 32 51 40 	div.f %d4,%d2,%d3
800075b4:	7b 00 f8 53 	movh %d5,16256
800075b8:	4b 64 01 f0 	cmp.f %d15,%d4,%d6
800075bc:	4b 54 01 70 	cmp.f %d7,%d4,%d5
800075c0:	87 f7 22 71 	or.t %d7,%d7,2,%d15,2
800075c4:	3b f0 3f f0 	mov %d15,1023
800075c8:	df 07 15 00 	jeq %d7,0,800075f2 <IfxMultican_Can_initModule+0xfc>
800075cc:	6b 04 31 f6 	sub.f %d15,%d6,%d4
800075d0:	3b 00 40 50 	mov %d5,1024
800075d4:	4b 0f 71 f1 	ftouz %d15,%d15
800075d8:	4b 64 01 70 	cmp.f %d7,%d4,%d6
800075dc:	37 0f 70 f0 	extr.u %d15,%d15,0,16
800075e0:	87 77 a0 70 	or.t %d7,%d7,0,%d7,1
800075e4:	a2 f5       	sub %d5,%d15
800075e6:	4b 05 41 51 	itof %d5,%d5
800075ea:	ab 0f 80 f7 	sel %d15,%d7,%d15,0
800075ee:	2b 65 40 57 	sel %d5,%d7,%d5,%d6
            freqN = fsys / (1024 - stepN);

            /* Fractional divider mode */
            stepF       = (uint16)__minf(((config->moduleFreq * 1024) / fsys), 1023);
800075f2:	7b 00 48 84 	movh %d8,17536
800075f6:	4b 83 41 80 	mul.f %d8,%d3,%d8
800075fa:	7b 00 48 64 	movh %d6,17536
800075fe:	4b 28 51 80 	div.f %d8,%d8,%d2
80007602:	1b 06 00 6c 	addi %d6,%d6,-16384

            float32 fsys = IfxScuCcu_getSpbFrequency();

            /* Normal divider mode */
            stepN = (uint16)__minf(__maxf(0, 1024.0f - (fsys / config->moduleFreq)), 1023);
            freqN = fsys / (1024 - stepN);
80007606:	4b 52 51 50 	div.f %d5,%d2,%d5

            /* Fractional divider mode */
            stepF       = (uint16)__minf(((config->moduleFreq * 1024) / fsys), 1023);
8000760a:	4b 68 01 70 	cmp.f %d7,%d8,%d6
8000760e:	4b 08 71 81 	ftouz %d8,%d8
80007612:	37 08 70 80 	extr.u %d8,%d8,0,16
80007616:	4b 08 41 41 	itof %d4,%d8
8000761a:	6f 07 05 80 	jnz.t %d7,0,80007624 <IfxMultican_Can_initModule+0x12e>
8000761e:	02 64       	mov %d4,%d6
80007620:	3b f0 3f 80 	mov %d8,1023
80007624:	7b 00 a8 63 	movh %d6,14976
80007628:	4b 62 41 20 	mul.f %d2,%d2,%d6
            freqF       = (fsys * stepF) / 1024;

            normalDiv   = (__absf(config->moduleFreq - freqN) <= __absf(config->moduleFreq - freqF));
8000762c:	6b 05 31 53 	sub.f %d5,%d3,%d5
80007630:	6b 42 71 23 	msub.f %d2,%d3,%d2,%d4
80007634:	b7 05 81 5f 	insert %d5,%d5,0,31,1
80007638:	82 1a       	mov %d10,1
8000763a:	b7 02 81 2f 	insert %d2,%d2,0,31,1

            stepValue   = (normalDiv != 0) ? stepN : stepF;
8000763e:	4b 25 01 20 	cmp.f %d2,%d5,%d2
80007642:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80007646:	2b 8f 40 82 	sel %d8,%d2,%d15,%d8
8000764a:	ab 2a 80 a2 	sel %d10,%d2,%d10,2
            dividerMode = (normalDiv != 0) ? 1 : 2;
        }

        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000764e:	6d 00 5f 17 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80007652:	02 24       	mov %d4,%d2

            stepValue   = (normalDiv != 0) ? stepN : stepF;
            dividerMode = (normalDiv != 0) ? 1 : 2;
        }

        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007654:	02 29       	mov %d9,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80007656:	6d 00 5d 16 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxMultican_enableModule(Ifx_CAN *mcan)
{
    mcan->CLC.B.DISR = 0U;
8000765a:	4c f0       	ld.w %d15,[%a15]0
8000765c:	8f 1f c0 f1 	andn %d15,%d15,1
80007660:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxMultican_disableSleepMode(Ifx_CAN *mcan)
{
    mcan->CLC.B.EDIS = 1U;
80007662:	4c f0       	ld.w %d15,[%a15]0
80007664:	96 08       	or %d15,8
80007666:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE boolean IfxMultican_isModuleEnabled(Ifx_CAN *mcan)
{
    return mcan->CLC.B.DISS == 0;
80007668:	4c f0       	ld.w %d15,[%a15]0
        /* Enable module, disregard Sleep Mode request */
        IfxMultican_enableModule(mcanSFR);
        IfxMultican_disableSleepMode(mcanSFR);

        /* Wait until module is enabled */
        while (IfxMultican_isModuleEnabled(mcanSFR) == FALSE)
8000766a:	6f 1f ff ff 	jnz.t %d15,1,80007668 <IfxMultican_Can_initModule+0x172>
}


IFX_INLINE void IfxMultican_setInputClock(Ifx_CAN *mcan, IfxMultican_ClockSelect clockSelect)
{
    mcan->MCR.B.CLKSEL = clockSelect;
8000766e:	19 ff 08 70 	ld.w %d15,[%a15]456
}


IFX_INLINE void IfxMultican_setFractionalDividerMode(Ifx_CAN *mcan, uint16 mode)
{
    mcan->FDR.B.DM = mode;
80007672:	8f ea 00 20 	sh %d2,%d10,14
}


IFX_INLINE void IfxMultican_setInputClock(Ifx_CAN *mcan, IfxMultican_ClockSelect clockSelect)
{
    mcan->MCR.B.CLKSEL = clockSelect;
80007676:	8f ff c0 f1 	andn %d15,%d15,15
8000767a:	59 ff 08 70 	st.w [%a15]456,%d15
8000767e:	19 ff 08 70 	ld.w %d15,[%a15]456
        IfxMultican_setInputClock(mcanSFR, IfxMultican_ClockSelect_noClock);
        IfxMultican_setInputClock(mcanSFR, IfxMultican_ClockSelect_fclc); /* Selects Fclc = Fspb */

        IfxMultican_setFractionalDividerStepValue(mcanSFR, stepValue);
        IfxMultican_setFractionalDividerMode(mcanSFR, dividerMode);
        IfxScuWdt_setCpuEndinit(passwd);
80007682:	02 94       	mov %d4,%d9
80007684:	b7 1f 04 f0 	insert %d15,%d15,1,0,4
80007688:	59 ff 08 70 	st.w [%a15]456,%d15
}


IFX_INLINE void IfxMultican_setFractionalDividerStepValue(Ifx_CAN *mcan, uint16 stepValue)
{
    mcan->FDR.B.STEP = stepValue;
8000768c:	4c f3       	ld.w %d15,[%a15]12
8000768e:	37 8f 0a 80 	insert %d8,%d15,%d8,0,10
80007692:	68 38       	st.w [%a15]12,%d8
}


IFX_INLINE void IfxMultican_setFractionalDividerMode(Ifx_CAN *mcan, uint16 mode)
{
    mcan->FDR.B.DM = mode;
80007694:	4c f3       	ld.w %d15,[%a15]12
80007696:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
8000769a:	a6 2f       	or %d15,%d2
8000769c:	68 3f       	st.w [%a15]12,%d15
8000769e:	6d 00 7d 18 	call 8000a798 <IfxScuWdt_setCpuEndinit>
800076a2:	d4 d2       	ld.a %a2,[%a13]
800076a4:	1d ff 31 ff 	j 80007506 <IfxMultican_Can_initModule+0x10>

800076a8 <IfxMultican_Can_initModuleConfig>:
    IfxMultican_SrcId srcId;
    /** - take over module pointer */
    config->module = mcan;

    /** - Selected input clock is from CLC */
    config->clockSelect = IfxMultican_ClockSelect_fclc;
800076a8:	82 1f       	mov %d15,1
800076aa:	2c 44       	st.b [%a4]4,%d15

void IfxMultican_Can_initModuleConfig(IfxMultican_Can_Config *config, Ifx_CAN *mcan)
{
    IfxMultican_SrcId srcId;
    /** - take over module pointer */
    config->module = mcan;
800076ac:	f4 45       	st.a [%a4],%a5
    return IfxMultican_Status_ok;
}


void IfxMultican_Can_initModuleConfig(IfxMultican_Can_Config *config, Ifx_CAN *mcan)
{
800076ae:	40 4f       	mov.aa %a15,%a4

    /** - Selected input clock is from CLC */
    config->clockSelect = IfxMultican_ClockSelect_fclc;

    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();
800076b0:	6d 00 a2 0b 	call 80008df4 <IfxScuCcu_getSpbFrequency>

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076b4:	82 0f       	mov %d15,0

    /** - Selected input clock is from CLC */
    config->clockSelect = IfxMultican_ClockSelect_fclc;

    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();
800076b6:	68 22       	st.w [%a15]8,%d2

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076b8:	a8 6f       	st.h [%a15]12,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076ba:	28 ef       	st.b [%a15]14,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076bc:	a8 8f       	st.h [%a15]16,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076be:	e9 ff 12 00 	st.b [%a15]18,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076c2:	a8 af       	st.h [%a15]20,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076c4:	e9 ff 16 00 	st.b [%a15]22,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076c8:	a8 cf       	st.h [%a15]24,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076ca:	e9 ff 1a 00 	st.b [%a15]26,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076ce:	a8 ef       	st.h [%a15]28,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076d0:	e9 ff 1e 00 	st.b [%a15]30,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076d4:	f9 ff 20 00 	st.h [%a15]32,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076d8:	e9 ff 22 00 	st.b [%a15]34,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076dc:	f9 ff 24 00 	st.h [%a15]36,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076e0:	e9 ff 26 00 	st.b [%a15]38,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076e4:	f9 ff 28 00 	st.h [%a15]40,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076e8:	e9 ff 2a 00 	st.b [%a15]42,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076ec:	f9 ff 2c 00 	st.h [%a15]44,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076f0:	e9 ff 2e 00 	st.b [%a15]46,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076f4:	f9 ff 30 00 	st.h [%a15]48,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
800076f8:	e9 ff 32 00 	st.b [%a15]50,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
800076fc:	f9 ff 34 00 	st.h [%a15]52,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80007700:	e9 ff 36 00 	st.b [%a15]54,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80007704:	f9 ff 38 00 	st.h [%a15]56,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80007708:	e9 ff 3a 00 	st.b [%a15]58,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000770c:	f9 ff 3c 00 	st.h [%a15]60,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80007710:	e9 ff 3e 00 	st.b [%a15]62,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80007714:	f9 ff 00 10 	st.h [%a15]64,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80007718:	e9 ff 02 10 	st.b [%a15]66,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
8000771c:	f9 ff 04 10 	st.h [%a15]68,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80007720:	e9 ff 06 10 	st.b [%a15]70,%d15
    /** - Module frequency is fSPB */
    config->moduleFreq = IfxScuCcu_getSpbFrequency();

    for (srcId = IfxMultican_SrcId_0; srcId < IFXMULTICAN_NUM_SRC; srcId++)
    {
        config->nodePointer[srcId].priority      = 0;
80007724:	f9 ff 08 10 	st.h [%a15]72,%d15
        config->nodePointer[srcId].typeOfService = IfxSrc_Tos_cpu0;
80007728:	e9 ff 0a 10 	st.b [%a15]74,%d15
8000772c:	00 90       	ret 

8000772e <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
8000772e:	91 00 00 28 	movh.a %a2,32768
80007732:	d9 2f 58 60 	lea %a15,[%a2]1432 <80000598 <IfxPort_cfg_esrMasks>>
80007736:	99 22 58 60 	ld.a %a2,[%a2]1432 <80000598 <IfxPort_cfg_esrMasks>>
8000773a:	7d 42 58 00 	jeq.a %a2,%a4,800077ea <IfxPort_disableEmergencyStop+0xbc>
8000773e:	c8 22       	ld.a %a2,[%a15]8
80007740:	7d 42 57 00 	jeq.a %a2,%a4,800077ee <IfxPort_disableEmergencyStop+0xc0>
80007744:	c8 42       	ld.a %a2,[%a15]16
80007746:	7d 42 56 00 	jeq.a %a2,%a4,800077f2 <IfxPort_disableEmergencyStop+0xc4>
8000774a:	c8 62       	ld.a %a2,[%a15]24
8000774c:	7d 42 55 00 	jeq.a %a2,%a4,800077f6 <IfxPort_disableEmergencyStop+0xc8>
80007750:	c8 82       	ld.a %a2,[%a15]32
80007752:	7d 42 54 00 	jeq.a %a2,%a4,800077fa <IfxPort_disableEmergencyStop+0xcc>
80007756:	c8 a2       	ld.a %a2,[%a15]40
80007758:	7d 42 53 00 	jeq.a %a2,%a4,800077fe <IfxPort_disableEmergencyStop+0xd0>
8000775c:	c8 c2       	ld.a %a2,[%a15]48
8000775e:	7d 42 52 00 	jeq.a %a2,%a4,80007802 <IfxPort_disableEmergencyStop+0xd4>
80007762:	c8 e2       	ld.a %a2,[%a15]56
80007764:	7d 42 51 00 	jeq.a %a2,%a4,80007806 <IfxPort_disableEmergencyStop+0xd8>
80007768:	99 f2 00 10 	ld.a %a2,[%a15]64
8000776c:	7d 42 4f 00 	jeq.a %a2,%a4,8000780a <IfxPort_disableEmergencyStop+0xdc>
80007770:	99 f2 08 10 	ld.a %a2,[%a15]72
80007774:	7d 42 4d 00 	jeq.a %a2,%a4,8000780e <IfxPort_disableEmergencyStop+0xe0>
80007778:	99 f2 10 10 	ld.a %a2,[%a15]80
8000777c:	7d 42 4b 00 	jeq.a %a2,%a4,80007812 <IfxPort_disableEmergencyStop+0xe4>
80007780:	99 f2 18 10 	ld.a %a2,[%a15]88
80007784:	7d 42 49 00 	jeq.a %a2,%a4,80007816 <IfxPort_disableEmergencyStop+0xe8>
80007788:	99 f2 20 10 	ld.a %a2,[%a15]96
8000778c:	7d 42 47 00 	jeq.a %a2,%a4,8000781a <IfxPort_disableEmergencyStop+0xec>
80007790:	99 f2 28 10 	ld.a %a2,[%a15]104
80007794:	7d 42 45 00 	jeq.a %a2,%a4,8000781e <IfxPort_disableEmergencyStop+0xf0>
80007798:	99 f2 30 10 	ld.a %a2,[%a15]112
8000779c:	7d 42 09 00 	jeq.a %a2,%a4,800077ae <IfxPort_disableEmergencyStop+0x80>
800077a0:	99 f2 38 10 	ld.a %a2,[%a15]120
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800077a4:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800077a6:	da 0f       	mov %d15,15
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800077a8:	7d 42 04 00 	jeq.a %a2,%a4,800077b0 <IfxPort_disableEmergencyStop+0x82>
            break;
        }
    }

    return result;
}
800077ac:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800077ae:	da 0e       	mov %d15,14
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800077b0:	d0 ff       	addsc.a %a15,%a15,%d15,3
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800077b2:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800077b4:	b9 ff 04 00 	ld.hu %d15,[%a15]4
800077b8:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
800077bc:	6e f8       	jz %d15,800077ac <IfxPort_disableEmergencyStop+0x7e>
800077be:	02 48       	mov %d8,%d4
800077c0:	40 4f       	mov.aa %a15,%a4
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800077c2:	6d 00 a5 16 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800077c6:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800077c8:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800077ca:	6d 00 a3 15 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
800077ce:	82 12       	mov %d2,1
800077d0:	d9 f4 10 10 	lea %a4,[%a15]80
800077d4:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
800077d8:	d2 06       	mov %e6,0
800077da:	02 27       	mov %d7,%d2
800077dc:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
800077e0:	02 f4       	mov %d4,%d15
800077e2:	6d 00 db 17 	call 8000a798 <IfxScuWdt_setCpuEndinit>
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
            {
                IfxPort_resetESR(port, pinIndex);
                result = TRUE;
800077e6:	82 12       	mov %d2,1
            break;
        }
    }

    return result;
}
800077e8:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800077ea:	82 0f       	mov %d15,0
800077ec:	3c e2       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
800077ee:	82 1f       	mov %d15,1
800077f0:	3c e0       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
800077f2:	82 2f       	mov %d15,2
800077f4:	3c de       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
800077f6:	82 3f       	mov %d15,3
800077f8:	3c dc       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
800077fa:	82 4f       	mov %d15,4
800077fc:	3c da       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
800077fe:	82 5f       	mov %d15,5
80007800:	3c d8       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
80007802:	82 6f       	mov %d15,6
80007804:	3c d6       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
80007806:	82 7f       	mov %d15,7
80007808:	3c d4       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
8000780a:	da 08       	mov %d15,8
8000780c:	3c d2       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
8000780e:	da 09       	mov %d15,9
80007810:	3c d0       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
80007812:	da 0a       	mov %d15,10
80007814:	3c ce       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
80007816:	da 0b       	mov %d15,11
80007818:	3c cc       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
8000781a:	da 0c       	mov %d15,12
8000781c:	3c ca       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>
8000781e:	da 0d       	mov %d15,13
80007820:	3c c8       	j 800077b0 <IfxPort_disableEmergencyStop+0x82>

80007822 <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
80007822:	82 18       	mov %d8,1
80007824:	0f 48 00 80 	sh %d8,%d8,%d4
80007828:	91 00 00 d8 	movh.a %a13,32768
8000782c:	40 4c       	mov.aa %a12,%a4
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
8000782e:	53 18 40 a0 	mul.u %e10,%d8,1
    sint32  portIndex;
    boolean result = FALSE;
80007832:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80007834:	82 0f       	mov %d15,0
80007836:	d9 dd 58 60 	lea %a13,[%a13]1432 <80000598 <IfxPort_cfg_esrMasks>>
void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
8000783a:	d9 4e 10 10 	lea %a14,[%a4]80 <80000598 <IfxPort_cfg_esrMasks>>
8000783e:	3c 06       	j 8000784a <IfxPort_enableEmergencyStop+0x28>
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80007840:	c2 1f       	add %d15,1
80007842:	8b 0f 21 32 	ne %d3,%d15,16
80007846:	df 03 1d 00 	jeq %d3,0,80007880 <IfxPort_enableEmergencyStop+0x5e>
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
8000784a:	d0 df       	addsc.a %a15,%a13,%d15,3
8000784c:	c8 02       	ld.a %a2,[%a15]0
8000784e:	7d c2 f9 ff 	jne.a %a2,%a12,80007840 <IfxPort_enableEmergencyStop+0x1e>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80007852:	b9 f3 04 00 	ld.hu %d3,[%a15]4
80007856:	26 83       	and %d3,%d8
80007858:	df 03 f4 7f 	jeq %d3,0,80007840 <IfxPort_enableEmergencyStop+0x1e>
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000785c:	6d 00 58 16 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007860:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007862:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007864:	6d 00 56 15 	call 8000a310 <IfxScuWdt_clearCpuEndinit>

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007868:	02 8b       	mov %d11,%d8
8000786a:	49 ea 40 08 	ldmst [%a14]0,%e10
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
    IfxScuWdt_setCpuEndinit(passwd);
8000786e:	02 94       	mov %d4,%d9
80007870:	6d 00 94 17 	call 8000a798 <IfxScuWdt_setCpuEndinit>
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80007874:	c2 1f       	add %d15,1
80007876:	8b 0f 21 32 	ne %d3,%d15,16
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
            {
                IfxPort_setESR(port, pinIndex);
                result = TRUE;
8000787a:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
8000787c:	df 03 e7 ff 	jne %d3,0,8000784a <IfxPort_enableEmergencyStop+0x28>
            }
        }
    }

    return result;
}
80007880:	00 90       	ret 

80007882 <IfxPort_getAddress>:


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
80007882:	91 00 00 38 	movh.a %a3,32768
80007886:	82 0f       	mov %d15,0
80007888:	d9 33 58 40 	lea %a3,[%a3]1304 <80000518 <IfxPort_cfg_indexMap>>
8000788c:	3c 0a       	j 800078a0 <IfxPort_getAddress+0x1e>
8000788e:	c2 12       	add %d2,1
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80007890:	8f f2 0f 21 	and %d2,%d2,255
80007894:	8b 02 61 22 	lt.u %d2,%d2,16
80007898:	26 32       	and %d2,%d3
8000789a:	c2 1f       	add %d15,1
8000789c:	df 02 19 00 	jeq %d2,0,800078ce <IfxPort_getAddress+0x4c>
800078a0:	8f ff 0f 31 	and %d3,%d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
800078a4:	01 33 03 f6 	addsc.a %a15,%a3,%d3,3
800078a8:	8f ff 0f 21 	and %d2,%d15,255
800078ac:	48 15       	ld.w %d5,[%a15]4
800078ae:	82 13       	mov %d3,1
800078b0:	a0 02       	mov.a %a2,0
800078b2:	5f 45 ee ff 	jne %d5,%d4,8000788e <IfxPort_getAddress+0xc>
        {
            module = IfxPort_cfg_indexMap[i].module;
800078b6:	c8 02       	ld.a %a2,[%a15]0
800078b8:	c2 12       	add %d2,1
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
800078ba:	8f f2 0f 21 	and %d2,%d2,255
800078be:	01 02 80 34 	eqz.a %d3,%a2
800078c2:	8b 02 61 22 	lt.u %d2,%d2,16
800078c6:	26 32       	and %d2,%d3
800078c8:	c2 1f       	add %d15,1
800078ca:	df 02 eb ff 	jne %d2,0,800078a0 <IfxPort_getAddress+0x1e>

        i++;
    }

    return module;
}
800078ce:	00 90       	ret 

800078d0 <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
800078d0:	91 00 00 28 	movh.a %a2,32768
800078d4:	d9 2f 58 40 	lea %a15,[%a2]1304 <80000518 <IfxPort_cfg_indexMap>>
800078d8:	99 22 58 40 	ld.a %a2,[%a2]1304 <80000518 <IfxPort_cfg_indexMap>>
800078dc:	7d 42 3f 00 	jeq.a %a2,%a4,8000795a <IfxPort_getIndex+0x8a>
800078e0:	c8 22       	ld.a %a2,[%a15]8
800078e2:	7d 42 3e 00 	jeq.a %a2,%a4,8000795e <IfxPort_getIndex+0x8e>
800078e6:	c8 42       	ld.a %a2,[%a15]16
800078e8:	7d 42 3d 00 	jeq.a %a2,%a4,80007962 <IfxPort_getIndex+0x92>
800078ec:	c8 62       	ld.a %a2,[%a15]24
800078ee:	7d 42 3c 00 	jeq.a %a2,%a4,80007966 <IfxPort_getIndex+0x96>
800078f2:	c8 82       	ld.a %a2,[%a15]32
800078f4:	7d 42 3b 00 	jeq.a %a2,%a4,8000796a <IfxPort_getIndex+0x9a>
800078f8:	c8 a2       	ld.a %a2,[%a15]40
800078fa:	7d 42 3a 00 	jeq.a %a2,%a4,8000796e <IfxPort_getIndex+0x9e>
800078fe:	c8 c2       	ld.a %a2,[%a15]48
80007900:	7d 42 39 00 	jeq.a %a2,%a4,80007972 <IfxPort_getIndex+0xa2>
80007904:	c8 e2       	ld.a %a2,[%a15]56
80007906:	7d 42 38 00 	jeq.a %a2,%a4,80007976 <IfxPort_getIndex+0xa6>
8000790a:	99 f2 00 10 	ld.a %a2,[%a15]64
8000790e:	7d 42 36 00 	jeq.a %a2,%a4,8000797a <IfxPort_getIndex+0xaa>
80007912:	99 f2 08 10 	ld.a %a2,[%a15]72
80007916:	7d 42 34 00 	jeq.a %a2,%a4,8000797e <IfxPort_getIndex+0xae>
8000791a:	99 f2 10 10 	ld.a %a2,[%a15]80
8000791e:	7d 42 32 00 	jeq.a %a2,%a4,80007982 <IfxPort_getIndex+0xb2>
80007922:	99 f2 18 10 	ld.a %a2,[%a15]88
80007926:	7d 42 30 00 	jeq.a %a2,%a4,80007986 <IfxPort_getIndex+0xb6>
8000792a:	99 f2 20 10 	ld.a %a2,[%a15]96
8000792e:	7d 42 2e 00 	jeq.a %a2,%a4,8000798a <IfxPort_getIndex+0xba>
80007932:	99 f2 28 10 	ld.a %a2,[%a15]104
80007936:	7d 42 2c 00 	jeq.a %a2,%a4,8000798e <IfxPort_getIndex+0xbe>
8000793a:	99 f2 30 10 	ld.a %a2,[%a15]112
8000793e:	7d 42 09 00 	jeq.a %a2,%a4,80007950 <IfxPort_getIndex+0x80>
80007942:	99 f2 38 10 	ld.a %a2,[%a15]120
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
80007946:	82 f2       	mov %d2,-1

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80007948:	da 0f       	mov %d15,15
    {
        if (IfxPort_cfg_indexMap[index].module == port)
8000794a:	7d 42 04 00 	jeq.a %a2,%a4,80007952 <IfxPort_getIndex+0x82>
            break;
        }
    }

    return result;
}
8000794e:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80007950:	da 0e       	mov %d15,14
    {
        if (IfxPort_cfg_indexMap[index].module == port)
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
80007952:	d0 ff       	addsc.a %a15,%a15,%d15,3
80007954:	79 f2 04 00 	ld.b %d2,[%a15]4
            break;
        }
    }

    return result;
}
80007958:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
8000795a:	82 0f       	mov %d15,0
8000795c:	3c fb       	j 80007952 <IfxPort_getIndex+0x82>
8000795e:	82 1f       	mov %d15,1
80007960:	3c f9       	j 80007952 <IfxPort_getIndex+0x82>
80007962:	82 2f       	mov %d15,2
80007964:	3c f7       	j 80007952 <IfxPort_getIndex+0x82>
80007966:	82 3f       	mov %d15,3
80007968:	3c f5       	j 80007952 <IfxPort_getIndex+0x82>
8000796a:	82 4f       	mov %d15,4
8000796c:	3c f3       	j 80007952 <IfxPort_getIndex+0x82>
8000796e:	82 5f       	mov %d15,5
80007970:	3c f1       	j 80007952 <IfxPort_getIndex+0x82>
80007972:	82 6f       	mov %d15,6
80007974:	3c ef       	j 80007952 <IfxPort_getIndex+0x82>
80007976:	82 7f       	mov %d15,7
80007978:	3c ed       	j 80007952 <IfxPort_getIndex+0x82>
8000797a:	da 08       	mov %d15,8
8000797c:	3c eb       	j 80007952 <IfxPort_getIndex+0x82>
8000797e:	da 09       	mov %d15,9
80007980:	3c e9       	j 80007952 <IfxPort_getIndex+0x82>
80007982:	da 0a       	mov %d15,10
80007984:	3c e7       	j 80007952 <IfxPort_getIndex+0x82>
80007986:	da 0b       	mov %d15,11
80007988:	3c e5       	j 80007952 <IfxPort_getIndex+0x82>
8000798a:	da 0c       	mov %d15,12
8000798c:	3c e3       	j 80007952 <IfxPort_getIndex+0x82>
8000798e:	da 0d       	mov %d15,13
80007990:	3c e1       	j 80007952 <IfxPort_getIndex+0x82>

80007992 <IfxPort_resetESR>:
    return result;
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
80007992:	40 4f       	mov.aa %a15,%a4
80007994:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007996:	6d 00 bb 15 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
8000799a:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000799c:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
8000799e:	6d 00 b9 14 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
800079a2:	82 12       	mov %d2,1
800079a4:	d9 f4 10 10 	lea %a4,[%a15]80
800079a8:	0f 82 00 20 	sh %d2,%d2,%d8
800079ac:	d2 06       	mov %e6,0
800079ae:	02 27       	mov %d7,%d2
800079b0:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
800079b4:	02 f4       	mov %d4,%d15
800079b6:	1d 00 f1 16 	j 8000a798 <IfxScuWdt_setCpuEndinit>

800079ba <IfxPort_setESR>:
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
800079ba:	40 4f       	mov.aa %a15,%a4
800079bc:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800079be:	6d 00 a7 15 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800079c2:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800079c4:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800079c6:	6d 00 a5 14 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
800079ca:	82 12       	mov %d2,1
800079cc:	0f 82 00 20 	sh %d2,%d2,%d8
800079d0:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
800079d4:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
800079d8:	02 27       	mov %d7,%d2
800079da:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
800079de:	02 f4       	mov %d4,%d15
800079e0:	1d 00 dc 16 	j 8000a798 <IfxScuWdt_setCpuEndinit>

800079e4 <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800079e4:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
800079e6:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800079e8:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
800079ea:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800079ec:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
800079ee:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800079f0:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
800079f2:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800079f4:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
800079f6:	78 07       	st.w [%sp]28,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
800079f8:	8b 04 a1 f2 	ge.u %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
800079fc:	0f 45 00 50 	sh %d5,%d5,%d4

    for (i = pinIndex; i < 16; i++)
80007a00:	ee 23       	jnz %d15,80007a46 <IfxPort_setGroupModeInput+0x62>
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007a02:	8b f4 00 f1 	rsub %d15,%d4,15
80007a06:	60 ff       	mov.a %a15,%d15
80007a08:	3b 80 0f 30 	mov %d3,248
    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
80007a0c:	57 05 61 f4 	extr.u %d15,%d5,%d4,1
80007a10:	6e 18       	jz %d15,80007a40 <IfxPort_setGroupModeInput+0x5c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007a12:	8f 34 c0 21 	andn %d2,%d4,3
80007a16:	d9 a3 20 00 	lea %a3,[%sp]32
80007a1a:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80007a1e:	8f 34 00 f1 	and %d15,%d4,3
80007a22:	06 3f       	sh %d15,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80007a24:	19 27 f0 ff 	ld.w %d7,[%a2]-16
80007a28:	0f f3 00 20 	sh %d2,%d3,%d15
80007a2c:	a6 72       	or %d2,%d7
80007a2e:	59 22 f0 ff 	st.w [%a2]-16,%d2
            iocrVal[index]  |= (mode) << shift;
80007a32:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80007a36:	0f f6 00 f0 	sh %d15,%d6,%d15
80007a3a:	a6 2f       	or %d15,%d2
80007a3c:	59 2f e0 ff 	st.w [%a2]-32,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80007a40:	c2 14       	add %d4,1
80007a42:	fd f0 e5 7f 	loop %a15,80007a0c <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007a46:	58 04       	ld.w %d15,[%sp]16
80007a48:	6e 08       	jz %d15,80007a58 <IfxPort_setGroupModeInput+0x74>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007a4a:	d9 4f 10 00 	lea %a15,[%a4]16
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007a4e:	54 a2       	ld.w %d2,[%sp]
80007a50:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007a52:	02 f3       	mov %d3,%d15
80007a54:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007a58:	58 05       	ld.w %d15,[%sp]20
80007a5a:	6e 09       	jz %d15,80007a6c <IfxPort_setGroupModeInput+0x88>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007a5c:	d9 4f 14 00 	lea %a15,[%a4]20
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007a60:	19 a2 04 00 	ld.w %d2,[%sp]4
80007a64:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007a66:	02 f3       	mov %d3,%d15
80007a68:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007a6c:	58 06       	ld.w %d15,[%sp]24
80007a6e:	6e 09       	jz %d15,80007a80 <IfxPort_setGroupModeInput+0x9c>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007a70:	d9 4f 18 00 	lea %a15,[%a4]24
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007a74:	19 a2 08 00 	ld.w %d2,[%sp]8
80007a78:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007a7a:	02 f3       	mov %d3,%d15
80007a7c:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007a80:	58 07       	ld.w %d15,[%sp]28
80007a82:	6e 0a       	jz %d15,80007a96 <IfxPort_setGroupModeInput+0xb2>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007a84:	d9 44 1c 00 	lea %a4,[%a4]28
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007a88:	19 a2 0c 00 	ld.w %d2,[%sp]12
80007a8c:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007a8e:	02 f3       	mov %d3,%d15
80007a90:	49 42 40 08 	ldmst [%a4]0,%e2
80007a94:	00 90       	ret 
80007a96:	00 90       	ret 

80007a98 <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80007a98:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
80007a9a:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80007a9c:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80007a9e:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80007aa0:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
80007aa2:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80007aa4:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80007aa6:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80007aa8:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80007aaa:	78 07       	st.w [%sp]28,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80007aac:	8b 04 a1 f2 	ge.u %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80007ab0:	0f 45 00 50 	sh %d5,%d5,%d4

    for (i = pinIndex; i < 16; i++)
80007ab4:	ee 24       	jnz %d15,80007afc <IfxPort_setGroupModeOutput+0x64>
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007ab6:	8b f4 00 f1 	rsub %d15,%d4,15
80007aba:	60 ff       	mov.a %a15,%d15
80007abc:	3b 80 0f 70 	mov %d7,248
    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
80007ac0:	57 05 61 f4 	extr.u %d15,%d5,%d4,1
80007ac4:	6e 19       	jz %d15,80007af6 <IfxPort_setGroupModeOutput+0x5e>
        {
            uint32 index = i / 4;
80007ac6:	8f e4 1f 20 	sh %d2,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007aca:	d9 a3 20 00 	lea %a3,[%sp]32
80007ace:	01 32 02 26 	addsc.a %a2,%a3,%d2,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
80007ad2:	8f 34 00 f1 	and %d15,%d4,3
80007ad6:	06 3f       	sh %d15,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
80007ad8:	a6 62       	or %d2,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007ada:	0f f7 00 30 	sh %d3,%d7,%d15
80007ade:	19 20 f0 ff 	ld.w %d0,[%a2]-16
            iocrVal[index]  |= (mode | index) << shift;
80007ae2:	0f f2 00 f0 	sh %d15,%d2,%d15
80007ae6:	19 22 e0 ff 	ld.w %d2,[%a2]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007aea:	a6 03       	or %d3,%d0
            iocrVal[index]  |= (mode | index) << shift;
80007aec:	a6 2f       	or %d15,%d2
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80007aee:	59 23 f0 ff 	st.w [%a2]-16,%d3
            iocrVal[index]  |= (mode | index) << shift;
80007af2:	59 2f e0 ff 	st.w [%a2]-32,%d15
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80007af6:	c2 14       	add %d4,1
80007af8:	fd f0 e4 7f 	loop %a15,80007ac0 <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007afc:	58 04       	ld.w %d15,[%sp]16
80007afe:	6e 08       	jz %d15,80007b0e <IfxPort_setGroupModeOutput+0x76>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007b00:	d9 4f 10 00 	lea %a15,[%a4]16
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007b04:	54 a2       	ld.w %d2,[%sp]
80007b06:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007b08:	02 f3       	mov %d3,%d15
80007b0a:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007b0e:	58 05       	ld.w %d15,[%sp]20
80007b10:	6e 09       	jz %d15,80007b22 <IfxPort_setGroupModeOutput+0x8a>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007b12:	d9 4f 14 00 	lea %a15,[%a4]20
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007b16:	19 a2 04 00 	ld.w %d2,[%sp]4
80007b1a:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007b1c:	02 f3       	mov %d3,%d15
80007b1e:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007b22:	58 06       	ld.w %d15,[%sp]24
80007b24:	6e 09       	jz %d15,80007b36 <IfxPort_setGroupModeOutput+0x9e>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007b26:	d9 4f 18 00 	lea %a15,[%a4]24
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007b2a:	19 a2 08 00 	ld.w %d2,[%sp]8
80007b2e:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007b30:	02 f3       	mov %d3,%d15
80007b32:	49 f2 40 08 	ldmst [%a15]0,%e2
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80007b36:	58 07       	ld.w %d15,[%sp]28
80007b38:	6e 0a       	jz %d15,80007b4c <IfxPort_setGroupModeOutput+0xb4>
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
80007b3a:	d9 44 1c 00 	lea %a4,[%a4]28
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007b3e:	19 a2 0c 00 	ld.w %d2,[%sp]12
80007b42:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007b44:	02 f3       	mov %d3,%d15
80007b46:	49 42 40 08 	ldmst [%a4]0,%e2
80007b4a:	00 90       	ret 
80007b4c:	00 90       	ret 

80007b4e <IfxPort_setGroupPadDriver>:
    }
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80007b4e:	20 10       	sub.a %sp,16
80007b50:	02 4f       	mov %d15,%d4
80007b52:	02 5a       	mov %d10,%d5
80007b54:	40 4c       	mov.aa %a12,%a4
80007b56:	02 68       	mov %d8,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007b58:	6d 00 da 14 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007b5c:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007b5e:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007b60:	6d 00 d8 13 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80007b64:	82 03       	mov %d3,0
80007b66:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80007b68:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80007b6c:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80007b70:	59 a3 0c 00 	st.w [%sp]12,%d3
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80007b74:	8b 0f a1 22 	ge.u %d2,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80007b78:	0f fa 00 50 	sh %d5,%d10,%d15

        for (i = pinIndex; i < 16; i++)
80007b7c:	df 02 36 80 	jne %d2,0,80007be8 <IfxPort_setGroupPadDriver+0x9a>
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80007b80:	8b ff 00 21 	rsub %d2,%d15,15
80007b84:	60 2f       	mov.a %a15,%d2
        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
80007b86:	57 05 61 3f 	extr.u %d3,%d5,%d15,1
80007b8a:	df 03 18 00 	jeq %d3,0,80007bba <IfxPort_setGroupPadDriver+0x6c>
            {
                uint32 index = i / 8;
80007b8e:	8f df 1f 70 	sh %d7,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80007b92:	d9 a3 10 00 	lea %a3,[%sp]16
80007b96:	01 37 02 26 	addsc.a %a2,%a3,%d7,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80007b9a:	8f 7f 00 31 	and %d3,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80007b9e:	19 27 f8 ff 	ld.w %d7,[%a2]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80007ba2:	06 23       	sh %d3,2
                pdrMask[index] |= (0xFUL << shift);
                pdrVal[index]  |= (padDriver << shift);
80007ba4:	19 22 f0 ff 	ld.w %d2,[%a2]-16
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80007ba8:	d7 f7 04 73 	insert %d7,%d7,15,%d3,4
                pdrVal[index]  |= (padDriver << shift);
80007bac:	0f 38 00 30 	sh %d3,%d8,%d3
80007bb0:	a6 23       	or %d3,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80007bb2:	59 27 f8 ff 	st.w [%a2]-8,%d7
                pdrVal[index]  |= (padDriver << shift);
80007bb6:	59 23 f0 ff 	st.w [%a2]-16,%d3
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80007bba:	c2 1f       	add %d15,1
80007bbc:	fd f0 e5 7f 	loop %a15,80007b86 <IfxPort_setGroupPadDriver+0x38>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80007bc0:	19 a2 08 00 	ld.w %d2,[%sp]8
80007bc4:	58 03       	ld.w %d15,[%sp]12
80007bc6:	76 28       	jz %d2,80007bd6 <IfxPort_setGroupPadDriver+0x88>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80007bc8:	d9 cf 00 10 	lea %a15,[%a12]64
80007bcc:	54 a6       	ld.w %d6,[%sp]
80007bce:	82 07       	mov %d7,0
80007bd0:	02 27       	mov %d7,%d2
80007bd2:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80007bd6:	6e 09       	jz %d15,80007be8 <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80007bd8:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007bdc:	19 a6 04 00 	ld.w %d6,[%sp]4
80007be0:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007be2:	02 f7       	mov %d7,%d15
80007be4:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80007be8:	02 94       	mov %d4,%d9
}
80007bea:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80007bee:	1d 00 d5 15 	j 8000a798 <IfxScuWdt_setCpuEndinit>

80007bf2 <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80007bf2:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80007bf6:	8f 34 00 81 	and %d8,%d4,3

    if (port == &MODULE_P40)
80007bfa:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80007bfe:	20 08       	sub.a %sp,8
80007c00:	02 4f       	mov %d15,%d4
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80007c02:	d9 4f 10 00 	lea %a15,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80007c06:	8f e4 1f 90 	sh %d9,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80007c0a:	06 38       	sh %d8,3

    if (port == &MODULE_P40)
80007c0c:	7d 24 0e 00 	jeq.a %a4,%a2,80007c28 <IfxPort_setPinMode+0x36>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80007c10:	da ff       	mov %d15,255
80007c12:	01 f9 02 f6 	addsc.a %a15,%a15,%d9,2
80007c16:	0f 8f 00 f0 	sh %d15,%d15,%d8
80007c1a:	0f 85 00 20 	sh %d2,%d5,%d8
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007c1e:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007c20:	02 f3       	mov %d3,%d15
80007c22:	49 f2 40 08 	ldmst [%a15]0,%e2
80007c26:	00 90       	ret 
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007c28:	74 a5       	st.w [%sp],%d5
80007c2a:	b5 a4 04 00 	st.a [%sp]4,%a4
80007c2e:	6d 00 6f 14 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80007c32:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007c34:	02 2a       	mov %d10,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80007c36:	6d 00 6d 13 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80007c3a:	99 a4 04 00 	ld.a %a4,[%sp]4
        IfxScuWdt_setCpuEndinit(passwd);
80007c3e:	02 a4       	mov %d4,%d10

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80007c40:	19 42 20 10 	ld.w %d2,[%a4]96
80007c44:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80007c48:	59 4f 20 10 	st.w [%a4]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80007c4c:	6d 00 a6 15 	call 8000a798 <IfxScuWdt_setCpuEndinit>
80007c50:	54 a5       	ld.w %d5,[%sp]
80007c52:	3c df       	j 80007c10 <IfxPort_setPinMode+0x1e>

80007c54 <IfxPort_setPinModeLvdsHigh>:
    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80007c54:	0b 45 10 88 	mov %e8,%d5,%d4
80007c58:	40 4f       	mov.aa %a15,%a4
80007c5a:	02 6a       	mov %d10,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007c5c:	6d 00 58 14 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007c60:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007c62:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007c64:	6d 00 56 13 	call 8000a310 <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80007c68:	37 09 48 50 	extr %d5,%d9,0,8
80007c6c:	bf 05 13 00 	jlt %d5,0,80007c92 <IfxPort_setPinModeLvdsHigh+0x3e>
    {
        if (pinIndex < 2)
80007c70:	bf 28 0e 80 	jlt.u %d8,2,80007c8c <IfxPort_setPinModeLvdsHigh+0x38>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80007c74:	19 f2 24 20 	ld.w %d2,[%a15]164
80007c78:	37 a2 01 a0 	insert %d10,%d2,%d10,0,1
80007c7c:	59 fa 24 20 	st.w [%a15]164,%d10
            port->LPCR1.B_P21.RX_DIS    = 0;
80007c80:	19 f2 24 20 	ld.w %d2,[%a15]164
80007c84:	8f 22 c0 21 	andn %d2,%d2,2
80007c88:	59 f2 24 20 	st.w [%a15]164,%d2
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
        port->LPCR2.B.TX_DIS    = 0;
        port->LPCR2.B.TX_PD     = 0;
    }

    IfxScuWdt_setCpuEndinit(passwd);
80007c8c:	02 f4       	mov %d4,%d15
80007c8e:	1d 00 85 15 	j 8000a798 <IfxScuWdt_setCpuEndinit>
            port->LPCR1.B_P21.RX_DIS    = 0;
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80007c92:	19 f2 28 20 	ld.w %d2,[%a15]168
        port->LPCR2.B.TX_DIS    = 0;
        port->LPCR2.B.TX_PD     = 0;
    }

    IfxScuWdt_setCpuEndinit(passwd);
80007c96:	02 f4       	mov %d4,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80007c98:	67 a2 0c a0 	ins.t %d10,%d2,12,%d10,0
80007c9c:	59 fa 28 20 	st.w [%a15]168,%d10
        port->LPCR2.B.TX_DIS    = 0;
80007ca0:	19 f2 28 20 	ld.w %d2,[%a15]168
80007ca4:	b7 02 81 26 	insert %d2,%d2,0,13,1
80007ca8:	59 f2 28 20 	st.w [%a15]168,%d2
        port->LPCR2.B.TX_PD     = 0;
80007cac:	19 f2 28 20 	ld.w %d2,[%a15]168
80007cb0:	b7 02 01 27 	insert %d2,%d2,0,14,1
80007cb4:	59 f2 28 20 	st.w [%a15]168,%d2
    }

    IfxScuWdt_setCpuEndinit(passwd);
80007cb8:	1d 00 70 15 	j 8000a798 <IfxScuWdt_setCpuEndinit>

80007cbc <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80007cbc:	0b 65 10 a8 	mov %e10,%d5,%d6
80007cc0:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80007cc2:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80007cc6:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80007cc8:	6d 00 22 14 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007ccc:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80007cce:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007cd0:	6d 00 20 13 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80007cd4:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80007cd6:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80007cda:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80007cde:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80007ce2:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80007ce6:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80007cea:	0f 2b 00 50 	sh %d5,%d11,%d2
80007cee:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80007cf0:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80007cf2:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80007cf4:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80007cf8:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80007cfa:	1d 00 4f 15 	j 8000a798 <IfxScuWdt_setCpuEndinit>

80007cfe <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80007cfe:	0b 45 10 88 	mov %e8,%d5,%d4
80007d02:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007d04:	6d 00 04 14 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007d08:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007d0a:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007d0c:	6d 00 02 13 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80007d10:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80007d14:	06 22       	sh %d2,2
80007d16:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80007d18:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80007d1c:	3b f0 00 30 	mov %d3,15
80007d20:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80007d24:	0f 23 00 30 	sh %d3,%d3,%d2
80007d28:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80007d2c:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80007d2e:	02 37       	mov %d7,%d3
80007d30:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80007d34:	02 f4       	mov %d4,%d15
80007d36:	1d 00 31 15 	j 8000a798 <IfxScuWdt_setCpuEndinit>
	...

80007d3c <IfxScuCcu_wait>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007d3c:	91 30 00 ff 	movh.a %a15,61443
80007d40:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007d44:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007d46:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007d4a:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007d4e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007d52:	df 02 2c 00 	jeq %d2,0,80007daa <IfxScuCcu_wait+0x6e>
80007d56:	df 12 41 80 	jne %d2,1,80007dd8 <IfxScuCcu_wait+0x9c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007d5a:	91 30 00 ff 	movh.a %a15,61443
80007d5e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007d62:	48 02       	ld.w %d2,[%a15]0
80007d64:	37 02 62 2e 	extr.u %d2,%d2,28,2
80007d68:	df 02 3a 80 	jne %d2,0,80007ddc <IfxScuCcu_wait+0xa0>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007d6c:	91 30 00 ff 	movh.a %a15,61443
80007d70:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007d74:	48 52       	ld.w %d2,[%a15]20
80007d76:	6f 02 40 80 	jnz.t %d2,0,80007df6 <IfxScuCcu_wait+0xba>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007d7a:	48 52       	ld.w %d2,[%a15]20
80007d7c:	6f 32 46 80 	jnz.t %d2,3,80007e08 <IfxScuCcu_wait+0xcc>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007d80:	48 65       	ld.w %d5,[%a15]24
80007d82:	48 72       	ld.w %d2,[%a15]28
80007d84:	37 05 e7 54 	extr.u %d5,%d5,9,7
80007d88:	8f f2 07 31 	and %d3,%d2,127
80007d8c:	48 62       	ld.w %d2,[%a15]24
80007d8e:	c2 15       	add %d5,1
80007d90:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007d94:	4b 05 41 51 	itof %d5,%d5
80007d98:	c2 12       	add %d2,1
80007d9a:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80007d9e:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80007da2:	4b 02 41 21 	itof %d2,%d2
80007da6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80007daa:	91 30 00 ff 	movh.a %a15,61443
80007dae:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007db2:	48 02       	ld.w %d2,[%a15]0
80007db4:	37 02 64 24 	extr.u %d2,%d2,8,4
80007db8:	4b 02 41 21 	itof %d2,%d2
80007dbc:	4b 2f 51 f0 	div.f %d15,%d15,%d2


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80007dc0:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80007dc4:	4b 4f 41 40 	mul.f %d4,%d15,%d4
80007dc8:	4b 04 71 41 	ftouz %d4,%d4
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80007dcc:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80007dd0:	a2 2f       	sub %d15,%d2
80007dd2:	3f 4f fd ff 	jlt.u %d15,%d4,80007dcc <IfxScuCcu_wait+0x90>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80007dd6:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007dd8:	82 0f       	mov %d15,0
80007dda:	3c e8       	j 80007daa <IfxScuCcu_wait+0x6e>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007ddc:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80007dde:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80007de0:	37 02 62 2e 	extr.u %d2,%d2,28,2
80007de4:	df 12 c4 ff 	jne %d2,1,80007d6c <IfxScuCcu_wait+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80007de8:	91 00 00 f7 	movh.a %a15,28672
80007dec:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80007df0:	4b 0f 61 f1 	utof %d15,%d15
80007df4:	3c bc       	j 80007d6c <IfxScuCcu_wait+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80007df6:	48 72       	ld.w %d2,[%a15]28
80007df8:	37 02 67 28 	extr.u %d2,%d2,16,7
80007dfc:	c2 12       	add %d2,1
80007dfe:	4b 02 41 21 	itof %d2,%d2
80007e02:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80007e06:	3c d2       	j 80007daa <IfxScuCcu_wait+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80007e08:	4c f7       	ld.w %d15,[%a15]28
80007e0a:	7b f0 cb 24 	movh %d2,19647
80007e0e:	16 7f       	and %d15,127
80007e10:	c2 1f       	add %d15,1
80007e12:	4b 0f 41 f1 	itof %d15,%d15
80007e16:	1b 02 c2 2b 	addi %d2,%d2,-17376
80007e1a:	4b f2 51 f0 	div.f %d15,%d2,%d15
80007e1e:	3c c6       	j 80007daa <IfxScuCcu_wait+0x6e>

80007e20 <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80007e20:	7b e0 e4 30 	movh %d3,3662
80007e24:	1b 13 c0 31 	addi %d3,%d3,7169
80007e28:	0b 34 30 e1 	lt.u %d14,%d4,%d3
80007e2c:	82 2f       	mov %d15,2
80007e2e:	ab 1f 80 ee 	sel %d14,%d14,%d15,1
80007e32:	8f 4e 00 50 	sh %d5,%d14,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80007e36:	7b c0 be 60 	movh %d6,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80007e3a:	91 40 0f 60 	movh.a %a6,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80007e3e:	7b 80 82 ce 	movh %d12,59432
80007e42:	91 80 7d 51 	movh.a %a5,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
80007e46:	19 4a 10 10 	ld.w %d10,[%a4]80
80007e4a:	60 53       	mov.a %a3,%d5
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80007e4c:	1b 06 20 6c 	addi %d6,%d6,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80007e50:	d2 00       	mov %e0,0
80007e52:	82 07       	mov %d7,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80007e54:	3b 00 01 90 	mov %d9,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80007e58:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80007e5c:	82 fd       	mov %d13,-1
80007e5e:	1b 0c c0 c7 	addi %d12,%d12,31744
80007e62:	d9 55 41 08 	lea %a5,[%a5]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
80007e66:	a0 f2       	mov.a %a2,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80007e68:	4b 9a 11 22 	div.u %e2,%d10,%d9

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80007e6c:	7b 60 f8 5f 	movh %d5,65414
80007e70:	1b 05 e0 5e 	addi %d5,%d5,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80007e74:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80007e76:	0b 52 40 50 	addx %d5,%d2,%d5
80007e7a:	8b f3 bf 20 	addc %d2,%d3,-1
80007e7e:	80 63       	mov.d %d3,%a6
80007e80:	ba 02       	eq %d15,%d2,0
80007e82:	0b 35 50 f2 	and.ge.u %d15,%d5,%d3
80007e86:	8b 02 00 f5 	or.ne %d15,%d2,0
80007e8a:	ee 24       	jnz %d15,80007ed2 <IfxScuCcu_calculateSysPllDividers+0xb2>
80007e8c:	02 9b       	mov %d11,%d9
80007e8e:	82 18       	mov %d8,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80007e90:	03 48 68 2c 	madd.u %e2,%e12,%d8,%d4
80007e94:	80 55       	mov.d %d5,%a5
80007e96:	ba 03       	eq %d15,%d3,0
80007e98:	0b 52 50 f2 	and.ge.u %d15,%d2,%d5
80007e9c:	8b 03 00 f5 	or.ne %d15,%d3,0
80007ea0:	ee 13       	jnz %d15,80007ec6 <IfxScuCcu_calculateSysPllDividers+0xa6>
80007ea2:	82 15       	mov %d5,1
80007ea4:	c5 0f 3f 10 	lea %a15,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
80007ea8:	4b b5 11 22 	div.u %e2,%d5,%d11
80007eac:	e2 a2       	mul %d2,%d10
80007eae:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
80007eb0:	df 02 1b 00 	jeq %d2,0,80007ee6 <IfxScuCcu_calculateSysPllDividers+0xc6>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
80007eb4:	82 1f       	mov %d15,1
80007eb6:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
80007eba:	6a 50       	cmovn %d0,%d15,%d5
80007ebc:	6a 26       	cmovn %d6,%d15,%d2
80007ebe:	6a 91       	cmovn %d1,%d15,%d9
80007ec0:	6a 87       	cmovn %d7,%d15,%d8
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
80007ec2:	c2 15       	add %d5,1
80007ec4:	fc f2       	loop %a15,80007ea8 <IfxScuCcu_calculateSysPllDividers+0x88>
80007ec6:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80007ec8:	42 e8       	add %d8,%d14
80007eca:	42 fb       	add %d11,%d15
80007ecc:	8b 18 68 f2 	lt.u %d15,%d8,129
80007ed0:	ee e0       	jnz %d15,80007e90 <IfxScuCcu_calculateSysPllDividers+0x70>
80007ed2:	60 ef       	mov.a %a15,%d14
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80007ed4:	c2 f9       	add %d9,-1
80007ed6:	01 f3 20 30 	sub.a %a3,%a3,%a15
80007eda:	fd 20 c7 7f 	loop %a2,80007e68 <IfxScuCcu_calculateSysPllDividers+0x48>
80007ede:	02 19       	mov %d9,%d1
80007ee0:	02 05       	mov %d5,%d0
80007ee2:	02 78       	mov %d8,%d7
80007ee4:	3c 02       	j 80007ee8 <IfxScuCcu_calculateSysPllDividers+0xc8>
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
80007ee6:	82 06       	mov %d6,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80007ee8:	7b c0 1e 25 	movh %d2,20972
80007eec:	06 14       	sh %d4,1
80007eee:	1b f2 51 28 	addi %d2,%d2,-31457
80007ef2:	73 24 68 20 	mul.u %e2,%d4,%d2
80007ef6:	82 1f       	mov %d15,1
80007ef8:	8f b3 1f 20 	sh %d2,%d3,-5
80007efc:	0b 26 50 f2 	and.ge.u %d15,%d6,%d2
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80007f00:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80007f02:	ee 0f       	jnz %d15,80007f20 <IfxScuCcu_calculateSysPllDividers+0x100>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80007f04:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80007f06:	c2 f5       	add %d5,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80007f08:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80007f0a:	c2 f8       	add %d8,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80007f0c:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80007f10:	e9 45 09 00 	st.b [%a4]9,%d5
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80007f14:	e9 49 08 00 	st.b [%a4]8,%d9
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80007f18:	e9 48 0a 00 	st.b [%a4]10,%d8
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80007f1c:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80007f1e:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80007f20:	00 90       	ret 

80007f22 <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80007f22:	91 30 00 ff 	movh.a %a15,61443
80007f26:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007f2a:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
80007f2c:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80007f2e:	8f ff 00 31 	and %d3,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
80007f32:	f6 32       	jnz %d3,80007f36 <IfxScuCcu_getBaud1Frequency+0x14>
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
    }

    return frequency;
}
80007f34:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007f36:	48 04       	ld.w %d4,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007f38:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007f3c:	37 04 62 4e 	extr.u %d4,%d4,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80007f40:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80007f44:	df 04 2c 00 	jeq %d4,0,80007f9c <IfxScuCcu_getBaud1Frequency+0x7a>
80007f48:	df 14 46 80 	jne %d4,1,80007fd4 <IfxScuCcu_getBaud1Frequency+0xb2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80007f4c:	91 30 00 ff 	movh.a %a15,61443
80007f50:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80007f54:	48 04       	ld.w %d4,[%a15]0
80007f56:	37 04 62 4e 	extr.u %d4,%d4,28,2
80007f5a:	df 04 79 80 	jne %d4,0,8000804c <_SMALL_DATA2_+0x4c>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80007f5e:	91 30 00 ff 	movh.a %a15,61443
80007f62:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80007f66:	48 52       	ld.w %d2,[%a15]20
80007f68:	6f 02 80 80 	jnz.t %d2,0,80008068 <_SMALL_DATA2_+0x68>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80007f6c:	48 52       	ld.w %d2,[%a15]20
80007f6e:	6f 32 86 80 	jnz.t %d2,3,8000807a <_SMALL_DATA2_+0x7a>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80007f72:	48 65       	ld.w %d5,[%a15]24
80007f74:	48 72       	ld.w %d2,[%a15]28
80007f76:	37 05 e7 54 	extr.u %d5,%d5,9,7
80007f7a:	8f f2 07 41 	and %d4,%d2,127
80007f7e:	48 62       	ld.w %d2,[%a15]24
80007f80:	c2 15       	add %d5,1
80007f82:	37 02 64 2c 	extr.u %d2,%d2,24,4
80007f86:	4b 05 41 51 	itof %d5,%d5
80007f8a:	c2 12       	add %d2,1
80007f8c:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80007f90:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80007f94:	4b 02 41 21 	itof %d2,%d2
80007f98:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007f9c:	91 30 00 ff 	movh.a %a15,61443
80007fa0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007fa4:	48 02       	ld.w %d2,[%a15]0
80007fa6:	37 02 64 26 	extr.u %d2,%d2,12,4
80007faa:	bf 52 04 80 	jlt.u %d2,5,80007fb2 <IfxScuCcu_getBaud1Frequency+0x90>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
        break;
    default:
        maxFrequency = 0.0f;
80007fae:	82 0f       	mov %d15,0
80007fb0:	3c 23       	j 80007ff6 <IfxScuCcu_getBaud1Frequency+0xd4>
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007fb2:	91 00 00 f8 	movh.a %a15,32768
80007fb6:	d9 ff c0 f7 	lea %a15,[%a15]32704 <80007fc0 <IfxScuCcu_getBaud1Frequency+0x9e>>
80007fba:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
80007fbe:	dc 0f       	ji %a15
80007fc0:	1d 00 2e 00 	j 8000801c <_SMALL_DATA2_+0x1c>
80007fc4:	1d 00 25 00 	j 8000800e <_SMALL_DATA2_+0xe>
80007fc8:	1d 00 1c 00 	j 80008000 <_SMALL_DATA2_>
80007fcc:	1d 00 0f 00 	j 80007fea <IfxScuCcu_getBaud1Frequency+0xc8>
80007fd0:	1d 00 37 00 	j 8000803e <_SMALL_DATA2_+0x3e>
80007fd4:	91 30 00 ff 	movh.a %a15,61443
80007fd8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80007fdc:	48 02       	ld.w %d2,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80007fde:	82 0f       	mov %d15,0
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80007fe0:	37 02 64 26 	extr.u %d2,%d2,12,4
80007fe4:	ff 52 e5 ff 	jge.u %d2,5,80007fae <IfxScuCcu_getBaud1Frequency+0x8c>
80007fe8:	3c e5       	j 80007fb2 <IfxScuCcu_getBaud1Frequency+0x90>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80007fea:	7b 90 c8 23 	movh %d2,15497
80007fee:	1b 92 88 28 	addi %d2,%d2,-30583
80007ff2:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
80007ff6:	4b 03 41 21 	itof %d2,%d3
80007ffa:	4b 2f 51 20 	div.f %d2,%d15,%d2
    }

    return frequency;
}
80007ffe:	00 90       	ret 
        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
80008000:	7b 90 d0 23 	movh %d2,15625
80008004:	1b 92 88 28 	addi %d2,%d2,-30583
80008008:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
8000800c:	3c f5       	j 80007ff6 <IfxScuCcu_getBaud1Frequency+0xd4>
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
8000800e:	7b 90 d8 23 	movh %d2,15753
80008012:	1b 92 88 28 	addi %d2,%d2,-30583
80008016:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
8000801a:	3c ee       	j 80007ff6 <IfxScuCcu_getBaud1Frequency+0xd4>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
8000801c:	91 30 00 ff 	movh.a %a15,61443
80008020:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80008024:	48 02       	ld.w %d2,[%a15]0
80008026:	8f f2 00 21 	and %d2,%d2,15
8000802a:	df 02 e6 7f 	jeq %d2,0,80007ff6 <IfxScuCcu_getBaud1Frequency+0xd4>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
8000802e:	48 02       	ld.w %d2,[%a15]0
80008030:	8f f2 00 21 	and %d2,%d2,15
80008034:	4b 02 41 21 	itof %d2,%d2
80008038:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000803c:	3c dd       	j 80007ff6 <IfxScuCcu_getBaud1Frequency+0xd4>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
8000803e:	7b 90 c0 23 	movh %d2,15369
80008042:	1b 92 88 28 	addi %d2,%d2,-30583
80008046:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
8000804a:	3c d6       	j 80007ff6 <IfxScuCcu_getBaud1Frequency+0xd4>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000804c:	48 04       	ld.w %d4,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
8000804e:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008050:	37 04 62 4e 	extr.u %d4,%d4,28,2
80008054:	df 14 85 ff 	jne %d4,1,80007f5e <IfxScuCcu_getBaud1Frequency+0x3c>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008058:	91 00 00 f7 	movh.a %a15,28672
8000805c:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008060:	4b 0f 61 f1 	utof %d15,%d15
80008064:	1d ff 7d ff 	j 80007f5e <IfxScuCcu_getBaud1Frequency+0x3c>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008068:	48 72       	ld.w %d2,[%a15]28
8000806a:	37 02 67 28 	extr.u %d2,%d2,16,7
8000806e:	c2 12       	add %d2,1
80008070:	4b 02 41 21 	itof %d2,%d2
80008074:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008078:	3c 92       	j 80007f9c <IfxScuCcu_getBaud1Frequency+0x7a>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000807a:	4c f7       	ld.w %d15,[%a15]28
8000807c:	7b f0 cb 24 	movh %d2,19647
80008080:	16 7f       	and %d15,127
80008082:	c2 1f       	add %d15,1
80008084:	4b 0f 41 f1 	itof %d15,%d15
80008088:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000808c:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008090:	3c 86       	j 80007f9c <IfxScuCcu_getBaud1Frequency+0x7a>

80008092 <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80008092:	91 30 00 ff 	movh.a %a15,61443
80008096:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000809a:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
8000809c:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000809e:	37 0f 64 32 	extr.u %d3,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
800080a2:	16 f0       	and %d15,240
800080a4:	ee 02       	jnz %d15,800080a8 <IfxScuCcu_getBaud2Frequency+0x16>
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
    }

    return frequency;
}
800080a6:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800080a8:	48 04       	ld.w %d4,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800080aa:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800080ae:	37 04 62 4e 	extr.u %d4,%d4,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800080b2:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800080b6:	df 04 2c 00 	jeq %d4,0,8000810e <IfxScuCcu_getBaud2Frequency+0x7c>
800080ba:	df 14 47 80 	jne %d4,1,80008148 <IfxScuCcu_getBaud2Frequency+0xb6>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
800080be:	91 30 00 ff 	movh.a %a15,61443
800080c2:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800080c6:	48 04       	ld.w %d4,[%a15]0
800080c8:	37 04 62 4e 	extr.u %d4,%d4,28,2
800080cc:	df 04 7a 80 	jne %d4,0,800081c0 <IfxScuCcu_getBaud2Frequency+0x12e>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800080d0:	91 30 00 ff 	movh.a %a15,61443
800080d4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800080d8:	48 52       	ld.w %d2,[%a15]20
800080da:	6f 02 81 80 	jnz.t %d2,0,800081dc <IfxScuCcu_getBaud2Frequency+0x14a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800080de:	48 52       	ld.w %d2,[%a15]20
800080e0:	6f 32 87 80 	jnz.t %d2,3,800081ee <IfxScuCcu_getBaud2Frequency+0x15c>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800080e4:	48 65       	ld.w %d5,[%a15]24
800080e6:	48 72       	ld.w %d2,[%a15]28
800080e8:	37 05 e7 54 	extr.u %d5,%d5,9,7
800080ec:	8f f2 07 41 	and %d4,%d2,127
800080f0:	48 62       	ld.w %d2,[%a15]24
800080f2:	c2 15       	add %d5,1
800080f4:	37 02 64 2c 	extr.u %d2,%d2,24,4
800080f8:	4b 05 41 51 	itof %d5,%d5
800080fc:	c2 12       	add %d2,1
800080fe:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80008102:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80008106:	4b 02 41 21 	itof %d2,%d2
8000810a:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000810e:	91 30 00 ff 	movh.a %a15,61443
80008112:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008116:	48 02       	ld.w %d2,[%a15]0
80008118:	37 02 64 26 	extr.u %d2,%d2,12,4
8000811c:	bf 52 04 80 	jlt.u %d2,5,80008124 <IfxScuCcu_getBaud2Frequency+0x92>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
        break;
    default:
        maxFrequency = 0.0f;
80008120:	82 0f       	mov %d15,0
80008122:	3c 24       	j 8000816a <IfxScuCcu_getBaud2Frequency+0xd8>
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008124:	91 10 00 f8 	movh.a %a15,32769
80008128:	d9 ff 34 48 	lea %a15,[%a15]-32460 <80008134 <IfxScuCcu_getBaud2Frequency+0xa2>>
8000812c:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
80008130:	dc 0f       	ji %a15
80008132:	00 00       	nop 
80008134:	1d 00 2e 00 	j 80008190 <IfxScuCcu_getBaud2Frequency+0xfe>
80008138:	1d 00 25 00 	j 80008182 <IfxScuCcu_getBaud2Frequency+0xf0>
8000813c:	1d 00 1c 00 	j 80008174 <IfxScuCcu_getBaud2Frequency+0xe2>
80008140:	1d 00 0f 00 	j 8000815e <IfxScuCcu_getBaud2Frequency+0xcc>
80008144:	1d 00 37 00 	j 800081b2 <IfxScuCcu_getBaud2Frequency+0x120>
80008148:	91 30 00 ff 	movh.a %a15,61443
8000814c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008150:	48 02       	ld.w %d2,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008152:	82 0f       	mov %d15,0
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008154:	37 02 64 26 	extr.u %d2,%d2,12,4
80008158:	ff 52 e4 ff 	jge.u %d2,5,80008120 <IfxScuCcu_getBaud2Frequency+0x8e>
8000815c:	3c e4       	j 80008124 <IfxScuCcu_getBaud2Frequency+0x92>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
8000815e:	7b 90 c8 23 	movh %d2,15497
80008162:	1b 92 88 28 	addi %d2,%d2,-30583
80008166:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
8000816a:	4b 03 41 21 	itof %d2,%d3
8000816e:	4b 2f 51 20 	div.f %d2,%d15,%d2
    }

    return frequency;
}
80008172:	00 90       	ret 
        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
80008174:	7b 90 d0 23 	movh %d2,15625
80008178:	1b 92 88 28 	addi %d2,%d2,-30583
8000817c:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80008180:	3c f5       	j 8000816a <IfxScuCcu_getBaud2Frequency+0xd8>
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80008182:	7b 90 d8 23 	movh %d2,15753
80008186:	1b 92 88 28 	addi %d2,%d2,-30583
8000818a:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
8000818e:	3c ee       	j 8000816a <IfxScuCcu_getBaud2Frequency+0xd8>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
80008190:	91 30 00 ff 	movh.a %a15,61443
80008194:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80008198:	48 02       	ld.w %d2,[%a15]0
8000819a:	8f f2 00 21 	and %d2,%d2,15
8000819e:	df 02 e6 7f 	jeq %d2,0,8000816a <IfxScuCcu_getBaud2Frequency+0xd8>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
800081a2:	48 02       	ld.w %d2,[%a15]0
800081a4:	8f f2 00 21 	and %d2,%d2,15
800081a8:	4b 02 41 21 	itof %d2,%d2
800081ac:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800081b0:	3c dd       	j 8000816a <IfxScuCcu_getBaud2Frequency+0xd8>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
800081b2:	7b 90 c0 23 	movh %d2,15369
800081b6:	1b 92 88 28 	addi %d2,%d2,-30583
800081ba:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
800081be:	3c d6       	j 8000816a <IfxScuCcu_getBaud2Frequency+0xd8>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800081c0:	48 04       	ld.w %d4,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800081c2:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800081c4:	37 04 62 4e 	extr.u %d4,%d4,28,2
800081c8:	df 14 84 ff 	jne %d4,1,800080d0 <IfxScuCcu_getBaud2Frequency+0x3e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800081cc:	91 00 00 f7 	movh.a %a15,28672
800081d0:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
800081d4:	4b 0f 61 f1 	utof %d15,%d15
800081d8:	1d ff 7c ff 	j 800080d0 <IfxScuCcu_getBaud2Frequency+0x3e>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800081dc:	48 72       	ld.w %d2,[%a15]28
800081de:	37 02 67 28 	extr.u %d2,%d2,16,7
800081e2:	c2 12       	add %d2,1
800081e4:	4b 02 41 21 	itof %d2,%d2
800081e8:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800081ec:	3c 91       	j 8000810e <IfxScuCcu_getBaud2Frequency+0x7c>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800081ee:	4c f7       	ld.w %d15,[%a15]28
800081f0:	7b f0 cb 24 	movh %d2,19647
800081f4:	16 7f       	and %d15,127
800081f6:	c2 1f       	add %d15,1
800081f8:	4b 0f 41 f1 	itof %d15,%d15
800081fc:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008200:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008204:	3c 85       	j 8000810e <IfxScuCcu_getBaud2Frequency+0x7c>

80008206 <IfxScuCcu_getBbbFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008206:	91 30 00 ff 	movh.a %a15,61443
8000820a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000820e:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008210:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008214:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008218:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000821c:	df 02 2c 00 	jeq %d2,0,80008274 <IfxScuCcu_getBbbFrequency+0x6e>
80008220:	df 12 4d 80 	jne %d2,1,800082ba <IfxScuCcu_getBbbFrequency+0xb4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008224:	91 30 00 ff 	movh.a %a15,61443
80008228:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000822c:	48 02       	ld.w %d2,[%a15]0
8000822e:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008232:	df 02 6d 80 	jne %d2,0,8000830c <IfxScuCcu_getBbbFrequency+0x106>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008236:	91 30 00 ff 	movh.a %a15,61443
8000823a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000823e:	48 52       	ld.w %d2,[%a15]20
80008240:	6f 02 73 80 	jnz.t %d2,0,80008326 <IfxScuCcu_getBbbFrequency+0x120>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008244:	48 52       	ld.w %d2,[%a15]20
80008246:	6f 32 79 80 	jnz.t %d2,3,80008338 <IfxScuCcu_getBbbFrequency+0x132>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000824a:	48 64       	ld.w %d4,[%a15]24
8000824c:	48 72       	ld.w %d2,[%a15]28
8000824e:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008252:	8f f2 07 31 	and %d3,%d2,127
80008256:	48 62       	ld.w %d2,[%a15]24
80008258:	c2 14       	add %d4,1
8000825a:	37 02 64 2c 	extr.u %d2,%d2,24,4
8000825e:	4b 04 41 41 	itof %d4,%d4
80008262:	c2 12       	add %d2,1
80008264:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80008268:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
8000826c:	4b 02 41 21 	itof %d2,%d2
80008270:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008274:	91 30 00 ff 	movh.a %a15,61443
80008278:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000827c:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0f;
8000827e:	82 02       	mov %d2,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008280:	37 03 64 36 	extr.u %d3,%d3,12,4
80008284:	ff 53 1a 80 	jge.u %d3,5,800082b8 <IfxScuCcu_getBbbFrequency+0xb2>
80008288:	91 10 00 f8 	movh.a %a15,32769
8000828c:	d9 ff 18 a8 	lea %a15,[%a15]-32104 <80008298 <IfxScuCcu_getBbbFrequency+0x92>>
80008290:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80008294:	dc 0f       	ji %a15
80008296:	00 00       	nop 
80008298:	1d 00 1a 00 	j 800082cc <IfxScuCcu_getBbbFrequency+0xc6>
8000829c:	1d 00 2a 00 	j 800082f0 <IfxScuCcu_getBbbFrequency+0xea>
800082a0:	1d 00 2f 00 	j 800082fe <IfxScuCcu_getBbbFrequency+0xf8>
800082a4:	1d 00 0d 00 	j 800082be <IfxScuCcu_getBbbFrequency+0xb8>
800082a8:	1d 00 02 00 	j 800082ac <IfxScuCcu_getBbbFrequency+0xa6>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
800082ac:	7b 90 b8 23 	movh %d2,15241
800082b0:	1b 92 88 28 	addi %d2,%d2,-30583
800082b4:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        bbbFrequency = 0.0f;
        break;
    }

    return bbbFrequency;
}
800082b8:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800082ba:	82 0f       	mov %d15,0
800082bc:	3c dc       	j 80008274 <IfxScuCcu_getBbbFrequency+0x6e>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
800082be:	7b 90 c0 23 	movh %d2,15369
800082c2:	1b 92 88 28 	addi %d2,%d2,-30583
800082c6:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
800082ca:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
800082cc:	91 30 00 ff 	movh.a %a15,61443
800082d0:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
800082d4:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0f;
800082d6:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
800082d8:	8f f3 00 31 	and %d3,%d3,15
800082dc:	df 03 ee 7f 	jeq %d3,0,800082b8 <IfxScuCcu_getBbbFrequency+0xb2>
        {
            bbbFrequency = 0.0f;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
800082e0:	48 02       	ld.w %d2,[%a15]0
800082e2:	8f f2 00 21 	and %d2,%d2,15
800082e6:	4b 02 41 21 	itof %d2,%d2
800082ea:	4b 2f 51 20 	div.f %d2,%d15,%d2
800082ee:	00 90       	ret 
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
800082f0:	7b 90 d0 23 	movh %d2,15625
800082f4:	1b 92 88 28 	addi %d2,%d2,-30583
800082f8:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
800082fc:	00 90       	ret 
    case 2:
        bbbFrequency = sourceFrequency / 60;
800082fe:	7b 90 c8 23 	movh %d2,15497
80008302:	1b 92 88 28 	addi %d2,%d2,-30583
80008306:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
8000830a:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000830c:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
8000830e:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008310:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008314:	df 12 91 ff 	jne %d2,1,80008236 <IfxScuCcu_getBbbFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008318:	91 00 00 f7 	movh.a %a15,28672
8000831c:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008320:	4b 0f 61 f1 	utof %d15,%d15
80008324:	3c 89       	j 80008236 <IfxScuCcu_getBbbFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008326:	48 72       	ld.w %d2,[%a15]28
80008328:	37 02 67 28 	extr.u %d2,%d2,16,7
8000832c:	c2 12       	add %d2,1
8000832e:	4b 02 41 21 	itof %d2,%d2
80008332:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008336:	3c 9f       	j 80008274 <IfxScuCcu_getBbbFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008338:	4c f7       	ld.w %d15,[%a15]28
8000833a:	7b f0 cb 24 	movh %d2,19647
8000833e:	16 7f       	and %d15,127
80008340:	c2 1f       	add %d15,1
80008342:	4b 0f 41 f1 	itof %d15,%d15
80008346:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000834a:	4b f2 51 f0 	div.f %d15,%d2,%d15
8000834e:	3c 93       	j 80008274 <IfxScuCcu_getBbbFrequency+0x6e>

80008350 <IfxScuCcu_getCpuFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008350:	91 30 00 ff 	movh.a %a15,61443
80008354:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008358:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000835a:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000835e:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008362:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008366:	df 02 2c 00 	jeq %d2,0,800083be <IfxScuCcu_getCpuFrequency+0x6e>
8000836a:	df 12 6a 80 	jne %d2,1,8000843e <IfxScuCcu_getCpuFrequency+0xee>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000836e:	91 30 00 ff 	movh.a %a15,61443
80008372:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008376:	48 02       	ld.w %d2,[%a15]0
80008378:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000837c:	df 02 8d 80 	jne %d2,0,80008496 <IfxScuCcu_getCpuFrequency+0x146>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008380:	91 30 00 ff 	movh.a %a15,61443
80008384:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008388:	48 52       	ld.w %d2,[%a15]20
8000838a:	6f 02 94 80 	jnz.t %d2,0,800084b2 <IfxScuCcu_getCpuFrequency+0x162>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000838e:	48 52       	ld.w %d2,[%a15]20
80008390:	6f 32 9b 80 	jnz.t %d2,3,800084c6 <IfxScuCcu_getCpuFrequency+0x176>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008394:	48 65       	ld.w %d5,[%a15]24
80008396:	48 72       	ld.w %d2,[%a15]28
80008398:	37 05 e7 54 	extr.u %d5,%d5,9,7
8000839c:	8f f2 07 31 	and %d3,%d2,127
800083a0:	48 62       	ld.w %d2,[%a15]24
800083a2:	c2 15       	add %d5,1
800083a4:	37 02 64 2c 	extr.u %d2,%d2,24,4
800083a8:	4b 05 41 51 	itof %d5,%d5
800083ac:	c2 12       	add %d2,1
800083ae:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
800083b2:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
800083b6:	4b 02 41 21 	itof %d2,%d2
800083ba:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800083be:	91 30 00 ff 	movh.a %a15,61443
800083c2:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800083c6:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800083c8:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800083ca:	37 03 64 36 	extr.u %d3,%d3,12,4
800083ce:	ff 53 23 80 	jge.u %d3,5,80008414 <IfxScuCcu_getCpuFrequency+0xc4>
800083d2:	91 10 00 f8 	movh.a %a15,32769
800083d6:	d9 ff 20 f8 	lea %a15,[%a15]-31776 <800083e0 <IfxScuCcu_getCpuFrequency+0x90>>
800083da:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800083de:	dc 0f       	ji %a15
800083e0:	1d 00 0a 00 	j 800083f4 <IfxScuCcu_getCpuFrequency+0xa4>
800083e4:	1d 00 4b 00 	j 8000847a <IfxScuCcu_getCpuFrequency+0x12a>
800083e8:	1d 00 50 00 	j 80008488 <IfxScuCcu_getCpuFrequency+0x138>
800083ec:	1d 00 39 00 	j 8000845e <IfxScuCcu_getCpuFrequency+0x10e>
800083f0:	1d 00 3e 00 	j 8000846c <IfxScuCcu_getCpuFrequency+0x11c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800083f4:	91 30 00 ff 	movh.a %a15,61443
800083f8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800083fc:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0f;
800083fe:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80008400:	37 03 64 34 	extr.u %d3,%d3,8,4
80008404:	76 38       	jz %d3,80008414 <IfxScuCcu_getCpuFrequency+0xc4>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80008406:	48 02       	ld.w %d2,[%a15]0
80008408:	37 02 64 24 	extr.u %d2,%d2,8,4
8000840c:	4b 02 41 21 	itof %d2,%d2
80008410:	4b 2f 51 20 	div.f %d2,%d15,%d2
float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
    float32 frequency = IfxScuCcu_getSriFrequency();
    uint32  cpuDiv    = 0;

    switch (cpu)
80008414:	df 14 1f 00 	jeq %d4,1,80008452 <IfxScuCcu_getCpuFrequency+0x102>
80008418:	df 04 17 00 	jeq %d4,0,80008446 <IfxScuCcu_getCpuFrequency+0xf6>
8000841c:	df 24 13 80 	jne %d4,2,80008442 <IfxScuCcu_getCpuFrequency+0xf2>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
80008420:	91 30 00 ff 	movh.a %a15,61443
80008424:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80008428:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0f;
        break;
    }

    if (cpuDiv != 0)
8000842a:	6e 0d       	jz %d15,80008444 <IfxScuCcu_getCpuFrequency+0xf4>
8000842c:	7b 00 c8 33 	movh %d3,15488
80008430:	4b 32 41 20 	mul.f %d2,%d2,%d3
    {
        frequency = frequency * (cpuDiv / 64.0f);
80008434:	4b 0f 61 f1 	utof %d15,%d15
80008438:	4b f2 41 20 	mul.f %d2,%d2,%d15
8000843c:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
8000843e:	82 0f       	mov %d15,0
80008440:	3c bf       	j 800083be <IfxScuCcu_getCpuFrequency+0x6e>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0f;
80008442:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
80008444:	00 90       	ret 
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
80008446:	91 30 00 ff 	movh.a %a15,61443
8000844a:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
8000844e:	4c f0       	ld.w %d15,[%a15]0
        break;
80008450:	3c ed       	j 8000842a <IfxScuCcu_getCpuFrequency+0xda>
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
80008452:	91 30 00 ff 	movh.a %a15,61443
80008456:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
8000845a:	4c f0       	ld.w %d15,[%a15]0
        break;
8000845c:	3c e7       	j 8000842a <IfxScuCcu_getCpuFrequency+0xda>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
8000845e:	7b 90 c0 23 	movh %d2,15369
80008462:	1b 92 88 28 	addi %d2,%d2,-30583
80008466:	4b 2f 41 20 	mul.f %d2,%d15,%d2
8000846a:	3c d5       	j 80008414 <IfxScuCcu_getCpuFrequency+0xc4>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
8000846c:	7b 90 b8 23 	movh %d2,15241
80008470:	1b 92 88 28 	addi %d2,%d2,-30583
80008474:	4b 2f 41 20 	mul.f %d2,%d15,%d2
80008478:	3c ce       	j 80008414 <IfxScuCcu_getCpuFrequency+0xc4>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
8000847a:	7b 90 d0 23 	movh %d2,15625
8000847e:	1b 92 88 28 	addi %d2,%d2,-30583
80008482:	4b 2f 41 20 	mul.f %d2,%d15,%d2
80008486:	3c c7       	j 80008414 <IfxScuCcu_getCpuFrequency+0xc4>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
80008488:	7b 90 c8 23 	movh %d2,15497
8000848c:	1b 92 88 28 	addi %d2,%d2,-30583
80008490:	4b 2f 41 20 	mul.f %d2,%d15,%d2
80008494:	3c c0       	j 80008414 <IfxScuCcu_getCpuFrequency+0xc4>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008496:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008498:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000849a:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000849e:	df 12 71 ff 	jne %d2,1,80008380 <IfxScuCcu_getCpuFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800084a2:	91 00 00 f7 	movh.a %a15,28672
800084a6:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
800084aa:	4b 0f 61 f1 	utof %d15,%d15
800084ae:	1d ff 69 ff 	j 80008380 <IfxScuCcu_getCpuFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800084b2:	48 72       	ld.w %d2,[%a15]28
800084b4:	37 02 67 28 	extr.u %d2,%d2,16,7
800084b8:	c2 12       	add %d2,1
800084ba:	4b 02 41 21 	itof %d2,%d2
800084be:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800084c2:	1d ff 7e ff 	j 800083be <IfxScuCcu_getCpuFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800084c6:	4c f7       	ld.w %d15,[%a15]28
800084c8:	7b f0 cb 24 	movh %d2,19647
800084cc:	16 7f       	and %d15,127
800084ce:	c2 1f       	add %d15,1
800084d0:	4b 0f 41 f1 	itof %d15,%d15
800084d4:	1b 02 c2 2b 	addi %d2,%d2,-17376
800084d8:	4b f2 51 f0 	div.f %d15,%d2,%d15
800084dc:	1d ff 71 ff 	j 800083be <IfxScuCcu_getCpuFrequency+0x6e>

800084e0 <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800084e0:	91 30 00 ff 	movh.a %a15,61443
800084e4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800084e8:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
800084ea:	7b 00 03 30 	movh %d3,48
800084ee:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800084f0:	37 0f 62 4a 	extr.u %d4,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
800084f4:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
800084f6:	f6 32       	jnz %d3,800084fa <IfxScuCcu_getFsi2Frequency+0x1a>
            frequency = frequency / ccucon0.B.FSI2DIV;
        }
    }

    return frequency;
}
800084f8:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800084fa:	48 05       	ld.w %d5,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
800084fc:	7b f0 cb 34 	movh %d3,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008500:	37 05 62 5e 	extr.u %d5,%d5,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008504:	1b 03 c2 3b 	addi %d3,%d3,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008508:	df 05 2c 00 	jeq %d5,0,80008560 <IfxScuCcu_getFsi2Frequency+0x80>
8000850c:	df 15 52 80 	jne %d5,1,800085b0 <IfxScuCcu_getFsi2Frequency+0xd0>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008510:	91 30 00 ff 	movh.a %a15,61443
80008514:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008518:	48 05       	ld.w %d5,[%a15]0
8000851a:	37 05 62 5e 	extr.u %d5,%d5,28,2
8000851e:	df 05 83 80 	jne %d5,0,80008624 <IfxScuCcu_getFsi2Frequency+0x144>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008522:	91 30 00 ff 	movh.a %a15,61443
80008526:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000852a:	48 52       	ld.w %d2,[%a15]20
8000852c:	6f 02 8a 80 	jnz.t %d2,0,80008640 <IfxScuCcu_getFsi2Frequency+0x160>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008530:	48 52       	ld.w %d2,[%a15]20
80008532:	6f 32 90 80 	jnz.t %d2,3,80008652 <IfxScuCcu_getFsi2Frequency+0x172>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008536:	48 66       	ld.w %d6,[%a15]24
80008538:	48 72       	ld.w %d2,[%a15]28
8000853a:	37 06 e7 64 	extr.u %d6,%d6,9,7
8000853e:	8f f2 07 51 	and %d5,%d2,127
80008542:	48 62       	ld.w %d2,[%a15]24
80008544:	c2 16       	add %d6,1
80008546:	37 02 64 2c 	extr.u %d2,%d2,24,4
8000854a:	4b 06 41 61 	itof %d6,%d6
8000854e:	c2 12       	add %d2,1
80008550:	03 25 0a 22 	madd %d2,%d2,%d5,%d2
80008554:	4b 63 41 30 	mul.f %d3,%d3,%d6
80008558:	4b 02 41 21 	itof %d2,%d2
8000855c:	4b 23 51 30 	div.f %d3,%d3,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008560:	91 30 00 ff 	movh.a %a15,61443
80008564:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008568:	48 05       	ld.w %d5,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
8000856a:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000856c:	37 05 64 56 	extr.u %d5,%d5,12,4
80008570:	bf 55 0f 80 	jlt.u %d5,5,8000858e <IfxScuCcu_getFsi2Frequency+0xae>
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
80008574:	3b 00 f0 30 	mov %d3,3840
80008578:	26 3f       	and %d15,%d3
8000857a:	1b 0f f0 ff 	addi %d15,%d15,-256
8000857e:	8f 0f d0 f1 	andn %d15,%d15,256
80008582:	ee bb       	jnz %d15,800084f8 <IfxScuCcu_getFsi2Frequency+0x18>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
80008584:	4b 04 41 41 	itof %d4,%d4
80008588:	4b 42 51 20 	div.f %d2,%d2,%d4
        }
    }

    return frequency;
}
8000858c:	00 90       	ret 
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000858e:	91 10 00 f8 	movh.a %a15,32769
80008592:	d9 ff 5c 68 	lea %a15,[%a15]-31332 <8000859c <IfxScuCcu_getFsi2Frequency+0xbc>>
80008596:	01 f5 02 f6 	addsc.a %a15,%a15,%d5,2
8000859a:	dc 0f       	ji %a15
8000859c:	1d 00 2b 00 	j 800085f2 <IfxScuCcu_getFsi2Frequency+0x112>
800085a0:	1d 00 22 00 	j 800085e4 <IfxScuCcu_getFsi2Frequency+0x104>
800085a4:	1d 00 19 00 	j 800085d6 <IfxScuCcu_getFsi2Frequency+0xf6>
800085a8:	1d 00 10 00 	j 800085c8 <IfxScuCcu_getFsi2Frequency+0xe8>
800085ac:	1d 00 35 00 	j 80008616 <IfxScuCcu_getFsi2Frequency+0x136>
800085b0:	91 30 00 ff 	movh.a %a15,61443
800085b4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800085b8:	48 05       	ld.w %d5,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800085ba:	82 03       	mov %d3,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800085bc:	37 05 64 56 	extr.u %d5,%d5,12,4
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800085c0:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800085c2:	ff 55 d9 ff 	jge.u %d5,5,80008574 <IfxScuCcu_getFsi2Frequency+0x94>
800085c6:	3c e4       	j 8000858e <IfxScuCcu_getFsi2Frequency+0xae>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
800085c8:	7b 90 c0 23 	movh %d2,15369
800085cc:	1b 92 88 28 	addi %d2,%d2,-30583
800085d0:	4b 23 41 20 	mul.f %d2,%d3,%d2
800085d4:	3c d0       	j 80008574 <IfxScuCcu_getFsi2Frequency+0x94>
        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
800085d6:	7b 90 c8 23 	movh %d2,15497
800085da:	1b 92 88 28 	addi %d2,%d2,-30583
800085de:	4b 23 41 20 	mul.f %d2,%d3,%d2
800085e2:	3c c9       	j 80008574 <IfxScuCcu_getFsi2Frequency+0x94>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
800085e4:	7b 90 d0 23 	movh %d2,15625
800085e8:	1b 92 88 28 	addi %d2,%d2,-30583
800085ec:	4b 23 41 20 	mul.f %d2,%d3,%d2
800085f0:	3c c2       	j 80008574 <IfxScuCcu_getFsi2Frequency+0x94>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800085f2:	91 30 00 ff 	movh.a %a15,61443
800085f6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800085fa:	48 05       	ld.w %d5,[%a15]0
        {
            sriFrequency = 0.0f;
800085fc:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800085fe:	37 05 64 54 	extr.u %d5,%d5,8,4
80008602:	df 05 b9 7f 	jeq %d5,0,80008574 <IfxScuCcu_getFsi2Frequency+0x94>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80008606:	48 02       	ld.w %d2,[%a15]0
80008608:	37 02 64 24 	extr.u %d2,%d2,8,4
8000860c:	4b 02 41 21 	itof %d2,%d2
80008610:	4b 23 51 20 	div.f %d2,%d3,%d2
80008614:	3c b0       	j 80008574 <IfxScuCcu_getFsi2Frequency+0x94>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
80008616:	7b 90 b8 23 	movh %d2,15241
8000861a:	1b 92 88 28 	addi %d2,%d2,-30583
8000861e:	4b 23 41 20 	mul.f %d2,%d3,%d2
80008622:	3c a9       	j 80008574 <IfxScuCcu_getFsi2Frequency+0x94>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008624:	48 05       	ld.w %d5,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008626:	82 03       	mov %d3,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008628:	37 05 62 5e 	extr.u %d5,%d5,28,2
8000862c:	df 15 7b ff 	jne %d5,1,80008522 <IfxScuCcu_getFsi2Frequency+0x42>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008630:	91 00 00 f7 	movh.a %a15,28672
80008634:	19 f3 00 b1 	ld.w %d3,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008638:	4b 03 61 31 	utof %d3,%d3
8000863c:	1d ff 73 ff 	j 80008522 <IfxScuCcu_getFsi2Frequency+0x42>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008640:	48 72       	ld.w %d2,[%a15]28
80008642:	37 02 67 28 	extr.u %d2,%d2,16,7
80008646:	c2 12       	add %d2,1
80008648:	4b 02 41 21 	itof %d2,%d2
8000864c:	4b 23 51 30 	div.f %d3,%d3,%d2
80008650:	3c 88       	j 80008560 <IfxScuCcu_getFsi2Frequency+0x80>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008652:	48 73       	ld.w %d3,[%a15]28
80008654:	8f f3 07 31 	and %d3,%d3,127
80008658:	c2 13       	add %d3,1
8000865a:	4b 03 41 21 	itof %d2,%d3
8000865e:	7b f0 cb 34 	movh %d3,19647
80008662:	1b 03 c2 3b 	addi %d3,%d3,-17376
80008666:	4b 23 51 30 	div.f %d3,%d3,%d2
8000866a:	1d ff 7b ff 	j 80008560 <IfxScuCcu_getFsi2Frequency+0x80>

8000866e <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000866e:	91 30 00 ff 	movh.a %a15,61443
80008672:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008676:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
80008678:	7b 00 30 30 	movh %d3,768
8000867c:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
8000867e:	37 0f 62 4c 	extr.u %d4,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
80008682:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
80008684:	f6 32       	jnz %d3,80008688 <IfxScuCcu_getFsiFrequency+0x1a>
            frequency = frequency / ccucon0.B.FSIDIV;
        }
    }

    return frequency;
}
80008686:	00 90       	ret 

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008688:	48 05       	ld.w %d5,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000868a:	7b f0 cb 34 	movh %d3,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000868e:	37 05 62 5e 	extr.u %d5,%d5,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008692:	1b 03 c2 3b 	addi %d3,%d3,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008696:	df 05 2c 00 	jeq %d5,0,800086ee <IfxScuCcu_getFsiFrequency+0x80>
8000869a:	df 15 53 80 	jne %d5,1,80008740 <IfxScuCcu_getFsiFrequency+0xd2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000869e:	91 30 00 ff 	movh.a %a15,61443
800086a2:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800086a6:	48 05       	ld.w %d5,[%a15]0
800086a8:	37 05 62 5e 	extr.u %d5,%d5,28,2
800086ac:	df 05 84 80 	jne %d5,0,800087b4 <IfxScuCcu_getFsiFrequency+0x146>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
800086b0:	91 30 00 ff 	movh.a %a15,61443
800086b4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
800086b8:	48 52       	ld.w %d2,[%a15]20
800086ba:	6f 02 8b 80 	jnz.t %d2,0,800087d0 <IfxScuCcu_getFsiFrequency+0x162>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
800086be:	48 52       	ld.w %d2,[%a15]20
800086c0:	6f 32 91 80 	jnz.t %d2,3,800087e2 <IfxScuCcu_getFsiFrequency+0x174>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800086c4:	48 66       	ld.w %d6,[%a15]24
800086c6:	48 72       	ld.w %d2,[%a15]28
800086c8:	37 06 e7 64 	extr.u %d6,%d6,9,7
800086cc:	8f f2 07 51 	and %d5,%d2,127
800086d0:	48 62       	ld.w %d2,[%a15]24
800086d2:	c2 16       	add %d6,1
800086d4:	37 02 64 2c 	extr.u %d2,%d2,24,4
800086d8:	4b 06 41 61 	itof %d6,%d6
800086dc:	c2 12       	add %d2,1
800086de:	03 25 0a 22 	madd %d2,%d2,%d5,%d2
800086e2:	4b 63 41 30 	mul.f %d3,%d3,%d6
800086e6:	4b 02 41 21 	itof %d2,%d2
800086ea:	4b 23 51 30 	div.f %d3,%d3,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800086ee:	91 30 00 ff 	movh.a %a15,61443
800086f2:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800086f6:	48 05       	ld.w %d5,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800086f8:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800086fa:	37 05 64 56 	extr.u %d5,%d5,12,4
800086fe:	bf 55 0f 80 	jlt.u %d5,5,8000871c <IfxScuCcu_getFsiFrequency+0xae>
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
80008702:	3b 00 f0 30 	mov %d3,3840
80008706:	26 3f       	and %d15,%d3
80008708:	1b 0f f0 ff 	addi %d15,%d15,-256
8000870c:	8f 0f d0 f1 	andn %d15,%d15,256
80008710:	ee bb       	jnz %d15,80008686 <IfxScuCcu_getFsiFrequency+0x18>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
80008712:	4b 04 41 41 	itof %d4,%d4
80008716:	4b 42 51 20 	div.f %d2,%d2,%d4
        }
    }

    return frequency;
}
8000871a:	00 90       	ret 
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000871c:	91 10 00 f8 	movh.a %a15,32769
80008720:	d9 ff 6c c8 	lea %a15,[%a15]-30932 <8000872c <IfxScuCcu_getFsiFrequency+0xbe>>
80008724:	01 f5 02 f6 	addsc.a %a15,%a15,%d5,2
80008728:	dc 0f       	ji %a15
8000872a:	00 00       	nop 
8000872c:	1d 00 2b 00 	j 80008782 <IfxScuCcu_getFsiFrequency+0x114>
80008730:	1d 00 22 00 	j 80008774 <IfxScuCcu_getFsiFrequency+0x106>
80008734:	1d 00 19 00 	j 80008766 <IfxScuCcu_getFsiFrequency+0xf8>
80008738:	1d 00 10 00 	j 80008758 <IfxScuCcu_getFsiFrequency+0xea>
8000873c:	1d 00 35 00 	j 800087a6 <IfxScuCcu_getFsiFrequency+0x138>
80008740:	91 30 00 ff 	movh.a %a15,61443
80008744:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008748:	48 05       	ld.w %d5,[%a15]0
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
8000874a:	82 03       	mov %d3,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000874c:	37 05 64 56 	extr.u %d5,%d5,12,4
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
80008750:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008752:	ff 55 d8 ff 	jge.u %d5,5,80008702 <IfxScuCcu_getFsiFrequency+0x94>
80008756:	3c e3       	j 8000871c <IfxScuCcu_getFsiFrequency+0xae>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80008758:	7b 90 c0 23 	movh %d2,15369
8000875c:	1b 92 88 28 	addi %d2,%d2,-30583
80008760:	4b 23 41 20 	mul.f %d2,%d3,%d2
80008764:	3c cf       	j 80008702 <IfxScuCcu_getFsiFrequency+0x94>
        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
80008766:	7b 90 c8 23 	movh %d2,15497
8000876a:	1b 92 88 28 	addi %d2,%d2,-30583
8000876e:	4b 23 41 20 	mul.f %d2,%d3,%d2
80008772:	3c c8       	j 80008702 <IfxScuCcu_getFsiFrequency+0x94>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
80008774:	7b 90 d0 23 	movh %d2,15625
80008778:	1b 92 88 28 	addi %d2,%d2,-30583
8000877c:	4b 23 41 20 	mul.f %d2,%d3,%d2
80008780:	3c c1       	j 80008702 <IfxScuCcu_getFsiFrequency+0x94>

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80008782:	91 30 00 ff 	movh.a %a15,61443
80008786:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000878a:	48 05       	ld.w %d5,[%a15]0
        {
            sriFrequency = 0.0f;
8000878c:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
8000878e:	37 05 64 54 	extr.u %d5,%d5,8,4
80008792:	df 05 b8 7f 	jeq %d5,0,80008702 <IfxScuCcu_getFsiFrequency+0x94>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80008796:	48 02       	ld.w %d2,[%a15]0
80008798:	37 02 64 24 	extr.u %d2,%d2,8,4
8000879c:	4b 02 41 21 	itof %d2,%d2
800087a0:	4b 23 51 20 	div.f %d2,%d3,%d2
800087a4:	3c af       	j 80008702 <IfxScuCcu_getFsiFrequency+0x94>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
800087a6:	7b 90 b8 23 	movh %d2,15241
800087aa:	1b 92 88 28 	addi %d2,%d2,-30583
800087ae:	4b 23 41 20 	mul.f %d2,%d3,%d2
800087b2:	3c a8       	j 80008702 <IfxScuCcu_getFsiFrequency+0x94>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800087b4:	48 05       	ld.w %d5,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800087b6:	82 03       	mov %d3,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800087b8:	37 05 62 5e 	extr.u %d5,%d5,28,2
800087bc:	df 15 7a ff 	jne %d5,1,800086b0 <IfxScuCcu_getFsiFrequency+0x42>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800087c0:	91 00 00 f7 	movh.a %a15,28672
800087c4:	19 f3 00 b1 	ld.w %d3,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
800087c8:	4b 03 61 31 	utof %d3,%d3
800087cc:	1d ff 72 ff 	j 800086b0 <IfxScuCcu_getFsiFrequency+0x42>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800087d0:	48 72       	ld.w %d2,[%a15]28
800087d2:	37 02 67 28 	extr.u %d2,%d2,16,7
800087d6:	c2 12       	add %d2,1
800087d8:	4b 02 41 21 	itof %d2,%d2
800087dc:	4b 23 51 30 	div.f %d3,%d3,%d2
800087e0:	3c 87       	j 800086ee <IfxScuCcu_getFsiFrequency+0x80>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800087e2:	48 73       	ld.w %d3,[%a15]28
800087e4:	8f f3 07 31 	and %d3,%d3,127
800087e8:	c2 13       	add %d3,1
800087ea:	4b 03 41 21 	itof %d2,%d3
800087ee:	7b f0 cb 34 	movh %d3,19647
800087f2:	1b 03 c2 3b 	addi %d3,%d3,-17376
800087f6:	4b 23 51 30 	div.f %d3,%d3,%d2
800087fa:	1d ff 7a ff 	j 800086ee <IfxScuCcu_getFsiFrequency+0x80>

800087fe <IfxScuCcu_getMaxFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800087fe:	91 30 00 ff 	movh.a %a15,61443
80008802:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008806:	4c f0       	ld.w %d15,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008808:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000880c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008810:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008814:	6e 2a       	jz %d15,80008868 <IfxScuCcu_getMaxFrequency+0x6a>
80008816:	df 1f 45 80 	jne %d15,1,800088a0 <IfxScuCcu_getMaxFrequency+0xa2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000881a:	91 30 00 ff 	movh.a %a15,61443
8000881e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008822:	4c f0       	ld.w %d15,[%a15]0
80008824:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008828:	ee 68       	jnz %d15,800088f8 <IfxScuCcu_getMaxFrequency+0xfa>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000882a:	91 30 00 ff 	movh.a %a15,61443
8000882e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008832:	4c f5       	ld.w %d15,[%a15]20
80008834:	6f 0f 6f 80 	jnz.t %d15,0,80008912 <IfxScuCcu_getMaxFrequency+0x114>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008838:	4c f5       	ld.w %d15,[%a15]20
8000883a:	6f 3f 75 80 	jnz.t %d15,3,80008924 <IfxScuCcu_getMaxFrequency+0x126>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000883e:	48 64       	ld.w %d4,[%a15]24
80008840:	4c f7       	ld.w %d15,[%a15]28
80008842:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008846:	8f ff 07 31 	and %d3,%d15,127
8000884a:	4c f6       	ld.w %d15,[%a15]24
8000884c:	c2 14       	add %d4,1
8000884e:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80008852:	4b 04 41 41 	itof %d4,%d4
80008856:	c2 1f       	add %d15,1
80008858:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
8000885c:	4b 42 41 20 	mul.f %d2,%d2,%d4
80008860:	4b 0f 41 f1 	itof %d15,%d15
80008864:	4b f2 51 20 	div.f %d2,%d2,%d15
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008868:	91 30 00 ff 	movh.a %a15,61443
8000886c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008870:	4c f0       	ld.w %d15,[%a15]0
80008872:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80008876:	bf 5f 04 80 	jlt.u %d15,5,8000887e <IfxScuCcu_getMaxFrequency+0x80>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
        break;
    default:
        maxFrequency = 0.0f;
8000887a:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
8000887c:	00 90       	ret 
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000887e:	91 10 00 f8 	movh.a %a15,32769
80008882:	d9 ff 8c 28 	lea %a15,[%a15]-30580 <8000888c <IfxScuCcu_getMaxFrequency+0x8e>>
80008886:	90 ff       	addsc.a %a15,%a15,%d15,2
80008888:	dc 0f       	ji %a15
8000888a:	00 00       	nop 
8000888c:	1d 00 1a 00 	j 800088c0 <IfxScuCcu_getMaxFrequency+0xc2>
80008890:	1d 00 26 00 	j 800088dc <IfxScuCcu_getMaxFrequency+0xde>
80008894:	1d 00 2b 00 	j 800088ea <IfxScuCcu_getMaxFrequency+0xec>
80008898:	1d 00 06 00 	j 800088a4 <IfxScuCcu_getMaxFrequency+0xa6>
8000889c:	1d 00 0b 00 	j 800088b2 <IfxScuCcu_getMaxFrequency+0xb4>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
800088a0:	82 02       	mov %d2,0
800088a2:	3c e3       	j 80008868 <IfxScuCcu_getMaxFrequency+0x6a>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
800088a4:	7b 90 c8 f3 	movh %d15,15497
800088a8:	1b 9f 88 f8 	addi %d15,%d15,-30583
800088ac:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
800088b0:	00 90       	ret 
    case 4:
        maxFrequency = sourceFrequency / 120;
800088b2:	7b 90 c0 f3 	movh %d15,15369
800088b6:	1b 9f 88 f8 	addi %d15,%d15,-30583
800088ba:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
800088be:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
800088c0:	91 30 00 ff 	movh.a %a15,61443
800088c4:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
800088c8:	4c f0       	ld.w %d15,[%a15]0
800088ca:	16 0f       	and %d15,15
800088cc:	6e d8       	jz %d15,8000887c <IfxScuCcu_getMaxFrequency+0x7e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
800088ce:	4c f0       	ld.w %d15,[%a15]0
800088d0:	16 0f       	and %d15,15
800088d2:	4b 0f 41 f1 	itof %d15,%d15
800088d6:	4b f2 51 20 	div.f %d2,%d2,%d15
800088da:	00 90       	ret 
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
800088dc:	7b 90 d8 f3 	movh %d15,15753
800088e0:	1b 9f 88 f8 	addi %d15,%d15,-30583
800088e4:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
800088e8:	00 90       	ret 
    case 2:
        maxFrequency = sourceFrequency / 30;
800088ea:	7b 90 d0 f3 	movh %d15,15625
800088ee:	1b 9f 88 f8 	addi %d15,%d15,-30583
800088f2:	4b f2 41 20 	mul.f %d2,%d2,%d15
        break;
800088f6:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800088f8:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800088fa:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800088fc:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008900:	df 1f 95 ff 	jne %d15,1,8000882a <IfxScuCcu_getMaxFrequency+0x2c>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008904:	91 00 00 f7 	movh.a %a15,28672
80008908:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
8000890c:	4b 02 61 21 	utof %d2,%d2
80008910:	3c 8d       	j 8000882a <IfxScuCcu_getMaxFrequency+0x2c>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008912:	4c f7       	ld.w %d15,[%a15]28
80008914:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80008918:	c2 1f       	add %d15,1
8000891a:	4b 0f 41 f1 	itof %d15,%d15
8000891e:	4b f2 51 20 	div.f %d2,%d2,%d15
80008922:	3c a3       	j 80008868 <IfxScuCcu_getMaxFrequency+0x6a>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008924:	48 72       	ld.w %d2,[%a15]28
80008926:	8f f2 07 21 	and %d2,%d2,127
8000892a:	c2 12       	add %d2,1
8000892c:	4b 02 41 f1 	itof %d15,%d2
80008930:	7b f0 cb 24 	movh %d2,19647
80008934:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008938:	4b f2 51 20 	div.f %d2,%d2,%d15
8000893c:	3c 96       	j 80008868 <IfxScuCcu_getMaxFrequency+0x6a>

8000893e <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
8000893e:	91 30 00 ff 	movh.a %a15,61443
80008942:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
80008946:	48 05       	ld.w %d5,[%a15]0

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008948:	91 30 00 ff 	movh.a %a15,61443
8000894c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008950:	48 03       	ld.w %d3,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008952:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008956:	37 03 62 3e 	extr.u %d3,%d3,28,2
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
8000895a:	b7 05 16 65 	insert %d6,%d5,0,10,22
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000895e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008962:	df 03 2c 00 	jeq %d3,0,800089ba <IfxScuCcu_getModuleFrequency+0x7c>
80008966:	df 13 60 80 	jne %d3,1,80008a26 <IfxScuCcu_getModuleFrequency+0xe8>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000896a:	91 30 00 ff 	movh.a %a15,61443
8000896e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008972:	48 02       	ld.w %d2,[%a15]0
80008974:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008978:	df 02 8c 80 	jne %d2,0,80008a90 <IfxScuCcu_getModuleFrequency+0x152>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000897c:	91 30 00 ff 	movh.a %a15,61443
80008980:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008984:	48 52       	ld.w %d2,[%a15]20
80008986:	6f 02 93 80 	jnz.t %d2,0,80008aac <IfxScuCcu_getModuleFrequency+0x16e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000898a:	48 52       	ld.w %d2,[%a15]20
8000898c:	6f 32 9a 80 	jnz.t %d2,3,80008ac0 <IfxScuCcu_getModuleFrequency+0x182>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008990:	48 64       	ld.w %d4,[%a15]24
80008992:	48 72       	ld.w %d2,[%a15]28
80008994:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008998:	8f f2 07 31 	and %d3,%d2,127
8000899c:	48 62       	ld.w %d2,[%a15]24
8000899e:	c2 14       	add %d4,1
800089a0:	37 02 64 2c 	extr.u %d2,%d2,24,4
800089a4:	4b 04 41 41 	itof %d4,%d4
800089a8:	c2 12       	add %d2,1
800089aa:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
800089ae:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
800089b2:	4b 02 41 21 	itof %d2,%d2
800089b6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800089ba:	91 30 00 ff 	movh.a %a15,61443
800089be:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800089c2:	48 04       	ld.w %d4,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0f;
800089c4:	82 03       	mov %d3,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800089c6:	37 04 64 46 	extr.u %d4,%d4,12,4
800089ca:	ff 54 23 80 	jge.u %d4,5,80008a10 <IfxScuCcu_getModuleFrequency+0xd2>
800089ce:	91 10 00 f8 	movh.a %a15,32769
800089d2:	d9 ff 9c 78 	lea %a15,[%a15]-30244 <800089dc <IfxScuCcu_getModuleFrequency+0x9e>>
800089d6:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
800089da:	dc 0f       	ji %a15
800089dc:	1d 00 0a 00 	j 800089f0 <IfxScuCcu_getModuleFrequency+0xb2>
800089e0:	1d 00 4a 00 	j 80008a74 <IfxScuCcu_getModuleFrequency+0x136>
800089e4:	1d 00 4f 00 	j 80008a82 <IfxScuCcu_getModuleFrequency+0x144>
800089e8:	1d 00 2a 00 	j 80008a3c <IfxScuCcu_getModuleFrequency+0xfe>
800089ec:	1d 00 3d 00 	j 80008a66 <IfxScuCcu_getModuleFrequency+0x128>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800089f0:	91 30 00 ff 	movh.a %a15,61443
800089f4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800089f8:	48 02       	ld.w %d2,[%a15]0
        {
            spbFrequency = 0.0f;
800089fa:	82 03       	mov %d3,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
800089fc:	37 02 64 28 	extr.u %d2,%d2,16,4
80008a00:	76 28       	jz %d2,80008a10 <IfxScuCcu_getModuleFrequency+0xd2>
        {
            spbFrequency = 0.0f;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80008a02:	48 03       	ld.w %d3,[%a15]0
80008a04:	37 03 64 38 	extr.u %d3,%d3,16,4
80008a08:	4b 03 41 31 	itof %d3,%d3
80008a0c:	4b 3f 51 30 	div.f %d3,%d15,%d3
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
80008a10:	bb 00 00 fc 	mov.u %d15,49152
80008a14:	26 5f       	and %d15,%d5
80008a16:	3b 00 00 24 	mov %d2,16384
80008a1a:	be 2e       	jeq %d15,%d2,80008a56 <IfxScuCcu_getModuleFrequency+0x118>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
80008a1c:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
80008a20:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
80008a22:	3e 44       	jeq %d15,%d4,80008a2a <IfxScuCcu_getModuleFrequency+0xec>
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
80008a24:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008a26:	82 0f       	mov %d15,0
80008a28:	3c c9       	j 800089ba <IfxScuCcu_getModuleFrequency+0x7c>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
80008a2a:	4b 06 41 21 	itof %d2,%d6
80008a2e:	7b 00 a8 f3 	movh %d15,14976
80008a32:	4b f2 41 20 	mul.f %d2,%d2,%d15
80008a36:	4b 32 41 20 	mul.f %d2,%d2,%d3
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
80008a3a:	00 90       	ret 
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
80008a3c:	7b 90 c0 33 	movh %d3,15369
80008a40:	1b 93 88 38 	addi %d3,%d3,-30583
80008a44:	4b 3f 41 30 	mul.f %d3,%d15,%d3
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
80008a48:	bb 00 00 fc 	mov.u %d15,49152
80008a4c:	26 5f       	and %d15,%d5
80008a4e:	3b 00 00 24 	mov %d2,16384
80008a52:	5f 2f e5 ff 	jne %d15,%d2,80008a1c <IfxScuCcu_getModuleFrequency+0xde>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
80008a56:	3b 00 40 20 	mov %d2,1024
80008a5a:	a2 62       	sub %d2,%d6
80008a5c:	4b 02 41 21 	itof %d2,%d2
80008a60:	4b 23 51 20 	div.f %d2,%d3,%d2
80008a64:	00 90       	ret 
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
80008a66:	7b 90 b8 33 	movh %d3,15241
80008a6a:	1b 93 88 38 	addi %d3,%d3,-30583
80008a6e:	4b 3f 41 30 	mul.f %d3,%d15,%d3
80008a72:	3c cf       	j 80008a10 <IfxScuCcu_getModuleFrequency+0xd2>
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80008a74:	7b 90 d0 33 	movh %d3,15625
80008a78:	1b 93 88 38 	addi %d3,%d3,-30583
80008a7c:	4b 3f 41 30 	mul.f %d3,%d15,%d3
80008a80:	3c c8       	j 80008a10 <IfxScuCcu_getModuleFrequency+0xd2>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
80008a82:	7b 90 c8 33 	movh %d3,15497
80008a86:	1b 93 88 38 	addi %d3,%d3,-30583
80008a8a:	4b 3f 41 30 	mul.f %d3,%d15,%d3
80008a8e:	3c c1       	j 80008a10 <IfxScuCcu_getModuleFrequency+0xd2>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008a90:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008a92:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008a94:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008a98:	df 12 72 ff 	jne %d2,1,8000897c <IfxScuCcu_getModuleFrequency+0x3e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008a9c:	91 00 00 f7 	movh.a %a15,28672
80008aa0:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008aa4:	4b 0f 61 f1 	utof %d15,%d15
80008aa8:	1d ff 6a ff 	j 8000897c <IfxScuCcu_getModuleFrequency+0x3e>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008aac:	48 72       	ld.w %d2,[%a15]28
80008aae:	37 02 67 28 	extr.u %d2,%d2,16,7
80008ab2:	c2 12       	add %d2,1
80008ab4:	4b 02 41 21 	itof %d2,%d2
80008ab8:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008abc:	1d ff 7f ff 	j 800089ba <IfxScuCcu_getModuleFrequency+0x7c>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008ac0:	4c f7       	ld.w %d15,[%a15]28
80008ac2:	7b f0 cb 24 	movh %d2,19647
80008ac6:	16 7f       	and %d15,127
80008ac8:	c2 1f       	add %d15,1
80008aca:	4b 0f 41 f1 	itof %d15,%d15
80008ace:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008ad2:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008ad6:	1d ff 72 ff 	j 800089ba <IfxScuCcu_getModuleFrequency+0x7c>

80008ada <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80008ada:	91 00 00 f7 	movh.a %a15,28672
80008ade:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
}
80008ae2:	4b 02 61 21 	utof %d2,%d2
80008ae6:	00 90       	ret 

80008ae8 <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008ae8:	91 30 00 ff 	movh.a %a15,61443
80008aec:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008af0:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80008af2:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008af6:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80008afa:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008afe:	6e 06       	jz %d15,80008b0a <IfxScuCcu_getOscFrequency+0x22>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008b00:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008b02:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008b04:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008b08:	1e 12       	jeq %d15,1,80008b0c <IfxScuCcu_getOscFrequency+0x24>
        /* Reserved values, this */
        freq = 0.0f;
    }

    return freq;
}
80008b0a:	00 90       	ret 
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008b0c:	91 00 00 f7 	movh.a %a15,28672
80008b10:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008b14:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0f;
    }

    return freq;
}
80008b18:	00 90       	ret 

80008b1a <IfxScuCcu_getPllErayFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008b1a:	91 30 00 ff 	movh.a %a15,61443
80008b1e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008b22:	48 02       	ld.w %d2,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80008b24:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008b28:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80008b2c:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008b30:	df 02 1e 80 	jne %d2,0,80008b6c <IfxScuCcu_getPllErayFrequency+0x52>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80008b34:	91 30 00 ff 	movh.a %a15,61443
80008b38:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008b3c:	48 92       	ld.w %d2,[%a15]36
80008b3e:	6f 02 2a 80 	jnz.t %d2,0,80008b92 <IfxScuCcu_getPllErayFrequency+0x78>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80008b42:	48 92       	ld.w %d2,[%a15]36
80008b44:	6f 32 30 80 	jnz.t %d2,3,80008ba4 <IfxScuCcu_getPllErayFrequency+0x8a>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80008b48:	48 a2       	ld.w %d2,[%a15]40
80008b4a:	48 b3       	ld.w %d3,[%a15]44
80008b4c:	37 02 e5 24 	extr.u %d2,%d2,9,5
80008b50:	8f f3 07 31 	and %d3,%d3,127
80008b54:	c2 12       	add %d2,1
80008b56:	4b 02 41 21 	itof %d2,%d2
80008b5a:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80008b5e:	1b 13 00 20 	addi %d2,%d3,1
80008b62:	4b 02 41 31 	itof %d3,%d2
80008b66:	4b 3f 51 20 	div.f %d2,%d15,%d3
    }

    return freq;
}
80008b6a:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008b6c:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008b6e:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008b70:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008b74:	df 12 e0 ff 	jne %d2,1,80008b34 <IfxScuCcu_getPllErayFrequency+0x1a>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008b78:	91 00 00 f7 	movh.a %a15,28672
80008b7c:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80008b80:	91 30 00 ff 	movh.a %a15,61443
80008b84:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008b88:	4b 02 61 f1 	utof %d15,%d2
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80008b8c:	48 92       	ld.w %d2,[%a15]36
80008b8e:	6f 02 da 7f 	jz.t %d2,0,80008b42 <IfxScuCcu_getPllErayFrequency+0x28>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80008b92:	48 b2       	ld.w %d2,[%a15]44
80008b94:	37 02 67 28 	extr.u %d2,%d2,16,7
80008b98:	c2 12       	add %d2,1
80008b9a:	4b 02 41 21 	itof %d2,%d2
80008b9e:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008ba2:	00 90       	ret 
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80008ba4:	48 b2       	ld.w %d2,[%a15]44
80008ba6:	8f f2 07 21 	and %d2,%d2,127
80008baa:	c2 12       	add %d2,1
80008bac:	4b 02 41 f1 	itof %d15,%d2
80008bb0:	7b f0 cb 24 	movh %d2,19647
80008bb4:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008bb8:	4b f2 51 20 	div.f %d2,%d2,%d15
80008bbc:	00 90       	ret 

80008bbe <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008bbe:	91 30 00 ff 	movh.a %a15,61443
80008bc2:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80008bc6:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80008bc8:	7b f0 cb 24 	movh %d2,19647
80008bcc:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80008bd0:	6f 3f 1e 80 	jnz.t %d15,3,80008c0c <IfxScuCcu_getPllErayVcoFrequency+0x4e>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008bd4:	91 30 00 ff 	movh.a %a15,61443
80008bd8:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008bdc:	4c f0       	ld.w %d15,[%a15]0
80008bde:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008be2:	ee 16       	jnz %d15,80008c0e <IfxScuCcu_getPllErayVcoFrequency+0x50>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80008be4:	91 30 00 ff 	movh.a %a15,61443
80008be8:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80008bec:	48 03       	ld.w %d3,[%a15]0
80008bee:	4c f0       	ld.w %d15,[%a15]0
80008bf0:	37 03 e5 34 	extr.u %d3,%d3,9,5
80008bf4:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80008bf8:	c2 13       	add %d3,1
80008bfa:	4b 03 41 31 	itof %d3,%d3
80008bfe:	c2 1f       	add %d15,1
80008c00:	4b 32 41 20 	mul.f %d2,%d2,%d3
80008c04:	4b 0f 41 f1 	itof %d15,%d15
80008c08:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80008c0c:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008c0e:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008c10:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008c12:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008c16:	df 1f e7 ff 	jne %d15,1,80008be4 <IfxScuCcu_getPllErayVcoFrequency+0x26>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008c1a:	91 00 00 f7 	movh.a %a15,28672
80008c1e:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008c22:	4b 02 61 21 	utof %d2,%d2
80008c26:	3c df       	j 80008be4 <IfxScuCcu_getPllErayVcoFrequency+0x26>

80008c28 <IfxScuCcu_getPllFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008c28:	91 30 00 ff 	movh.a %a15,61443
80008c2c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008c30:	48 02       	ld.w %d2,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80008c32:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008c36:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80008c3a:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008c3e:	df 02 22 80 	jne %d2,0,80008c82 <IfxScuCcu_getPllFrequency+0x5a>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008c42:	91 30 00 ff 	movh.a %a15,61443
80008c46:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008c4a:	48 52       	ld.w %d2,[%a15]20
80008c4c:	6f 02 2e 80 	jnz.t %d2,0,80008ca8 <IfxScuCcu_getPllFrequency+0x80>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008c50:	48 52       	ld.w %d2,[%a15]20
80008c52:	6f 32 34 80 	jnz.t %d2,3,80008cba <IfxScuCcu_getPllFrequency+0x92>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008c56:	48 62       	ld.w %d2,[%a15]24
80008c58:	48 73       	ld.w %d3,[%a15]28
80008c5a:	37 02 e7 24 	extr.u %d2,%d2,9,7
80008c5e:	8f f3 07 41 	and %d4,%d3,127
80008c62:	48 63       	ld.w %d3,[%a15]24
80008c64:	c2 12       	add %d2,1
80008c66:	37 03 64 3c 	extr.u %d3,%d3,24,4
80008c6a:	4b 02 41 21 	itof %d2,%d2
80008c6e:	c2 13       	add %d3,1
80008c70:	03 34 0a 33 	madd %d3,%d3,%d4,%d3
80008c74:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
80008c78:	4b 03 41 31 	itof %d3,%d3
80008c7c:	4b 3f 51 20 	div.f %d2,%d15,%d3
    }

    return freq;
}
80008c80:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008c82:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008c84:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008c86:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008c8a:	df 12 dc ff 	jne %d2,1,80008c42 <IfxScuCcu_getPllFrequency+0x1a>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008c8e:	91 00 00 f7 	movh.a %a15,28672
80008c92:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008c96:	91 30 00 ff 	movh.a %a15,61443
80008c9a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008c9e:	4b 02 61 f1 	utof %d15,%d2
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008ca2:	48 52       	ld.w %d2,[%a15]20
80008ca4:	6f 02 d6 7f 	jz.t %d2,0,80008c50 <IfxScuCcu_getPllFrequency+0x28>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008ca8:	48 72       	ld.w %d2,[%a15]28
80008caa:	37 02 67 28 	extr.u %d2,%d2,16,7
80008cae:	c2 12       	add %d2,1
80008cb0:	4b 02 41 21 	itof %d2,%d2
80008cb4:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008cb8:	00 90       	ret 
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008cba:	48 72       	ld.w %d2,[%a15]28
80008cbc:	8f f2 07 21 	and %d2,%d2,127
80008cc0:	c2 12       	add %d2,1
80008cc2:	4b 02 41 f1 	itof %d15,%d2
80008cc6:	7b f0 cb 24 	movh %d2,19647
80008cca:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008cce:	4b f2 51 20 	div.f %d2,%d2,%d15
80008cd2:	00 90       	ret 

80008cd4 <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008cd4:	91 30 00 ff 	movh.a %a15,61443
80008cd8:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008cdc:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80008cde:	7b f0 cb 24 	movh %d2,19647
80008ce2:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80008ce6:	6f 3f 1e 80 	jnz.t %d15,3,80008d22 <IfxScuCcu_getPllVcoFrequency+0x4e>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008cea:	91 30 00 ff 	movh.a %a15,61443
80008cee:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008cf2:	4c f0       	ld.w %d15,[%a15]0
80008cf4:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008cf8:	ee 16       	jnz %d15,80008d24 <IfxScuCcu_getPllVcoFrequency+0x50>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80008cfa:	91 30 00 ff 	movh.a %a15,61443
80008cfe:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008d02:	48 03       	ld.w %d3,[%a15]0
80008d04:	4c f0       	ld.w %d15,[%a15]0
80008d06:	37 03 e7 34 	extr.u %d3,%d3,9,7
80008d0a:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80008d0e:	c2 13       	add %d3,1
80008d10:	4b 03 41 31 	itof %d3,%d3
80008d14:	c2 1f       	add %d15,1
80008d16:	4b 32 41 20 	mul.f %d2,%d2,%d3
80008d1a:	4b 0f 41 f1 	itof %d15,%d15
80008d1e:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80008d22:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008d24:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008d26:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008d28:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008d2c:	df 1f e7 ff 	jne %d15,1,80008cfa <IfxScuCcu_getPllVcoFrequency+0x26>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008d30:	91 00 00 f7 	movh.a %a15,28672
80008d34:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008d38:	4b 02 61 21 	utof %d2,%d2
80008d3c:	3c df       	j 80008cfa <IfxScuCcu_getPllVcoFrequency+0x26>

80008d3e <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008d3e:	91 30 00 ff 	movh.a %a15,61443
80008d42:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008d46:	4c f0       	ld.w %d15,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008d48:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008d4c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008d50:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008d54:	6e 2a       	jz %d15,80008da8 <IfxScuCcu_getSourceFrequency+0x6a>
80008d56:	df 1f 2a 80 	jne %d15,1,80008daa <IfxScuCcu_getSourceFrequency+0x6c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008d5a:	91 30 00 ff 	movh.a %a15,61443
80008d5e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008d62:	4c f0       	ld.w %d15,[%a15]0
80008d64:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008d68:	ee 23       	jnz %d15,80008dae <IfxScuCcu_getSourceFrequency+0x70>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008d6a:	91 30 00 ff 	movh.a %a15,61443
80008d6e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008d72:	4c f5       	ld.w %d15,[%a15]20
80008d74:	6f 0f 2a 80 	jnz.t %d15,0,80008dc8 <IfxScuCcu_getSourceFrequency+0x8a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008d78:	4c f5       	ld.w %d15,[%a15]20
80008d7a:	6f 3f 30 80 	jnz.t %d15,3,80008dda <IfxScuCcu_getSourceFrequency+0x9c>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008d7e:	48 64       	ld.w %d4,[%a15]24
80008d80:	4c f7       	ld.w %d15,[%a15]28
80008d82:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008d86:	8f ff 07 31 	and %d3,%d15,127
80008d8a:	4c f6       	ld.w %d15,[%a15]24
80008d8c:	c2 14       	add %d4,1
80008d8e:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80008d92:	4b 04 41 41 	itof %d4,%d4
80008d96:	c2 1f       	add %d15,1
80008d98:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80008d9c:	4b 42 41 20 	mul.f %d2,%d2,%d4
80008da0:	4b 0f 41 f1 	itof %d15,%d15
80008da4:	4b f2 51 20 	div.f %d2,%d2,%d15
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
80008da8:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008daa:	82 02       	mov %d2,0
80008dac:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008dae:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008db0:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008db2:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80008db6:	df 1f da ff 	jne %d15,1,80008d6a <IfxScuCcu_getSourceFrequency+0x2c>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008dba:	91 00 00 f7 	movh.a %a15,28672
80008dbe:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008dc2:	4b 02 61 21 	utof %d2,%d2
80008dc6:	3c d2       	j 80008d6a <IfxScuCcu_getSourceFrequency+0x2c>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008dc8:	4c f7       	ld.w %d15,[%a15]28
80008dca:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80008dce:	c2 1f       	add %d15,1
80008dd0:	4b 0f 41 f1 	itof %d15,%d15
80008dd4:	4b f2 51 20 	div.f %d2,%d2,%d15
80008dd8:	00 90       	ret 
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008dda:	48 72       	ld.w %d2,[%a15]28
80008ddc:	8f f2 07 21 	and %d2,%d2,127
80008de0:	c2 12       	add %d2,1
80008de2:	4b 02 41 f1 	itof %d15,%d2
80008de6:	7b f0 cb 24 	movh %d2,19647
80008dea:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008dee:	4b f2 51 20 	div.f %d2,%d2,%d15
80008df2:	00 90       	ret 

80008df4 <IfxScuCcu_getSpbFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008df4:	91 30 00 ff 	movh.a %a15,61443
80008df8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008dfc:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008dfe:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008e02:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008e06:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008e0a:	df 02 2c 00 	jeq %d2,0,80008e62 <IfxScuCcu_getSpbFrequency+0x6e>
80008e0e:	df 12 4c 80 	jne %d2,1,80008ea6 <IfxScuCcu_getSpbFrequency+0xb2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008e12:	91 30 00 ff 	movh.a %a15,61443
80008e16:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008e1a:	48 02       	ld.w %d2,[%a15]0
80008e1c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008e20:	df 02 6c 80 	jne %d2,0,80008ef8 <IfxScuCcu_getSpbFrequency+0x104>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008e24:	91 30 00 ff 	movh.a %a15,61443
80008e28:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008e2c:	48 52       	ld.w %d2,[%a15]20
80008e2e:	6f 02 72 80 	jnz.t %d2,0,80008f12 <IfxScuCcu_getSpbFrequency+0x11e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008e32:	48 52       	ld.w %d2,[%a15]20
80008e34:	6f 32 78 80 	jnz.t %d2,3,80008f24 <IfxScuCcu_getSpbFrequency+0x130>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008e38:	48 64       	ld.w %d4,[%a15]24
80008e3a:	48 72       	ld.w %d2,[%a15]28
80008e3c:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008e40:	8f f2 07 31 	and %d3,%d2,127
80008e44:	48 62       	ld.w %d2,[%a15]24
80008e46:	c2 14       	add %d4,1
80008e48:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008e4c:	4b 04 41 41 	itof %d4,%d4
80008e50:	c2 12       	add %d2,1
80008e52:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80008e56:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
80008e5a:	4b 02 41 21 	itof %d2,%d2
80008e5e:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008e62:	91 30 00 ff 	movh.a %a15,61443
80008e66:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008e6a:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0f;
80008e6c:	82 02       	mov %d2,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008e6e:	37 03 64 36 	extr.u %d3,%d3,12,4
80008e72:	ff 53 19 80 	jge.u %d3,5,80008ea4 <IfxScuCcu_getSpbFrequency+0xb0>
80008e76:	91 10 00 f8 	movh.a %a15,32769
80008e7a:	d9 ff c4 a8 	lea %a15,[%a15]-29052 <80008e84 <IfxScuCcu_getSpbFrequency+0x90>>
80008e7e:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80008e82:	dc 0f       	ji %a15
80008e84:	1d 00 1a 00 	j 80008eb8 <IfxScuCcu_getSpbFrequency+0xc4>
80008e88:	1d 00 2a 00 	j 80008edc <IfxScuCcu_getSpbFrequency+0xe8>
80008e8c:	1d 00 2f 00 	j 80008eea <IfxScuCcu_getSpbFrequency+0xf6>
80008e90:	1d 00 0d 00 	j 80008eaa <IfxScuCcu_getSpbFrequency+0xb6>
80008e94:	1d 00 02 00 	j 80008e98 <IfxScuCcu_getSpbFrequency+0xa4>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
80008e98:	7b 90 b8 23 	movh %d2,15241
80008e9c:	1b 92 88 28 	addi %d2,%d2,-30583
80008ea0:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        spbFrequency = 0.0f;
        break;
    }

    return spbFrequency;
}
80008ea4:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008ea6:	82 0f       	mov %d15,0
80008ea8:	3c dd       	j 80008e62 <IfxScuCcu_getSpbFrequency+0x6e>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
80008eaa:	7b 90 c0 23 	movh %d2,15369
80008eae:	1b 92 88 28 	addi %d2,%d2,-30583
80008eb2:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008eb6:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80008eb8:	91 30 00 ff 	movh.a %a15,61443
80008ebc:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008ec0:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0f;
80008ec2:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80008ec4:	37 03 64 38 	extr.u %d3,%d3,16,4
80008ec8:	df 03 ee 7f 	jeq %d3,0,80008ea4 <IfxScuCcu_getSpbFrequency+0xb0>
        {
            spbFrequency = 0.0f;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80008ecc:	48 02       	ld.w %d2,[%a15]0
80008ece:	37 02 64 28 	extr.u %d2,%d2,16,4
80008ed2:	4b 02 41 21 	itof %d2,%d2
80008ed6:	4b 2f 51 20 	div.f %d2,%d15,%d2
80008eda:	00 90       	ret 
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80008edc:	7b 90 d0 23 	movh %d2,15625
80008ee0:	1b 92 88 28 	addi %d2,%d2,-30583
80008ee4:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008ee8:	00 90       	ret 
    case 2:
        spbFrequency = sourceFrequency / 60;
80008eea:	7b 90 c8 23 	movh %d2,15497
80008eee:	1b 92 88 28 	addi %d2,%d2,-30583
80008ef2:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008ef6:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008ef8:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80008efa:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80008efc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008f00:	df 12 92 ff 	jne %d2,1,80008e24 <IfxScuCcu_getSpbFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80008f04:	91 00 00 f7 	movh.a %a15,28672
80008f08:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80008f0c:	4b 0f 61 f1 	utof %d15,%d15
80008f10:	3c 8a       	j 80008e24 <IfxScuCcu_getSpbFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80008f12:	48 72       	ld.w %d2,[%a15]28
80008f14:	37 02 67 28 	extr.u %d2,%d2,16,7
80008f18:	c2 12       	add %d2,1
80008f1a:	4b 02 41 21 	itof %d2,%d2
80008f1e:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80008f22:	3c a0       	j 80008e62 <IfxScuCcu_getSpbFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80008f24:	4c f7       	ld.w %d15,[%a15]28
80008f26:	7b f0 cb 24 	movh %d2,19647
80008f2a:	16 7f       	and %d15,127
80008f2c:	c2 1f       	add %d15,1
80008f2e:	4b 0f 41 f1 	itof %d15,%d15
80008f32:	1b 02 c2 2b 	addi %d2,%d2,-17376
80008f36:	4b f2 51 f0 	div.f %d15,%d2,%d15
80008f3a:	3c 94       	j 80008e62 <IfxScuCcu_getSpbFrequency+0x6e>

80008f3c <IfxScuCcu_getSriFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008f3c:	91 30 00 ff 	movh.a %a15,61443
80008f40:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008f44:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008f46:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008f4a:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80008f4e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80008f52:	df 02 2c 00 	jeq %d2,0,80008faa <IfxScuCcu_getSriFrequency+0x6e>
80008f56:	df 12 4c 80 	jne %d2,1,80008fee <IfxScuCcu_getSriFrequency+0xb2>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80008f5a:	91 30 00 ff 	movh.a %a15,61443
80008f5e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008f62:	48 02       	ld.w %d2,[%a15]0
80008f64:	37 02 62 2e 	extr.u %d2,%d2,28,2
80008f68:	df 02 6c 80 	jne %d2,0,80009040 <IfxScuCcu_getSriFrequency+0x104>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80008f6c:	91 30 00 ff 	movh.a %a15,61443
80008f70:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80008f74:	48 52       	ld.w %d2,[%a15]20
80008f76:	6f 02 72 80 	jnz.t %d2,0,8000905a <IfxScuCcu_getSriFrequency+0x11e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80008f7a:	48 52       	ld.w %d2,[%a15]20
80008f7c:	6f 32 78 80 	jnz.t %d2,3,8000906c <IfxScuCcu_getSriFrequency+0x130>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80008f80:	48 64       	ld.w %d4,[%a15]24
80008f82:	48 72       	ld.w %d2,[%a15]28
80008f84:	37 04 e7 44 	extr.u %d4,%d4,9,7
80008f88:	8f f2 07 31 	and %d3,%d2,127
80008f8c:	48 62       	ld.w %d2,[%a15]24
80008f8e:	c2 14       	add %d4,1
80008f90:	37 02 64 2c 	extr.u %d2,%d2,24,4
80008f94:	4b 04 41 41 	itof %d4,%d4
80008f98:	c2 12       	add %d2,1
80008f9a:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80008f9e:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
80008fa2:	4b 02 41 21 	itof %d2,%d2
80008fa6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008faa:	91 30 00 ff 	movh.a %a15,61443
80008fae:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008fb2:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
80008fb4:	82 02       	mov %d2,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80008fb6:	37 03 64 36 	extr.u %d3,%d3,12,4
80008fba:	ff 53 19 80 	jge.u %d3,5,80008fec <IfxScuCcu_getSriFrequency+0xb0>
80008fbe:	91 10 00 f8 	movh.a %a15,32769
80008fc2:	d9 ff cc f8 	lea %a15,[%a15]-28724 <80008fcc <IfxScuCcu_getSriFrequency+0x90>>
80008fc6:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80008fca:	dc 0f       	ji %a15
80008fcc:	1d 00 1a 00 	j 80009000 <IfxScuCcu_getSriFrequency+0xc4>
80008fd0:	1d 00 2a 00 	j 80009024 <IfxScuCcu_getSriFrequency+0xe8>
80008fd4:	1d 00 2f 00 	j 80009032 <IfxScuCcu_getSriFrequency+0xf6>
80008fd8:	1d 00 0d 00 	j 80008ff2 <IfxScuCcu_getSriFrequency+0xb6>
80008fdc:	1d 00 02 00 	j 80008fe0 <IfxScuCcu_getSriFrequency+0xa4>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
80008fe0:	7b 90 b8 23 	movh %d2,15241
80008fe4:	1b 92 88 28 	addi %d2,%d2,-30583
80008fe8:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        sriFrequency = 0.0f;
        break;
    }

    return sriFrequency;
}
80008fec:	00 90       	ret 
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80008fee:	82 0f       	mov %d15,0
80008ff0:	3c dd       	j 80008faa <IfxScuCcu_getSriFrequency+0x6e>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80008ff2:	7b 90 c0 23 	movh %d2,15369
80008ff6:	1b 92 88 28 	addi %d2,%d2,-30583
80008ffa:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80008ffe:	00 90       	ret 

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80009000:	91 30 00 ff 	movh.a %a15,61443
80009004:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009008:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0f;
8000900a:	82 02       	mov %d2,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
8000900c:	37 03 64 34 	extr.u %d3,%d3,8,4
80009010:	df 03 ee 7f 	jeq %d3,0,80008fec <IfxScuCcu_getSriFrequency+0xb0>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80009014:	48 02       	ld.w %d2,[%a15]0
80009016:	37 02 64 24 	extr.u %d2,%d2,8,4
8000901a:	4b 02 41 21 	itof %d2,%d2
8000901e:	4b 2f 51 20 	div.f %d2,%d15,%d2
80009022:	00 90       	ret 
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
80009024:	7b 90 d0 23 	movh %d2,15625
80009028:	1b 92 88 28 	addi %d2,%d2,-30583
8000902c:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
80009030:	00 90       	ret 
    case 2:
        sriFrequency = sourceFrequency / 60;
80009032:	7b 90 c8 23 	movh %d2,15497
80009036:	1b 92 88 28 	addi %d2,%d2,-30583
8000903a:	4b 2f 41 20 	mul.f %d2,%d15,%d2
        break;
8000903e:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009040:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009042:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009044:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009048:	df 12 92 ff 	jne %d2,1,80008f6c <IfxScuCcu_getSriFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
8000904c:	91 00 00 f7 	movh.a %a15,28672
80009050:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009054:	4b 0f 61 f1 	utof %d15,%d15
80009058:	3c 8a       	j 80008f6c <IfxScuCcu_getSriFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
8000905a:	48 72       	ld.w %d2,[%a15]28
8000905c:	37 02 67 28 	extr.u %d2,%d2,16,7
80009060:	c2 12       	add %d2,1
80009062:	4b 02 41 21 	itof %d2,%d2
80009066:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000906a:	3c a0       	j 80008faa <IfxScuCcu_getSriFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000906c:	4c f7       	ld.w %d15,[%a15]28
8000906e:	7b f0 cb 24 	movh %d2,19647
80009072:	16 7f       	and %d15,127
80009074:	c2 1f       	add %d15,1
80009076:	4b 0f 41 f1 	itof %d15,%d15
8000907a:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000907e:	4b f2 51 f0 	div.f %d15,%d2,%d15
80009082:	3c 94       	j 80008faa <IfxScuCcu_getSriFrequency+0x6e>

80009084 <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80009084:	19 42 10 10 	ld.w %d2,[%a4]80
80009088:	91 00 00 d7 	movh.a %a13,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
8000908c:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
8000908e:	59 d2 00 b1 	st.w [%a13]4800 <700012c0 <IfxScuCcu_xtalFrequency>>,%d2

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
80009092:	6d 00 3d 0a 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>
80009096:	02 2a       	mov %d10,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80009098:	6d 00 58 0a 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000909c:	02 a4       	mov %d4,%d10
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
8000909e:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800090a0:	6d 00 38 09 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800090a4:	91 30 00 ff 	movh.a %a15,61443
800090a8:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800090ac:	48 0c       	ld.w %d12,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
800090ae:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800090b0:	02 a4       	mov %d4,%d10

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800090b2:	96 08       	or %d15,8
800090b4:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
800090b6:	6d 00 71 0b 	call 8000a798 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800090ba:	02 84       	mov %d4,%d8
800090bc:	6d 00 45 09 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800090c0:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
800090c4:	91 30 00 2f 	movh.a %a2,61443
800090c8:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090cc:	4c 20       	ld.w %d15,[%a2]0
800090ce:	91 30 00 ff 	movh.a %a15,61443
800090d2:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800090d6:	bf 0f fb 7f 	jlt %d15,0,800090cc <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800090da:	4c f0       	ld.w %d15,[%a15]0
        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON1.B.LCK != 0U)
800090dc:	91 30 00 2f 	movh.a %a2,61443
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800090e0:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON1.B.LCK != 0U)
800090e4:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800090e8:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
800090ea:	4c f0       	ld.w %d15,[%a15]0
800090ec:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800090f0:	68 0f       	st.w [%a15]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
800090f2:	91 30 00 ff 	movh.a %a15,61443
800090f6:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800090fa:	4c f0       	ld.w %d15,[%a15]0
800090fc:	96 10       	or %d15,16
800090fe:	68 0f       	st.w [%a15]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON1.B.LCK != 0U)
80009100:	4c 20       	ld.w %d15,[%a2]0
80009102:	91 30 00 ff 	movh.a %a15,61443
80009106:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000910a:	bf 0f fb 7f 	jlt %d15,0,80009100 <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon1 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
8000910e:	4c f0       	ld.w %d15,[%a15]0
80009110:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
80009114:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
80009116:	4c f0       	ld.w %d15,[%a15]0
80009118:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000911c:	68 0f       	st.w [%a15]0,%d15
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
8000911e:	91 30 00 ff 	movh.a %a15,61443
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
80009122:	6d 00 f5 09 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80009126:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
8000912a:	4c f0       	ld.w %d15,[%a15]0
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
8000912c:	02 29       	mov %d9,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
8000912e:	8f 0f c6 f1 	andn %d15,%d15,96
80009132:	68 0f       	st.w [%a15]0,%d15

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80009134:	19 d6 00 b1 	ld.w %d6,[%a13]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009138:	7b 00 b6 f6 	movh %d15,27488
8000913c:	1b bf a6 fc 	addi %d15,%d15,-13717
80009140:	73 f6 68 60 	mul.u %e6,%d6,%d15
80009144:	48 02       	ld.w %d2,[%a15]0

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80009146:	40 f2       	mov.aa %a2,%a15

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80009148:	8f c7 1e f0 	sh %d15,%d7,-20
8000914c:	c2 ff       	add %d15,-1
8000914e:	37 f2 05 f8 	insert %d15,%d2,%d15,16,5
80009152:	68 0f       	st.w [%a15]0,%d15

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
80009154:	4c f0       	ld.w %d15,[%a15]0
80009156:	96 04       	or %d15,4
80009158:	68 0f       	st.w [%a15]0,%d15

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
8000915a:	c5 0f 3f 90 	lea %a15,27f <_.+0x27e>
8000915e:	4c 20       	ld.w %d15,[%a2]0
80009160:	2e 14       	jz.t %d15,1,80009168 <IfxScuCcu_init+0xe4>
80009162:	4c 20       	ld.w %d15,[%a2]0
80009164:	6f 8f 1d 80 	jnz.t %d15,8,8000919e <IfxScuCcu_init+0x11a>
80009168:	fc fb       	loop %a15,8000915e <IfxScuCcu_init+0xda>
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000916a:	91 30 00 ff 	movh.a %a15,61443
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
8000916e:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80009170:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
80009174:	6d 00 ce 08 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80009178:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
8000917a:	02 94       	mov %d4,%d9
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000917c:	96 08       	or %d15,8
8000917e:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
80009180:	91 30 00 ff 	movh.a %a15,61443
80009184:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009188:	4c f0       	ld.w %d15,[%a15]0
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
8000918a:	82 19       	mov %d9,1

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
8000918c:	96 08       	or %d15,8
8000918e:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinitPw);
80009190:	6d 00 04 0b 	call 8000a798 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009194:	02 84       	mov %d4,%d8
80009196:	6d 00 1c 0b 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
8000919a:	1d 00 46 01 	j 80009426 <IfxScuCcu_init+0x3a2>
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000919e:	91 30 00 ff 	movh.a %a15,61443
800091a2:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800091a6:	02 94       	mov %d4,%d9
800091a8:	6d 00 b4 08 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800091ac:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
800091ae:	02 94       	mov %d4,%d9
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800091b0:	96 08       	or %d15,8
800091b2:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800091b4:	91 30 00 ff 	movh.a %a15,61443
800091b8:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800091bc:	4c f0       	ld.w %d15,[%a15]0
800091be:	96 08       	or %d15,8
800091c0:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinitPw);
800091c2:	6d 00 eb 0a 	call 8000a798 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800091c6:	02 84       	mov %d4,%d8
800091c8:	6d 00 03 0b 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800091cc:	02 84       	mov %d4,%d8
800091ce:	6d 00 bc 08 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
800091d2:	91 30 00 ff 	movh.a %a15,61443
800091d6:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800091da:	4c f0       	ld.w %d15,[%a15]0
800091dc:	6f 5f ff 7f 	jz.t %d15,5,800091da <IfxScuCcu_init+0x156>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800091e0:	91 30 00 ff 	movh.a %a15,61443
800091e4:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
800091e8:	48 02       	ld.w %d2,[%a15]0
800091ea:	0c ca       	ld.bu %d15,[%a12]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800091ec:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800091f0:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800091f4:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800091f8:	68 0f       	st.w [%a15]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
800091fa:	91 30 00 ff 	movh.a %a15,61443
800091fe:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009202:	48 02       	ld.w %d2,[%a15]0
80009204:	0c c8       	ld.bu %d15,[%a12]8
80009206:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
8000920a:	68 0f       	st.w [%a15]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
8000920c:	48 02       	ld.w %d2,[%a15]0
8000920e:	0c c9       	ld.bu %d15,[%a12]9
80009210:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
80009214:	68 0f       	st.w [%a15]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
80009216:	4c f0       	ld.w %d15,[%a15]0
80009218:	96 40       	or %d15,64
8000921a:	68 0f       	st.w [%a15]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
8000921c:	4c f0       	ld.w %d15,[%a15]0
8000921e:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80009222:	68 0f       	st.w [%a15]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
80009224:	4c f0       	ld.w %d15,[%a15]0
80009226:	96 20       	or %d15,32
80009228:	68 0f       	st.w [%a15]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
8000922a:	4c f0       	ld.w %d15,[%a15]0
8000922c:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80009230:	68 0f       	st.w [%a15]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
80009232:	4c f0       	ld.w %d15,[%a15]0
80009234:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80009238:	68 0f       	st.w [%a15]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000923a:	6d ff 81 f5 	call 80007d3c <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
8000923e:	91 30 00 ff 	movh.a %a15,61443
80009242:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009246:	4c f0       	ld.w %d15,[%a15]0
80009248:	6f 2f ff 7f 	jz.t %d15,2,80009246 <IfxScuCcu_init+0x1c2>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
8000924c:	91 30 00 ff 	movh.a %a15,61443
80009250:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009254:	4c f0       	ld.w %d15,[%a15]0
80009256:	8f 1f c0 f1 	andn %d15,%d15,1
8000925a:	68 0f       	st.w [%a15]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
8000925c:	91 30 00 ff 	movh.a %a15,61443
80009260:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009264:	4c f0       	ld.w %d15,[%a15]0
80009266:	91 30 00 2f 	movh.a %a2,61443
8000926a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000926e:	bf 0f fb 7f 	jlt %d15,0,80009264 <IfxScuCcu_init+0x1e0>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
80009272:	4c 20       	ld.w %d15,[%a2]0

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
80009274:	40 2f       	mov.aa %a15,%a2
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
80009276:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
8000927a:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
8000927c:	4c f0       	ld.w %d15,[%a15]0
8000927e:	91 30 00 df 	movh.a %a13,61443
80009282:	d9 dd 30 06 	lea %a13,[%a13]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009286:	bf 0f fb 7f 	jlt %d15,0,8000927c <IfxScuCcu_init+0x1f8>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
8000928a:	19 c4 0c 00 	ld.w %d4,[%a12]12
8000928e:	6d ff 57 f5 	call 80007d3c <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80009292:	4c c5       	ld.w %d15,[%a12]20
80009294:	54 d2       	ld.w %d2,[%a13]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80009296:	19 c3 10 00 	ld.w %d3,[%a12]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
8000929a:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
8000929e:	26 3f       	and %d15,%d3
800092a0:	a6 2f       	or %d15,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
800092a2:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
800092a6:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800092aa:	91 30 00 ff 	movh.a %a15,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
800092ae:	6c d0       	st.w [%a13]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800092b0:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800092b4:	4c f0       	ld.w %d15,[%a15]0
800092b6:	91 30 00 2f 	movh.a %a2,61443
800092ba:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800092be:	bf 0f fb 7f 	jlt %d15,0,800092b4 <IfxScuCcu_init+0x230>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
800092c2:	4c c7       	ld.w %d15,[%a12]28
800092c4:	54 22       	ld.w %d2,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
800092c6:	19 c3 18 00 	ld.w %d3,[%a12]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
800092ca:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
800092ce:	26 3f       	and %d15,%d3
800092d0:	a6 2f       	or %d15,%d2
                        ccucon1.B.INSEL = 1;
800092d2:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
800092d6:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
800092da:	91 30 00 ff 	movh.a %a15,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
800092de:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
800092e0:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
800092e4:	4c f0       	ld.w %d15,[%a15]0
800092e6:	91 30 00 2f 	movh.a %a2,61443
800092ea:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
800092ee:	bf 0f fb 7f 	jlt %d15,0,800092e4 <IfxScuCcu_init+0x260>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
800092f2:	4c c9       	ld.w %d15,[%a12]36
800092f4:	54 22       	ld.w %d2,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
800092f6:	19 c3 20 00 	ld.w %d3,[%a12]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
800092fa:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
800092fe:	26 3f       	and %d15,%d3
80009300:	a6 2f       	or %d15,%d2
                        ccucon2.B.UP = 1;
80009302:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
80009306:	91 30 00 ff 	movh.a %a15,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
8000930a:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
8000930c:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80009310:	4c f0       	ld.w %d15,[%a15]0
80009312:	91 30 00 2f 	movh.a %a2,61443
80009316:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
8000931a:	bf 0f fb 7f 	jlt %d15,0,80009310 <IfxScuCcu_init+0x28c>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
8000931e:	54 22       	ld.w %d2,[%a2]
80009320:	4c cb       	ld.w %d15,[%a12]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80009322:	19 c3 28 00 	ld.w %d3,[%a12]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80009326:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000932a:	26 3f       	and %d15,%d3
8000932c:	a6 2f       	or %d15,%d2
                        ccucon5.B.UP = 1;
8000932e:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80009332:	91 30 00 ff 	movh.a %a15,61443
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
80009336:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80009338:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
8000933c:	48 02       	ld.w %d2,[%a15]0
8000933e:	4c cd       	ld.w %d15,[%a12]52
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80009340:	19 c3 30 00 	ld.w %d3,[%a12]48 <f0030000 <_SMALL_DATA4_+0x40028000>>
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80009344:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80009348:	26 3f       	and %d15,%d3
8000934a:	a6 2f       	or %d15,%d2
                        SCU_CCUCON6 = ccucon6;
8000934c:	68 0f       	st.w [%a15]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
8000934e:	91 30 00 ff 	movh.a %a15,61443
80009352:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
80009356:	48 02       	ld.w %d2,[%a15]0
80009358:	4c cf       	ld.w %d15,[%a12]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
8000935a:	19 c3 38 00 	ld.w %d3,[%a12]56 <f0030000 <_SMALL_DATA4_+0x40028000>>
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
8000935e:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
80009362:	26 3f       	and %d15,%d3
80009364:	a6 2f       	or %d15,%d2
                        SCU_CCUCON7 = ccucon7;
80009366:	68 0f       	st.w [%a15]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
80009368:	91 30 00 ff 	movh.a %a15,61443
8000936c:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80009370:	48 02       	ld.w %d2,[%a15]0
80009372:	19 cf 04 10 	ld.w %d15,[%a12]68 <f0030000 <_SMALL_DATA4_+0x40028000>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
80009376:	19 c3 00 10 	ld.w %d3,[%a12]64 <f0030000 <_SMALL_DATA4_+0x40028000>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
8000937a:	0f f2 e0 20 	andn %d2,%d2,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
8000937e:	26 3f       	and %d15,%d3
80009380:	a6 2f       	or %d15,%d2
                        SCU_CCUCON8 = ccucon8;
80009382:	68 0f       	st.w [%a15]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009384:	02 84       	mov %d4,%d8
80009386:	6d 00 24 0a 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
8000938a:	91 00 80 ff 	movh.a %a15,63488
8000938e:	d9 ff 14 02 	lea %a15,[%a15]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
80009392:	48 02       	ld.w %d2,[%a15]0
80009394:	19 cf 0c 10 	ld.w %d15,[%a12]76 <f8000000 <_SMALL_DATA4_+0x47ff8000>>

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80009398:	19 c3 08 10 	ld.w %d3,[%a12]72 <f8000000 <_SMALL_DATA4_+0x47ff8000>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
8000939c:	0f f2 e0 20 	andn %d2,%d2,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800093a0:	02 a4       	mov %d4,%d10
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800093a2:	26 3f       	and %d15,%d3
800093a4:	a6 2f       	or %d15,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800093a6:	6d 00 b5 07 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
800093aa:	68 0f       	st.w [%a15]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
800093ac:	02 a4       	mov %d4,%d10
800093ae:	6d 00 f5 09 	call 8000a798 <IfxScuWdt_setCpuEndinit>
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800093b2:	0c c0       	ld.bu %d15,[%a12]0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800093b4:	91 30 00 ff 	movh.a %a15,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800093b8:	91 30 00 df 	movh.a %a13,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800093bc:	82 09       	mov %d9,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800093be:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800093c2:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800093c6:	6e 2f       	jz %d15,80009424 <IfxScuCcu_init+0x3a0>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800093c8:	02 84       	mov %d4,%d8
800093ca:	8f f9 0f b1 	and %d11,%d9,255
800093ce:	6d 00 bc 07 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800093d2:	4c f0       	ld.w %d15,[%a15]0
800093d4:	6f 5f ff 7f 	jz.t %d15,5,800093d2 <IfxScuCcu_init+0x34e>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800093d8:	8f f9 0f f1 	and %d15,%d9,255
800093dc:	99 c3 04 00 	ld.a %a3,[%a12]4
800093e0:	53 cf 20 f0 	mul %d15,%d15,12
800093e4:	54 d3       	ld.w %d3,[%a13]
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800093e6:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800093e8:	10 32       	addsc.a %a2,%a3,%d15,0
800093ea:	14 22       	ld.bu %d2,[%a2]
800093ec:	37 23 07 20 	insert %d2,%d3,%d2,0,7
800093f0:	74 d2       	st.w [%a13],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800093f2:	6d 00 ee 09 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
800093f6:	99 c3 04 00 	ld.a %a3,[%a12]4
800093fa:	10 32       	addsc.a %a2,%a3,%d15,0
800093fc:	99 23 08 00 	ld.a %a3,[%a2]8
80009400:	bc 36       	jz.a %a3,8000940c <IfxScuCcu_init+0x388>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
80009402:	2d 03 00 00 	calli %a3
80009406:	99 c3 04 00 	ld.a %a3,[%a12]4
8000940a:	10 32       	addsc.a %a2,%a3,%d15,0
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
8000940c:	19 24 04 00 	ld.w %d4,[%a2]4
80009410:	6d ff 96 f4 	call 80007d3c <IfxScuCcu_wait>
80009414:	1b 1b 00 20 	addi %d2,%d11,1
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80009418:	0c c0       	ld.bu %d15,[%a12]0
8000941a:	8f f2 0f 21 	and %d2,%d2,255
8000941e:	c2 19       	add %d9,1
80009420:	3f f2 d4 ff 	jlt.u %d2,%d15,800093c8 <IfxScuCcu_init+0x344>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
80009424:	82 09       	mov %d9,0
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009426:	02 84       	mov %d4,%d8
80009428:	6d 00 8f 07 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000942c:	91 30 00 ff 	movh.a %a15,61443
80009430:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009434:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009436:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80009438:	8f 0f c4 f1 	andn %d15,%d15,64
8000943c:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000943e:	6d 00 c8 09 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80009442:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80009446:	02 a4       	mov %d4,%d10
        SCU_TRAPCLR.B.SMUT = 1U;
80009448:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000944c:	6d 00 62 07 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80009450:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80009452:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80009454:	96 08       	or %d15,8
80009456:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80009458:	91 30 00 ff 	movh.a %a15,61443
8000945c:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009460:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80009462:	02 a4       	mov %d4,%d10
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80009464:	8f 8f c0 f1 	andn %d15,%d15,8
80009468:	a6 fc       	or %d12,%d15
8000946a:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000946c:	6d 00 96 09 	call 8000a798 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80009470:	02 92       	mov %d2,%d9
80009472:	00 90       	ret 

80009474 <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
80009474:	7b 00 00 28 	movh %d2,32768
80009478:	60 22       	mov.a %a2,%d2
8000947a:	d9 2f 60 80 	lea %a15,[%a2]1568
8000947e:	a0 92       	mov.a %a2,9
80009480:	09 f2 48 01 	ld.d %e2,[%a15+]8
80009484:	89 42 48 01 	st.d [%a4+]8,%e2
80009488:	fc 2c       	loop %a2,80009480 <IfxScuCcu_initConfig+0xc>
8000948a:	44 f2       	ld.w %d2,[%a15+]
8000948c:	64 42       	st.w [%a4+],%d2
8000948e:	00 90       	ret 

80009490 <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
80009490:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80009492:	6d 00 3d 08 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>
80009496:	02 28       	mov %d8,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009498:	6d 00 58 08 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000949c:	02 84       	mov %d4,%d8
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000949e:	02 29       	mov %d9,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800094a0:	6d 00 38 07 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800094a4:	91 30 00 ff 	movh.a %a15,61443
800094a8:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800094ac:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
800094ae:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800094b0:	02 84       	mov %d4,%d8
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800094b2:	96 08       	or %d15,8
800094b4:	68 0f       	st.w [%a15]0,%d15
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800094b6:	37 02 e1 b1 	extr.u %d11,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
800094ba:	6d 00 6f 09 	call 8000a798 <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800094be:	91 30 00 ff 	movh.a %a15,61443
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800094c2:	02 94       	mov %d4,%d9

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800094c4:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800094c8:	6d 00 3f 07 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800094cc:	4c f0       	ld.w %d15,[%a15]0
800094ce:	ef 0f 05 00 	jz.t %d15,16,800094d8 <IfxScuCcu_initErayPll+0x48>
800094d2:	4c f0       	ld.w %d15,[%a15]0
800094d4:	6f 1f a1 00 	jz.t %d15,1,80009616 <IfxScuCcu_initErayPll+0x186>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
800094d8:	91 30 00 ff 	movh.a %a15,61443
800094dc:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800094e0:	4c f0       	ld.w %d15,[%a15]0
800094e2:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800094e6:	68 0f       	st.w [%a15]0,%d15
        SCU_PLLERAYCON0.B.VCOPWD = 0;
800094e8:	4c f0       	ld.w %d15,[%a15]0
800094ea:	8f 2f c0 f1 	andn %d15,%d15,2
800094ee:	68 0f       	st.w [%a15]0,%d15

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
800094f0:	91 30 00 ff 	movh.a %a15,61443
800094f4:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800094f8:	4c f0       	ld.w %d15,[%a15]0
800094fa:	6f 1f ff ff 	jnz.t %d15,1,800094f8 <IfxScuCcu_initErayPll+0x68>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
800094fe:	19 c4 04 00 	ld.w %d4,[%a12]4
80009502:	6d ff 1d f4 	call 80007d3c <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
80009506:	91 30 00 ff 	movh.a %a15,61443
8000950a:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000950e:	4c f0       	ld.w %d15,[%a15]0
80009510:	6f 0f 38 00 	jz.t %d15,0,80009580 <IfxScuCcu_initErayPll+0xf0>

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
80009514:	91 30 00 ff 	movh.a %a15,61443
80009518:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000951c:	4c f0       	ld.w %d15,[%a15]0
8000951e:	6f 5f ff 7f 	jz.t %d15,5,8000951c <IfxScuCcu_initErayPll+0x8c>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
80009522:	91 30 00 ff 	movh.a %a15,61443
80009526:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
8000952a:	48 02       	ld.w %d2,[%a15]0
8000952c:	0c c2       	ld.bu %d15,[%a12]2
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000952e:	02 94       	mov %d4,%d9
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
80009530:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
80009534:	68 0f       	st.w [%a15]0,%d15
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
80009536:	91 30 00 ff 	movh.a %a15,61443
8000953a:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000953e:	48 02       	ld.w %d2,[%a15]0
80009540:	0c c0       	ld.bu %d15,[%a12]0
80009542:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80009546:	68 0f       	st.w [%a15]0,%d15
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
80009548:	48 02       	ld.w %d2,[%a15]0
8000954a:	0c c1       	ld.bu %d15,[%a12]1
8000954c:	37 f2 85 f4 	insert %d15,%d2,%d15,9,5
80009550:	68 0f       	st.w [%a15]0,%d15
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
80009552:	4c f0       	ld.w %d15,[%a15]0
80009554:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80009558:	68 0f       	st.w [%a15]0,%d15
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
8000955a:	4c f0       	ld.w %d15,[%a15]0
8000955c:	96 20       	or %d15,32
8000955e:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009560:	6d 00 37 09 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
80009564:	91 10 00 f0 	movh.a %a15,1
80009568:	91 30 00 2f 	movh.a %a2,61443
8000956c:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80009570:	d9 ff 0e dc 	lea %a15,[%a15]-15538 <c34e <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4e>>
80009574:	4c 20       	ld.w %d15,[%a2]0
80009576:	6f 2f 18 80 	jnz.t %d15,2,800095a6 <IfxScuCcu_initErayPll+0x116>
8000957a:	fc fd       	loop %a15,80009574 <IfxScuCcu_initErayPll+0xe4>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
8000957c:	82 1a       	mov %d10,1
8000957e:	3c 15       	j 800095a8 <IfxScuCcu_initErayPll+0x118>

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
80009580:	4c f0       	ld.w %d15,[%a15]0
80009582:	6f 4f ff 7f 	jz.t %d15,4,80009580 <IfxScuCcu_initErayPll+0xf0>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
80009586:	91 30 00 ff 	movh.a %a15,61443
8000958a:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
8000958e:	4c f0       	ld.w %d15,[%a15]0
80009590:	b7 3f 07 f8 	insert %d15,%d15,3,16,7
80009594:	68 0f       	st.w [%a15]0,%d15

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
80009596:	91 30 00 ff 	movh.a %a15,61443
8000959a:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
8000959e:	4c f0       	ld.w %d15,[%a15]0
800095a0:	96 01       	or %d15,1
800095a2:	68 0f       	st.w [%a15]0,%d15
800095a4:	3c b8       	j 80009514 <IfxScuCcu_initErayPll+0x84>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
800095a6:	82 0a       	mov %d10,0
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
800095a8:	91 30 00 ff 	movh.a %a15,61443
800095ac:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800095b0:	02 94       	mov %d4,%d9
800095b2:	6d 00 ca 06 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
800095b6:	4c f0       	ld.w %d15,[%a15]0
800095b8:	8f 1f c0 f1 	andn %d15,%d15,1
800095bc:	68 0f       	st.w [%a15]0,%d15

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
800095be:	91 30 00 ff 	movh.a %a15,61443
800095c2:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800095c6:	4c f0       	ld.w %d15,[%a15]0
800095c8:	6f 0f ff ff 	jnz.t %d15,0,800095c6 <IfxScuCcu_initErayPll+0x136>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
800095cc:	91 30 00 ff 	movh.a %a15,61443
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800095d0:	02 94       	mov %d4,%d9

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
800095d2:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800095d6:	4c f0       	ld.w %d15,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800095d8:	6d 00 fb 08 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
800095dc:	37 0f 61 f1 	extr.u %d15,%d15,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800095e0:	91 30 00 ff 	movh.a %a15,61443
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800095e4:	02 84       	mov %d4,%d8
        SCU_TRAPCLR.B.SMUT = 1U;
800095e6:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800095ea:	6d 00 93 06 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
800095ee:	ea 1a       	cmovn %d10,%d15,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800095f0:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800095f2:	8f 3b 00 20 	sh %d2,%d11,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800095f6:	96 08       	or %d15,8
800095f8:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800095fa:	91 30 00 ff 	movh.a %a15,61443
800095fe:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009602:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80009604:	02 84       	mov %d4,%d8
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80009606:	8f 8f c0 f1 	andn %d15,%d15,8
8000960a:	a6 2f       	or %d15,%d2
8000960c:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000960e:	6d 00 c5 08 	call 8000a798 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80009612:	02 a2       	mov %d2,%d10
80009614:	00 90       	ret 
        IfxScuWdt_setCpuEndinit(endinit_pw);
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
80009616:	91 30 00 ff 	movh.a %a15,61443
8000961a:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000961e:	4c f0       	ld.w %d15,[%a15]0
80009620:	6f 1f 73 7f 	jz.t %d15,1,80009506 <IfxScuCcu_initErayPll+0x76>
80009624:	1d ff 5a ff 	j 800094d8 <IfxScuCcu_initErayPll+0x48>

80009628 <IfxScuCcu_initErayPllConfig>:
}


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
80009628:	82 0f       	mov %d15,0
8000962a:	2c 40       	st.b [%a4]0,%d15
8000962c:	da 17       	mov %d15,23
8000962e:	2c 41       	st.b [%a4]1,%d15
80009630:	82 5f       	mov %d15,5
80009632:	2c 42       	st.b [%a4]2,%d15
80009634:	82 0f       	mov %d15,0
80009636:	6c 41       	st.w [%a4]4,%d15
80009638:	00 90       	ret 

8000963a <IfxScuCcu_setCpuFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000963a:	91 30 00 ff 	movh.a %a15,61443
8000963e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009642:	4c f0       	ld.w %d15,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009644:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009648:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
8000964c:	02 49       	mov %d9,%d4
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000964e:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009652:	6e 2b       	jz %d15,800096a8 <IfxScuCcu_setCpuFrequency+0x6e>
80009654:	df 1f 91 80 	jne %d15,1,80009776 <IfxScuCcu_setCpuFrequency+0x13c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009658:	91 30 00 ff 	movh.a %a15,61443
8000965c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009660:	4c f0       	ld.w %d15,[%a15]0
80009662:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80009666:	df 0f b4 80 	jne %d15,0,800097ce <IfxScuCcu_setCpuFrequency+0x194>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000966a:	91 30 00 ff 	movh.a %a15,61443
8000966e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80009672:	4c f5       	ld.w %d15,[%a15]20
80009674:	6f 0f bb 80 	jnz.t %d15,0,800097ea <IfxScuCcu_setCpuFrequency+0x1b0>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80009678:	4c f5       	ld.w %d15,[%a15]20
8000967a:	6f 3f c2 80 	jnz.t %d15,3,800097fe <IfxScuCcu_setCpuFrequency+0x1c4>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000967e:	48 64       	ld.w %d4,[%a15]24
80009680:	4c f7       	ld.w %d15,[%a15]28
80009682:	37 04 e7 44 	extr.u %d4,%d4,9,7
80009686:	8f ff 07 31 	and %d3,%d15,127
8000968a:	4c f6       	ld.w %d15,[%a15]24
8000968c:	c2 14       	add %d4,1
8000968e:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80009692:	4b 04 41 41 	itof %d4,%d4
80009696:	c2 1f       	add %d15,1
80009698:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
8000969c:	4b 42 41 20 	mul.f %d2,%d2,%d4
800096a0:	4b 0f 41 f1 	itof %d15,%d15
800096a4:	4b f2 51 20 	div.f %d2,%d2,%d15
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800096a8:	91 30 00 ff 	movh.a %a15,61443
800096ac:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800096b0:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0f;
800096b2:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800096b4:	37 03 64 36 	extr.u %d3,%d3,12,4
800096b8:	ff 53 24 80 	jge.u %d3,5,80009700 <IfxScuCcu_setCpuFrequency+0xc6>
800096bc:	91 10 00 f8 	movh.a %a15,32769
800096c0:	d9 ff 4c b9 	lea %a15,[%a15]-26932 <800096cc <IfxScuCcu_setCpuFrequency+0x92>>
800096c4:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800096c8:	dc 0f       	ji %a15
800096ca:	00 00       	nop 
800096cc:	1d 00 0a 00 	j 800096e0 <IfxScuCcu_setCpuFrequency+0xa6>
800096d0:	1d 00 78 00 	j 800097c0 <IfxScuCcu_setCpuFrequency+0x186>
800096d4:	1d 00 68 00 	j 800097a4 <IfxScuCcu_setCpuFrequency+0x16a>
800096d8:	1d 00 6d 00 	j 800097b2 <IfxScuCcu_setCpuFrequency+0x178>
800096dc:	1d 00 5d 00 	j 80009796 <IfxScuCcu_setCpuFrequency+0x15c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800096e0:	91 30 00 ff 	movh.a %a15,61443
800096e4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800096e8:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0f;
800096ea:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
800096ec:	37 03 64 34 	extr.u %d3,%d3,8,4
800096f0:	76 38       	jz %d3,80009700 <IfxScuCcu_setCpuFrequency+0xc6>
        {
            sriFrequency = 0.0f;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
800096f2:	4c f0       	ld.w %d15,[%a15]0
800096f4:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800096f8:	4b 0f 41 f1 	itof %d15,%d15
800096fc:	4b f2 51 f0 	div.f %d15,%d2,%d15
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
80009700:	4b f5 01 20 	cmp.f %d2,%d5,%d15
80009704:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
80009708:	df 02 24 80 	jne %d2,0,80009750 <IfxScuCcu_setCpuFrequency+0x116>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
8000970c:	7b 00 28 84 	movh %d8,17024
80009710:	4b 85 41 80 	mul.f %d8,%d5,%d8
80009714:	4b f8 51 80 	div.f %d8,%d8,%d15
80009718:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000971c:	6d 00 16 07 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009720:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009722:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009724:	6d 00 11 06 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
80009728:	df 19 2a 00 	jeq %d9,1,8000977c <IfxScuCcu_setCpuFrequency+0x142>
8000972c:	df 09 2f 00 	jeq %d9,0,8000978a <IfxScuCcu_setCpuFrequency+0x150>
80009730:	df 29 1d 00 	jeq %d9,2,8000976a <IfxScuCcu_setCpuFrequency+0x130>

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009734:	02 a4       	mov %d4,%d10
80009736:	6d 00 4c 08 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
8000973a:	76 89       	jz %d8,8000974c <IfxScuCcu_setCpuFrequency+0x112>
8000973c:	7b 00 c8 23 	movh %d2,15488
80009740:	4b 2f 41 f0 	mul.f %d15,%d15,%d2
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
80009744:	4b 08 61 81 	utof %d8,%d8
80009748:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
8000974c:	02 f2       	mov %d2,%d15
8000974e:	00 90       	ret 
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009750:	6d 00 fc 06 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009754:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009756:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009758:	6d 00 f7 05 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
8000975c:	df 19 0f 00 	jeq %d9,1,8000977a <IfxScuCcu_setCpuFrequency+0x140>
80009760:	df 09 14 00 	jeq %d9,0,80009788 <IfxScuCcu_setCpuFrequency+0x14e>
80009764:	df 29 5b 80 	jne %d9,2,8000981a <IfxScuCcu_setCpuFrequency+0x1e0>

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
    {
        cpuDiv = 0;
80009768:	82 08       	mov %d8,0
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
8000976a:	91 30 00 ff 	movh.a %a15,61443
8000976e:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80009772:	68 08       	st.w [%a15]0,%d8
            break;
80009774:	3c e0       	j 80009734 <IfxScuCcu_setCpuFrequency+0xfa>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80009776:	82 02       	mov %d2,0
80009778:	3c 98       	j 800096a8 <IfxScuCcu_setCpuFrequency+0x6e>

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
    {
        cpuDiv = 0;
8000977a:	82 08       	mov %d8,0
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
8000977c:	91 30 00 ff 	movh.a %a15,61443
80009780:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
80009784:	68 08       	st.w [%a15]0,%d8
            break;
80009786:	3c d7       	j 80009734 <IfxScuCcu_setCpuFrequency+0xfa>

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
    {
        cpuDiv = 0;
80009788:	82 08       	mov %d8,0
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
8000978a:	91 30 00 ff 	movh.a %a15,61443
8000978e:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80009792:	68 08       	st.w [%a15]0,%d8
            break;
80009794:	3c d0       	j 80009734 <IfxScuCcu_setCpuFrequency+0xfa>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
80009796:	7b 90 b8 f3 	movh %d15,15241
8000979a:	1b 9f 88 f8 	addi %d15,%d15,-30583
8000979e:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800097a2:	3c af       	j 80009700 <IfxScuCcu_setCpuFrequency+0xc6>
        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
800097a4:	7b 90 c8 f3 	movh %d15,15497
800097a8:	1b 9f 88 f8 	addi %d15,%d15,-30583
800097ac:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800097b0:	3c a8       	j 80009700 <IfxScuCcu_setCpuFrequency+0xc6>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
800097b2:	7b 90 c0 f3 	movh %d15,15369
800097b6:	1b 9f 88 f8 	addi %d15,%d15,-30583
800097ba:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800097be:	3c a1       	j 80009700 <IfxScuCcu_setCpuFrequency+0xc6>
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
800097c0:	7b 90 d0 f3 	movh %d15,15625
800097c4:	1b 9f 88 f8 	addi %d15,%d15,-30583
800097c8:	4b f2 41 f0 	mul.f %d15,%d2,%d15
800097cc:	3c 9a       	j 80009700 <IfxScuCcu_setCpuFrequency+0xc6>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800097ce:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800097d0:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800097d2:	37 0f 62 fe 	extr.u %d15,%d15,28,2
800097d6:	df 1f 4a ff 	jne %d15,1,8000966a <IfxScuCcu_setCpuFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800097da:	91 00 00 f7 	movh.a %a15,28672
800097de:	19 f2 00 b1 	ld.w %d2,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
800097e2:	4b 02 61 21 	utof %d2,%d2
800097e6:	1d ff 42 ff 	j 8000966a <IfxScuCcu_setCpuFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800097ea:	4c f7       	ld.w %d15,[%a15]28
800097ec:	37 0f 67 f8 	extr.u %d15,%d15,16,7
800097f0:	c2 1f       	add %d15,1
800097f2:	4b 0f 41 f1 	itof %d15,%d15
800097f6:	4b f2 51 20 	div.f %d2,%d2,%d15
800097fa:	1d ff 57 ff 	j 800096a8 <IfxScuCcu_setCpuFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800097fe:	48 72       	ld.w %d2,[%a15]28
80009800:	8f f2 07 21 	and %d2,%d2,127
80009804:	c2 12       	add %d2,1
80009806:	4b 02 41 f1 	itof %d15,%d2
8000980a:	7b f0 cb 24 	movh %d2,19647
8000980e:	1b 02 c2 2b 	addi %d2,%d2,-17376
80009812:	4b f2 51 20 	div.f %d2,%d2,%d15
80009816:	1d ff 49 ff 	j 800096a8 <IfxScuCcu_setCpuFrequency+0x6e>

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000981a:	02 a4       	mov %d4,%d10
8000981c:	6d 00 d9 07 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
80009820:	3c 96       	j 8000974c <IfxScuCcu_setCpuFrequency+0x112>

80009822 <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80009822:	91 30 00 ff 	movh.a %a15,61443

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009826:	91 30 00 2f 	movh.a %a2,61443


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
8000982a:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000982e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80009832:	48 08       	ld.w %d8,[%a15]0

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009834:	54 22       	ld.w %d2,[%a2]
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009836:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000983a:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
8000983e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009842:	df 02 28 00 	jeq %d2,0,80009892 <IfxScuCcu_setGtmFrequency+0x70>
80009846:	df 12 a0 80 	jne %d2,1,80009986 <IfxScuCcu_setGtmFrequency+0x164>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000984a:	48 02       	ld.w %d2,[%a15]0
8000984c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009850:	df 02 aa 80 	jne %d2,0,800099a4 <IfxScuCcu_setGtmFrequency+0x182>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80009854:	91 30 00 ff 	movh.a %a15,61443
80009858:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000985c:	48 52       	ld.w %d2,[%a15]20
8000985e:	6f 02 b1 80 	jnz.t %d2,0,800099c0 <IfxScuCcu_setGtmFrequency+0x19e>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80009862:	48 52       	ld.w %d2,[%a15]20
80009864:	6f 32 c1 80 	jnz.t %d2,3,800099e6 <IfxScuCcu_setGtmFrequency+0x1c4>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80009868:	48 65       	ld.w %d5,[%a15]24
8000986a:	48 72       	ld.w %d2,[%a15]28
8000986c:	37 05 e7 54 	extr.u %d5,%d5,9,7
80009870:	8f f2 07 31 	and %d3,%d2,127
80009874:	48 62       	ld.w %d2,[%a15]24
80009876:	c2 15       	add %d5,1
80009878:	37 02 64 2c 	extr.u %d2,%d2,24,4
8000987c:	4b 05 41 51 	itof %d5,%d5
80009880:	c2 12       	add %d2,1
80009882:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80009886:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
8000988a:	4b 02 41 21 	itof %d2,%d2
8000988e:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
80009892:	4b 4f 51 f0 	div.f %d15,%d15,%d4
80009896:	4b 0f 31 21 	ftoiz %d2,%d15
8000989a:	4b 02 41 31 	itof %d3,%d2
8000989e:	6b 03 31 ff 	sub.f %d15,%d15,%d3
800098a2:	7b 00 f0 33 	movh %d3,16128
800098a6:	4b 3f 01 f0 	cmp.f %d15,%d15,%d3
800098aa:	37 0f 61 f1 	extr.u %d15,%d15,2,1
800098ae:	42 2f       	add %d15,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800098b0:	82 12       	mov %d2,1
800098b2:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
800098b6:	92 92       	add %d2,%d15,-7
800098b8:	ff 72 5e 80 	jge.u %d2,7,80009974 <IfxScuCcu_setGtmFrequency+0x152>
    {
        gtmDiv = gtmDiv - 1;
800098bc:	8f 1f c0 f1 	andn %d15,%d15,1
800098c0:	8f ff 00 a1 	and %d10,%d15,15
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
800098c4:	6d 00 42 06 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
800098c8:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
800098ca:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
800098cc:	6d 00 3d 05 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
800098d0:	91 30 00 ff 	movh.a %a15,61443
800098d4:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800098d8:	4c f0       	ld.w %d15,[%a15]0
800098da:	91 30 00 cf 	movh.a %a12,61443
800098de:	d9 cc 34 06 	lea %a12,[%a12]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800098e2:	bf 0f fb 7f 	jlt %d15,0,800098d8 <IfxScuCcu_setGtmFrequency+0xb6>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
800098e6:	37 a8 04 86 	insert %d8,%d8,%d10,12,4
    ccucon1.B.UP     = 1U;
800098ea:	b7 18 01 8f 	insert %d8,%d8,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800098ee:	02 94       	mov %d4,%d9
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
800098f0:	74 c8       	st.w [%a12],%d8

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800098f2:	6d 00 6e 07 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
800098f6:	91 30 00 ff 	movh.a %a15,61443
800098fa:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800098fe:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009900:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009904:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009908:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
8000990c:	df 02 28 00 	jeq %d2,0,8000995c <IfxScuCcu_setGtmFrequency+0x13a>
80009910:	df 12 39 80 	jne %d2,1,80009982 <IfxScuCcu_setGtmFrequency+0x160>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009914:	54 c2       	ld.w %d2,[%a12]
80009916:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000991a:	df 02 38 80 	jne %d2,0,8000998a <IfxScuCcu_setGtmFrequency+0x168>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000991e:	91 30 00 ff 	movh.a %a15,61443
80009922:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80009926:	48 52       	ld.w %d2,[%a15]20
80009928:	6f 02 56 80 	jnz.t %d2,0,800099d4 <IfxScuCcu_setGtmFrequency+0x1b2>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000992c:	48 52       	ld.w %d2,[%a15]20
8000992e:	6f 32 69 80 	jnz.t %d2,3,80009a00 <IfxScuCcu_setGtmFrequency+0x1de>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80009932:	48 64       	ld.w %d4,[%a15]24
80009934:	48 72       	ld.w %d2,[%a15]28
80009936:	37 04 e7 44 	extr.u %d4,%d4,9,7
8000993a:	8f f2 07 31 	and %d3,%d2,127
8000993e:	48 62       	ld.w %d2,[%a15]24
80009940:	c2 14       	add %d4,1
80009942:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009946:	4b 04 41 41 	itof %d4,%d4
8000994a:	c2 12       	add %d2,1
8000994c:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80009950:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
80009954:	4b 02 41 21 	itof %d2,%d2
80009958:	4b 2f 51 f0 	div.f %d15,%d15,%d2
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
8000995c:	91 30 00 ff 	movh.a %a15,61443
80009960:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009964:	48 02       	ld.w %d2,[%a15]0
80009966:	37 02 64 26 	extr.u %d2,%d2,12,4
8000996a:	4b 02 41 21 	itof %d2,%d2
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    return IfxScuCcu_getGtmFrequency();
}
8000996e:	4b 2f 51 20 	div.f %d2,%d15,%d2
80009972:	00 90       	ret 
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
80009974:	8b ef 00 22 	eq %d2,%d15,14
80009978:	3b c0 00 a0 	mov %d10,12
8000997c:	df 02 a4 ff 	jne %d2,0,800098c4 <IfxScuCcu_setGtmFrequency+0xa2>
80009980:	3c a0       	j 800098c0 <IfxScuCcu_setGtmFrequency+0x9e>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80009982:	82 0f       	mov %d15,0
80009984:	3c ec       	j 8000995c <IfxScuCcu_setGtmFrequency+0x13a>
80009986:	82 0f       	mov %d15,0
80009988:	3c 85       	j 80009892 <IfxScuCcu_setGtmFrequency+0x70>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000998a:	54 c2       	ld.w %d2,[%a12]
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
8000998c:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000998e:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009992:	df 12 c6 ff 	jne %d2,1,8000991e <IfxScuCcu_setGtmFrequency+0xfc>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009996:	91 00 00 f7 	movh.a %a15,28672
8000999a:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
8000999e:	4b 0f 61 f1 	utof %d15,%d15
800099a2:	3c be       	j 8000991e <IfxScuCcu_setGtmFrequency+0xfc>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800099a4:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800099a6:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
800099a8:	37 02 62 2e 	extr.u %d2,%d2,28,2
800099ac:	df 12 54 ff 	jne %d2,1,80009854 <IfxScuCcu_setGtmFrequency+0x32>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
800099b0:	91 00 00 f7 	movh.a %a15,28672
800099b4:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
800099b8:	4b 0f 61 f1 	utof %d15,%d15
800099bc:	1d ff 4c ff 	j 80009854 <IfxScuCcu_setGtmFrequency+0x32>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
800099c0:	48 72       	ld.w %d2,[%a15]28
800099c2:	37 02 67 28 	extr.u %d2,%d2,16,7
800099c6:	c2 12       	add %d2,1
800099c8:	4b 02 41 21 	itof %d2,%d2
800099cc:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800099d0:	1d ff 61 ff 	j 80009892 <IfxScuCcu_setGtmFrequency+0x70>
800099d4:	48 72       	ld.w %d2,[%a15]28
800099d6:	37 02 67 28 	extr.u %d2,%d2,16,7
800099da:	c2 12       	add %d2,1
800099dc:	4b 02 41 21 	itof %d2,%d2
800099e0:	4b 2f 51 f0 	div.f %d15,%d15,%d2
800099e4:	3c bc       	j 8000995c <IfxScuCcu_setGtmFrequency+0x13a>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
800099e6:	4c f7       	ld.w %d15,[%a15]28
800099e8:	7b f0 cb 24 	movh %d2,19647
800099ec:	16 7f       	and %d15,127
800099ee:	c2 1f       	add %d15,1
800099f0:	4b 0f 41 f1 	itof %d15,%d15
800099f4:	1b 02 c2 2b 	addi %d2,%d2,-17376
800099f8:	4b f2 51 f0 	div.f %d15,%d2,%d15
800099fc:	1d ff 4b ff 	j 80009892 <IfxScuCcu_setGtmFrequency+0x70>
80009a00:	4c f7       	ld.w %d15,[%a15]28
80009a02:	7b f0 cb 24 	movh %d2,19647
80009a06:	16 7f       	and %d15,127
80009a08:	c2 1f       	add %d15,1
80009a0a:	4b 0f 41 f1 	itof %d15,%d15
80009a0e:	1b 02 c2 2b 	addi %d2,%d2,-17376
80009a12:	4b f2 51 f0 	div.f %d15,%d2,%d15
80009a16:	3c a3       	j 8000995c <IfxScuCcu_setGtmFrequency+0x13a>

80009a18 <IfxScuCcu_setPll2ErayFrequency>:
    return IfxScuCcu_getGtmFrequency();
}


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
80009a18:	02 49       	mov %d9,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80009a1a:	6d 00 97 05 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80009a1e:	91 30 00 ff 	movh.a %a15,61443
80009a22:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
}


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80009a26:	02 28       	mov %d8,%d2

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80009a28:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80009a2a:	7b f0 cb f4 	movh %d15,19647
80009a2e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80009a32:	6f 32 1f 80 	jnz.t %d2,3,80009a70 <IfxScuCcu_setPll2ErayFrequency+0x58>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009a36:	91 30 00 ff 	movh.a %a15,61443
80009a3a:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009a3e:	48 02       	ld.w %d2,[%a15]0
80009a40:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009a44:	df 02 61 80 	jne %d2,0,80009b06 <IfxScuCcu_setPll2ErayFrequency+0xee>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80009a48:	91 30 00 ff 	movh.a %a15,61443
80009a4c:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80009a50:	48 03       	ld.w %d3,[%a15]0
80009a52:	48 02       	ld.w %d2,[%a15]0
80009a54:	37 03 e5 34 	extr.u %d3,%d3,9,5
80009a58:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009a5c:	c2 13       	add %d3,1
80009a5e:	4b 03 41 31 	itof %d3,%d3
80009a62:	c2 12       	add %d2,1
80009a64:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80009a68:	4b 02 41 21 	itof %d2,%d2
80009a6c:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80009a70:	91 30 00 ff 	movh.a %a15,61443
80009a74:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(password);
80009a78:	02 84       	mov %d4,%d8
80009a7a:	6d 00 66 04 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80009a7e:	4b 9f 51 f0 	div.f %d15,%d15,%d9
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80009a82:	48 09       	ld.w %d9,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80009a84:	7b 00 f8 23 	movh %d2,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
80009a88:	02 84       	mov %d4,%d8


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80009a8a:	6b 02 31 ff 	sub.f %d15,%d15,%d2
80009a8e:	4b 0f 71 f1 	ftouz %d15,%d15
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80009a92:	37 f9 04 f4 	insert %d15,%d9,%d15,8,4
80009a96:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(password);
80009a98:	6d 00 9b 06 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80009a9c:	91 30 00 ff 	movh.a %a15,61443
80009aa0:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80009aa4:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80009aa6:	7b f0 cb f4 	movh %d15,19647
80009aaa:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80009aae:	6f 32 1f 80 	jnz.t %d2,3,80009aec <IfxScuCcu_setPll2ErayFrequency+0xd4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009ab2:	91 30 00 ff 	movh.a %a15,61443
80009ab6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009aba:	48 02       	ld.w %d2,[%a15]0
80009abc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009ac0:	df 02 30 80 	jne %d2,0,80009b20 <IfxScuCcu_setPll2ErayFrequency+0x108>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80009ac4:	91 30 00 ff 	movh.a %a15,61443
80009ac8:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80009acc:	48 03       	ld.w %d3,[%a15]0
80009ace:	48 02       	ld.w %d2,[%a15]0
80009ad0:	37 03 e5 34 	extr.u %d3,%d3,9,5
80009ad4:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009ad8:	c2 13       	add %d3,1
80009ada:	4b 03 41 31 	itof %d3,%d3
80009ade:	c2 12       	add %d2,1
80009ae0:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80009ae4:	4b 02 41 21 	itof %d2,%d2
80009ae8:	4b 2f 51 f0 	div.f %d15,%d15,%d2

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
80009aec:	91 30 00 ff 	movh.a %a15,61443
80009af0:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80009af4:	48 02       	ld.w %d2,[%a15]0
80009af6:	37 02 64 24 	extr.u %d2,%d2,8,4
80009afa:	c2 12       	add %d2,1
80009afc:	4b 02 41 21 	itof %d2,%d2
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
80009b00:	4b 2f 51 20 	div.f %d2,%d15,%d2
80009b04:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009b06:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009b08:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009b0a:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009b0e:	df 12 9d ff 	jne %d2,1,80009a48 <IfxScuCcu_setPll2ErayFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009b12:	91 00 00 f7 	movh.a %a15,28672
80009b16:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009b1a:	4b 0f 61 f1 	utof %d15,%d15
80009b1e:	3c 95       	j 80009a48 <IfxScuCcu_setPll2ErayFrequency+0x30>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009b20:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009b22:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009b24:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009b28:	df 12 ce ff 	jne %d2,1,80009ac4 <IfxScuCcu_setPll2ErayFrequency+0xac>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009b2c:	91 00 00 f7 	movh.a %a15,28672
80009b30:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009b34:	4b 0f 61 f1 	utof %d15,%d15
80009b38:	3c c6       	j 80009ac4 <IfxScuCcu_setPll2ErayFrequency+0xac>

80009b3a <IfxScuCcu_setPll2Frequency>:
    return IfxScuCcu_getPll2ErayFrequency();
}


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
80009b3a:	02 49       	mov %d9,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009b3c:	6d 00 06 05 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80009b40:	91 30 00 ff 	movh.a %a15,61443
80009b44:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
}


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009b48:	02 28       	mov %d8,%d2

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80009b4a:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80009b4c:	7b f0 cb f4 	movh %d15,19647
80009b50:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80009b54:	6f 32 1f 80 	jnz.t %d2,3,80009b92 <IfxScuCcu_setPll2Frequency+0x58>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009b58:	91 30 00 ff 	movh.a %a15,61443
80009b5c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009b60:	48 02       	ld.w %d2,[%a15]0
80009b62:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009b66:	df 02 61 80 	jne %d2,0,80009c28 <IfxScuCcu_setPll2Frequency+0xee>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80009b6a:	91 30 00 ff 	movh.a %a15,61443
80009b6e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009b72:	48 03       	ld.w %d3,[%a15]0
80009b74:	48 02       	ld.w %d2,[%a15]0
80009b76:	37 03 e7 34 	extr.u %d3,%d3,9,7
80009b7a:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009b7e:	c2 13       	add %d3,1
80009b80:	4b 03 41 31 	itof %d3,%d3
80009b84:	c2 12       	add %d2,1
80009b86:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80009b8a:	4b 02 41 21 	itof %d2,%d2
80009b8e:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80009b92:	91 30 00 ff 	movh.a %a15,61443
80009b96:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009b9a:	02 84       	mov %d4,%d8
80009b9c:	6d 00 d5 03 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80009ba0:	4b 9f 51 f0 	div.f %d15,%d15,%d9
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80009ba4:	48 09       	ld.w %d9,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80009ba6:	7b 00 f8 23 	movh %d2,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009baa:	02 84       	mov %d4,%d8


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80009bac:	6b 02 31 ff 	sub.f %d15,%d15,%d2
80009bb0:	4b 0f 71 f1 	ftouz %d15,%d15
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80009bb4:	37 f9 07 f4 	insert %d15,%d9,%d15,8,7
80009bb8:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009bba:	6d 00 0a 06 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80009bbe:	91 30 00 ff 	movh.a %a15,61443
80009bc2:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009bc6:	48 02       	ld.w %d2,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80009bc8:	7b f0 cb f4 	movh %d15,19647
80009bcc:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80009bd0:	6f 32 1f 80 	jnz.t %d2,3,80009c0e <IfxScuCcu_setPll2Frequency+0xd4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009bd4:	91 30 00 ff 	movh.a %a15,61443
80009bd8:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009bdc:	48 02       	ld.w %d2,[%a15]0
80009bde:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009be2:	df 02 30 80 	jne %d2,0,80009c42 <IfxScuCcu_setPll2Frequency+0x108>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80009be6:	91 30 00 ff 	movh.a %a15,61443
80009bea:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009bee:	48 03       	ld.w %d3,[%a15]0
80009bf0:	48 02       	ld.w %d2,[%a15]0
80009bf2:	37 03 e7 34 	extr.u %d3,%d3,9,7
80009bf6:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009bfa:	c2 13       	add %d3,1
80009bfc:	4b 03 41 31 	itof %d3,%d3
80009c00:	c2 12       	add %d2,1
80009c02:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
80009c06:	4b 02 41 21 	itof %d2,%d2
80009c0a:	4b 2f 51 f0 	div.f %d15,%d15,%d2


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80009c0e:	91 30 00 ff 	movh.a %a15,61443
80009c12:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009c16:	48 02       	ld.w %d2,[%a15]0
80009c18:	37 02 67 24 	extr.u %d2,%d2,8,7
80009c1c:	c2 12       	add %d2,1
80009c1e:	4b 02 41 21 	itof %d2,%d2
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    return IfxScuCcu_getPll2Frequency();
}
80009c22:	4b 2f 51 20 	div.f %d2,%d15,%d2
80009c26:	00 90       	ret 

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009c28:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009c2a:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009c2c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009c30:	df 12 9d ff 	jne %d2,1,80009b6a <IfxScuCcu_setPll2Frequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009c34:	91 00 00 f7 	movh.a %a15,28672
80009c38:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009c3c:	4b 0f 61 f1 	utof %d15,%d15
80009c40:	3c 95       	j 80009b6a <IfxScuCcu_setPll2Frequency+0x30>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009c42:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009c44:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009c46:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009c4a:	df 12 ce ff 	jne %d2,1,80009be6 <IfxScuCcu_setPll2Frequency+0xac>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009c4e:	91 00 00 f7 	movh.a %a15,28672
80009c52:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009c56:	4b 0f 61 f1 	utof %d15,%d15
80009c5a:	3c c6       	j 80009be6 <IfxScuCcu_setPll2Frequency+0xac>

80009c5c <IfxScuCcu_setSpbFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009c5c:	91 30 00 ff 	movh.a %a15,61443
80009c60:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009c64:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009c66:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009c6a:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009c6e:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009c72:	df 02 2c 00 	jeq %d2,0,80009cca <IfxScuCcu_setSpbFrequency+0x6e>
80009c76:	df 12 81 80 	jne %d2,1,80009d78 <IfxScuCcu_setSpbFrequency+0x11c>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009c7a:	91 30 00 ff 	movh.a %a15,61443
80009c7e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009c82:	48 02       	ld.w %d2,[%a15]0
80009c84:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009c88:	df 02 7a 80 	jne %d2,0,80009d7c <IfxScuCcu_setSpbFrequency+0x120>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80009c8c:	91 30 00 ff 	movh.a %a15,61443
80009c90:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80009c94:	48 52       	ld.w %d2,[%a15]20
80009c96:	6f 02 81 80 	jnz.t %d2,0,80009d98 <IfxScuCcu_setSpbFrequency+0x13c>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80009c9a:	48 52       	ld.w %d2,[%a15]20
80009c9c:	6f 32 87 80 	jnz.t %d2,3,80009daa <IfxScuCcu_setSpbFrequency+0x14e>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80009ca0:	48 65       	ld.w %d5,[%a15]24
80009ca2:	48 72       	ld.w %d2,[%a15]28
80009ca4:	37 05 e7 54 	extr.u %d5,%d5,9,7
80009ca8:	8f f2 07 31 	and %d3,%d2,127
80009cac:	48 62       	ld.w %d2,[%a15]24
80009cae:	c2 15       	add %d5,1
80009cb0:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009cb4:	4b 05 41 51 	itof %d5,%d5
80009cb8:	c2 12       	add %d2,1
80009cba:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80009cbe:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80009cc2:	4b 02 41 21 	itof %d2,%d2
80009cc6:	4b 2f 51 f0 	div.f %d15,%d15,%d2
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80009cca:	4b 4f 51 40 	div.f %d4,%d15,%d4
80009cce:	4b 04 71 f1 	ftouz %d15,%d4
80009cd2:	82 24       	mov %d4,2
80009cd4:	0b 4f b0 41 	max.u %d4,%d15,%d4
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
80009cd8:	9a 94       	add %d15,%d4,-7
80009cda:	ff 7f 49 80 	jge.u %d15,7,80009d6c <IfxScuCcu_setSpbFrequency+0x110>
    {
        spbDiv = spbDiv - 1;
80009cde:	8f 14 c0 41 	andn %d4,%d4,1
80009ce2:	8f f4 00 a1 	and %d10,%d4,15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
80009ce6:	6d 00 13 04 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>
80009cea:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80009cec:	6d 00 2e 04 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80009cf0:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80009cf2:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80009cf4:	6d 00 0e 03 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80009cf8:	91 30 00 ff 	movh.a %a15,61443
80009cfc:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009d00:	48 02       	ld.w %d2,[%a15]0
80009d02:	3b 00 3e f0 	mov %d15,992
80009d06:	a6 2f       	or %d15,%d2
80009d08:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80009d0a:	02 84       	mov %d4,%d8
80009d0c:	6d 00 46 05 	call 8000a798 <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80009d10:	02 94       	mov %d4,%d9
80009d12:	6d 00 1a 03 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80009d16:	91 30 00 ff 	movh.a %a15,61443
80009d1a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009d1e:	4c f0       	ld.w %d15,[%a15]0
80009d20:	91 30 00 2f 	movh.a %a2,61443
80009d24:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009d28:	bf 0f fb 7f 	jlt %d15,0,80009d1e <IfxScuCcu_setSpbFrequency+0xc2>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80009d2c:	4c 20       	ld.w %d15,[%a2]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80009d2e:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
80009d30:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
80009d34:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80009d38:	91 30 00 ff 	movh.a %a15,61443
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
80009d3c:	6c 20       	st.w [%a2]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80009d3e:	6d 00 48 05 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80009d42:	02 84       	mov %d4,%d8
80009d44:	6d 00 e6 02 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80009d48:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009d4c:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80009d4e:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
80009d50:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
80009d54:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80009d56:	6d 00 21 05 	call 8000a798 <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80009d5a:	91 30 00 ff 	movh.a %a15,61443
80009d5e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009d62:	4c f0       	ld.w %d15,[%a15]0
80009d64:	bf 0f ff 7f 	jlt %d15,0,80009d62 <IfxScuCcu_setSpbFrequency+0x106>
    {}

    return IfxScuCcu_getSpbFrequency();
80009d68:	1d ff 46 f8 	j 80008df4 <IfxScuCcu_getSpbFrequency>
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
80009d6c:	8b e4 00 f2 	eq %d15,%d4,14
80009d70:	3b c0 00 a0 	mov %d10,12
80009d74:	ee b9       	jnz %d15,80009ce6 <IfxScuCcu_setSpbFrequency+0x8a>
80009d76:	3c b6       	j 80009ce2 <IfxScuCcu_setSpbFrequency+0x86>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80009d78:	82 0f       	mov %d15,0
80009d7a:	3c a8       	j 80009cca <IfxScuCcu_setSpbFrequency+0x6e>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009d7c:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009d7e:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009d80:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009d84:	df 12 84 ff 	jne %d2,1,80009c8c <IfxScuCcu_setSpbFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009d88:	91 00 00 f7 	movh.a %a15,28672
80009d8c:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009d90:	4b 0f 61 f1 	utof %d15,%d15
80009d94:	1d ff 7c ff 	j 80009c8c <IfxScuCcu_setSpbFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80009d98:	48 72       	ld.w %d2,[%a15]28
80009d9a:	37 02 67 28 	extr.u %d2,%d2,16,7
80009d9e:	c2 12       	add %d2,1
80009da0:	4b 02 41 21 	itof %d2,%d2
80009da4:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80009da8:	3c 91       	j 80009cca <IfxScuCcu_setSpbFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80009daa:	4c f7       	ld.w %d15,[%a15]28
80009dac:	7b f0 cb 24 	movh %d2,19647
80009db0:	16 7f       	and %d15,127
80009db2:	c2 1f       	add %d15,1
80009db4:	4b 0f 41 f1 	itof %d15,%d15
80009db8:	1b 02 c2 2b 	addi %d2,%d2,-17376
80009dbc:	4b f2 51 f0 	div.f %d15,%d2,%d15
80009dc0:	3c 85       	j 80009cca <IfxScuCcu_setSpbFrequency+0x6e>

80009dc2 <IfxScuCcu_setSriFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009dc2:	91 30 00 ff 	movh.a %a15,61443
80009dc6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009dca:	48 02       	ld.w %d2,[%a15]0
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009dcc:	7b f0 cb f4 	movh %d15,19647

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009dd0:	37 02 62 2e 	extr.u %d2,%d2,28,2
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009dd4:	1b 0f c2 fb 	addi %d15,%d15,-17376

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009dd8:	df 02 2c 00 	jeq %d2,0,80009e30 <IfxScuCcu_setSriFrequency+0x6e>
80009ddc:	df 12 6d 80 	jne %d2,1,80009eb6 <IfxScuCcu_setSriFrequency+0xf4>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80009de0:	91 30 00 ff 	movh.a %a15,61443
80009de4:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009de8:	48 02       	ld.w %d2,[%a15]0
80009dea:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009dee:	df 02 66 80 	jne %d2,0,80009eba <IfxScuCcu_setSriFrequency+0xf8>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80009df2:	91 30 00 ff 	movh.a %a15,61443
80009df6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80009dfa:	48 52       	ld.w %d2,[%a15]20
80009dfc:	6f 02 6c 80 	jnz.t %d2,0,80009ed4 <IfxScuCcu_setSriFrequency+0x112>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80009e00:	48 52       	ld.w %d2,[%a15]20
80009e02:	6f 32 72 80 	jnz.t %d2,3,80009ee6 <IfxScuCcu_setSriFrequency+0x124>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80009e06:	48 65       	ld.w %d5,[%a15]24
80009e08:	48 72       	ld.w %d2,[%a15]28
80009e0a:	37 05 e7 54 	extr.u %d5,%d5,9,7
80009e0e:	8f f2 07 31 	and %d3,%d2,127
80009e12:	48 62       	ld.w %d2,[%a15]24
80009e14:	c2 15       	add %d5,1
80009e16:	37 02 64 2c 	extr.u %d2,%d2,24,4
80009e1a:	4b 05 41 51 	itof %d5,%d5
80009e1e:	c2 12       	add %d2,1
80009e20:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
80009e24:	4b 5f 41 f0 	mul.f %d15,%d15,%d5
80009e28:	4b 02 41 21 	itof %d2,%d2
80009e2c:	4b 2f 51 f0 	div.f %d15,%d15,%d2
{
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
80009e30:	4b 4f 51 f0 	div.f %d15,%d15,%d4
80009e34:	4b 0f 31 21 	ftoiz %d2,%d15
80009e38:	4b 02 41 31 	itof %d3,%d2
80009e3c:	6b 03 31 ff 	sub.f %d15,%d15,%d3
80009e40:	7b 00 f0 33 	movh %d3,16128
80009e44:	4b 3f 01 f0 	cmp.f %d15,%d15,%d3
80009e48:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80009e4c:	42 2f       	add %d15,%d2
80009e4e:	82 12       	mov %d2,1
80009e50:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
80009e54:	92 92       	add %d2,%d15,-7
80009e56:	ff 72 29 80 	jge.u %d2,7,80009ea8 <IfxScuCcu_setSriFrequency+0xe6>
    {
        sriDiv = sriDiv - 1;
80009e5a:	8f 1f c0 f1 	andn %d15,%d15,1
80009e5e:	8f ff 00 91 	and %d9,%d15,15
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80009e62:	6d 00 73 03 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80009e66:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80009e68:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80009e6a:	6d 00 6e 02 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80009e6e:	91 30 00 ff 	movh.a %a15,61443
80009e72:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009e76:	4c f0       	ld.w %d15,[%a15]0
80009e78:	91 30 00 2f 	movh.a %a2,61443
80009e7c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009e80:	bf 0f fb 7f 	jlt %d15,0,80009e76 <IfxScuCcu_setSriFrequency+0xb4>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80009e84:	4c 20       	ld.w %d15,[%a2]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80009e86:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
80009e88:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
80009e8c:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    while (SCU_CCUCON0.B.LCK != 0U)
80009e90:	91 30 00 ff 	movh.a %a15,61443
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
80009e94:	6c 20       	st.w [%a2]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80009e96:	6d 00 9c 04 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80009e9a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009e9e:	4c f0       	ld.w %d15,[%a15]0
80009ea0:	bf 0f ff 7f 	jlt %d15,0,80009e9e <IfxScuCcu_setSriFrequency+0xdc>
    {}

    freq = IfxScuCcu_getSriFrequency();
80009ea4:	1d ff 4c f8 	j 80008f3c <IfxScuCcu_getSriFrequency>
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
80009ea8:	8b ef 00 22 	eq %d2,%d15,14
80009eac:	3b c0 00 90 	mov %d9,12
80009eb0:	df 02 d9 ff 	jne %d2,0,80009e62 <IfxScuCcu_setSriFrequency+0xa0>
80009eb4:	3c d5       	j 80009e5e <IfxScuCcu_setSriFrequency+0x9c>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80009eb6:	82 0f       	mov %d15,0
80009eb8:	3c bc       	j 80009e30 <IfxScuCcu_setSriFrequency+0x6e>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009eba:	48 02       	ld.w %d2,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
80009ebc:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80009ebe:	37 02 62 2e 	extr.u %d2,%d2,28,2
80009ec2:	df 12 98 ff 	jne %d2,1,80009df2 <IfxScuCcu_setSriFrequency+0x30>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009ec6:	91 00 00 f7 	movh.a %a15,28672
80009eca:	19 ff 00 b1 	ld.w %d15,[%a15]4800 <700012c0 <IfxScuCcu_xtalFrequency>>
80009ece:	4b 0f 61 f1 	utof %d15,%d15
80009ed2:	3c 90       	j 80009df2 <IfxScuCcu_setSriFrequency+0x30>
    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80009ed4:	48 72       	ld.w %d2,[%a15]28
80009ed6:	37 02 67 28 	extr.u %d2,%d2,16,7
80009eda:	c2 12       	add %d2,1
80009edc:	4b 02 41 21 	itof %d2,%d2
80009ee0:	4b 2f 51 f0 	div.f %d15,%d15,%d2
80009ee4:	3c a6       	j 80009e30 <IfxScuCcu_setSriFrequency+0x6e>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80009ee6:	4c f7       	ld.w %d15,[%a15]28
80009ee8:	7b f0 cb 24 	movh %d2,19647
80009eec:	16 7f       	and %d15,127
80009eee:	c2 1f       	add %d15,1
80009ef0:	4b 0f 41 f1 	itof %d15,%d15
80009ef4:	1b 02 c2 2b 	addi %d2,%d2,-17376
80009ef8:	4b f2 51 f0 	div.f %d15,%d2,%d15
80009efc:	3c 9a       	j 80009e30 <IfxScuCcu_setSriFrequency+0x6e>

80009efe <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80009efe:	91 30 00 ff 	movh.a %a15,61443
80009f02:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009f06:	4c f0       	ld.w %d15,[%a15]0
80009f08:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80009f0c:	ee 02       	jnz %d15,80009f10 <IfxScuCcu_switchToBackupClock+0x12>
80009f0e:	00 90       	ret 
80009f10:	40 4c       	mov.aa %a12,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80009f12:	6d 00 1b 03 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>
80009f16:	02 28       	mov %d8,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80009f18:	6d 00 fa 02 	call 8000a50c <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80009f1c:	14 c9       	ld.bu %d9,[%a12]
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80009f1e:	91 30 00 ff 	movh.a %a15,61443
80009f22:	53 c9 20 f0 	mul %d15,%d9,12
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80009f26:	91 30 00 ef 	movh.a %a14,61443

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009f2a:	7b 30 00 af 	movh %d10,61443
80009f2e:	60 f2       	mov.a %a2,%d15
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009f30:	7b f0 cb c4 	movh %d12,19647
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009f34:	7b 00 00 d7 	movh %d13,28672
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80009f38:	02 2b       	mov %d11,%d2
80009f3a:	d9 2d f4 ff 	lea %a13,[%a2]-12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80009f3e:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80009f42:	d9 ee 1c 06 	lea %a14,[%a14]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009f46:	1b 0a 03 a6 	addi %d10,%d10,24624
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009f4a:	1b 0c c2 cb 	addi %d12,%d12,-17376
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80009f4e:	1b 0d 2c d1 	addi %d13,%d13,4800

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80009f52:	df 09 3f 00 	jeq %d9,0,80009fd0 <IfxScuCcu_switchToBackupClock+0xd2>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009f56:	02 84       	mov %d4,%d8
80009f58:	6d 00 f7 01 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80009f5c:	4c f0       	ld.w %d15,[%a15]0
80009f5e:	6f 5f ff 7f 	jz.t %d15,5,80009f5c <IfxScuCcu_switchToBackupClock+0x5e>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80009f62:	99 c2 04 00 	ld.a %a2,[%a12]4
80009f66:	54 e3       	ld.w %d3,[%a14]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009f68:	02 84       	mov %d4,%d8
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80009f6a:	30 d2       	add.a %a2,%a13
80009f6c:	0c 20       	ld.bu %d15,[%a2]0
80009f6e:	37 f3 07 f0 	insert %d15,%d3,%d15,0,7
80009f72:	6c e0       	st.w [%a14]0,%d15

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80009f74:	6d 00 2d 04 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80009f78:	99 c2 04 00 	ld.a %a2,[%a12]4
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80009f7c:	7b f0 cb f4 	movh %d15,19647
80009f80:	1b 0f c2 fb 	addi %d15,%d15,-17376
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80009f84:	30 d2       	add.a %a2,%a13
80009f86:	19 26 04 00 	ld.w %d6,[%a2]4

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80009f8a:	60 a2       	mov.a %a2,%d10
80009f8c:	54 25       	ld.w %d5,[%a2]
80009f8e:	37 05 62 5e 	extr.u %d5,%d5,28,2
80009f92:	76 54       	jz %d5,80009f9a <IfxScuCcu_switchToBackupClock+0x9c>
80009f94:	df 15 6d 00 	jeq %d5,1,8000a06e <IfxScuCcu_switchToBackupClock+0x170>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80009f98:	82 0f       	mov %d15,0
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80009f9a:	91 30 00 2f 	movh.a %a2,61443
80009f9e:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80009fa2:	54 23       	ld.w %d3,[%a2]


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80009fa4:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
80009fa8:	37 03 64 34 	extr.u %d3,%d3,8,4
80009fac:	4b 03 41 31 	itof %d3,%d3
80009fb0:	4b 3f 51 30 	div.f %d3,%d15,%d3
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80009fb4:	4b 63 41 30 	mul.f %d3,%d3,%d6
80009fb8:	4b 03 71 31 	ftouz %d3,%d3
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80009fbc:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80009fc0:	a2 5f       	sub %d15,%d5
80009fc2:	3f 3f fd ff 	jlt.u %d15,%d3,80009fbc <IfxScuCcu_switchToBackupClock+0xbe>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80009fc6:	c2 f9       	add %d9,-1
80009fc8:	d9 dd f4 ff 	lea %a13,[%a13]-12
80009fcc:	df 09 c5 ff 	jne %d9,0,80009f56 <IfxScuCcu_switchToBackupClock+0x58>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80009fd0:	02 b4       	mov %d4,%d11
80009fd2:	6d 00 9f 01 	call 8000a310 <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80009fd6:	91 30 00 ff 	movh.a %a15,61443
80009fda:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80009fde:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80009fe0:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
80009fe2:	02 b4       	mov %d4,%d11
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80009fe4:	96 08       	or %d15,8
80009fe6:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80009fe8:	37 02 e1 91 	extr.u %d9,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80009fec:	6d 00 d6 03 	call 8000a798 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80009ff0:	02 84       	mov %d4,%d8
80009ff2:	6d 00 aa 01 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
80009ff6:	91 30 00 2f 	movh.a %a2,61443
80009ffa:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80009ffe:	4c 20       	ld.w %d15,[%a2]0
8000a000:	91 30 00 ff 	movh.a %a15,61443
8000a004:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000a008:	bf 0f fb 7f 	jlt %d15,0,80009ffe <IfxScuCcu_switchToBackupClock+0x100>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
8000a00c:	4c f0       	ld.w %d15,[%a15]0
8000a00e:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
8000a012:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
8000a014:	4c f0       	ld.w %d15,[%a15]0
8000a016:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000a01a:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
8000a01c:	4c f0       	ld.w %d15,[%a15]0
8000a01e:	bf 0f ff 7f 	jlt %d15,0,8000a01c <IfxScuCcu_switchToBackupClock+0x11e>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
8000a022:	91 30 00 ff 	movh.a %a15,61443
8000a026:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000a02a:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000a02c:	02 84       	mov %d4,%d8
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
8000a02e:	96 10       	or %d15,16
8000a030:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000a032:	4c f0       	ld.w %d15,[%a15]0
8000a034:	8f 0f c4 f1 	andn %d15,%d15,64
8000a038:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000a03a:	6d 00 ca 03 	call 8000a7ce <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000a03e:	91 30 00 ff 	movh.a %a15,61443
8000a042:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000a046:	02 b4       	mov %d4,%d11
8000a048:	6d 00 64 01 	call 8000a310 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
8000a04c:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000a04e:	8f 39 00 20 	sh %d2,%d9,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000a052:	96 08       	or %d15,8
8000a054:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000a056:	91 30 00 ff 	movh.a %a15,61443
8000a05a:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000a05e:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000a060:	02 b4       	mov %d4,%d11
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000a062:	8f 8f c0 f1 	andn %d15,%d15,8
8000a066:	a6 2f       	or %d15,%d2
8000a068:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000a06a:	1d 00 97 03 	j 8000a798 <IfxScuWdt_setCpuEndinit>

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
8000a06e:	91 30 00 2f 	movh.a %a2,61443
8000a072:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000a076:	54 22       	ld.w %d2,[%a2]
8000a078:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000a07c:	df 02 28 80 	jne %d2,0,8000a0cc <IfxScuCcu_switchToBackupClock+0x1ce>
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000a080:	91 30 00 2f 	movh.a %a2,61443
8000a084:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000a088:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
8000a08c:	6f 02 32 80 	jnz.t %d2,0,8000a0f0 <IfxScuCcu_switchToBackupClock+0x1f2>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000a090:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
8000a094:	6f 32 39 80 	jnz.t %d2,3,8000a106 <IfxScuCcu_switchToBackupClock+0x208>
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000a098:	19 24 18 00 	ld.w %d4,[%a2]24 <f0030018 <_SMALL_DATA4_+0x40028018>>
8000a09c:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x4002801c>>
8000a0a0:	37 04 e7 44 	extr.u %d4,%d4,9,7
8000a0a4:	8f f2 07 31 	and %d3,%d2,127
8000a0a8:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x40028018>>
8000a0ac:	c2 14       	add %d4,1
8000a0ae:	37 02 64 2c 	extr.u %d2,%d2,24,4
8000a0b2:	4b 04 41 41 	itof %d4,%d4
8000a0b6:	c2 12       	add %d2,1
8000a0b8:	03 23 0a 22 	madd %d2,%d2,%d3,%d2
8000a0bc:	4b 4f 41 f0 	mul.f %d15,%d15,%d4
8000a0c0:	4b 02 41 21 	itof %d2,%d2
8000a0c4:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000a0c8:	1d ff 69 ff 	j 80009f9a <IfxScuCcu_switchToBackupClock+0x9c>

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000a0cc:	54 22       	ld.w %d2,[%a2]
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
8000a0ce:	82 0f       	mov %d15,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000a0d0:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000a0d4:	df 12 d6 ff 	jne %d2,1,8000a080 <IfxScuCcu_switchToBackupClock+0x182>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
8000a0d8:	60 d2       	mov.a %a2,%d13
8000a0da:	4c 20       	ld.w %d15,[%a2]0
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000a0dc:	91 30 00 2f 	movh.a %a2,61443
8000a0e0:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000a0e4:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
8000a0e8:	4b 0f 61 f1 	utof %d15,%d15
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
8000a0ec:	6f 02 d2 7f 	jz.t %d2,0,8000a090 <IfxScuCcu_switchToBackupClock+0x192>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
8000a0f0:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x4002801c>>
8000a0f4:	37 02 67 28 	extr.u %d2,%d2,16,7
8000a0f8:	c2 12       	add %d2,1
8000a0fa:	4b 02 41 21 	itof %d2,%d2
8000a0fe:	4b 2f 51 f0 	div.f %d15,%d15,%d2
8000a102:	1d ff 4c ff 	j 80009f9a <IfxScuCcu_switchToBackupClock+0x9c>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000a106:	4c 27       	ld.w %d15,[%a2]28
8000a108:	16 7f       	and %d15,127
8000a10a:	c2 1f       	add %d15,1
8000a10c:	4b 0f 41 f1 	itof %d15,%d15
8000a110:	4b fc 51 f0 	div.f %d15,%d12,%d15
8000a114:	1d ff 43 ff 	j 80009f9a <IfxScuCcu_switchToBackupClock+0x9c>

8000a118 <IfxScuCcu_enableExtClockOut0>:
    }
}


void IfxScuCcu_enableExtClockOut0(IfxScuCcu_ClkSel0 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk0Mode mode)
{
8000a118:	0b 45 10 88 	mov %e8,%d5,%d4
8000a11c:	02 6a       	mov %d10,%d6
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000a11e:	6d 00 15 02 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000a122:	02 24       	mov %d4,%d2

void IfxScuCcu_enableExtClockOut0(IfxScuCcu_ClkSel0 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk0Mode mode)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000a124:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000a126:	6d 00 10 01 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

    SCU_EXTCON.B.SEL0 = (uint32)Clk_Sel;
8000a12a:	91 30 00 ff 	movh.a %a15,61443
8000a12e:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
8000a132:	48 02       	ld.w %d2,[%a15]0
8000a134:	37 82 04 21 	insert %d2,%d2,%d8,2,4
8000a138:	68 02       	st.w [%a15]0,%d2

    if (IfxScuCcu_ClkSel0_fOUT == Clk_Sel)
8000a13a:	df 08 1a 80 	jne %d8,0,8000a16e <IfxScuCcu_enableExtClockOut0+0x56>
    {
        if (mode == IfxScuCcu_Clk0Mode_normal)
        {
            /* normal divider mode */
            SCU_FDR.B.DM = 1U;
8000a13e:	91 30 00 ff 	movh.a %a15,61443
8000a142:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
8000a146:	48 02       	ld.w %d2,[%a15]0

    SCU_EXTCON.B.SEL0 = (uint32)Clk_Sel;

    if (IfxScuCcu_ClkSel0_fOUT == Clk_Sel)
    {
        if (mode == IfxScuCcu_Clk0Mode_normal)
8000a148:	df 1a 1e 00 	jeq %d10,1,8000a184 <IfxScuCcu_enableExtClockOut0+0x6c>
            }
        }
        else
        {
            /* fractional divider mode */
            SCU_FDR.B.DM   = 2U;
8000a14c:	b7 22 02 27 	insert %d2,%d2,2,14,2
            SCU_FDR.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxScuCcu_getSpbFrequency()));
8000a150:	8f b9 00 90 	sh %d9,%d9,11
            }
        }
        else
        {
            /* fractional divider mode */
            SCU_FDR.B.DM   = 2U;
8000a154:	68 02       	st.w [%a15]0,%d2
            SCU_FDR.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxScuCcu_getSpbFrequency()));
8000a156:	6d ff 4f f6 	call 80008df4 <IfxScuCcu_getSpbFrequency>
8000a15a:	4b 09 61 91 	utof %d9,%d9
8000a15e:	4b 29 51 20 	div.f %d2,%d9,%d2
8000a162:	48 09       	ld.w %d9,[%a15]0
8000a164:	4b 02 71 21 	ftouz %d2,%d2
8000a168:	37 29 0a 20 	insert %d2,%d9,%d2,0,10
8000a16c:	68 02       	st.w [%a15]0,%d2
        }
    }

    SCU_EXTCON.B.EN0 = 1U;
8000a16e:	91 30 00 ff 	movh.a %a15,61443
8000a172:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
8000a176:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000a178:	02 f4       	mov %d4,%d15
            SCU_FDR.B.DM   = 2U;
            SCU_FDR.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxScuCcu_getSpbFrequency()));
        }
    }

    SCU_EXTCON.B.EN0 = 1U;
8000a17a:	8f 12 40 21 	or %d2,%d2,1
8000a17e:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000a180:	1d 00 27 03 	j 8000a7ce <IfxScuWdt_setSafetyEndinit>
    if (IfxScuCcu_ClkSel0_fOUT == Clk_Sel)
    {
        if (mode == IfxScuCcu_Clk0Mode_normal)
        {
            /* normal divider mode */
            SCU_FDR.B.DM = 1U;
8000a184:	b7 12 02 27 	insert %d2,%d2,1,14,2
8000a188:	68 02       	st.w [%a15]0,%d2

            if (freqHz == (IfxScuCcu_getSpbFrequency() / 2))
8000a18a:	6d ff 35 f6 	call 80008df4 <IfxScuCcu_getSpbFrequency>
8000a18e:	7b 00 f0 43 	movh %d4,16128
8000a192:	4b 09 61 31 	utof %d3,%d9
8000a196:	4b 42 41 20 	mul.f %d2,%d2,%d4
8000a19a:	4b 23 01 20 	cmp.f %d2,%d3,%d2
8000a19e:	8f d2 00 21 	and %d2,%d2,13
8000a1a2:	f6 27       	jnz %d2,8000a1b0 <IfxScuCcu_enableExtClockOut0+0x98>
            {
                SCU_FDR.B.STEP = 0x3FFu;
8000a1a4:	48 03       	ld.w %d3,[%a15]0
8000a1a6:	3b f0 3f 20 	mov %d2,1023
8000a1aa:	a6 32       	or %d2,%d3
8000a1ac:	68 02       	st.w [%a15]0,%d2
8000a1ae:	3c e0       	j 8000a16e <IfxScuCcu_enableExtClockOut0+0x56>
            }
            else
            {
                SCU_FDR.B.STEP = (uint32)(1024u - (IfxScuCcu_getSpbFrequency() / (2u * freqHz)));
8000a1b0:	6d ff 22 f6 	call 80008df4 <IfxScuCcu_getSpbFrequency>
8000a1b4:	06 19       	sh %d9,1
8000a1b6:	4b 09 61 91 	utof %d9,%d9
8000a1ba:	7b 00 48 34 	movh %d3,17536
8000a1be:	4b 92 51 20 	div.f %d2,%d2,%d9
8000a1c2:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000a1c6:	48 03       	ld.w %d3,[%a15]0
8000a1c8:	4b 02 71 21 	ftouz %d2,%d2
8000a1cc:	37 23 0a 20 	insert %d2,%d3,%d2,0,10
8000a1d0:	68 02       	st.w [%a15]0,%d2
8000a1d2:	3c ce       	j 8000a16e <IfxScuCcu_enableExtClockOut0+0x56>

8000a1d4 <IfxScuCcu_enableExtClockOut1>:
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
}


void IfxScuCcu_enableExtClockOut1(IfxScuCcu_ClkSel1 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk1Negation sel)
{
8000a1d4:	02 48       	mov %d8,%d4
8000a1d6:	02 5a       	mov %d10,%d5
8000a1d8:	02 69       	mov %d9,%d6
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000a1da:	6d 00 b7 01 	call 8000a548 <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000a1de:	02 24       	mov %d4,%d2

void IfxScuCcu_enableExtClockOut1(IfxScuCcu_ClkSel1 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk1Negation sel)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
8000a1e0:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000a1e2:	6d 00 b2 00 	call 8000a346 <IfxScuWdt_clearSafetyEndinit>

    SCU_EXTCON.B.SEL1 = (uint32)Clk_Sel;
8000a1e6:	91 30 00 ff 	movh.a %a15,61443
8000a1ea:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
8000a1ee:	48 03       	ld.w %d3,[%a15]0
8000a1f0:	37 83 04 39 	insert %d3,%d3,%d8,18,4
8000a1f4:	68 03       	st.w [%a15]0,%d3

    if (IfxScuCcu_ClkSel1_fOUT == Clk_Sel)
8000a1f6:	df 08 16 80 	jne %d8,0,8000a222 <IfxScuCcu_enableExtClockOut1+0x4e>
    {
        SCU_EXTCON.B.DIV1 = (uint32)((IfxScuCcu_getSpbFrequency() / freqHz) - 1U);
8000a1fa:	6d ff fd f5 	call 80008df4 <IfxScuCcu_getSpbFrequency>
8000a1fe:	4b 0a 61 a1 	utof %d10,%d10
8000a202:	4b a2 51 20 	div.f %d2,%d2,%d10
8000a206:	7b 00 f8 a3 	movh %d10,16256
8000a20a:	6b 0a 31 22 	sub.f %d2,%d2,%d10
8000a20e:	48 0a       	ld.w %d10,[%a15]0
8000a210:	4b 02 71 21 	ftouz %d2,%d2
8000a214:	37 2a 08 2c 	insert %d2,%d10,%d2,24,8
8000a218:	68 02       	st.w [%a15]0,%d2
        SCU_EXTCON.B.NSEL = sel;
8000a21a:	48 02       	ld.w %d2,[%a15]0
8000a21c:	67 92 11 90 	ins.t %d9,%d2,17,%d9,0
8000a220:	68 09       	st.w [%a15]0,%d9
    }

    SCU_EXTCON.B.EN1 = 1U;
8000a222:	91 30 00 ff 	movh.a %a15,61443
8000a226:	d9 ff 3c 06 	lea %a15,[%a15]24636 <f003603c <_SMALL_DATA4_+0x4002e03c>>
8000a22a:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000a22c:	02 f4       	mov %d4,%d15
    {
        SCU_EXTCON.B.DIV1 = (uint32)((IfxScuCcu_getSpbFrequency() / freqHz) - 1U);
        SCU_EXTCON.B.NSEL = sel;
    }

    SCU_EXTCON.B.EN1 = 1U;
8000a22e:	b7 f2 01 28 	insert %d2,%d2,15,16,1
8000a232:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000a234:	1d 00 cd 02 	j 8000a7ce <IfxScuWdt_setSafetyEndinit>

8000a238 <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a238:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a23c:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
8000a23e:	53 cf 20 f0 	mul %d15,%d15,12
8000a242:	60 f2       	mov.a %a2,%d15
8000a244:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a248:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
8000a24c:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000a24e:	2e 16       	jz.t %d15,1,8000a25a <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000a250:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000a254:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
8000a258:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
8000a25a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000a25e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
8000a262:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
8000a266:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a268:	4c f0       	ld.w %d15,[%a15]0
8000a26a:	6f 0f ff 7f 	jz.t %d15,0,8000a268 <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
8000a26e:	00 90       	ret 

8000a270 <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a270:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a274:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000a276:	53 cf 20 f0 	mul %d15,%d15,12
8000a27a:	60 f2       	mov.a %a2,%d15
8000a27c:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a280:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
8000a284:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000a286:	2e 16       	jz.t %d15,1,8000a292 <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000a288:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000a28c:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000a290:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
8000a292:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000a296:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
8000a29a:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
8000a29e:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
8000a2a0:	4c f0       	ld.w %d15,[%a15]0
8000a2a2:	6f 0f ff 7f 	jz.t %d15,0,8000a2a0 <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
8000a2a6:	00 90       	ret 

8000a2a8 <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
8000a2a8:	91 30 00 ff 	movh.a %a15,61443
8000a2ac:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a2b0:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000a2b2:	2e 16       	jz.t %d15,1,8000a2be <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000a2b4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000a2b8:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
8000a2bc:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
8000a2be:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000a2c2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
8000a2c6:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
8000a2ca:	91 30 00 ff 	movh.a %a15,61443
8000a2ce:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a2d2:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a2d4:	4c f0       	ld.w %d15,[%a15]0
8000a2d6:	6f 0f ff 7f 	jz.t %d15,0,8000a2d4 <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
8000a2da:	00 90       	ret 

8000a2dc <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
8000a2dc:	91 30 00 ff 	movh.a %a15,61443
8000a2e0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a2e4:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
8000a2e6:	2e 16       	jz.t %d15,1,8000a2f2 <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000a2e8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
8000a2ec:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000a2f0:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
8000a2f2:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
8000a2f6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
8000a2fa:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
8000a2fe:	91 30 00 ff 	movh.a %a15,61443
8000a302:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a306:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
8000a308:	4c f0       	ld.w %d15,[%a15]0
8000a30a:	6f 0f ff 7f 	jz.t %d15,0,8000a308 <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
8000a30e:	00 90       	ret 

8000a310 <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a310:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a314:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000a316:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a31a:	06 24       	sh %d4,2
8000a31c:	60 f2       	mov.a %a2,%d15
8000a31e:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a322:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a326:	4c f0       	ld.w %d15,[%a15]0
8000a328:	2e 16       	jz.t %d15,1,8000a334 <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a32a:	4c f0       	ld.w %d15,[%a15]0
8000a32c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a330:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a332:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a334:	4c f0       	ld.w %d15,[%a15]0
8000a336:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a33a:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a33c:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000a33e:	4c f0       	ld.w %d15,[%a15]0
8000a340:	6f 0f ff ff 	jnz.t %d15,0,8000a33e <IfxScuWdt_clearCpuEndinit+0x2e>
}
8000a344:	00 90       	ret 

8000a346 <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a346:	91 30 00 ff 	movh.a %a15,61443
8000a34a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a34e:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a350:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a352:	2e 16       	jz.t %d15,1,8000a35e <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a354:	4c f0       	ld.w %d15,[%a15]0
8000a356:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a35a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a35c:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a35e:	91 30 00 ff 	movh.a %a15,61443
8000a362:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a366:	4c f0       	ld.w %d15,[%a15]0
8000a368:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a36c:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a36e:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000a370:	4c f0       	ld.w %d15,[%a15]0
8000a372:	6f 0f ff ff 	jnz.t %d15,0,8000a370 <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
8000a376:	00 90       	ret 

8000a378 <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a378:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a37c:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000a37e:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a382:	06 24       	sh %d4,2
8000a384:	60 f2       	mov.a %a2,%d15
8000a386:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a38a:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a38e:	4c f0       	ld.w %d15,[%a15]0
8000a390:	2e 16       	jz.t %d15,1,8000a39c <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a392:	4c f0       	ld.w %d15,[%a15]0
8000a394:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a398:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a39a:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a39c:	4c f0       	ld.w %d15,[%a15]0
8000a39e:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a3a2:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a3a4:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000a3a6:	4c f0       	ld.w %d15,[%a15]0
8000a3a8:	6f 0f ff ff 	jnz.t %d15,0,8000a3a6 <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
8000a3ac:	4c f1       	ld.w %d15,[%a15]4
8000a3ae:	96 08       	or %d15,8
8000a3b0:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a3b2:	4c f0       	ld.w %d15,[%a15]0
8000a3b4:	2e 16       	jz.t %d15,1,8000a3c0 <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a3b6:	4c f0       	ld.w %d15,[%a15]0
8000a3b8:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a3bc:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a3be:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a3c0:	4c f0       	ld.w %d15,[%a15]0
8000a3c2:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a3c6:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a3c8:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a3ca:	4c f0       	ld.w %d15,[%a15]0
8000a3cc:	6f 0f ff 7f 	jz.t %d15,0,8000a3ca <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
8000a3d0:	00 90       	ret 

8000a3d2 <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a3d2:	91 30 00 ff 	movh.a %a15,61443
8000a3d6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a3da:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a3dc:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a3de:	2e 16       	jz.t %d15,1,8000a3ea <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a3e0:	4c f0       	ld.w %d15,[%a15]0
8000a3e2:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a3e6:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a3e8:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a3ea:	91 30 00 ff 	movh.a %a15,61443
8000a3ee:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a3f2:	4c f0       	ld.w %d15,[%a15]0
8000a3f4:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a3f8:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a3fa:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000a3fc:	4c f0       	ld.w %d15,[%a15]0
8000a3fe:	91 30 00 2f 	movh.a %a2,61443
8000a402:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a406:	6f 0f fb ff 	jnz.t %d15,0,8000a3fc <IfxScuWdt_disableSafetyWatchdog+0x2a>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
8000a40a:	91 30 00 ff 	movh.a %a15,61443
8000a40e:	d9 ff 34 36 	lea %a15,[%a15]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
8000a412:	4c f0       	ld.w %d15,[%a15]0
8000a414:	96 08       	or %d15,8
8000a416:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a418:	4c 20       	ld.w %d15,[%a2]0
8000a41a:	2e 16       	jz.t %d15,1,8000a426 <IfxScuWdt_disableSafetyWatchdog+0x54>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a41c:	4c 20       	ld.w %d15,[%a2]0
8000a41e:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a422:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a424:	6c 20       	st.w [%a2]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a426:	91 30 00 ff 	movh.a %a15,61443
8000a42a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a42e:	4c f0       	ld.w %d15,[%a15]0
8000a430:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a434:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a436:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000a438:	4c f0       	ld.w %d15,[%a15]0
8000a43a:	6f 0f ff 7f 	jz.t %d15,0,8000a438 <IfxScuWdt_disableSafetyWatchdog+0x66>
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000a43e:	00 90       	ret 

8000a440 <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a440:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a444:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000a446:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a44a:	06 24       	sh %d4,2
8000a44c:	60 f2       	mov.a %a2,%d15
8000a44e:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a452:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a456:	4c f0       	ld.w %d15,[%a15]0
8000a458:	2e 16       	jz.t %d15,1,8000a464 <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a45a:	4c f0       	ld.w %d15,[%a15]0
8000a45c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a460:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a462:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a464:	4c f0       	ld.w %d15,[%a15]0
8000a466:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a46a:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a46c:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000a46e:	4c f0       	ld.w %d15,[%a15]0
8000a470:	6f 0f ff ff 	jnz.t %d15,0,8000a46e <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
8000a474:	4c f1       	ld.w %d15,[%a15]4
8000a476:	8f 8f c0 f1 	andn %d15,%d15,8
8000a47a:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a47c:	4c f0       	ld.w %d15,[%a15]0
8000a47e:	2e 16       	jz.t %d15,1,8000a48a <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a480:	4c f0       	ld.w %d15,[%a15]0
8000a482:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a486:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a488:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a48a:	4c f0       	ld.w %d15,[%a15]0
8000a48c:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a490:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a492:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a494:	4c f0       	ld.w %d15,[%a15]0
8000a496:	6f 0f ff 7f 	jz.t %d15,0,8000a494 <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
8000a49a:	00 90       	ret 

8000a49c <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a49c:	91 30 00 ff 	movh.a %a15,61443
8000a4a0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a4a4:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a4a6:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a4a8:	2e 16       	jz.t %d15,1,8000a4b4 <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a4aa:	4c f0       	ld.w %d15,[%a15]0
8000a4ac:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a4b0:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a4b2:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a4b4:	91 30 00 ff 	movh.a %a15,61443
8000a4b8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a4bc:	4c f0       	ld.w %d15,[%a15]0
8000a4be:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a4c2:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a4c4:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000a4c6:	4c f0       	ld.w %d15,[%a15]0
8000a4c8:	91 30 00 2f 	movh.a %a2,61443
8000a4cc:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a4d0:	6f 0f fb ff 	jnz.t %d15,0,8000a4c6 <IfxScuWdt_enableSafetyWatchdog+0x2a>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
8000a4d4:	91 30 00 ff 	movh.a %a15,61443
8000a4d8:	d9 ff 34 36 	lea %a15,[%a15]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
8000a4dc:	4c f0       	ld.w %d15,[%a15]0
8000a4de:	8f 8f c0 f1 	andn %d15,%d15,8
8000a4e2:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a4e4:	4c 20       	ld.w %d15,[%a2]0
8000a4e6:	2e 16       	jz.t %d15,1,8000a4f2 <IfxScuWdt_enableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a4e8:	4c 20       	ld.w %d15,[%a2]0
8000a4ea:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a4ee:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a4f0:	6c 20       	st.w [%a2]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a4f2:	91 30 00 ff 	movh.a %a15,61443
8000a4f6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a4fa:	4c f0       	ld.w %d15,[%a15]0
8000a4fc:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a500:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a502:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000a504:	4c f0       	ld.w %d15,[%a15]0
8000a506:	6f 0f ff 7f 	jz.t %d15,0,8000a504 <IfxScuWdt_enableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000a50a:	00 90       	ret 

8000a50c <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a50c:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a510:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
8000a512:	53 cf 20 f0 	mul %d15,%d15,12
8000a516:	60 f2       	mov.a %a2,%d15
8000a518:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a51c:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
8000a520:	48 02       	ld.w %d2,[%a15]0
8000a522:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
8000a526:	8f f2 83 21 	xor %d2,%d2,63
8000a52a:	00 90       	ret 

8000a52c <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a52c:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a530:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
8000a532:	53 cf 20 f0 	mul %d15,%d15,12
8000a536:	60 f2       	mov.a %a2,%d15
8000a538:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a53c:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
8000a540:	48 02       	ld.w %d2,[%a15]0
}
8000a542:	8f 12 00 21 	and %d2,%d2,1
8000a546:	00 90       	ret 

8000a548 <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
8000a548:	91 30 00 ff 	movh.a %a15,61443
8000a54c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a550:	48 02       	ld.w %d2,[%a15]0
8000a552:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
8000a556:	8f f2 83 21 	xor %d2,%d2,63
8000a55a:	00 90       	ret 

8000a55c <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
8000a55c:	da 3c       	mov %d15,60
8000a55e:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
8000a560:	82 cf       	mov %d15,-4
8000a562:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
8000a564:	82 0f       	mov %d15,0
8000a566:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
8000a568:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
8000a56a:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
8000a56c:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
8000a56e:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
8000a570:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
8000a572:	2c 4a       	st.b [%a4]10,%d15
8000a574:	00 90       	ret 

8000a576 <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
8000a576:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
8000a578:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000a57a:	6f 12 0b 00 	jz.t %d2,1,8000a590 <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000a57e:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
8000a582:	37 02 6e 31 	extr.u %d3,%d2,2,14
8000a586:	8f f3 83 31 	xor %d3,%d3,63
8000a58a:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000a58e:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
8000a590:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
8000a592:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
8000a596:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
8000a59a:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
8000a59e:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000a5a2:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
8000a5a6:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
8000a5a8:	54 42       	ld.w %d2,[%a4]
8000a5aa:	6f 02 ff ff 	jnz.t %d2,0,8000a5a8 <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
8000a5ae:	39 52 04 00 	ld.bu %d2,[%a5]4
8000a5b2:	df 12 48 00 	jeq %d2,1,8000a642 <IfxScuWdt_initCpuWatchdog+0xcc>
8000a5b6:	df 02 4b 00 	jeq %d2,0,8000a64c <IfxScuWdt_initCpuWatchdog+0xd6>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
8000a5ba:	8b 22 20 22 	ne %d2,%d2,2
8000a5be:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
8000a5c2:	39 52 05 00 	ld.bu %d2,[%a5]5
8000a5c6:	8b 02 20 22 	ne %d2,%d2,0
8000a5ca:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
8000a5ce:	39 52 06 00 	ld.bu %d2,[%a5]6
8000a5d2:	8b 02 20 22 	ne %d2,%d2,0
8000a5d6:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
8000a5da:	39 52 07 00 	ld.bu %d2,[%a5]7
8000a5de:	8b 02 20 22 	ne %d2,%d2,0
8000a5e2:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
8000a5e6:	39 52 08 00 	ld.bu %d2,[%a5]8
8000a5ea:	8b 02 20 22 	ne %d2,%d2,0
8000a5ee:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
8000a5f2:	39 52 09 00 	ld.bu %d2,[%a5]9
8000a5f6:	8b 02 20 22 	ne %d2,%d2,0
8000a5fa:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
8000a5fe:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
8000a600:	b9 5f 00 00 	ld.hu %d15,[%a5]0


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a604:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a608:	8f 72 00 21 	and %d2,%d2,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000a60c:	53 c2 20 20 	mul %d2,%d2,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a610:	06 2f       	sh %d15,2
8000a612:	60 22       	mov.a %a2,%d2
8000a614:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a618:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a61c:	48 02       	ld.w %d2,[%a15]0
8000a61e:	6f 12 09 00 	jz.t %d2,1,8000a630 <IfxScuWdt_initCpuWatchdog+0xba>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a622:	48 02       	ld.w %d2,[%a15]0
8000a624:	b7 02 10 20 	insert %d2,%d2,0,0,16
8000a628:	a6 f2       	or %d2,%d15
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a62a:	8f 12 40 21 	or %d2,%d2,1
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a62e:	68 02       	st.w [%a15]0,%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a630:	48 02       	ld.w %d2,[%a15]0
8000a632:	b7 32 10 20 	insert %d2,%d2,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a636:	a6 2f       	or %d15,%d2
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a638:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a63a:	4c f0       	ld.w %d15,[%a15]0
8000a63c:	6f 0f ff 7f 	jz.t %d15,0,8000a63a <IfxScuWdt_initCpuWatchdog+0xc4>
    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
}
8000a640:	00 90       	ret 
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000a642:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000a646:	8f 0f c2 f1 	andn %d15,%d15,32
        break;
8000a64a:	3c bc       	j 8000a5c2 <IfxScuWdt_initCpuWatchdog+0x4c>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
8000a64c:	82 0f       	mov %d15,0
        break;
8000a64e:	3c ba       	j 8000a5c2 <IfxScuWdt_initCpuWatchdog+0x4c>

8000a650 <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
8000a650:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
8000a652:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000a654:	6f 12 0b 00 	jz.t %d2,1,8000a66a <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000a658:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
8000a65c:	37 02 6e 31 	extr.u %d3,%d2,2,14
8000a660:	8f f3 83 31 	xor %d3,%d3,63
8000a664:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000a668:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
8000a66a:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
8000a66c:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
8000a670:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
8000a674:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
8000a678:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000a67c:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
8000a680:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
8000a682:	54 42       	ld.w %d2,[%a4]
8000a684:	6f 02 ff ff 	jnz.t %d2,0,8000a682 <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
8000a688:	39 52 04 00 	ld.bu %d2,[%a5]4
8000a68c:	df 12 4b 00 	jeq %d2,1,8000a722 <IfxScuWdt_initSafetyWatchdog+0xd2>
8000a690:	df 02 4e 00 	jeq %d2,0,8000a72c <IfxScuWdt_initSafetyWatchdog+0xdc>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
8000a694:	8b 22 20 22 	ne %d2,%d2,2
8000a698:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
8000a69c:	39 52 05 00 	ld.bu %d2,[%a5]5
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a6a0:	91 30 00 ff 	movh.a %a15,61443
8000a6a4:	8b 02 20 22 	ne %d2,%d2,0
8000a6a8:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
8000a6ac:	39 52 06 00 	ld.bu %d2,[%a5]6
8000a6b0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a6b4:	8b 02 20 22 	ne %d2,%d2,0
8000a6b8:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
8000a6bc:	39 52 07 00 	ld.bu %d2,[%a5]7
8000a6c0:	8b 02 20 22 	ne %d2,%d2,0
8000a6c4:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
8000a6c8:	39 52 08 00 	ld.bu %d2,[%a5]8
8000a6cc:	8b 02 20 22 	ne %d2,%d2,0
8000a6d0:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
8000a6d4:	39 52 09 00 	ld.bu %d2,[%a5]9
8000a6d8:	8b 02 20 22 	ne %d2,%d2,0
8000a6dc:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 1 : 0;
8000a6e0:	39 52 0a 00 	ld.bu %d2,[%a5]10
8000a6e4:	8b 02 20 22 	ne %d2,%d2,0
8000a6e8:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
8000a6ec:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
8000a6ee:	b9 5f 00 00 	ld.hu %d15,[%a5]0
8000a6f2:	48 02       	ld.w %d2,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a6f4:	06 2f       	sh %d15,2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a6f6:	6f 12 09 00 	jz.t %d2,1,8000a708 <IfxScuWdt_initSafetyWatchdog+0xb8>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a6fa:	48 02       	ld.w %d2,[%a15]0
8000a6fc:	b7 02 10 20 	insert %d2,%d2,0,0,16
8000a700:	a6 f2       	or %d2,%d15
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a702:	8f 12 40 21 	or %d2,%d2,1
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a706:	68 02       	st.w [%a15]0,%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a708:	91 30 00 ff 	movh.a %a15,61443
8000a70c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a710:	48 02       	ld.w %d2,[%a15]0
8000a712:	b7 32 10 20 	insert %d2,%d2,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a716:	a6 2f       	or %d15,%d2
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a718:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000a71a:	4c f0       	ld.w %d15,[%a15]0
8000a71c:	6f 0f ff 7f 	jz.t %d15,0,8000a71a <IfxScuWdt_initSafetyWatchdog+0xca>
}
8000a720:	00 90       	ret 
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000a722:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000a726:	8f 0f c2 f1 	andn %d15,%d15,32
        break;
8000a72a:	3c b9       	j 8000a69c <IfxScuWdt_initSafetyWatchdog+0x4c>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
8000a72c:	82 0f       	mov %d15,0
        break;
8000a72e:	3c b7       	j 8000a69c <IfxScuWdt_initSafetyWatchdog+0x4c>

8000a730 <IfxScuWdt_serviceCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a730:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a734:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000a736:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a73a:	06 24       	sh %d4,2
8000a73c:	60 f2       	mov.a %a2,%d15
8000a73e:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a742:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a746:	4c f0       	ld.w %d15,[%a15]0
8000a748:	2e 16       	jz.t %d15,1,8000a754 <IfxScuWdt_serviceCpuWatchdog+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a74a:	4c f0       	ld.w %d15,[%a15]0
8000a74c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a750:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a752:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a754:	4c f0       	ld.w %d15,[%a15]0
8000a756:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a75a:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a75c:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a75e:	4c f0       	ld.w %d15,[%a15]0
8000a760:	6f 0f ff 7f 	jz.t %d15,0,8000a75e <IfxScuWdt_serviceCpuWatchdog+0x2e>


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
}
8000a764:	00 90       	ret 

8000a766 <IfxScuWdt_serviceSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a766:	91 30 00 ff 	movh.a %a15,61443
8000a76a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a76e:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a770:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a772:	2e 16       	jz.t %d15,1,8000a77e <IfxScuWdt_serviceSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a774:	4c f0       	ld.w %d15,[%a15]0
8000a776:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a77a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a77c:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a77e:	91 30 00 ff 	movh.a %a15,61443
8000a782:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a786:	4c f0       	ld.w %d15,[%a15]0
8000a788:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a78c:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a78e:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000a790:	4c f0       	ld.w %d15,[%a15]0
8000a792:	6f 0f ff 7f 	jz.t %d15,0,8000a790 <IfxScuWdt_serviceSafetyWatchdog+0x2a>


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
}
8000a796:	00 90       	ret 

8000a798 <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000a798:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000a79c:	16 07       	and %d15,7


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000a79e:	53 cf 20 f0 	mul %d15,%d15,12
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a7a2:	06 24       	sh %d4,2
8000a7a4:	60 f2       	mov.a %a2,%d15
8000a7a6:	d9 2f 00 46 	lea %a15,[%a2]24832
8000a7aa:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000a7ae:	4c f0       	ld.w %d15,[%a15]0
8000a7b0:	2e 16       	jz.t %d15,1,8000a7bc <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a7b2:	4c f0       	ld.w %d15,[%a15]0
8000a7b4:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a7b8:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a7ba:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000a7bc:	4c f0       	ld.w %d15,[%a15]0
8000a7be:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000a7c2:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000a7c4:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000a7c6:	4c f0       	ld.w %d15,[%a15]0
8000a7c8:	6f 0f ff 7f 	jz.t %d15,0,8000a7c6 <IfxScuWdt_setCpuEndinit+0x2e>
}
8000a7cc:	00 90       	ret 

8000a7ce <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a7ce:	91 30 00 ff 	movh.a %a15,61443
8000a7d2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a7d6:	4c f0       	ld.w %d15,[%a15]0
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a7d8:	06 24       	sh %d4,2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000a7da:	2e 16       	jz.t %d15,1,8000a7e6 <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a7dc:	4c f0       	ld.w %d15,[%a15]0
8000a7de:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a7e2:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a7e4:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000a7e6:	91 30 00 ff 	movh.a %a15,61443
8000a7ea:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000a7ee:	4c f0       	ld.w %d15,[%a15]0
8000a7f0:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000a7f4:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000a7f6:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000a7f8:	4c f0       	ld.w %d15,[%a15]0
8000a7fa:	6f 0f ff 7f 	jz.t %d15,0,8000a7f8 <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000a7fe:	00 90       	ret 

8000a800 <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
8000a800:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
8000a804:	2e 0c       	jz.t %d15,0,8000a81c <IfxScuWdt_enableWatchdogWithDebugger+0x1c>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
8000a806:	3b 00 00 f3 	mov %d15,12288
8000a80a:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
8000a80e:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
8000a812:	82 02       	mov %d2,0

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
8000a814:	37 0f e1 f3 	extr.u %d15,%d15,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
8000a818:	ea 12       	cmovn %d2,%d15,1
8000a81a:	00 90       	ret 

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
8000a81c:	3b 10 0a 20 	mov %d2,161
8000a820:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
8000a824:	da 5e       	mov %d15,94
8000a826:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
8000a82a:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
8000a82e:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
8000a832:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
8000a836:	6f 0f e8 ff 	jnz.t %d15,0,8000a806 <IfxScuWdt_enableWatchdogWithDebugger+0x6>
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
8000a83a:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
8000a83e:	82 12       	mov %d2,1

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
8000a840:	37 0f e1 f3 	extr.u %d15,%d15,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
8000a844:	ea 12       	cmovn %d2,%d15,1
8000a846:	00 90       	ret 

8000a848 <_init_uart3>:
	unsigned int denominator = 3125;
	unsigned int pisel = 3; /* select ARXnD */

	/* ARX3D/P32.2 (RXD), ATX3/P15.7 (TXD) */
	/* Set TXD/P15.7 to "output" and "high" */
	MODULE_P15.IOCR4.B.PC7 = 0x12;
8000a848:	91 40 00 ff 	movh.a %a15,61444
8000a84c:	d9 ff 40 4b 	lea %a15,[%a15]-19200 <f003b500 <_SMALL_DATA4_+0x40033500>>
8000a850:	4c f5       	ld.w %d15,[%a15]20
8000a852:	7b 00 00 29 	movh %d2,36864
8000a856:	b7 0f 85 fd 	insert %d15,%d15,0,27,5
8000a85a:	a6 2f       	or %d15,%d2
8000a85c:	68 5f       	st.w [%a15]20,%d15
	MODULE_P15.OUT.B.P7 = 1;
8000a85e:	4c f0       	ld.w %d15,[%a15]0
8000a860:	96 80       	or %d15,128
8000a862:	68 0f       	st.w [%a15]0,%d15

	/* Enable ASCn */
	unlock_wdtcon();
	MODULE_ASCLIN3.CLC.U = 0;
8000a864:	c5 ff 80 40 	lea %a15,f0000900 <_SMALL_DATA4_+0x3fff8900>
8000a868:	82 0f       	mov %d15,0
	/* Set TXD/P15.7 to "output" and "high" */
	MODULE_P15.IOCR4.B.PC7 = 0x12;
	MODULE_P15.OUT.B.P7 = 1;

	/* Enable ASCn */
	unlock_wdtcon();
8000a86a:	6d 00 65 35 	call 80011334 <unlock_wdtcon>
	MODULE_ASCLIN3.CLC.U = 0;
8000a86e:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000a870:	6d 00 78 35 	call 80011360 <lock_wdtcon>
	/* read back for activating module */
	(void)MODULE_ASCLIN3.CLC.U;
8000a874:	48 02       	ld.w %d2,[%a15]0

	/* select RXD as input pin */
	MODULE_ASCLIN3.IOCR.B.ALTI = pisel;
8000a876:	48 12       	ld.w %d2,[%a15]4
	MODULE_ASCLIN3.CSR.U = 1;				/* select CLC as clock source */

	/* ASCLIN3RX Interrupt */
	MODULE_ASCLIN3.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
	/* set SRC register  */
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.TOS = 0;	// execute core
8000a878:	91 40 00 2f 	movh.a %a2,61444
	lock_wdtcon();
	/* read back for activating module */
	(void)MODULE_ASCLIN3.CLC.U;

	/* select RXD as input pin */
	MODULE_ASCLIN3.IOCR.B.ALTI = pisel;
8000a87c:	b7 32 03 20 	insert %d2,%d2,3,0,3
	MODULE_ASCLIN3.CSR.U = 1;				/* select CLC as clock source */

	/* ASCLIN3RX Interrupt */
	MODULE_ASCLIN3.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
	/* set SRC register  */
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.TOS = 0;	// execute core
8000a880:	d9 22 00 08 	lea %a2,[%a2]-32768 <f0038000 <_SMALL_DATA4_+0x40030000>>
	lock_wdtcon();
	/* read back for activating module */
	(void)MODULE_ASCLIN3.CLC.U;

	/* select RXD as input pin */
	MODULE_ASCLIN3.IOCR.B.ALTI = pisel;
8000a884:	68 12       	st.w [%a15]4,%d2

	/* Program ASC0 */
	MODULE_ASCLIN3.CSR.U = 0;
8000a886:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* configure TX and RX FIFOs */
	MODULE_ASCLIN3.TXFIFOCON.U = (1 << 6)	/* INW: (1 == 1 byte) */
8000a88a:	da 43       	mov %d15,67
8000a88c:	68 3f       	st.w [%a15]12,%d15
						  | (1 << 1)	/* ENO */
						  | (1 << 0);	/* FLUSH */
	MODULE_ASCLIN3.RXFIFOCON.U = (1 << 31)  /* BUF: (1 == Single Stage RX Buffer) */
8000a88e:	9b 0f 00 f8 	addih %d15,%d15,32768
8000a892:	68 4f       	st.w [%a15]16,%d15
						  | (1 << 6)	/* OUTW: (1 == 1 byte) */
						  | (1 << 1)	/* ENI */
						  | (1 << 0);	/* FLUSH */

	/* 38400 */
	MODULE_ASCLIN3.BITCON.U = ( 9 << 0)		/* PRESCALER: 10 */
8000a894:	7b f0 90 f8 	movh %d15,35087
8000a898:	1b 9f 00 f0 	addi %d15,%d15,9
8000a89c:	68 5f       	st.w [%a15]20,%d15
					   | (15 << 16)		/* OVERSAMPLING: 16 */
					   | ( 9 << 24)		/* SAMPLEPOINT: position 7,8,9 */
					   | (1u << 31);	/* SM: 3 samples per bit */
	/* data format: 8N1 */
	MODULE_ASCLIN3.FRAMECON.U = (1 << 9)		/* STOP: 1 bit */
8000a89e:	3b 00 20 f0 	mov %d15,512
8000a8a2:	68 6f       	st.w [%a15]24,%d15
						 | (0 << 16)	/* MODE: Init */
						 | (0 << 30);	/* PEN: no parity */
	MODULE_ASCLIN3.DATCON.U = (7 << 0);		/* DATLEN: 8 bit */
8000a8a4:	82 7f       	mov %d15,7
8000a8a6:	68 7f       	st.w [%a15]28,%d15

	/* set baudrate value */
	MODULE_ASCLIN3.BRG.U = (denominator << 0)	/* DENOMINATOR */
8000a8a8:	7b 00 0c f0 	movh %d15,192
8000a8ac:	1b 5f c3 f0 	addi %d15,%d15,3125
8000a8b0:	68 8f       	st.w [%a15]32,%d15
					| (numerator << 16);	/* NUMERATOR */

	MODULE_ASCLIN3.FRAMECON.B.MODE = 1;		/* ASC mode */
8000a8b2:	4c f6       	ld.w %d15,[%a15]24
8000a8b4:	b7 1f 02 f8 	insert %d15,%d15,1,16,2
8000a8b8:	68 6f       	st.w [%a15]24,%d15
	MODULE_ASCLIN3.CSR.U = 1;				/* select CLC as clock source */
8000a8ba:	82 1f       	mov %d15,1
8000a8bc:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* ASCLIN3RX Interrupt */
	MODULE_ASCLIN3.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
8000a8c0:	7b 00 00 f1 	movh %d15,4096
8000a8c4:	59 ff 00 10 	st.w [%a15]64 <f0040040 <_SMALL_DATA4_+0x40038040>>,%d15
	/* set SRC register  */
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.TOS = 0;	// execute core
8000a8c8:	19 2f 28 20 	ld.w %d15,[%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>
8000a8cc:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
8000a8d0:	59 2f 28 20 	st.w [%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>,%d15
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.SRPN = 1;	// priority
8000a8d4:	19 2f 28 20 	ld.w %d15,[%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>
8000a8d8:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000a8dc:	59 2f 28 20 	st.w [%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>,%d15
	MODULE_SRC.ASCLIN.ASCLIN[3].RX.B.SRE = 1;	// enable
8000a8e0:	19 2f 28 20 	ld.w %d15,[%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>
8000a8e4:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000a8e8:	59 2f 28 20 	st.w [%a2]168 <f00400a8 <_SMALL_DATA4_+0x400380a8>>,%d15

	TX_START(MODULE_ASCLIN3);
8000a8ec:	7b 00 00 f8 	movh %d15,32768
8000a8f0:	68 ef       	st.w [%a15]56,%d15
8000a8f2:	00 90       	ret 

8000a8f4 <_out_uart3>:

/* Send character CHR via the serial line */
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));
8000a8f4:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a8f8:	ff 0f fe 7f 	jge %d15,0,8000a8f4 <_out_uart3>

	TX_CLEAR(MODULE_ASCLIN3);
8000a8fc:	7b 00 00 f8 	movh %d15,32768
8000a900:	a5 ff bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d15

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN3, chr);
8000a904:	a5 f4 84 50 	st.w f0000944 <_SMALL_DATA4_+0x3fff8944>,%d4
8000a908:	00 90       	ret 

8000a90a <_in_uart3>:

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000a90a:	7b 00 00 41 	movh %d4,4096
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000a90e:	7b 50 40 30 	movh %d3,1029
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
8000a912:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a916:	ef cf fe 7f 	jz.t %d15,28,8000a912 <_in_uart3+0x8>
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
8000a91a:	85 f2 88 50 	ld.w %d2,f0000948 <_SMALL_DATA4_+0x3fff8948>
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000a91e:	a5 f4 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d4
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000a922:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a926:	26 3f       	and %d15,%d3
8000a928:	ee 04       	jnz %d15,8000a930 <_in_uart3+0x26>

	/* wait for a new character */
	while (_poll_uart3(&ch) == 0);

	return ch;
}
8000a92a:	8f f2 0f 21 	and %d2,%d2,255
8000a92e:	00 90       	ret 
		RX_CLEAR(MODULE_ASCLIN3);
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
		{
			/* reset error flags */
			RESET_ERROR(MODULE_ASCLIN3);
8000a930:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3
8000a934:	3c ef       	j 8000a912 <_in_uart3+0x8>

8000a936 <_poll_uart3>:
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
8000a936:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
   else 0
 */
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
8000a93a:	82 02       	mov %d2,0

	if (RX_READY(MODULE_ASCLIN3))
8000a93c:	ef cf 10 00 	jz.t %d15,28,8000a95c <_poll_uart3+0x26>
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000a940:	7b 00 00 f1 	movh %d15,4096
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
8000a944:	85 f4 88 50 	ld.w %d4,f0000948 <_SMALL_DATA4_+0x3fff8948>
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000a948:	a5 ff bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d15
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000a94c:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000a950:	7b 50 40 30 	movh %d3,1029
8000a954:	26 3f       	and %d15,%d3
8000a956:	ee 04       	jnz %d15,8000a95e <_poll_uart3+0x28>
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
8000a958:	34 44       	st.b [%a4],%d4
		}
		else
		{
			/* this is a valid character */
			*chr = ret;
			res = 1;
8000a95a:	82 12       	mov %d2,1
		}
	}

	return res;
}
8000a95c:	00 90       	ret 
		RX_CLEAR(MODULE_ASCLIN3);
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
		{
			/* reset error flags */
			RESET_ERROR(MODULE_ASCLIN3);
8000a95e:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3
8000a962:	00 90       	ret 

8000a964 <usr_vsprintf>:
	*buf = '\0';
	return length;
}

int usr_vsprintf(char *dest, const char *fmt, va_list ap)
{
8000a964:	20 70       	sub.a %sp,112
			/* handle type modifier */
			if (c == 'l' || c == 'h')
			{
				c = *fmt++;
			}
			switch (c)
8000a966:	7b 10 00 e8 	movh %d14,32769
	*buf = '\0';
	return length;
}

int usr_vsprintf(char *dest, const char *fmt, va_list ap)
{
8000a96a:	80 4d       	mov.d %d13,%a4
8000a96c:	40 5c       	mov.aa %a12,%a5
	char c, sign, *cp, *dp = dest;
8000a96e:	40 4f       	mov.aa %a15,%a4
		}
		else
		{
			if (c == '\n')
			{
				*dp++= '\r';
8000a970:	3b d0 00 b0 	mov %d11,13
			/* handle type modifier */
			if (c == 'l' || c == 'h')
			{
				c = *fmt++;
			}
			switch (c)
8000a974:	1b 8e a8 ea 	addi %d14,%d14,-21880
			}
			if (pad_on_right)
			{
				while (pad-- > 0)
				{
					*dp++= ' ';
8000a978:	3b 00 02 90 	mov %d9,32
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000a97c:	d9 ae 20 00 	lea %a14,[%sp]32
	int left_prec, right_prec, zero_fill, length, pad, pad_on_right;
	unsigned int p;
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
8000a980:	79 cf 00 00 	ld.b %d15,[%a12]0
8000a984:	6e 0e       	jz %d15,8000a9a0 <usr_vsprintf+0x3c>
	{
		cp = buf;
		length = 0;
		if (c == '%')
8000a986:	8b 5f 22 32 	ne %d3,%d15,37
8000a98a:	76 3f       	jz %d3,8000a9a8 <usr_vsprintf+0x44>
				}
			}
		}
		else
		{
			if (c == '\n')
8000a98c:	8b af 20 32 	ne %d3,%d15,10
8000a990:	df 03 24 01 	jeq %d3,0,8000abd8 <usr_vsprintf+0x274>
			{
				*dp++= '\r';
			}
			*dp++ = c;
8000a994:	28 0f       	st.b [%a15]0,%d15
	int left_prec, right_prec, zero_fill, length, pad, pad_on_right;
	unsigned int p;
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
8000a996:	b0 1c       	add.a %a12,1
8000a998:	79 cf 00 00 	ld.b %d15,[%a12]0
		{
			if (c == '\n')
			{
				*dp++= '\r';
			}
			*dp++ = c;
8000a99c:	b0 1f       	add.a %a15,1
	int left_prec, right_prec, zero_fill, length, pad, pad_on_right;
	unsigned int p;
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
8000a99e:	ee f4       	jnz %d15,8000a986 <usr_vsprintf+0x22>
		}
	}

	*dp = '\0';

	return ((int)dp - (int)dest);
8000a9a0:	80 f2       	mov.d %d2,%a15
			}
			*dp++ = c;
		}
	}

	*dp = '\0';
8000a9a2:	28 0f       	st.b [%a15]0,%d15

	return ((int)dp - (int)dest);
8000a9a4:	a2 d2       	sub %d2,%d13
8000a9a6:	00 90       	ret 
	{
		cp = buf;
		length = 0;
		if (c == '%')
		{
			c = *fmt++;
8000a9a8:	79 cf 01 00 	ld.b %d15,[%a12]1
8000a9ac:	d9 c2 02 00 	lea %a2,[%a12]2
			left_prec = right_prec = pad_on_right = 0;
			if (c == '-')
8000a9b0:	8b df 02 32 	eq %d3,%d15,45
		cp = buf;
		length = 0;
		if (c == '%')
		{
			c = *fmt++;
			left_prec = right_prec = pad_on_right = 0;
8000a9b4:	82 0a       	mov %d10,0
			if (c == '-')
8000a9b6:	df 03 15 81 	jne %d3,0,8000abe0 <usr_vsprintf+0x27c>
			{
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
8000a9ba:	8b 0f 23 32 	ne %d3,%d15,48
				zero_fill = TRUE;
				c = *fmt++;
			}
			else
			{
				zero_fill = FALSE;
8000a9be:	82 0c       	mov %d12,0
			if (c == '-')
			{
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
8000a9c0:	df 03 1a 01 	jeq %d3,0,8000abf4 <usr_vsprintf+0x290>
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
8000a9c4:	1b 0f fd 3f 	addi %d3,%d15,-48
8000a9c8:	8f f3 0f 41 	and %d4,%d3,255
8000a9cc:	40 2c       	mov.aa %a12,%a2
8000a9ce:	82 08       	mov %d8,0
8000a9d0:	ff a4 0f 80 	jge.u %d4,10,8000a9ee <usr_vsprintf+0x8a>
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
8000a9d4:	79 2f 00 00 	ld.b %d15,[%a2]0
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
			{
				left_prec = (left_prec * 10) + (c - '0');
8000a9d8:	13 a8 20 83 	madd %d8,%d3,%d8,10
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
8000a9dc:	1b 0f fd 3f 	addi %d3,%d15,-48
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
8000a9e0:	d9 2c 01 00 	lea %a12,[%a2]1
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
8000a9e4:	8f f3 0f 41 	and %d4,%d3,255
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
8000a9e8:	40 c2       	mov.aa %a2,%a12
			}
			else
			{
				zero_fill = FALSE;
			}
			while (is_digit(c))
8000a9ea:	bf a4 f5 ff 	jlt.u %d4,10,8000a9d4 <usr_vsprintf+0x70>
			{
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
			}
			if (c == '.')
8000a9ee:	8b ef 22 32 	ne %d3,%d15,46
8000a9f2:	df 03 07 01 	jeq %d3,0,8000ac00 <usr_vsprintf+0x29c>
			{
				right_prec = left_prec;
			}
			sign = '\0';
			/* handle type modifier */
			if (c == 'l' || c == 'h')
8000a9f6:	8f 4f c0 31 	andn %d3,%d15,4
8000a9fa:	8b 83 26 32 	ne %d3,%d3,104
8000a9fe:	f6 34       	jnz %d3,8000aa06 <usr_vsprintf+0xa2>
			{
				c = *fmt++;
8000aa00:	79 cf 00 00 	ld.b %d15,[%a12]0
8000aa04:	b0 1c       	add.a %a12,1
			}
			switch (c)
8000aa06:	1b bf fd 4f 	addi %d4,%d15,-37
8000aa0a:	8b 44 a5 32 	ge.u %d3,%d4,84
8000aa0e:	df 03 38 00 	jeq %d3,0,8000aa7e <usr_vsprintf+0x11a>
				case 'P' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
				default:
					*dp++ = '?';
8000aa12:	da 3f       	mov %d15,63
8000aa14:	28 0f       	st.b [%a15]0,%d15
8000aa16:	82 f4       	mov %d4,-1
8000aa18:	b0 1f       	add.a %a15,1
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
		length = 0;
8000aa1a:	82 02       	mov %d2,0
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000aa1c:	40 ad       	mov.aa %a13,%sp
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
				default:
					*dp++ = '?';
			}
			pad = left_prec - length;
8000aa1e:	a2 28       	sub %d8,%d2
8000aa20:	82 03       	mov %d3,0
			if (sign != '\0')
			{
				pad--;
			}
			if (zero_fill)
8000aa22:	df 0c 08 01 	jeq %d12,0,8000ac32 <usr_vsprintf+0x2ce>
			}
			else
			{
				c = ' ';
			}
			if (!pad_on_right)
8000aa26:	df 0a 91 01 	jeq %d10,0,8000ad48 <usr_vsprintf+0x3e4>
			}
			if (sign != '\0')
			{
				*dp++ = sign;
			}
			while (length-- > 0)
8000aa2a:	bf 12 1f 00 	jlt %d2,1,8000aa68 <usr_vsprintf+0x104>
			{
				c = *cp++;
				if (c == '\n')
				{
					*dp++ = '\r';
8000aa2e:	80 d2       	mov.d %d2,%a13
8000aa30:	80 df       	mov.d %d15,%a13
8000aa32:	46 02       	not %d2
8000aa34:	1b 14 00 30 	addi %d3,%d4,1
8000aa38:	42 2f       	add %d15,%d2
8000aa3a:	42 3f       	add %d15,%d3
8000aa3c:	8b 04 80 42 	ge %d4,%d4,0
8000aa40:	ab 0f 80 44 	sel %d4,%d4,%d15,0
8000aa44:	60 42       	mov.a %a2,%d4
					*dp++ = c;
				}
			}
			if (sign != '\0')
			{
				*dp++ = sign;
8000aa46:	40 d3       	mov.aa %a3,%a13
			}
			while (length-- > 0)
			{
				c = *cp++;
8000aa48:	79 3f 00 00 	ld.b %d15,[%a3]0
8000aa4c:	d9 37 01 00 	lea %a7,[%a3]1
				if (c == '\n')
8000aa50:	8b af 20 32 	ne %d3,%d15,10
8000aa54:	40 f3       	mov.aa %a3,%a15
8000aa56:	df 03 75 01 	jeq %d3,0,8000ad40 <usr_vsprintf+0x3dc>
				{
					*dp++ = '\r';
				}
				*dp++ = c;
8000aa5a:	2c 30       	st.b [%a3]0,%d15
8000aa5c:	d9 3f 01 00 	lea %a15,[%a3]1
			{
				*dp++ = sign;
			}
			while (length-- > 0)
			{
				c = *cp++;
8000aa60:	40 73       	mov.aa %a3,%a7
8000aa62:	fc 23       	loop %a2,8000aa48 <usr_vsprintf+0xe4>
				{
					*dp++ = '\r';
				}
				*dp++ = c;
			}
			if (pad_on_right)
8000aa64:	df 0a 8e 7f 	jeq %d10,0,8000a980 <usr_vsprintf+0x1c>
			{
				while (pad-- > 0)
8000aa68:	bf 18 8c 7f 	jlt %d8,1,8000a980 <usr_vsprintf+0x1c>
				{
					*dp++= ' ';
8000aa6c:	80 ff       	mov.d %d15,%a15
8000aa6e:	01 f8 00 26 	addsc.a %a2,%a15,%d8,0
8000aa72:	46 0f       	not %d15
8000aa74:	10 22       	addsc.a %a2,%a2,%d15,0
8000aa76:	28 09       	st.b [%a15]0,%d9
8000aa78:	b0 1f       	add.a %a15,1
8000aa7a:	fc 2e       	loop %a2,8000aa76 <usr_vsprintf+0x112>
8000aa7c:	3c 82       	j 8000a980 <usr_vsprintf+0x1c>
			/* handle type modifier */
			if (c == 'l' || c == 'h')
			{
				c = *fmt++;
			}
			switch (c)
8000aa7e:	60 e3       	mov.a %a3,%d14
8000aa80:	01 34 02 26 	addsc.a %a2,%a3,%d4,2
8000aa84:	dc 02       	ji %a2
8000aa86:	00 00       	nop 
8000aa88:	1d 00 59 01 	j 8000ad3a <usr_vsprintf+0x3d6>
8000aa8c:	1d ff c3 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aa90:	1d ff c1 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aa94:	1d ff bf ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aa98:	1d ff bd ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aa9c:	1d ff bb ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaa0:	1d ff b9 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaa4:	1d ff b7 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaa8:	1d ff b5 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaac:	1d ff b3 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aab0:	1d ff b1 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aab4:	1d ff af ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aab8:	1d ff ad ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aabc:	1d ff ab ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aac0:	1d ff a9 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aac4:	1d ff a7 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aac8:	1d ff a5 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aacc:	1d ff a3 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aad0:	1d ff a1 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aad4:	1d ff 9f ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aad8:	1d ff 9d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aadc:	1d ff 9b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aae0:	1d ff 99 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aae4:	1d ff 97 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aae8:	1d ff 95 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaec:	1d ff 93 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaf0:	1d ff 91 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaf4:	1d ff 8f ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aaf8:	1d ff 8d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aafc:	1d ff 8b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab00:	1d ff 89 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab04:	1d ff 87 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab08:	1d ff 85 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab0c:	1d ff 83 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab10:	1d ff 81 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab14:	1d ff 7f ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab18:	1d ff 7d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab1c:	1d ff 7b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab20:	1d ff 79 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab24:	1d ff 77 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab28:	1d ff 75 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab2c:	1d ff 73 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab30:	1d ff 71 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab34:	1d 00 de 00 	j 8000acf0 <usr_vsprintf+0x38c>
8000ab38:	1d ff 6d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab3c:	1d ff 6b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab40:	1d ff 69 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab44:	1d ff 67 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab48:	1d ff 65 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab4c:	1d ff 63 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab50:	1d ff 61 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab54:	1d 00 bf 00 	j 8000acd2 <usr_vsprintf+0x36e>
8000ab58:	1d ff 5d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab5c:	1d ff 5b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab60:	1d ff 59 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab64:	1d ff 57 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab68:	1d ff 55 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab6c:	1d ff 53 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab70:	1d ff 51 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab74:	1d ff 4f ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab78:	1d ff 4d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab7c:	1d ff 4b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab80:	1d 00 a3 00 	j 8000acc6 <usr_vsprintf+0x362>
8000ab84:	1d 00 a7 00 	j 8000acd2 <usr_vsprintf+0x36e>
8000ab88:	1d ff 45 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab8c:	1d ff 43 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab90:	1d ff 41 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab94:	1d ff 3f ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab98:	1d ff 3d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000ab9c:	1d ff 3b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aba0:	1d ff 39 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aba4:	1d ff 37 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000aba8:	1d ff 35 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abac:	1d ff 33 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abb0:	1d ff 31 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abb4:	1d 00 63 00 	j 8000ac7a <usr_vsprintf+0x316>
8000abb8:	1d ff 2d ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abbc:	1d ff 2b ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abc0:	1d 00 52 00 	j 8000ac64 <usr_vsprintf+0x300>
8000abc4:	1d ff 27 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abc8:	1d 00 85 00 	j 8000acd2 <usr_vsprintf+0x36e>
8000abcc:	1d ff 23 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abd0:	1d ff 21 ff 	j 8000aa12 <usr_vsprintf+0xae>
8000abd4:	1d 00 7f 00 	j 8000acd2 <usr_vsprintf+0x36e>
		}
		else
		{
			if (c == '\n')
			{
				*dp++= '\r';
8000abd8:	28 0b       	st.b [%a15]0,%d11
8000abda:	b0 1f       	add.a %a15,1
8000abdc:	1d ff dc fe 	j 8000a994 <usr_vsprintf+0x30>
		{
			c = *fmt++;
			left_prec = right_prec = pad_on_right = 0;
			if (c == '-')
			{
				c = *fmt++;
8000abe0:	79 cf 02 00 	ld.b %d15,[%a12]2
8000abe4:	d9 c2 03 00 	lea %a2,[%a12]3
				pad_on_right++;
			}
			if (c == '0')
8000abe8:	8b 0f 23 32 	ne %d3,%d15,48
			c = *fmt++;
			left_prec = right_prec = pad_on_right = 0;
			if (c == '-')
			{
				c = *fmt++;
				pad_on_right++;
8000abec:	82 1a       	mov %d10,1
				zero_fill = TRUE;
				c = *fmt++;
			}
			else
			{
				zero_fill = FALSE;
8000abee:	82 0c       	mov %d12,0
			if (c == '-')
			{
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
8000abf0:	df 03 ea fe 	jne %d3,0,8000a9c4 <usr_vsprintf+0x60>
			{
				zero_fill = TRUE;
				c = *fmt++;
8000abf4:	79 2f 00 00 	ld.b %d15,[%a2]0
				c = *fmt++;
				pad_on_right++;
			}
			if (c == '0')
			{
				zero_fill = TRUE;
8000abf8:	82 1c       	mov %d12,1
				c = *fmt++;
8000abfa:	b0 12       	add.a %a2,1
8000abfc:	1d ff e4 fe 	j 8000a9c4 <usr_vsprintf+0x60>
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
			}
			if (c == '.')
			{
				c = *fmt++;
8000ac00:	79 cf 00 00 	ld.b %d15,[%a12]0
8000ac04:	d9 c2 01 00 	lea %a2,[%a12]1
				zero_fill++;
				while (is_digit(c))
8000ac08:	1b 0f fd 2f 	addi %d2,%d15,-48
8000ac0c:	8f f2 0f 21 	and %d2,%d2,255
				c = *fmt++;
			}
			if (c == '.')
			{
				c = *fmt++;
				zero_fill++;
8000ac10:	c2 1c       	add %d12,1
				left_prec = (left_prec * 10) + (c - '0');
				c = *fmt++;
			}
			if (c == '.')
			{
				c = *fmt++;
8000ac12:	40 2c       	mov.aa %a12,%a2
				zero_fill++;
				while (is_digit(c))
8000ac14:	ff a2 f1 fe 	jge.u %d2,10,8000a9f6 <usr_vsprintf+0x92>
				{
					right_prec = (right_prec * 10) + (c - '0');
					c = *fmt++;
8000ac18:	79 2f 00 00 	ld.b %d15,[%a2]0
8000ac1c:	d9 2c 01 00 	lea %a12,[%a2]1
			}
			if (c == '.')
			{
				c = *fmt++;
				zero_fill++;
				while (is_digit(c))
8000ac20:	1b 0f fd 3f 	addi %d3,%d15,-48
8000ac24:	8f f3 0f 31 	and %d3,%d3,255
				{
					right_prec = (right_prec * 10) + (c - '0');
					c = *fmt++;
8000ac28:	40 c2       	mov.aa %a2,%a12
			}
			if (c == '.')
			{
				c = *fmt++;
				zero_fill++;
				while (is_digit(c))
8000ac2a:	bf a3 f7 ff 	jlt.u %d3,10,8000ac18 <usr_vsprintf+0x2b4>
8000ac2e:	1d ff e4 fe 	j 8000a9f6 <usr_vsprintf+0x92>
8000ac32:	da 20       	mov %d15,32
			}
			else
			{
				c = ' ';
			}
			if (!pad_on_right)
8000ac34:	f6 af       	jnz %d10,8000ac52 <usr_vsprintf+0x2ee>
			{
				while (pad-- > 0)
8000ac36:	1b f8 ff 5f 	addi %d5,%d8,-1
8000ac3a:	bf 18 8d 00 	jlt %d8,1,8000ad54 <usr_vsprintf+0x3f0>
8000ac3e:	80 f5       	mov.d %d5,%a15
8000ac40:	01 f8 00 56 	addsc.a %a5,%a15,%d8,0
8000ac44:	46 05       	not %d5
8000ac46:	01 55 00 56 	addsc.a %a5,%a5,%d5,0
				{
					*dp++ = c;
8000ac4a:	28 0f       	st.b [%a15]0,%d15
8000ac4c:	b0 1f       	add.a %a15,1
8000ac4e:	fc 5e       	loop %a5,8000ac4a <usr_vsprintf+0x2e6>
8000ac50:	82 f8       	mov %d8,-1
				}
			}
			if (sign != '\0')
8000ac52:	76 33       	jz %d3,8000ac58 <usr_vsprintf+0x2f4>
			{
				*dp++ = sign;
8000ac54:	28 03       	st.b [%a15]0,%d3
8000ac56:	b0 1f       	add.a %a15,1
			}
			while (length-- > 0)
8000ac58:	ff 12 eb 7e 	jge %d2,1,8000aa2e <usr_vsprintf+0xca>
				{
					*dp++ = '\r';
				}
				*dp++ = c;
			}
			if (pad_on_right)
8000ac5c:	df 0a 92 7e 	jeq %d10,0,8000a980 <usr_vsprintf+0x1c>
8000ac60:	1d ff 04 ff 	j 8000aa68 <usr_vsprintf+0x104>
							length = _cvt(val, buf, 16, "0123456789ABCDEF");
							break;
					}
					break;
				case 's' :
					cp = va_arg(ap, char *);
8000ac64:	d4 6d       	ld.a %a13,[%a6]
8000ac66:	80 6f       	mov.d %d15,%a6
					length = strlen(cp);
8000ac68:	40 d4       	mov.aa %a4,%a13
8000ac6a:	6d 00 cf 18 	call 8000de08 <strlen>
							length = _cvt(val, buf, 16, "0123456789ABCDEF");
							break;
					}
					break;
				case 's' :
					cp = va_arg(ap, char *);
8000ac6e:	c2 4f       	add %d15,4
8000ac70:	1b f2 ff 4f 	addi %d4,%d2,-1
8000ac74:	60 f6       	mov.a %a6,%d15
					length = strlen(cp);
					break;
8000ac76:	1d ff d4 fe 	j 8000aa1e <usr_vsprintf+0xba>
					continue;
				case '%' : /* '%%' ==> output '%' */
					*dp++ = c;
					break;
				case 'p' :
					p = va_arg(ap, unsigned int);
8000ac7a:	4c 60       	ld.w %d15,[%a6]0
8000ac7c:	d9 67 04 00 	lea %a7,[%a6]4
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000ac80:	df 0f cc 80 	jne %d15,0,8000ae18 <usr_vsprintf+0x4b4>
	{
		/* Special case */
		*cp++ = '0';
8000ac84:	da 30       	mov %d15,48
8000ac86:	e9 af 20 00 	st.b [%sp]32,%d15
8000ac8a:	d9 a4 21 00 	lea %a4,[%sp]33
8000ac8e:	01 4e 20 20 	sub.a %a2,%a14,%a4
8000ac92:	80 2f       	mov.d %d15,%a2
8000ac94:	40 43       	mov.aa %a3,%a4
8000ac96:	46 0f       	not %d15
8000ac98:	60 f2       	mov.a %a2,%d15
8000ac9a:	40 a5       	mov.aa %a5,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000ac9c:	09 3f 7f f4 	ld.bu %d15,[+%a3]-1
8000aca0:	2c 50       	st.b [%a5]0,%d15
8000aca2:	b0 15       	add.a %a5,1
8000aca4:	fc 2c       	loop %a2,8000ac9c <usr_vsprintf+0x338>
8000aca6:	d9 42 ff ff 	lea %a2,[%a4]-1
8000acaa:	01 32 20 20 	sub.a %a2,%a2,%a3
8000acae:	80 24       	mov.d %d4,%a2
8000acb0:	01 34 20 40 	sub.a %a4,%a4,%a3
8000acb4:	30 a4       	add.a %a4,%sp
8000acb6:	1b 14 00 20 	addi %d2,%d4,1
		length++;
	}
	*buf = '\0';
8000acba:	82 0f       	mov %d15,0
8000acbc:	2c 40       	st.b [%a4]0,%d15
					continue;
				case '%' : /* '%%' ==> output '%' */
					*dp++ = c;
					break;
				case 'p' :
					p = va_arg(ap, unsigned int);
8000acbe:	40 76       	mov.aa %a6,%a7
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000acc0:	40 ad       	mov.aa %a13,%sp
					*dp++ = c;
					break;
				case 'p' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789abcdef");
					break;
8000acc2:	1d ff ae fe 	j 8000aa1e <usr_vsprintf+0xba>
				case 's' :
					cp = va_arg(ap, char *);
					length = strlen(cp);
					break;
				case 'c' :
					c = (char)va_arg(ap, long);
8000acc6:	4c 60       	ld.w %d15,[%a6]0
8000acc8:	b0 46       	add.a %a6,4
8000acca:	28 0f       	st.b [%a15]0,%d15
					*dp++ = c;
8000accc:	b0 1f       	add.a %a15,1
					continue;
8000acce:	1d ff 59 fe 	j 8000a980 <usr_vsprintf+0x1c>
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
					switch (c)
8000acd2:	1b 8f fa ff 	addi %d15,%d15,-88
8000acd6:	8b 1f a2 32 	ge.u %d3,%d15,33
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000acda:	d9 64 04 00 	lea %a4,[%a6]4
8000acde:	54 62       	ld.w %d2,[%a6]
					switch (c)
8000ace0:	df 03 3d 00 	jeq %d3,0,8000ad5a <usr_vsprintf+0x3f6>
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000ace4:	40 46       	mov.aa %a6,%a4
					switch (c)
8000ace6:	82 f4       	mov %d4,-1
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
		length = 0;
8000ace8:	82 02       	mov %d2,0
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000acea:	40 ad       	mov.aa %a13,%sp
8000acec:	1d ff 99 fe 	j 8000aa1e <usr_vsprintf+0xba>
				case 'p' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789abcdef");
					break;
				case 'P' :
					p = va_arg(ap, unsigned int);
8000acf0:	4c 60       	ld.w %d15,[%a6]0
8000acf2:	d9 64 04 00 	lea %a4,[%a6]4
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000acf6:	ee 7b       	jnz %d15,8000adec <usr_vsprintf+0x488>
	{
		/* Special case */
		*cp++ = '0';
8000acf8:	da 30       	mov %d15,48
8000acfa:	e9 af 20 00 	st.b [%sp]32,%d15
8000acfe:	d9 a6 21 00 	lea %a6,[%sp]33
8000ad02:	01 6e 20 20 	sub.a %a2,%a14,%a6
8000ad06:	80 2f       	mov.d %d15,%a2
8000ad08:	40 63       	mov.aa %a3,%a6
8000ad0a:	46 0f       	not %d15
8000ad0c:	60 f2       	mov.a %a2,%d15
8000ad0e:	40 a5       	mov.aa %a5,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000ad10:	09 3f 7f f4 	ld.bu %d15,[+%a3]-1
8000ad14:	2c 50       	st.b [%a5]0,%d15
8000ad16:	b0 15       	add.a %a5,1
8000ad18:	fc 2c       	loop %a2,8000ad10 <usr_vsprintf+0x3ac>
8000ad1a:	d9 62 ff ff 	lea %a2,[%a6]-1
8000ad1e:	01 36 20 60 	sub.a %a6,%a6,%a3
8000ad22:	01 32 20 30 	sub.a %a3,%a2,%a3
8000ad26:	80 34       	mov.d %d4,%a3
8000ad28:	30 a6       	add.a %a6,%sp
8000ad2a:	1b 14 00 20 	addi %d2,%d4,1
		length++;
	}
	*buf = '\0';
8000ad2e:	82 0f       	mov %d15,0
8000ad30:	2c 60       	st.b [%a6]0,%d15
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000ad32:	40 ad       	mov.aa %a13,%sp
				case 'p' :
					p = va_arg(ap, unsigned int);
					length = _cvt(p, buf, 16, "0123456789abcdef");
					break;
				case 'P' :
					p = va_arg(ap, unsigned int);
8000ad34:	40 46       	mov.aa %a6,%a4
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
8000ad36:	1d ff 74 fe 	j 8000aa1e <usr_vsprintf+0xba>
				case 'c' :
					c = (char)va_arg(ap, long);
					*dp++ = c;
					continue;
				case '%' : /* '%%' ==> output '%' */
					*dp++ = c;
8000ad3a:	da 25       	mov %d15,37
8000ad3c:	1d ff 6c fe 	j 8000aa14 <usr_vsprintf+0xb0>
			while (length-- > 0)
			{
				c = *cp++;
				if (c == '\n')
				{
					*dp++ = '\r';
8000ad40:	b0 13       	add.a %a3,1
8000ad42:	28 0b       	st.b [%a15]0,%d11
8000ad44:	1d ff 8b fe 	j 8000aa5a <usr_vsprintf+0xf6>
			}
			else
			{
				c = ' ';
			}
			if (!pad_on_right)
8000ad48:	82 03       	mov %d3,0
8000ad4a:	da 30       	mov %d15,48
			{
				while (pad-- > 0)
8000ad4c:	1b f8 ff 5f 	addi %d5,%d8,-1
8000ad50:	ff 18 77 7f 	jge %d8,1,8000ac3e <usr_vsprintf+0x2da>
8000ad54:	02 58       	mov %d8,%d5
8000ad56:	1d ff 7e ff 	j 8000ac52 <usr_vsprintf+0x2ee>
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
					switch (c)
8000ad5a:	91 10 00 58 	movh.a %a5,32769
8000ad5e:	d9 55 e8 5a 	lea %a5,[%a5]-21144 <8000ad68 <usr_vsprintf+0x404>>
8000ad62:	90 52       	addsc.a %a2,%a5,%d15,2
8000ad64:	dc 02       	ji %a2
8000ad66:	00 00       	nop 
8000ad68:	1d 00 a6 00 	j 8000aeb4 <usr_vsprintf+0x550>
8000ad6c:	1d ff bc ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad70:	1d ff ba ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad74:	1d ff b8 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad78:	1d ff b6 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad7c:	1d ff b4 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad80:	1d ff b2 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad84:	1d ff b0 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad88:	1d ff ae ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad8c:	1d ff ac ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad90:	1d ff aa ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad94:	1d ff a8 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ad98:	1d 00 87 00 	j 8000aea6 <usr_vsprintf+0x542>
8000ad9c:	1d ff a4 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ada0:	1d ff a2 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ada4:	1d ff a0 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ada8:	1d ff 9e ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adac:	1d ff 9c ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adb0:	1d ff 9a ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adb4:	1d ff 98 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adb8:	1d ff 96 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adbc:	1d ff 94 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adc0:	1d ff 92 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adc4:	1d ff 90 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adc8:	1d ff 8e ff 	j 8000ace4 <usr_vsprintf+0x380>
8000adcc:	1d ff 8c ff 	j 8000ace4 <usr_vsprintf+0x380>
8000add0:	1d ff 8a ff 	j 8000ace4 <usr_vsprintf+0x380>
8000add4:	1d ff 88 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000add8:	1d ff 86 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000addc:	1d 00 34 00 	j 8000ae44 <usr_vsprintf+0x4e0>
8000ade0:	1d ff 82 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ade4:	1d ff 80 ff 	j 8000ace4 <usr_vsprintf+0x380>
8000ade8:	1d 00 92 00 	j 8000af0c <usr_vsprintf+0x5a8>
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000adec:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000adee:	91 00 00 58 	movh.a %a5,32768
8000adf2:	8f ff 00 21 	and %d2,%d15,15
8000adf6:	d9 55 74 a0 	lea %a5,[%a5]1716 <800006b4 <IfxScuCcu_aDefaultPllConfigSteps+0x40>>
8000adfa:	01 52 00 36 	addsc.a %a3,%a5,%d2,0
8000adfe:	d9 26 01 00 	lea %a6,[%a2]1
8000ae02:	14 32       	ld.bu %d2,[%a3]
			val /= radix;
8000ae04:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000ae06:	34 22       	st.b [%a2],%d2
8000ae08:	40 62       	mov.aa %a2,%a6
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000ae0a:	ee f2       	jnz %d15,8000adee <usr_vsprintf+0x48a>
		{
			*cp++ = digits[val % radix];
			val /= radix;
		}
	}
	while (cp != temp)
8000ae0c:	7d e6 7b ff 	jne.a %a6,%a14,8000ad02 <usr_vsprintf+0x39e>
8000ae10:	82 f4       	mov %d4,-1
8000ae12:	82 02       	mov %d2,0
8000ae14:	40 a6       	mov.aa %a6,%sp
8000ae16:	3c 8c       	j 8000ad2e <usr_vsprintf+0x3ca>
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000ae18:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000ae1a:	91 00 00 48 	movh.a %a4,32768
8000ae1e:	8f ff 00 21 	and %d2,%d15,15
8000ae22:	d9 44 63 a0 	lea %a4,[%a4]1699 <800006a3 <IfxScuCcu_aDefaultPllConfigSteps+0x2f>>
8000ae26:	01 42 00 36 	addsc.a %a3,%a4,%d2,0
			val /= radix;
8000ae2a:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000ae2c:	14 32       	ld.bu %d2,[%a3]
8000ae2e:	34 22       	st.b [%a2],%d2
8000ae30:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000ae32:	ee f4       	jnz %d15,8000ae1a <usr_vsprintf+0x4b6>
		{
			*cp++ = digits[val % radix];
8000ae34:	40 24       	mov.aa %a4,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000ae36:	7d e2 2c ff 	jne.a %a2,%a14,8000ac8e <usr_vsprintf+0x32a>
8000ae3a:	82 f4       	mov %d4,-1
8000ae3c:	82 02       	mov %d2,0
8000ae3e:	40 a4       	mov.aa %a4,%sp
8000ae40:	1d ff 3d ff 	j 8000acba <usr_vsprintf+0x356>
			}
			else
			{
				right_prec = left_prec;
			}
			sign = '\0';
8000ae44:	82 03       	mov %d3,0
								sign = '-';
								val = -val;
							} // @suppress("No break at end of case")
							/* fall through */
						case 'u' :
							length = _cvt(val, buf, 10, "0123456789");
8000ae46:	02 2f       	mov %d15,%d2
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000ae48:	df 02 8e 80 	jne %d2,0,8000af64 <usr_vsprintf+0x600>
	{
		/* Special case */
		*cp++ = '0';
8000ae4c:	da 30       	mov %d15,48
8000ae4e:	e9 af 20 00 	st.b [%sp]32,%d15
8000ae52:	d9 a6 21 00 	lea %a6,[%sp]33
8000ae56:	01 6e 20 20 	sub.a %a2,%a14,%a6
8000ae5a:	80 2f       	mov.d %d15,%a2
8000ae5c:	40 63       	mov.aa %a3,%a6
8000ae5e:	46 0f       	not %d15
8000ae60:	60 f2       	mov.a %a2,%d15
8000ae62:	40 a5       	mov.aa %a5,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000ae64:	09 3f 7f f4 	ld.bu %d15,[+%a3]-1
8000ae68:	2c 50       	st.b [%a5]0,%d15
8000ae6a:	b0 15       	add.a %a5,1
8000ae6c:	fc 2c       	loop %a2,8000ae64 <usr_vsprintf+0x500>
8000ae6e:	d9 62 ff ff 	lea %a2,[%a6]-1
8000ae72:	01 36 20 60 	sub.a %a6,%a6,%a3
8000ae76:	01 32 20 30 	sub.a %a3,%a2,%a3
8000ae7a:	80 34       	mov.d %d4,%a3
8000ae7c:	30 a6       	add.a %a6,%sp
8000ae7e:	1b 14 00 20 	addi %d2,%d4,1
		length++;
	}
	*buf = '\0';
8000ae82:	82 0f       	mov %d15,0
8000ae84:	2c 60       	st.b [%a6]0,%d15
					length = _cvt(p, buf, 16, "0123456789ABCDEF");
					break;
				default:
					*dp++ = '?';
			}
			pad = left_prec - length;
8000ae86:	a2 28       	sub %d8,%d2
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000ae88:	40 46       	mov.aa %a6,%a4
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000ae8a:	40 ad       	mov.aa %a13,%sp
					break;
				default:
					*dp++ = '?';
			}
			pad = left_prec - length;
			if (sign != '\0')
8000ae8c:	df 03 ca 7d 	jeq %d3,0,8000aa20 <usr_vsprintf+0xbc>
			{
				pad--;
8000ae90:	c2 f8       	add %d8,-1
			{
				case 'd' :
				case 'u' :
				case 'x' :
				case 'X' :
					val = va_arg(ap, long);
8000ae92:	40 46       	mov.aa %a6,%a4
	char buf[32];
	long val;

	while ((c = *fmt++) != 0)
	{
		cp = buf;
8000ae94:	40 ad       	mov.aa %a13,%sp
			pad = left_prec - length;
			if (sign != '\0')
			{
				pad--;
			}
			if (zero_fill)
8000ae96:	df 0c ce 7e 	jeq %d12,0,8000ac32 <usr_vsprintf+0x2ce>
			{
				c = '0';
				if (sign != '\0')
				{
					*dp++ = sign;
8000ae9a:	28 03       	st.b [%a15]0,%d3
8000ae9c:	40 46       	mov.aa %a6,%a4
8000ae9e:	b0 1f       	add.a %a15,1
8000aea0:	40 ad       	mov.aa %a13,%sp
8000aea2:	1d ff c2 fd 	j 8000aa26 <usr_vsprintf+0xc2>
			}
			else
			{
				right_prec = left_prec;
			}
			sign = '\0';
8000aea6:	82 03       	mov %d3,0
				case 'X' :
					val = va_arg(ap, long);
					switch (c)
					{
						case 'd' :
							if (val < 0)
8000aea8:	ff 02 cf 7f 	jge %d2,0,8000ae46 <usr_vsprintf+0x4e2>
							{
								sign = '-';
								val = -val;
8000aeac:	32 52       	rsub %d2
					switch (c)
					{
						case 'd' :
							if (val < 0)
							{
								sign = '-';
8000aeae:	3b d0 02 30 	mov %d3,45
8000aeb2:	3c ca       	j 8000ae46 <usr_vsprintf+0x4e2>
							break;
						case 'x' :
							length = _cvt(val, buf, 16, "0123456789abcdef");
							break;
						case 'X' :
							length = _cvt(val, buf, 16, "0123456789ABCDEF");
8000aeb4:	02 2f       	mov %d15,%d2
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000aeb6:	df 02 7c 00 	jeq %d2,0,8000afae <usr_vsprintf+0x64a>
8000aeba:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000aebc:	91 00 00 58 	movh.a %a5,32768
8000aec0:	8f ff 00 21 	and %d2,%d15,15
8000aec4:	d9 55 74 a0 	lea %a5,[%a5]1716 <800006b4 <IfxScuCcu_aDefaultPllConfigSteps+0x40>>
8000aec8:	01 52 00 36 	addsc.a %a3,%a5,%d2,0
			val /= radix;
8000aecc:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000aece:	14 32       	ld.bu %d2,[%a3]
8000aed0:	34 22       	st.b [%a2],%d2
8000aed2:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000aed4:	ee f4       	jnz %d15,8000aebc <usr_vsprintf+0x558>
		{
			*cp++ = digits[val % radix];
8000aed6:	40 26       	mov.aa %a6,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000aed8:	7d e2 9c 7f 	jeq.a %a2,%a14,8000ae10 <usr_vsprintf+0x4ac>
	int length = 0;

	if (val == 0)
	{
		/* Special case */
		*cp++ = '0';
8000aedc:	01 6e 20 50 	sub.a %a5,%a14,%a6
8000aee0:	80 5f       	mov.d %d15,%a5
8000aee2:	40 62       	mov.aa %a2,%a6
8000aee4:	46 0f       	not %d15
8000aee6:	60 f5       	mov.a %a5,%d15
8000aee8:	40 a3       	mov.aa %a3,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000aeea:	09 2f 7f f4 	ld.bu %d15,[+%a2]-1
8000aeee:	2c 30       	st.b [%a3]0,%d15
8000aef0:	b0 13       	add.a %a3,1
8000aef2:	fc 5c       	loop %a5,8000aeea <usr_vsprintf+0x586>
8000aef4:	d9 63 ff ff 	lea %a3,[%a6]-1
8000aef8:	01 23 20 30 	sub.a %a3,%a3,%a2
8000aefc:	80 34       	mov.d %d4,%a3
8000aefe:	01 26 20 60 	sub.a %a6,%a6,%a2
8000af02:	30 a6       	add.a %a6,%sp
8000af04:	1b 14 00 20 	addi %d2,%d4,1
8000af08:	1d ff 13 ff 	j 8000ad2e <usr_vsprintf+0x3ca>
							/* fall through */
						case 'u' :
							length = _cvt(val, buf, 10, "0123456789");
							break;
						case 'x' :
							length = _cvt(val, buf, 16, "0123456789abcdef");
8000af0c:	02 2f       	mov %d15,%d2
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000af0e:	df 02 4a 00 	jeq %d2,0,8000afa2 <usr_vsprintf+0x63e>
8000af12:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000af14:	91 00 00 58 	movh.a %a5,32768
8000af18:	8f ff 00 21 	and %d2,%d15,15
8000af1c:	d9 55 63 a0 	lea %a5,[%a5]1699 <800006a3 <IfxScuCcu_aDefaultPllConfigSteps+0x2f>>
8000af20:	01 52 00 36 	addsc.a %a3,%a5,%d2,0
			val /= radix;
8000af24:	06 cf       	sh %d15,-4
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000af26:	14 32       	ld.bu %d2,[%a3]
8000af28:	34 22       	st.b [%a2],%d2
8000af2a:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000af2c:	ee f4       	jnz %d15,8000af14 <usr_vsprintf+0x5b0>
		{
			*cp++ = digits[val % radix];
8000af2e:	40 26       	mov.aa %a6,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000af30:	7d e2 70 7f 	jeq.a %a2,%a14,8000ae10 <usr_vsprintf+0x4ac>
	int length = 0;

	if (val == 0)
	{
		/* Special case */
		*cp++ = '0';
8000af34:	01 6e 20 50 	sub.a %a5,%a14,%a6
8000af38:	80 5f       	mov.d %d15,%a5
8000af3a:	40 62       	mov.aa %a2,%a6
8000af3c:	46 0f       	not %d15
8000af3e:	60 f5       	mov.a %a5,%d15
8000af40:	40 a3       	mov.aa %a3,%sp
			val /= radix;
		}
	}
	while (cp != temp)
	{
		*buf++ = *--cp;
8000af42:	09 2f 7f f4 	ld.bu %d15,[+%a2]-1
8000af46:	2c 30       	st.b [%a3]0,%d15
8000af48:	b0 13       	add.a %a3,1
8000af4a:	fc 5c       	loop %a5,8000af42 <usr_vsprintf+0x5de>
8000af4c:	d9 63 ff ff 	lea %a3,[%a6]-1
8000af50:	01 26 20 60 	sub.a %a6,%a6,%a2
8000af54:	01 23 20 20 	sub.a %a2,%a3,%a2
8000af58:	80 24       	mov.d %d4,%a2
8000af5a:	30 a6       	add.a %a6,%sp
8000af5c:	1b 14 00 20 	addi %d2,%d4,1
8000af60:	1d ff e7 fe 	j 8000ad2e <usr_vsprintf+0x3ca>
{
	char temp[80];
	char *cp = temp;
	int length = 0;

	if (val == 0)
8000af64:	40 e2       	mov.aa %a2,%a14
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000af66:	7b d0 cc 4c 	movh %d4,52429
8000af6a:	1b d4 cc 4c 	addi %d4,%d4,-13107
8000af6e:	73 4f 68 40 	mul.u %e4,%d15,%d4
8000af72:	91 00 00 58 	movh.a %a5,32768
8000af76:	d9 55 58 a0 	lea %a5,[%a5]1688 <80000698 <IfxScuCcu_aDefaultPllConfigSteps+0x24>>
8000af7a:	8f d5 1f 20 	sh %d2,%d5,-3
8000af7e:	53 a2 20 40 	mul %d4,%d2,10
8000af82:	a2 4f       	sub %d15,%d4
8000af84:	10 53       	addsc.a %a3,%a5,%d15,0
8000af86:	0c 30       	ld.bu %d15,[%a3]0
8000af88:	2c 20       	st.b [%a2]0,%d15
			val /= radix;
8000af8a:	02 2f       	mov %d15,%d2
	}
	else
	{
		while (val)
		{
			*cp++ = digits[val % radix];
8000af8c:	b0 12       	add.a %a2,1
		/* Special case */
		*cp++ = '0';
	}
	else
	{
		while (val)
8000af8e:	df 02 ec ff 	jne %d2,0,8000af66 <usr_vsprintf+0x602>
		{
			*cp++ = digits[val % radix];
8000af92:	40 26       	mov.aa %a6,%a2
			val /= radix;
		}
	}
	while (cp != temp)
8000af94:	7d e2 61 ff 	jne.a %a2,%a14,8000ae56 <usr_vsprintf+0x4f2>
8000af98:	82 f4       	mov %d4,-1
8000af9a:	82 02       	mov %d2,0
8000af9c:	40 a6       	mov.aa %a6,%sp
8000af9e:	1d ff 72 ff 	j 8000ae82 <usr_vsprintf+0x51e>
	int length = 0;

	if (val == 0)
	{
		/* Special case */
		*cp++ = '0';
8000afa2:	da 30       	mov %d15,48
8000afa4:	e9 af 20 00 	st.b [%sp]32,%d15
8000afa8:	d9 a6 21 00 	lea %a6,[%sp]33
8000afac:	3c c4       	j 8000af34 <usr_vsprintf+0x5d0>
8000afae:	da 30       	mov %d15,48
8000afb0:	e9 af 20 00 	st.b [%sp]32,%d15
8000afb4:	d9 a6 21 00 	lea %a6,[%sp]33
8000afb8:	3c 92       	j 8000aedc <usr_vsprintf+0x578>

8000afba <usr_sprintf>:
{
	int ret;
	va_list ap;

	va_start(ap, fmt);
	ret = usr_vsprintf(buf, fmt, ap);
8000afba:	40 a6       	mov.aa %a6,%sp
	va_end(ap);

	return ret;
}
8000afbc:	1d ff d4 fc 	j 8000a964 <usr_vsprintf>

8000afc0 <my_puts>:
#define BUFSIZE		128
#define KB_BS '\x7F'
#define KB_CR '\r'

void my_puts(const char *str)
{
8000afc0:	20 88       	sub.a %sp,136
	char buffer[BUFSIZE];
	char *ptr;

	usr_sprintf(buffer, "%s\r\n", str);
8000afc2:	91 00 00 58 	movh.a %a5,32768
8000afc6:	f4 a4       	st.a [%sp],%a4
8000afc8:	d9 55 45 b0 	lea %a5,[%a5]1733 <800006c5 <IfxScuCcu_aDefaultPllConfigSteps+0x51>>
8000afcc:	d9 a4 08 00 	lea %a4,[%sp]8 <800006c5 <IfxScuCcu_aDefaultPllConfigSteps+0x51>>
8000afd0:	6d ff f5 ff 	call 8000afba <usr_sprintf>

	for (ptr = buffer; *ptr; ++ptr)
8000afd4:	79 af 08 00 	ld.b %d15,[%sp]8
8000afd8:	d9 af 08 00 	lea %a15,[%sp]8
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));

	TX_CLEAR(MODULE_ASCLIN3);
8000afdc:	7b 00 00 38 	movh %d3,32768
	char buffer[BUFSIZE];
	char *ptr;

	usr_sprintf(buffer, "%s\r\n", str);

	for (ptr = buffer; *ptr; ++ptr)
8000afe0:	6e 0e       	jz %d15,8000affc <my_puts+0x3c>
		_out_uart3((const unsigned char) *ptr);
8000afe2:	8f ff 0f 21 	and %d2,%d15,255

/* Send character CHR via the serial line */
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));
8000afe6:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000afea:	ff 0f fe 7f 	jge %d15,0,8000afe6 <my_puts+0x26>

	TX_CLEAR(MODULE_ASCLIN3);
8000afee:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN3, chr);
8000aff2:	a5 f2 84 50 	st.w f0000944 <_SMALL_DATA4_+0x3fff8944>,%d2
	char buffer[BUFSIZE];
	char *ptr;

	usr_sprintf(buffer, "%s\r\n", str);

	for (ptr = buffer; *ptr; ++ptr)
8000aff6:	09 ff 01 04 	ld.b %d15,[+%a15]1
8000affa:	ee f4       	jnz %d15,8000afe2 <my_puts+0x22>
8000affc:	00 90       	ret 

8000affe <my_printf>:
		_out_uart3((const unsigned char) *ptr);
}

void my_printf(const char *fmt, ...)
{
8000affe:	d9 aa c0 cf 	lea %sp,[%sp]-256
8000b002:	40 45       	mov.aa %a5,%a4
	char buffer2[BUFSIZE]; // add \r before \n
	char *ptr;
	va_list ap;

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
8000b004:	d9 a6 00 40 	lea %a6,[%sp]256
8000b008:	40 a4       	mov.aa %a4,%sp
8000b00a:	6d 00 a9 17 	call 8000df5c <vsprintf>
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000b00e:	79 af 00 00 	ld.b %d15,[%sp]0
	va_list ap;

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
8000b012:	a0 0f       	mov.a %a15,0
	for (int i = 0; buffer[i]; i++) {
8000b014:	6e 28       	jz %d15,8000b064 <my_printf+0x66>
8000b016:	a0 02       	mov.a %a2,0
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
8000b018:	3b d0 00 30 	mov %d3,13
8000b01c:	3c 0c       	j 8000b034 <my_printf+0x36>
			buffer2[j++] = buffer[i];
		} else {
			buffer2[j++] = buffer[i];
8000b01e:	d9 a3 00 20 	lea %a3,[%sp]128
8000b022:	30 f3       	add.a %a3,%a15
8000b024:	2c 30       	st.b [%a3]0,%d15

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000b026:	b0 12       	add.a %a2,1
8000b028:	40 a3       	mov.aa %a3,%sp
8000b02a:	30 23       	add.a %a3,%a2
8000b02c:	79 3f 00 00 	ld.b %d15,[%a3]0
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
			buffer2[j++] = buffer[i];
		} else {
			buffer2[j++] = buffer[i];
8000b030:	b0 1f       	add.a %a15,1

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000b032:	6e 19       	jz %d15,8000b064 <my_printf+0x66>
		if (buffer[i] == '\n') {
8000b034:	8b af 20 22 	ne %d2,%d15,10
8000b038:	df 02 f3 ff 	jne %d2,0,8000b01e <my_printf+0x20>
			buffer2[j++] = '\r';
8000b03c:	d9 a3 00 20 	lea %a3,[%sp]128
8000b040:	30 f3       	add.a %a3,%a15
8000b042:	34 33       	st.b [%a3],%d3
8000b044:	d9 f4 01 00 	lea %a4,[%a15]1
			buffer2[j++] = buffer[i];
8000b048:	d9 a3 00 20 	lea %a3,[%sp]128
8000b04c:	30 34       	add.a %a4,%a3
8000b04e:	40 a3       	mov.aa %a3,%sp
8000b050:	30 23       	add.a %a3,%a2
8000b052:	0c 30       	ld.bu %d15,[%a3]0

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000b054:	b0 12       	add.a %a2,1
8000b056:	40 a3       	mov.aa %a3,%sp
8000b058:	30 23       	add.a %a3,%a2
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
			buffer2[j++] = buffer[i];
8000b05a:	2c 40       	st.b [%a4]0,%d15

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000b05c:	79 3f 00 00 	ld.b %d15,[%a3]0
		if (buffer[i] == '\n') {
			buffer2[j++] = '\r';
			buffer2[j++] = buffer[i];
8000b060:	b0 2f       	add.a %a15,2

	va_start(ap, fmt);
	vsprintf(buffer, fmt, ap);
	va_end(ap);
	int j = 0;
	for (int i = 0; buffer[i]; i++) {
8000b062:	ee e9       	jnz %d15,8000b034 <my_printf+0x36>
			buffer2[j++] = buffer[i];
		} else {
			buffer2[j++] = buffer[i];
		}
	}
	buffer2[j] = '\0';
8000b064:	d9 a2 00 20 	lea %a2,[%sp]128
8000b068:	30 2f       	add.a %a15,%a2
8000b06a:	82 0f       	mov %d15,0
8000b06c:	28 0f       	st.b [%a15]0,%d15

	for (ptr = buffer2; *ptr; ++ptr)
8000b06e:	79 af 00 20 	ld.b %d15,[%sp]128
8000b072:	40 2f       	mov.aa %a15,%a2
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));

	TX_CLEAR(MODULE_ASCLIN3);
8000b074:	7b 00 00 38 	movh %d3,32768
			buffer2[j++] = buffer[i];
		}
	}
	buffer2[j] = '\0';

	for (ptr = buffer2; *ptr; ++ptr)
8000b078:	6e 0e       	jz %d15,8000b094 <my_printf+0x96>
		_out_uart3((const unsigned char) *ptr);
8000b07a:	8f ff 0f 21 	and %d2,%d15,255

/* Send character CHR via the serial line */
void _out_uart3(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN3));
8000b07e:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000b082:	ff 0f fe 7f 	jge %d15,0,8000b07e <my_printf+0x80>

	TX_CLEAR(MODULE_ASCLIN3);
8000b086:	a5 f3 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d3

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN3, chr);
8000b08a:	a5 f2 84 50 	st.w f0000944 <_SMALL_DATA4_+0x3fff8944>,%d2
			buffer2[j++] = buffer[i];
		}
	}
	buffer2[j] = '\0';

	for (ptr = buffer2; *ptr; ++ptr)
8000b08e:	09 ff 01 04 	ld.b %d15,[+%a15]1
8000b092:	ee f4       	jnz %d15,8000b07a <my_printf+0x7c>
8000b094:	00 90       	ret 

8000b096 <my_scanf>:
		_out_uart3((const unsigned char) *ptr);
}

void my_scanf(const char *fmt, ...)
{
8000b096:	d9 aa b8 ff 	lea %sp,[%sp]-1032
	char *pstr, *pidx;
	va_list ap;
	va_start(ap, fmt);

	idx = 0;
	memset(buf, 0, 512);
8000b09a:	d9 ac 08 00 	lea %a12,[%sp]8
8000b09e:	40 c2       	mov.aa %a2,%a12
8000b0a0:	91 00 00 d8 	movh.a %a13,32768
	for (ptr = buffer2; *ptr; ++ptr)
		_out_uart3((const unsigned char) *ptr);
}

void my_scanf(const char *fmt, ...)
{
8000b0a4:	40 4f       	mov.aa %a15,%a4
	char c = 0, buf[512];
	int idx, i;
	char *pstr, *pidx;
	va_list ap;
	va_start(ap, fmt);
8000b0a6:	d9 ae 48 00 	lea %a14,[%sp]1032

	idx = 0;
	memset(buf, 0, 512);
8000b0aa:	d2 02       	mov %e2,0
8000b0ac:	c5 03 3f 00 	lea %a3,3f <_.+0x3e>
8000b0b0:	89 22 48 01 	st.d [%a2+]8,%e2
8000b0b4:	fc 3e       	loop %a3,8000b0b0 <my_scanf+0x1a>
	int idx, i;
	char *pstr, *pidx;
	va_list ap;
	va_start(ap, fmt);

	idx = 0;
8000b0b6:	82 0a       	mov %d10,0
8000b0b8:	d9 dd 4a b0 	lea %a13,[%a13]1738 <800006ca <IfxScuCcu_aDefaultPllConfigSteps+0x56>>

	if (RX_READY(MODULE_ASCLIN3))
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000b0bc:	7b 00 00 91 	movh %d9,4096
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000b0c0:	7b 50 40 80 	movh %d8,1029
int _poll_uart3(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;

	if (RX_READY(MODULE_ASCLIN3))
8000b0c4:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000b0c8:	ef cf fe 7f 	jz.t %d15,28,8000b0c4 <my_scanf+0x2e>
	{
		ret = (unsigned char)GET_CHAR(MODULE_ASCLIN3);
8000b0cc:	85 f2 88 50 	ld.w %d2,f0000948 <_SMALL_DATA4_+0x3fff8948>
		/* acknowledge receive */
		RX_CLEAR(MODULE_ASCLIN3);
8000b0d0:	a5 f9 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d9
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
8000b0d4:	85 ff b4 40 	ld.w %d15,f0000934 <_SMALL_DATA4_+0x3fff8934>
8000b0d8:	26 8f       	and %d15,%d8
8000b0da:	ee 14       	jnz %d15,8000b102 <my_scanf+0x6c>

	idx = 0;
	memset(buf, 0, 512);
	while (c != '\r')
	{
		c = _in_uart3();
8000b0dc:	37 02 48 20 	extr %d2,%d2,0,8
		if (c == KB_BS)
8000b0e0:	8b f2 07 32 	eq %d3,%d2,127
8000b0e4:	df 03 12 80 	jne %d3,0,8000b108 <my_scanf+0x72>
			if (idx != 0) { buf[idx--] = 0; }
			else { continue; }
		}
		else
		{
			if (c == KB_CR) { buf[idx++] = '\0'; }
8000b0e8:	8b d2 20 32 	ne %d3,%d2,13
8000b0ec:	01 ca 00 26 	addsc.a %a2,%a12,%d10,0
8000b0f0:	df 03 13 00 	jeq %d3,0,8000b116 <my_scanf+0x80>
			else { buf[idx++] = c; }
8000b0f4:	34 22       	st.b [%a2],%d2
8000b0f6:	c2 1a       	add %d10,1
		}
		my_printf("%c", c);
8000b0f8:	74 a2       	st.w [%sp],%d2
8000b0fa:	40 d4       	mov.aa %a4,%a13
8000b0fc:	6d ff 81 ff 	call 8000affe <my_printf>
8000b100:	3c e2       	j 8000b0c4 <my_scanf+0x2e>
		RX_CLEAR(MODULE_ASCLIN3);
		/* check for error condition */
		if (GET_ERROR_STATUS(MODULE_ASCLIN3))
		{
			/* reset error flags */
			RESET_ERROR(MODULE_ASCLIN3);
8000b102:	a5 f8 bc 40 	st.w f000093c <_SMALL_DATA4_+0x3fff893c>,%d8
8000b106:	3c df       	j 8000b0c4 <my_scanf+0x2e>
	while (c != '\r')
	{
		c = _in_uart3();
		if (c == KB_BS)
		{
			if (idx != 0) { buf[idx--] = 0; }
8000b108:	df 0a de 7f 	jeq %d10,0,8000b0c4 <my_scanf+0x2e>
8000b10c:	01 ca 00 26 	addsc.a %a2,%a12,%d10,0
8000b110:	c2 fa       	add %d10,-1
8000b112:	2c 20       	st.b [%a2]0,%d15
8000b114:	3c f2       	j 8000b0f8 <my_scanf+0x62>
			else { continue; }
		}
		else
		{
			if (c == KB_CR) { buf[idx++] = '\0'; }
8000b116:	2c 20       	st.b [%a2]0,%d15
			else { buf[idx++] = c; }
		}
		my_printf("%c", c);
8000b118:	40 d4       	mov.aa %a4,%a13
8000b11a:	74 a2       	st.w [%sp],%d2
8000b11c:	6d ff 71 ff 	call 8000affe <my_printf>
	}
	my_printf("\r\n");
8000b120:	91 00 00 48 	movh.a %a4,32768
8000b124:	d9 44 4d b0 	lea %a4,[%a4]1741 <800006cd <IfxScuCcu_aDefaultPllConfigSteps+0x59>>
8000b128:	6d ff 6b ff 	call 8000affe <my_printf>
					pidx = strchr(buf, ' ');
					if (pidx != NULL) { *pidx = '\0'; }
					for (i = 0; ; i++)
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
8000b12c:	82 08       	mov %d8,0
	int i, start_idx;
	char buf[512];

	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
8000b12e:	d9 ad 08 80 	lea %a13,[%sp]520
		}
		my_printf("%c", c);
	}
	my_printf("\r\n");

	while ((c = *fmt++) != 0)
8000b132:	3c 05       	j 8000b13c <my_scanf+0xa6>
	{
		if (c == '%')
8000b134:	8b 5f 22 f2 	ne %d15,%d15,37
8000b138:	6e 08       	jz %d15,8000b148 <my_scanf+0xb2>
		}
		my_printf("%c", c);
	}
	my_printf("\r\n");

	while ((c = *fmt++) != 0)
8000b13a:	40 2f       	mov.aa %a15,%a2
8000b13c:	79 ff 00 00 	ld.b %d15,[%a15]0
8000b140:	d9 f2 01 00 	lea %a2,[%a15]1
8000b144:	ee f8       	jnz %d15,8000b134 <my_scanf+0x9e>
8000b146:	00 90       	ret 
	{
		if (c == '%')
		{
			c = *fmt++;
			switch (c)
8000b148:	79 ff 01 00 	ld.b %d15,[%a15]1

	while ((c = *fmt++) != 0)
	{
		if (c == '%')
		{
			c = *fmt++;
8000b14c:	80 f9       	mov.d %d9,%a15
			switch (c)
8000b14e:	8b 4f 06 22 	eq %d2,%d15,100

	while ((c = *fmt++) != 0)
	{
		if (c == '%')
		{
			c = *fmt++;
8000b152:	c2 29       	add %d9,2
			switch (c)
8000b154:	df 02 57 80 	jne %d2,0,8000b202 <my_scanf+0x16c>
8000b158:	8b 3f 07 22 	eq %d2,%d15,115
8000b15c:	df 02 34 80 	jne %d2,0,8000b1c4 <my_scanf+0x12e>
8000b160:	8b 3f 06 f2 	eq %d15,%d15,99
8000b164:	ee 48       	jnz %d15,8000b1f4 <my_scanf+0x15e>
void remove_null(char *s)
{
	int i, start_idx;
	char buf[512];

	start_idx = 0;
8000b166:	a0 0f       	mov.a %a15,0
	while (*(s + start_idx++) == '\0');
8000b168:	b0 1f       	add.a %a15,1
8000b16a:	d9 a2 07 00 	lea %a2,[%sp]7
8000b16e:	30 f2       	add.a %a2,%a15
8000b170:	79 2f 00 00 	ld.b %d15,[%a2]0
8000b174:	6e fa       	jz %d15,8000b168 <my_scanf+0xd2>
	memset(buf, 0, 512);
8000b176:	40 d2       	mov.aa %a2,%a13
8000b178:	d2 02       	mov %e2,0
8000b17a:	c5 03 3f 00 	lea %a3,3f <_.+0x3e>
8000b17e:	89 22 48 01 	st.d [%a2+]8,%e2
8000b182:	fc 3e       	loop %a3,8000b17e <my_scanf+0xe8>
	strcpy(buf, (s + (start_idx - 1)));
8000b184:	b0 ff       	add.a %a15,-1
8000b186:	40 d2       	mov.aa %a2,%a13
8000b188:	30 cf       	add.a %a15,%a12
8000b18a:	04 ff       	ld.bu %d15,[%a15+]
8000b18c:	24 2f       	st.b [%a2+],%d15
8000b18e:	ee fe       	jnz %d15,8000b18a <my_scanf+0xf4>

	memset(s, 0, 512);
8000b190:	40 c2       	mov.aa %a2,%a12
	i = 0;
	while (buf[i] != '\0')
8000b192:	79 af 08 80 	ld.b %d15,[%sp]520
	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
8000b196:	d2 02       	mov %e2,0
8000b198:	c5 03 3f 00 	lea %a3,3f <_.+0x3e>
8000b19c:	89 22 48 01 	st.d [%a2+]8,%e2
8000b1a0:	fc 3e       	loop %a3,8000b19c <my_scanf+0x106>
	i = 0;
	while (buf[i] != '\0')
8000b1a2:	40 cf       	mov.aa %a15,%a12
8000b1a4:	6e 0d       	jz %d15,8000b1be <my_scanf+0x128>
8000b1a6:	82 02       	mov %d2,0
	{
		*(s + i) = buf[i];
8000b1a8:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
		++i;
8000b1ac:	c2 12       	add %d2,1

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
	{
		*(s + i) = buf[i];
8000b1ae:	28 0f       	st.b [%a15]0,%d15
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
8000b1b0:	01 d2 00 f6 	addsc.a %a15,%a13,%d2,0
8000b1b4:	79 ff 00 00 	ld.b %d15,[%a15]0
8000b1b8:	ee f8       	jnz %d15,8000b1a8 <my_scanf+0x112>
8000b1ba:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
	{
		*(s + i) = buf[i];
		++i;
	}
	*(s + i) = '\0';
8000b1be:	28 08       	st.b [%a15]0,%d8

	while ((c = *fmt++) != 0)
	{
		if (c == '%')
		{
			c = *fmt++;
8000b1c0:	60 9f       	mov.a %a15,%d9
8000b1c2:	3c bd       	j 8000b13c <my_scanf+0xa6>
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
8000b1c4:	cc e0       	ld.a %a15,[%a14]0
					for (i = 0; buf[i] != '\0'; i++)
8000b1c6:	79 cf 00 00 	ld.b %d15,[%a12]0
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
8000b1ca:	d9 e3 04 00 	lea %a3,[%a14]4
8000b1ce:	40 f2       	mov.aa %a2,%a15
					for (i = 0; buf[i] != '\0'; i++)
8000b1d0:	6e 0f       	jz %d15,8000b1ee <my_scanf+0x158>
8000b1d2:	82 02       	mov %d2,0
					{
						*pstr++ = buf[i];
8000b1d4:	28 0f       	st.b [%a15]0,%d15
8000b1d6:	d9 f2 01 00 	lea %a2,[%a15]1
						buf[i] = '\0';
8000b1da:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
					for (i = 0; buf[i] != '\0'; i++)
8000b1de:	c2 12       	add %d2,1
					{
						*pstr++ = buf[i];
						buf[i] = '\0';
8000b1e0:	28 08       	st.b [%a15]0,%d8
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
					for (i = 0; buf[i] != '\0'; i++)
8000b1e2:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
8000b1e6:	79 ff 00 00 	ld.b %d15,[%a15]0
					{
						*pstr++ = buf[i];
8000b1ea:	40 2f       	mov.aa %a15,%a2
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
					for (i = 0; buf[i] != '\0'; i++)
8000b1ec:	ee f4       	jnz %d15,8000b1d4 <my_scanf+0x13e>
					{
						*pstr++ = buf[i];
						buf[i] = '\0';
					}
					*pstr = '\0';
8000b1ee:	34 28       	st.b [%a2],%d8
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
					}
					break;
				case 's':
					pstr = va_arg(ap, char *);
8000b1f0:	40 3e       	mov.aa %a14,%a3
					{
						*pstr++ = buf[i];
						buf[i] = '\0';
					}
					*pstr = '\0';
					break;
8000b1f2:	3c ba       	j 8000b166 <my_scanf+0xd0>
		{
			c = *fmt++;
			switch (c)
			{
				case 'c':
					*va_arg(ap, char *) = buf[0];
8000b1f4:	cc e0       	ld.a %a15,[%a14]0
8000b1f6:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b1fa:	b0 4e       	add.a %a14,4
8000b1fc:	28 0f       	st.b [%a15]0,%d15
					buf[0] = '\0';
8000b1fe:	34 c8       	st.b [%a12],%d8
					break;
8000b200:	3c b3       	j 8000b166 <my_scanf+0xd0>
				case 'd':
					*va_arg(ap, int *) = atoi(buf);
8000b202:	cc e0       	ld.a %a15,[%a14]0
8000b204:	40 c4       	mov.aa %a4,%a12
8000b206:	b0 4e       	add.a %a14,4
8000b208:	6d 00 ed 15 	call 8000dde2 <atoi>
					pidx = strchr(buf, ' ');
8000b20c:	40 c4       	mov.aa %a4,%a12
				case 'c':
					*va_arg(ap, char *) = buf[0];
					buf[0] = '\0';
					break;
				case 'd':
					*va_arg(ap, int *) = atoi(buf);
8000b20e:	68 02       	st.w [%a15]0,%d2
					pidx = strchr(buf, ' ');
8000b210:	3b 00 02 40 	mov %d4,32
8000b214:	6d 00 ec 15 	call 8000ddec <strchr>
					if (pidx != NULL) { *pidx = '\0'; }
8000b218:	bc 22       	jz.a %a2,8000b21c <my_scanf+0x186>
8000b21a:	34 28       	st.b [%a2],%d8
					for (i = 0; ; i++)
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
8000b21c:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b220:	82 02       	mov %d2,0
8000b222:	8f 0f c2 f1 	andn %d15,%d15,32
8000b226:	6e 0c       	jz %d15,8000b23e <my_scanf+0x1a8>
						buf[i] = '\0';
8000b228:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
					break;
				case 'd':
					*va_arg(ap, int *) = atoi(buf);
					pidx = strchr(buf, ' ');
					if (pidx != NULL) { *pidx = '\0'; }
					for (i = 0; ; i++)
8000b22c:	c2 12       	add %d2,1
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
						buf[i] = '\0';
8000b22e:	28 08       	st.b [%a15]0,%d8
					*va_arg(ap, int *) = atoi(buf);
					pidx = strchr(buf, ' ');
					if (pidx != NULL) { *pidx = '\0'; }
					for (i = 0; ; i++)
					{
						if (buf[i] == '\0' || buf[i] == ' ') { buf[i] = '\0'; break; }
8000b230:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
8000b234:	79 ff 00 00 	ld.b %d15,[%a15]0
8000b238:	8f 0f c2 f1 	andn %d15,%d15,32
8000b23c:	ee f6       	jnz %d15,8000b228 <my_scanf+0x192>
8000b23e:	01 c2 00 f6 	addsc.a %a15,%a12,%d2,0
8000b242:	28 08       	st.b [%a15]0,%d8
						buf[i] = '\0';
					}
					break;
8000b244:	3c 91       	j 8000b166 <my_scanf+0xd0>

8000b246 <remove_null>:
	}
	va_end(ap);
}

void remove_null(char *s)
{
8000b246:	d9 aa c0 8f 	lea %sp,[%sp]-512
	int i, start_idx;
	char buf[512];

	start_idx = 0;
8000b24a:	82 02       	mov %d2,0
	while (*(s + start_idx++) == '\0');
8000b24c:	c2 12       	add %d2,1
8000b24e:	01 42 00 f6 	addsc.a %a15,%a4,%d2,0
8000b252:	79 ff ff ff 	ld.b %d15,[%a15]-1
8000b256:	6e fb       	jz %d15,8000b24c <remove_null+0x6>
	memset(buf, 0, 512);
8000b258:	40 a3       	mov.aa %a3,%sp
8000b25a:	d2 04       	mov %e4,0
8000b25c:	c5 0f 3f 00 	lea %a15,3f <_.+0x3e>
8000b260:	89 34 48 01 	st.d [%a3+]8,%e4
8000b264:	fc fe       	loop %a15,8000b260 <remove_null+0x1a>
	strcpy(buf, (s + (start_idx - 1)));
8000b266:	c2 f2       	add %d2,-1
8000b268:	01 42 00 36 	addsc.a %a3,%a4,%d2,0
	int i, start_idx;
	char buf[512];

	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
8000b26c:	40 a2       	mov.aa %a2,%sp
	strcpy(buf, (s + (start_idx - 1)));
8000b26e:	40 af       	mov.aa %a15,%sp
8000b270:	04 3f       	ld.bu %d15,[%a3+]
8000b272:	24 ff       	st.b [%a15+],%d15
8000b274:	ee fe       	jnz %d15,8000b270 <remove_null+0x2a>

	memset(s, 0, 512);
8000b276:	40 43       	mov.aa %a3,%a4
	i = 0;
	while (buf[i] != '\0')
8000b278:	79 af 00 00 	ld.b %d15,[%sp]0
	start_idx = 0;
	while (*(s + start_idx++) == '\0');
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
8000b27c:	82 04       	mov %d4,0
8000b27e:	c5 0f 3f 70 	lea %a15,1ff <_.+0x1fe>
8000b282:	24 34       	st.b [%a3+],%d4
8000b284:	fc ff       	loop %a15,8000b282 <remove_null+0x3c>
	i = 0;
	while (buf[i] != '\0')
8000b286:	82 02       	mov %d2,0
8000b288:	6e 0a       	jz %d15,8000b29c <remove_null+0x56>
	{
		*(s + i) = buf[i];
8000b28a:	01 42 00 f6 	addsc.a %a15,%a4,%d2,0
		++i;
8000b28e:	c2 12       	add %d2,1

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
	{
		*(s + i) = buf[i];
8000b290:	28 0f       	st.b [%a15]0,%d15
	memset(buf, 0, 512);
	strcpy(buf, (s + (start_idx - 1)));

	memset(s, 0, 512);
	i = 0;
	while (buf[i] != '\0')
8000b292:	01 22 00 f6 	addsc.a %a15,%a2,%d2,0
8000b296:	79 ff 00 00 	ld.b %d15,[%a15]0
8000b29a:	ee f8       	jnz %d15,8000b28a <remove_null+0x44>
	{
		*(s + i) = buf[i];
		++i;
	}
	*(s + i) = '\0';
8000b29c:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8000b2a0:	82 0f       	mov %d15,0
8000b2a2:	2c 40       	st.b [%a4]0,%d15
8000b2a4:	00 90       	ret 

8000b2a6 <_init_uart1>:
void _init_uart1(void)
{
	unsigned int numerator = 2304;
	unsigned int denominator = 3125;
	/* Set TXD/P15.0 to "output" and "high" */
	MODULE_P15.IOCR0.B.PC0 = 0b10010;
8000b2a6:	91 40 00 ff 	movh.a %a15,61444
8000b2aa:	d9 ff 40 4b 	lea %a15,[%a15]-19200 <f003b500 <_SMALL_DATA4_+0x40033500>>
8000b2ae:	4c f4       	ld.w %d15,[%a15]16
8000b2b0:	8f 8f cf f1 	andn %d15,%d15,248
8000b2b4:	96 90       	or %d15,144
8000b2b6:	68 4f       	st.w [%a15]16,%d15
	P15_OMR.B.PS0 = 1;
8000b2b8:	91 40 00 ff 	movh.a %a15,61444
8000b2bc:	d9 ff 44 4b 	lea %a15,[%a15]-19196 <f003b504 <_SMALL_DATA4_+0x40033504>>
8000b2c0:	4c f0       	ld.w %d15,[%a15]0
8000b2c2:	96 01       	or %d15,1
8000b2c4:	68 0f       	st.w [%a15]0,%d15

	/* Enable ASCn */
	unlock_wdtcon();
	MODULE_ASCLIN1.CLC.U = 0;
8000b2c6:	c5 ff 40 c0 	lea %a15,f0000700 <_SMALL_DATA4_+0x3fff8700>
8000b2ca:	82 0f       	mov %d15,0
	/* Set TXD/P15.0 to "output" and "high" */
	MODULE_P15.IOCR0.B.PC0 = 0b10010;
	P15_OMR.B.PS0 = 1;

	/* Enable ASCn */
	unlock_wdtcon();
8000b2cc:	6d 00 34 30 	call 80011334 <unlock_wdtcon>
	MODULE_ASCLIN1.CLC.U = 0;
8000b2d0:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000b2d2:	6d 00 47 30 	call 80011360 <lock_wdtcon>
	/* read back for activating module */
	(void) MODULE_ASCLIN1.CLC.U;
8000b2d6:	48 02       	ld.w %d2,[%a15]0

	/* select RXD as input pin */
	MODULE_ASCLIN1.IOCR.B.ALTI = 0;
8000b2d8:	48 12       	ld.w %d2,[%a15]4
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000b2da:	91 10 00 48 	movh.a %a4,32769
	lock_wdtcon();
	/* read back for activating module */
	(void) MODULE_ASCLIN1.CLC.U;

	/* select RXD as input pin */
	MODULE_ASCLIN1.IOCR.B.ALTI = 0;
8000b2de:	8f 72 c0 21 	andn %d2,%d2,7
8000b2e2:	68 12       	st.w [%a15]4,%d2

	/* Program ASC0 */
	MODULE_ASCLIN1.CSR.U = 0;
8000b2e4:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* configure TX and RX FIFOs */
	MODULE_ASCLIN1.TXFIFOCON.U = (1 << 6)  /* INW: 1byte */
8000b2e8:	da 43       	mov %d15,67
8000b2ea:	68 3f       	st.w [%a15]12,%d15
							   | (1 << 1)  /* ENO*/
							   | (1 << 0); /* FLUSH */
	MODULE_ASCLIN1.RXFIFOCON.U = (1 << 6)  /* OUTW: 1byte */
8000b2ec:	68 4f       	st.w [%a15]16,%d15
							   | (1 << 1)  /* ENI */
							   | (1 << 0); /* FLUSH */

	MODULE_ASCLIN1.BITCON.U = (4 << 0)	   /* PRESCALER: 5 */
8000b2ee:	7b f0 90 f8 	movh %d15,35087
8000b2f2:	c2 4f       	add %d15,4
8000b2f4:	68 5f       	st.w [%a15]20,%d15
							| (15 << 16)   /* OVERSAMPLING: 16 */
							| (9 << 24)    /* SAMPLEPOINT: position 7,8,9 */
							| (1u << 31);  /* SM: 3 samples per bit */

	/* data format: 8N1 */
	MODULE_ASCLIN1.FRAMECON.U = (1 << 9)   /* STOP: 1 bit */
8000b2f6:	3b 00 20 f0 	mov %d15,512
8000b2fa:	68 6f       	st.w [%a15]24,%d15
							  | (0 << 16)  /* MODE: Init */
							  | (0 << 30); /* PEN: no parity */
	MODULE_ASCLIN1.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */
8000b2fc:	82 7f       	mov %d15,7
8000b2fe:	68 7f       	st.w [%a15]28,%d15

	/* set baudrate value: 921600 */
	MODULE_ASCLIN1.BRG.U = (denominator << 0) | (numerator << 16);
8000b300:	7b 00 90 f0 	movh %d15,2304
8000b304:	1b 5f c3 f0 	addi %d15,%d15,3125
8000b308:	68 8f       	st.w [%a15]32,%d15

	MODULE_ASCLIN1.FRAMECON.B.MODE = 1; /* ASC Mode */
8000b30a:	4c f6       	ld.w %d15,[%a15]24
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000b30c:	3b 40 02 40 	mov %d4,36
	MODULE_ASCLIN1.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */

	/* set baudrate value: 921600 */
	MODULE_ASCLIN1.BRG.U = (denominator << 0) | (numerator << 16);

	MODULE_ASCLIN1.FRAMECON.B.MODE = 1; /* ASC Mode */
8000b310:	b7 1f 02 f8 	insert %d15,%d15,1,16,2
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000b314:	d9 44 5a cb 	lea %a4,[%a4]-18662 <8000b71a <IsrUart1RxHandler_tof>>
	MODULE_ASCLIN1.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */

	/* set baudrate value: 921600 */
	MODULE_ASCLIN1.BRG.U = (denominator << 0) | (numerator << 16);

	MODULE_ASCLIN1.FRAMECON.B.MODE = 1; /* ASC Mode */
8000b318:	68 6f       	st.w [%a15]24,%d15

	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
8000b31a:	82 1f       	mov %d15,1
8000b31c:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);
8000b320:	7b 00 00 f8 	movh %d15,32768
8000b324:	68 ef       	st.w [%a15]56,%d15

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000b326:	82 15       	mov %d5,1
8000b328:	82 06       	mov %d6,0
	MODULE_ASCLIN1.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
8000b32a:	7b 00 00 f1 	movh %d15,4096
	MODULE_ASCLIN1.CSR.U = 1; /* select CLC as clock source */
	/* Module Start */
	MODULE_ASCLIN1.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);

	/* UART1 Rx Interrupt  */
	InterruptInstall(SRC_ID_ASCLIN1RX, (void(*)(int))IsrUart1RxHandler_tof, 1, 0);
8000b32e:	6d 00 83 02 	call 8000b834 <InterruptInstall>
	MODULE_ASCLIN1.FLAGSENABLE.U = (1 << 28); /* FLAGSENABLE.RFLE */
8000b332:	59 ff 00 10 	st.w [%a15]64 <f0040040 <_SMALL_DATA4_+0x40038040>>,%d15
8000b336:	00 90       	ret 

8000b338 <_in_uart1>:
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b338:	7b 00 00 41 	movh %d4,4096
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
8000b33c:	7b 50 40 30 	movh %d3,1029
			/* reset error flags */
			MODULE_ASCLIN1.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
8000b340:	3b 30 0c 50 	mov %d5,195

int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
8000b344:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
8000b348:	ef cf fe 7f 	jz.t %d15,28,8000b344 <_in_uart1+0xc>
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
8000b34c:	85 f2 48 d0 	ld.w %d2,f0000748 <_SMALL_DATA4_+0x3fff8748>
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b350:	a5 f4 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d4
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
8000b354:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
8000b358:	26 3f       	and %d15,%d3
8000b35a:	ee 04       	jnz %d15,8000b362 <_in_uart1+0x2a>
{
	unsigned char ch;
	/* wait for a new character */
	while (_poll_uart1(&ch) == 0);
	return ch;
}
8000b35c:	8f f2 0f 21 	and %d2,%d2,255
8000b360:	00 90       	ret 
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN1.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000b362:	a5 f3 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d3
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
8000b366:	a5 f5 50 c0 	st.w f0000710 <_SMALL_DATA4_+0x3fff8710>,%d5
8000b36a:	3c ed       	j 8000b344 <_in_uart1+0xc>

8000b36c <_poll_uart1>:

int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
8000b36c:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
}

int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
8000b370:	82 02       	mov %d2,0
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
8000b372:	ef cf 10 00 	jz.t %d15,28,8000b392 <_poll_uart1+0x26>
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b376:	7b 00 00 f1 	movh %d15,4096
int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
8000b37a:	85 f4 48 d0 	ld.w %d4,f0000748 <_SMALL_DATA4_+0x3fff8748>
		/* acknowledge receive */
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b37e:	a5 ff 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d15
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
8000b382:	85 ff 74 c0 	ld.w %d15,f0000734 <_SMALL_DATA4_+0x3fff8734>
8000b386:	7b 50 40 30 	movh %d3,1029
8000b38a:	26 3f       	and %d15,%d3
8000b38c:	ee 04       	jnz %d15,8000b394 <_poll_uart1+0x28>
int _poll_uart1(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN1.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN1.RXDATA.U;
8000b38e:	34 44       	st.b [%a4],%d4
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
			/* ignore this character */
		} else {
			/* this is a valid character */
			*chr = ret;
			res = 1;
8000b390:	82 12       	mov %d2,1
		}
	}
	return res;
}
8000b392:	00 90       	ret 
		MODULE_ASCLIN1.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN1.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN1.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000b394:	a5 f3 7c c0 	st.w f000073c <_SMALL_DATA4_+0x3fff873c>,%d3
			MODULE_ASCLIN1.RXFIFOCON.U = (3 << 6) | (1 << 1) | (1 << 0);
8000b398:	da c3       	mov %d15,195
8000b39a:	a5 ff 50 c0 	st.w f0000710 <_SMALL_DATA4_+0x3fff8710>,%d15
8000b39e:	00 90       	ret 

8000b3a0 <_init_uart0>:
void _init_uart0(void)
{
	unsigned int numerator = 48;
	unsigned int denominator = 3125;
	/* Set TXD/P14.0 to "output" and "high" */
	MODULE_P14.IOCR0.B.PC0 = 0b10010;
8000b3a0:	91 40 00 ff 	movh.a %a15,61444
8000b3a4:	d9 ff 40 0b 	lea %a15,[%a15]-19456 <f003b400 <_SMALL_DATA4_+0x40033400>>
8000b3a8:	4c f4       	ld.w %d15,[%a15]16
8000b3aa:	8f 8f cf f1 	andn %d15,%d15,248
8000b3ae:	96 90       	or %d15,144
8000b3b0:	68 4f       	st.w [%a15]16,%d15
	P14_OMR.B.PS0 = 1;
8000b3b2:	91 40 00 ff 	movh.a %a15,61444
8000b3b6:	d9 ff 44 0b 	lea %a15,[%a15]-19452 <f003b404 <_SMALL_DATA4_+0x40033404>>
8000b3ba:	4c f0       	ld.w %d15,[%a15]0
8000b3bc:	96 01       	or %d15,1
8000b3be:	68 0f       	st.w [%a15]0,%d15

	/* Enable ASCn */
	unlock_wdtcon();
	MODULE_ASCLIN0.CLC.U = 0;
8000b3c0:	c5 ff 40 80 	lea %a15,f0000600 <_SMALL_DATA4_+0x3fff8600>
8000b3c4:	82 0f       	mov %d15,0
	/* Set TXD/P14.0 to "output" and "high" */
	MODULE_P14.IOCR0.B.PC0 = 0b10010;
	P14_OMR.B.PS0 = 1;

	/* Enable ASCn */
	unlock_wdtcon();
8000b3c6:	6d 00 b7 2f 	call 80011334 <unlock_wdtcon>
	MODULE_ASCLIN0.CLC.U = 0;
8000b3ca:	68 0f       	st.w [%a15]0,%d15
	lock_wdtcon();
8000b3cc:	6d 00 ca 2f 	call 80011360 <lock_wdtcon>
	/* read back for activating module */
	(void) MODULE_ASCLIN0.CLC.U;
8000b3d0:	48 02       	ld.w %d2,[%a15]0

	/* select RXD as input pin */
	MODULE_ASCLIN0.IOCR.B.ALTI = 0;
8000b3d2:	48 12       	ld.w %d2,[%a15]4
8000b3d4:	8f 72 c0 21 	andn %d2,%d2,7
8000b3d8:	68 12       	st.w [%a15]4,%d2

	/* Program ASC0 */
	MODULE_ASCLIN0.CSR.U = 0;
8000b3da:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15

	/* configure TX and RX FIFOs */
	MODULE_ASCLIN0.TXFIFOCON.U = (1 << 6)  /* INW: 1byte */
8000b3de:	da 43       	mov %d15,67
8000b3e0:	68 3f       	st.w [%a15]12,%d15
							   | (1 << 1)  /* ENO*/
							   | (1 << 0); /* FLUSH */
//	MODULE_ASCLIN0.RXFIFOCON.U = (1 << 6)  /* OUTW: 1byte */
//							   | (1 << 1)  /* ENI */
//							   | (1 << 0); /* FLUSH */
	MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000b3e2:	9b 0f 00 f8 	addih %d15,%d15,32768
8000b3e6:	68 4f       	st.w [%a15]16,%d15

	MODULE_ASCLIN0.BITCON.U = (9 << 0)	   /* PRESCALER: 10 */
8000b3e8:	7b f0 90 f8 	movh %d15,35087
8000b3ec:	1b 9f 00 f0 	addi %d15,%d15,9
8000b3f0:	68 5f       	st.w [%a15]20,%d15
							| (15 << 16)   /* OVERSAMPLING: 16 */
							| (9 << 24)    /* SAMPLEPOINT: position 7,8,9 */
							| (1u << 31);  /* SM: 3 samples per bit */

	/* data format: 8N1 */
	MODULE_ASCLIN0.FRAMECON.U = (1 << 9)   /* STOP: 1 bit */
8000b3f2:	3b 00 20 f0 	mov %d15,512
8000b3f6:	68 6f       	st.w [%a15]24,%d15
							  | (0 << 16)  /* MODE: Init */
							  | (0 << 30); /* PEN: no parity */
	MODULE_ASCLIN0.DATCON.U = (7 << 0);    /* DATLEN: 8 bit */
8000b3f8:	82 7f       	mov %d15,7
8000b3fa:	68 7f       	st.w [%a15]28,%d15

	/* set baudrate value: 921600 */
	MODULE_ASCLIN0.BRG.U = (denominator << 0) | (numerator << 16);
8000b3fc:	7b 00 03 f0 	movh %d15,48
8000b400:	1b 5f c3 f0 	addi %d15,%d15,3125
8000b404:	68 8f       	st.w [%a15]32,%d15

	MODULE_ASCLIN0.FRAMECON.B.MODE = 1; /* ASC Mode */
8000b406:	4c f6       	ld.w %d15,[%a15]24
8000b408:	b7 1f 02 f8 	insert %d15,%d15,1,16,2
8000b40c:	68 6f       	st.w [%a15]24,%d15

	MODULE_ASCLIN0.CSR.U = 1; /* select CLC as clock source */
8000b40e:	82 1f       	mov %d15,1
8000b410:	59 ff 0c 10 	st.w [%a15]76 <f004004c <_SMALL_DATA4_+0x4003804c>>,%d15
	/* Module Start */
	MODULE_ASCLIN0.FLAGSSET.U = (IFX_ASCLIN_FLAGSSET_TFLS_MSK << IFX_ASCLIN_FLAGSSET_TFLS_OFF);
8000b414:	7b 00 00 f8 	movh %d15,32768
8000b418:	68 ef       	st.w [%a15]56,%d15
8000b41a:	00 90       	ret 

8000b41c <_in_uart0>:
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000b41c:	7b 00 00 58 	movh %d5,32768
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b420:	7b 00 00 41 	movh %d4,4096
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
8000b424:	7b 50 40 30 	movh %d3,1029
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000b428:	1b 35 04 50 	addi %d5,%d5,67

int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
8000b42c:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000b430:	ef cf fe 7f 	jz.t %d15,28,8000b42c <_in_uart0+0x10>
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
8000b434:	85 f2 48 90 	ld.w %d2,f0000648 <_SMALL_DATA4_+0x3fff8648>
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b438:	a5 f4 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d4
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
8000b43c:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000b440:	26 3f       	and %d15,%d3
8000b442:	ee 04       	jnz %d15,8000b44a <_in_uart0+0x2e>
{
	unsigned char ch;
	/* wait for a new character */
	while (_poll_uart0(&ch) == 0);
	return ch;
}
8000b444:	8f f2 0f 21 	and %d2,%d2,255
8000b448:	00 90       	ret 
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000b44a:	a5 f3 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d3
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000b44e:	a5 f5 50 80 	st.w f0000610 <_SMALL_DATA4_+0x3fff8610>,%d5
8000b452:	3c ed       	j 8000b42c <_in_uart0+0x10>

8000b454 <_poll_uart0>:

int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
8000b454:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
}

int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
8000b458:	82 02       	mov %d2,0
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
8000b45a:	ef cf 10 00 	jz.t %d15,28,8000b47a <_poll_uart0+0x26>
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b45e:	7b 00 00 f1 	movh %d15,4096
int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
8000b462:	85 f4 48 90 	ld.w %d4,f0000648 <_SMALL_DATA4_+0x3fff8648>
		/* acknowledge receive */
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
8000b466:	a5 ff 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d15
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
8000b46a:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000b46e:	7b 50 40 30 	movh %d3,1029
8000b472:	26 3f       	and %d15,%d3
8000b474:	ee 04       	jnz %d15,8000b47c <_poll_uart0+0x28>
int _poll_uart0(unsigned char *chr)
{
	unsigned char ret;
	int res = 0;
	if (MODULE_ASCLIN0.FLAGS.B.RFL != 0) {
		ret = (unsigned char) MODULE_ASCLIN0.RXDATA.U;
8000b476:	34 44       	st.b [%a4],%d4
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
			/* ignore this character */
		} else {
			/* this is a valid character */
			*chr = ret;
			res = 1;
8000b478:	82 12       	mov %d2,1
		}
	}
	return res;
}
8000b47a:	00 90       	ret 
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000b47c:	7b 00 00 f8 	movh %d15,32768
		MODULE_ASCLIN0.FLAGSCLEAR.U = (IFX_ASCLIN_FLAGSCLEAR_RFLC_MSK
				<< IFX_ASCLIN_FLAGSCLEAR_RFLC_OFF);
		/* check for error condition */
		if (MODULE_ASCLIN0.FLAGS.U & ASC_ERROR_MASK) {
			/* reset error flags */
			MODULE_ASCLIN0.FLAGSCLEAR.U = ASC_CLRERR_MASK;
8000b480:	a5 f3 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d3
			MODULE_ASCLIN0.RXFIFOCON.U = (1 << 31) | (1 << 6) | (1 << 1) | (1 << 0);
8000b484:	1b 3f 04 f0 	addi %d15,%d15,67
8000b488:	a5 ff 50 80 	st.w f0000610 <_SMALL_DATA4_+0x3fff8610>,%d15
8000b48c:	00 90       	ret 

8000b48e <_out_uart0>:

/* Send character CHR via the serial line */
void _out_uart0(const unsigned char chr)
{
	/* wait until space is available in the FIFO */
	while (!TX_READY(MODULE_ASCLIN0));
8000b48e:	85 ff 74 80 	ld.w %d15,f0000634 <_SMALL_DATA4_+0x3fff8634>
8000b492:	ff 0f fe 7f 	jge %d15,0,8000b48e <_out_uart0>

	TX_CLEAR(MODULE_ASCLIN0);
8000b496:	7b 00 00 f8 	movh %d15,32768
8000b49a:	a5 ff 7c 80 	st.w f000063c <_SMALL_DATA4_+0x3fff863c>,%d15

	/* send the character */
	PUT_CHAR(MODULE_ASCLIN0, chr);
8000b49e:	a5 f4 44 90 	st.w f0000644 <_SMALL_DATA4_+0x3fff8644>,%d4
8000b4a2:	00 90       	ret 

8000b4a4 <delay_ms>:
#include "etc.h"

void delay_ms(unsigned int delay_time)
{
8000b4a4:	20 08       	sub.a %sp,8
	volatile unsigned int i, j;
	for (i = 0; i < delay_time; i++)
8000b4a6:	82 0f       	mov %d15,0
8000b4a8:	78 00       	st.w [%sp]0,%d15
8000b4aa:	54 a2       	ld.w %d2,[%sp]
		for (j = 0; j < 18200; j++)
8000b4ac:	82 03       	mov %d3,0
8000b4ae:	3b 80 71 f4 	mov %d15,18200
#include "etc.h"

void delay_ms(unsigned int delay_time)
{
	volatile unsigned int i, j;
	for (i = 0; i < delay_time; i++)
8000b4b2:	3f 42 09 80 	jlt.u %d2,%d4,8000b4c4 <delay_ms+0x20>
8000b4b6:	3c 20       	j 8000b4f6 <delay_ms+0x52>
8000b4b8:	54 a2       	ld.w %d2,[%sp]
8000b4ba:	c2 12       	add %d2,1
8000b4bc:	74 a2       	st.w [%sp],%d2
8000b4be:	54 a2       	ld.w %d2,[%sp]
8000b4c0:	7f 42 1c 80 	jge.u %d2,%d4,8000b4f8 <delay_ms+0x54>
		for (j = 0; j < 18200; j++)
8000b4c4:	59 a3 04 00 	st.w [%sp]4,%d3
8000b4c8:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b4cc:	7f f2 f6 ff 	jge.u %d2,%d15,8000b4b8 <delay_ms+0x14>
8000b4d0:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b4d4:	c2 12       	add %d2,1
8000b4d6:	59 a2 04 00 	st.w [%sp]4,%d2
8000b4da:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b4de:	7f f2 ed ff 	jge.u %d2,%d15,8000b4b8 <delay_ms+0x14>
8000b4e2:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b4e6:	c2 12       	add %d2,1
8000b4e8:	59 a2 04 00 	st.w [%sp]4,%d2
8000b4ec:	19 a2 04 00 	ld.w %d2,[%sp]4
8000b4f0:	3f f2 f0 ff 	jlt.u %d2,%d15,8000b4d0 <delay_ms+0x2c>
8000b4f4:	3c e2       	j 8000b4b8 <delay_ms+0x14>
8000b4f6:	00 90       	ret 
8000b4f8:	00 90       	ret 

8000b4fa <Init_GPIO>:
#include "GPIO.h"
#include "tc27xd/IfxPort_PinMap.h"
void Init_GPIO(void)
{
	/* Set P10.2(LED1) as push-pull output */
	MODULE_P10.IOCR0.B.PC2 = 0b10000;
8000b4fa:	91 40 00 ff 	movh.a %a15,61444
8000b4fe:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b502:	4c f4       	ld.w %d15,[%a15]16
8000b504:	3b 00 08 50 	mov %d5,128
8000b508:	b7 0f 85 f9 	insert %d15,%d15,0,19,5
8000b50c:	b7 ff 81 fb 	insert %d15,%d15,15,23,1
8000b510:	68 4f       	st.w [%a15]16,%d15

	/* Set P10.1(LED2) as push-pull output */
	MODULE_P10.IOCR0.B.PC1 = 0b10000;
8000b512:	4c f4       	ld.w %d15,[%a15]16
8000b514:	b7 0f 85 f5 	insert %d15,%d15,0,11,5
8000b518:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000b51c:	68 4f       	st.w [%a15]16,%d15

	/* Set P2.0(SW1) as input pull-up */
	MODULE_P02.IOCR0.B.PC0 = 0b00010;
8000b51e:	91 40 00 ff 	movh.a %a15,61444
8000b522:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b526:	4c f4       	ld.w %d15,[%a15]16
8000b528:	b7 2f 85 f1 	insert %d15,%d15,2,3,5
8000b52c:	68 4f       	st.w [%a15]16,%d15

	/* Set P2.1(SW2) as input pull-up */
	MODULE_P02.IOCR0.B.PC1 = 0b00010;
8000b52e:	4c f4       	ld.w %d15,[%a15]16
8000b530:	b7 2f 85 f5 	insert %d15,%d15,2,11,5
8000b534:	68 4f       	st.w [%a15]16,%d15

	/*P20_6    Digital Output*/
	IfxPort_setPinModeOutput(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
8000b536:	91 00 00 f7 	movh.a %a15,28672
8000b53a:	99 f4 f0 f0 	ld.a %a4,[%a15]4080 <70000ff0 <IfxPort_P20_6>>
8000b53e:	d9 fc f0 f0 	lea %a12,[%a15]4080 <70000ff0 <IfxPort_P20_6>>
8000b542:	39 c4 04 00 	ld.bu %d4,[%a12]4 <70000ff0 <IfxPort_P20_6>>
8000b546:	6d ff 56 e3 	call 80007bf2 <IfxPort_setPinMode>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
8000b54a:	0c c4       	ld.bu %d15,[%a12]4
	IfxPort_setPinLow(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex);
8000b54c:	99 ff f0 f0 	ld.a %a15,[%a15]4080 <70000ff0 <IfxPort_P20_6>>
8000b550:	7b 10 00 20 	movh %d2,1
8000b554:	0f f2 00 f0 	sh %d15,%d2,%d15
8000b558:	68 1f       	st.w [%a15]4,%d15
8000b55a:	00 90       	ret 

8000b55c <setLED1>:

void setLED1(int onoff)	// on if true, off if false
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P2 = 1;
8000b55c:	91 40 00 ff 	movh.a %a15,61444
8000b560:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b564:	4c f0       	ld.w %d15,[%a15]0
	IfxPort_setPinLow(IfxPort_P20_6.port, IfxPort_P20_6.pinIndex);
}

void setLED1(int onoff)	// on if true, off if false
{
	if(onoff)
8000b566:	f6 45       	jnz %d4,8000b570 <setLED1+0x14>
	{
		MODULE_P10.OUT.B.P2 = 1;
	}
	else
	{
		MODULE_P10.OUT.B.P2 = 0;
8000b568:	8f 4f c0 f1 	andn %d15,%d15,4
8000b56c:	68 0f       	st.w [%a15]0,%d15
8000b56e:	00 90       	ret 

void setLED1(int onoff)	// on if true, off if false
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P2 = 1;
8000b570:	96 04       	or %d15,4
8000b572:	68 0f       	st.w [%a15]0,%d15
8000b574:	00 90       	ret 

8000b576 <setLED2>:

void setLED2(int onoff)
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P1 = 1;
8000b576:	91 40 00 ff 	movh.a %a15,61444
8000b57a:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b57e:	4c f0       	ld.w %d15,[%a15]0
	}
}

void setLED2(int onoff)
{
	if(onoff)
8000b580:	f6 45       	jnz %d4,8000b58a <setLED2+0x14>
	{
		MODULE_P10.OUT.B.P1 = 1;
	}
	else
	{
		MODULE_P10.OUT.B.P1 = 0;
8000b582:	8f 2f c0 f1 	andn %d15,%d15,2
8000b586:	68 0f       	st.w [%a15]0,%d15
8000b588:	00 90       	ret 

void setLED2(int onoff)
{
	if(onoff)
	{
		MODULE_P10.OUT.B.P1 = 1;
8000b58a:	96 02       	or %d15,2
8000b58c:	68 0f       	st.w [%a15]0,%d15
8000b58e:	00 90       	ret 

8000b590 <toggleLED1>:
	}
}

void toggleLED1(void)
{
	MODULE_P10.OUT.B.P2 ^= 1;
8000b590:	91 40 00 ff 	movh.a %a15,61444
8000b594:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b598:	4c f0       	ld.w %d15,[%a15]0
8000b59a:	07 ff 02 f1 	nand.t %d15,%d15,2,%d15,2
8000b59e:	8f 2f 00 20 	sh %d2,%d15,2
8000b5a2:	4c f0       	ld.w %d15,[%a15]0
8000b5a4:	8f 4f c0 f1 	andn %d15,%d15,4
8000b5a8:	a6 2f       	or %d15,%d2
8000b5aa:	68 0f       	st.w [%a15]0,%d15
8000b5ac:	00 90       	ret 

8000b5ae <toggleLED2>:
}

void toggleLED2(void)
{
	MODULE_P10.OUT.B.P1 ^= 1;
8000b5ae:	91 40 00 ff 	movh.a %a15,61444
8000b5b2:	d9 ff 00 0b 	lea %a15,[%a15]-20480 <f003b000 <_SMALL_DATA4_+0x40033000>>
8000b5b6:	4c f0       	ld.w %d15,[%a15]0
8000b5b8:	07 ff 81 f0 	nand.t %d15,%d15,1,%d15,1
8000b5bc:	8f 1f 00 20 	sh %d2,%d15,1
8000b5c0:	4c f0       	ld.w %d15,[%a15]0
8000b5c2:	8f 2f c0 f1 	andn %d15,%d15,2
8000b5c6:	a6 2f       	or %d15,%d2
8000b5c8:	68 0f       	st.w [%a15]0,%d15
8000b5ca:	00 90       	ret 

8000b5cc <getSW1>:
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000b5cc:	91 40 00 ff 	movh.a %a15,61444
8000b5d0:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b5d4:	48 92       	ld.w %d2,[%a15]36
}
8000b5d6:	8f 12 00 21 	and %d2,%d2,1
8000b5da:	00 90       	ret 

8000b5dc <getSW2>:

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000b5dc:	91 40 00 ff 	movh.a %a15,61444
8000b5e0:	d9 ff 00 8a 	lea %a15,[%a15]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
8000b5e4:	48 92       	ld.w %d2,[%a15]36
}
8000b5e6:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000b5ea:	00 90       	ret 

8000b5ec <getSW1_Debounce>:

int getSW1_Debounce(void)
{
8000b5ec:	20 18       	sub.a %sp,24
	volatile int SW1, i, cnt = 0;
8000b5ee:	82 0f       	mov %d15,0
	volatile char buf[10] = { 0, };
8000b5f0:	d9 a2 0e 00 	lea %a2,[%sp]14
	return MODULE_P02.IN.B.P1;
}

int getSW1_Debounce(void)
{
	volatile int SW1, i, cnt = 0;
8000b5f4:	78 02       	st.w [%sp]8,%d15
	volatile char buf[10] = { 0, };
8000b5f6:	40 23       	mov.aa %a3,%a2
8000b5f8:	82 0f       	mov %d15,0
8000b5fa:	a0 4f       	mov.a %a15,4
8000b5fc:	a4 3f       	st.h [%a3+],%d15
8000b5fe:	fc ff       	loop %a15,8000b5fc <getSW1_Debounce+0x10>

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
8000b600:	19 a2 08 00 	ld.w %d2,[%sp]8
8000b604:	3b 00 71 f2 	mov %d15,10000
	MODULE_P10.OUT.B.P1 ^= 1;
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000b608:	91 40 00 3f 	movh.a %a3,61444
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000b60c:	82 03       	mov %d3,0
	MODULE_P10.OUT.B.P1 ^= 1;
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000b60e:	d9 33 00 8a 	lea %a3,[%a3]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
{
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
8000b612:	02 f4       	mov %d4,%d15
8000b614:	7f f2 31 00 	jge %d2,%d15,8000b676 <getSW1_Debounce+0x8a>
		for (i = 0; i < 10; i++) {
8000b618:	59 a3 04 00 	st.w [%sp]4,%d3
8000b61c:	58 01       	ld.w %d15,[%sp]4
8000b61e:	8b af 40 f2 	lt %d15,%d15,10
8000b622:	6e 0d       	jz %d15,8000b63c <getSW1_Debounce+0x50>
			buf[i] = getSW1();
8000b624:	d8 01       	ld.a %a15,[%sp]4
	MODULE_P10.OUT.B.P1 ^= 1;
}

int getSW1(void)
{
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
8000b626:	4c 39       	ld.w %d15,[%a3]36
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW1();
8000b628:	30 2f       	add.a %a15,%a2
8000b62a:	16 01       	and %d15,1
8000b62c:	28 0f       	st.b [%a15]0,%d15
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000b62e:	58 01       	ld.w %d15,[%sp]4
8000b630:	c2 1f       	add %d15,1
8000b632:	78 01       	st.w [%sp]4,%d15
8000b634:	58 01       	ld.w %d15,[%sp]4
8000b636:	8b af 40 f2 	lt %d15,%d15,10
8000b63a:	ee f5       	jnz %d15,8000b624 <getSW1_Debounce+0x38>
			buf[i] = getSW1();
		}
		for (i = 0; i < 10; i++) {
8000b63c:	59 a3 04 00 	st.w [%sp]4,%d3
8000b640:	58 01       	ld.w %d15,[%sp]4
8000b642:	8b af 40 f2 	lt %d15,%d15,10
8000b646:	6e 12       	jz %d15,8000b66a <getSW1_Debounce+0x7e>
			if (buf[0] != buf[i]) {
8000b648:	79 a2 0e 00 	ld.b %d2,[%sp]14
8000b64c:	d8 01       	ld.a %a15,[%sp]4
8000b64e:	30 2f       	add.a %a15,%a2
8000b650:	79 ff 00 00 	ld.b %d15,[%a15]0
8000b654:	5f f2 04 00 	jeq %d2,%d15,8000b65c <getSW1_Debounce+0x70>
				cnt = 0;
8000b658:	59 a3 08 00 	st.w [%sp]8,%d3
	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW1();
		}
		for (i = 0; i < 10; i++) {
8000b65c:	58 01       	ld.w %d15,[%sp]4
8000b65e:	c2 1f       	add %d15,1
8000b660:	78 01       	st.w [%sp]4,%d15
8000b662:	58 01       	ld.w %d15,[%sp]4
8000b664:	8b af 40 f2 	lt %d15,%d15,10
8000b668:	ee f0       	jnz %d15,8000b648 <getSW1_Debounce+0x5c>
			if (buf[0] != buf[i]) {
				cnt = 0;
			}
		}
		cnt += 1;
8000b66a:	58 02       	ld.w %d15,[%sp]8
8000b66c:	c2 1f       	add %d15,1
8000b66e:	78 02       	st.w [%sp]8,%d15
{
	volatile int SW1, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW1 states not change */
	while (cnt < 10000) {
8000b670:	58 02       	ld.w %d15,[%sp]8
8000b672:	3f 4f d3 7f 	jlt %d15,%d4,8000b618 <getSW1_Debounce+0x2c>
				cnt = 0;
			}
		}
		cnt += 1;
	}
	SW1 = buf[0];
8000b676:	79 af 0e 00 	ld.b %d15,[%sp]14
8000b67a:	78 00       	st.w [%sp]0,%d15
	return SW1;
8000b67c:	54 a2       	ld.w %d2,[%sp]
8000b67e:	00 90       	ret 

8000b680 <getSW2_Debounce>:
}

int getSW2_Debounce(void)
{
8000b680:	20 18       	sub.a %sp,24
	volatile int SW2, i, cnt = 0;
8000b682:	82 0f       	mov %d15,0
	volatile char buf[10] = { 0, };
8000b684:	d9 a2 0e 00 	lea %a2,[%sp]14
	return SW1;
}

int getSW2_Debounce(void)
{
	volatile int SW2, i, cnt = 0;
8000b688:	78 02       	st.w [%sp]8,%d15
	volatile char buf[10] = { 0, };
8000b68a:	40 23       	mov.aa %a3,%a2
8000b68c:	82 0f       	mov %d15,0
8000b68e:	a0 4f       	mov.a %a15,4
8000b690:	a4 3f       	st.h [%a3+],%d15
8000b692:	fc ff       	loop %a15,8000b690 <getSW2_Debounce+0x10>

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
8000b694:	19 a2 08 00 	ld.w %d2,[%sp]8
8000b698:	3b 00 71 f2 	mov %d15,10000
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
}

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000b69c:	91 40 00 3f 	movh.a %a3,61444
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000b6a0:	82 03       	mov %d3,0
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
}

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000b6a2:	d9 33 00 8a 	lea %a3,[%a3]-24064 <f003a200 <_SMALL_DATA4_+0x40032200>>
{
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
8000b6a6:	02 f4       	mov %d4,%d15
8000b6a8:	7f f2 32 00 	jge %d2,%d15,8000b70c <getSW2_Debounce+0x8c>
		for (i = 0; i < 10; i++) {
8000b6ac:	59 a3 04 00 	st.w [%sp]4,%d3
8000b6b0:	58 01       	ld.w %d15,[%sp]4
8000b6b2:	8b af 40 f2 	lt %d15,%d15,10
8000b6b6:	6e 0e       	jz %d15,8000b6d2 <getSW2_Debounce+0x52>
			buf[i] = getSW2();
8000b6b8:	d8 01       	ld.a %a15,[%sp]4
	return MODULE_P02.IN.B.P0; // return 1 if pushed, otherwise 0
}

int getSW2(void)
{
	return MODULE_P02.IN.B.P1;
8000b6ba:	4c 39       	ld.w %d15,[%a3]36
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW2();
8000b6bc:	37 0f e1 f0 	extr.u %d15,%d15,1,1
8000b6c0:	30 2f       	add.a %a15,%a2
8000b6c2:	28 0f       	st.b [%a15]0,%d15
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
8000b6c4:	58 01       	ld.w %d15,[%sp]4
8000b6c6:	c2 1f       	add %d15,1
8000b6c8:	78 01       	st.w [%sp]4,%d15
8000b6ca:	58 01       	ld.w %d15,[%sp]4
8000b6cc:	8b af 40 f2 	lt %d15,%d15,10
8000b6d0:	ee f4       	jnz %d15,8000b6b8 <getSW2_Debounce+0x38>
			buf[i] = getSW2();
		}
		for (i = 0; i < 10; i++) {
8000b6d2:	59 a3 04 00 	st.w [%sp]4,%d3
8000b6d6:	58 01       	ld.w %d15,[%sp]4
8000b6d8:	8b af 40 f2 	lt %d15,%d15,10
8000b6dc:	6e 12       	jz %d15,8000b700 <getSW2_Debounce+0x80>
			if (buf[0] != buf[i]) {
8000b6de:	79 a2 0e 00 	ld.b %d2,[%sp]14
8000b6e2:	d8 01       	ld.a %a15,[%sp]4
8000b6e4:	30 2f       	add.a %a15,%a2
8000b6e6:	79 ff 00 00 	ld.b %d15,[%a15]0
8000b6ea:	5f f2 04 00 	jeq %d2,%d15,8000b6f2 <getSW2_Debounce+0x72>
				cnt = 0;
8000b6ee:	59 a3 08 00 	st.w [%sp]8,%d3
	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
		for (i = 0; i < 10; i++) {
			buf[i] = getSW2();
		}
		for (i = 0; i < 10; i++) {
8000b6f2:	58 01       	ld.w %d15,[%sp]4
8000b6f4:	c2 1f       	add %d15,1
8000b6f6:	78 01       	st.w [%sp]4,%d15
8000b6f8:	58 01       	ld.w %d15,[%sp]4
8000b6fa:	8b af 40 f2 	lt %d15,%d15,10
8000b6fe:	ee f0       	jnz %d15,8000b6de <getSW2_Debounce+0x5e>
			if (buf[0] != buf[i]) {
				cnt = 0;
			}
		}
		cnt += 1;
8000b700:	58 02       	ld.w %d15,[%sp]8
8000b702:	c2 1f       	add %d15,1
8000b704:	78 02       	st.w [%sp]8,%d15
{
	volatile int SW2, i, cnt = 0;
	volatile char buf[10] = { 0, };

	/* wait for last 10K SW2 states not change */
	while (cnt < 10000) {
8000b706:	58 02       	ld.w %d15,[%sp]8
8000b708:	3f 4f d2 7f 	jlt %d15,%d4,8000b6ac <getSW2_Debounce+0x2c>
				cnt = 0;
			}
		}
		cnt += 1;
	}
	SW2 = buf[0];
8000b70c:	79 af 0e 00 	ld.b %d15,[%sp]14
8000b710:	78 00       	st.w [%sp]0,%d15
	return SW2;
8000b712:	54 a2       	ld.w %d2,[%sp]
8000b714:	00 90       	ret 

8000b716 <Init_ToF>:
static unsigned int rxBufIdx = 0;
static unsigned char gBuf_tof[16] = { 0 };

void Init_ToF(void)
{
    _init_uart1();
8000b716:	1d ff c8 fd 	j 8000b2a6 <_init_uart1>

8000b71a <IsrUart1RxHandler_tof>:
/* Interrupt Service Routine for RX */
void IsrUart1RxHandler_tof(void)
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();
8000b71a:	6d ff 0f fe 	call 8000b338 <_in_uart1>

	rxBuf[rxBufIdx] = c;
8000b71e:	91 00 00 f7 	movh.a %a15,28672
8000b722:	99 f2 e0 f1 	ld.a %a2,[%a15]8160 <70001fe0 <rxBufIdx>>
	++rxBufIdx;
8000b726:	19 ff e0 f1 	ld.w %d15,[%a15]8160 <70001fe0 <rxBufIdx>>
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();

	rxBuf[rxBufIdx] = c;
8000b72a:	91 00 00 37 	movh.a %a3,28672
8000b72e:	d9 33 c0 f1 	lea %a3,[%a3]8128 <70001fc0 <rxBuf.37683>>
	++rxBufIdx;
8000b732:	c2 1f       	add %d15,1
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();

	rxBuf[rxBufIdx] = c;
8000b734:	30 32       	add.a %a2,%a3
	++rxBufIdx;
8000b736:	59 ff e0 f1 	st.w [%a15]8160 <70001fe0 <rxBufIdx>>,%d15
{
	static unsigned char rxBuf[16] = { 0 };

	unsigned char c = (unsigned char)_in_uart1();

	rxBuf[rxBufIdx] = c;
8000b73a:	34 22       	st.b [%a2],%d2
	++rxBufIdx;

	/*   , buf_tof  */
	if (rxBufIdx == TOF_length) {
8000b73c:	8b 0f 21 f2 	ne %d15,%d15,16
8000b740:	6e 02       	jz %d15,8000b744 <IsrUart1RxHandler_tof+0x2a>
8000b742:	00 90       	ret 
		memcpy(gBuf_tof, rxBuf, TOF_length);
8000b744:	91 00 00 27 	movh.a %a2,28672
8000b748:	d9 22 d0 f1 	lea %a2,[%a2]8144 <70001fd0 <gBuf_tof>>
8000b74c:	a0 f4       	mov.a %a4,15
8000b74e:	04 3f       	ld.bu %d15,[%a3+]
8000b750:	24 2f       	st.b [%a2+],%d15
8000b752:	fc 4e       	loop %a4,8000b74e <IsrUart1RxHandler_tof+0x34>
		rxBufIdx = 0;
8000b754:	82 0f       	mov %d15,0
8000b756:	59 ff e0 f1 	st.w [%a15]8160,%d15
8000b75a:	00 90       	ret 

8000b75c <getTofDistance>:
	}
}

/* Return Distance(mm) */
int getTofDistance (void)
{
8000b75c:	20 10       	sub.a %sp,16
    int TOF_distance = 0;
    unsigned char buf_ToF[TOF_length];

    /* copy buf_tof into tmp */
    memcpy(buf_ToF, gBuf_tof, TOF_length);
8000b75e:	91 00 00 27 	movh.a %a2,28672
8000b762:	40 af       	mov.aa %a15,%sp
8000b764:	d9 22 d0 f1 	lea %a2,[%a2]8144 <70001fd0 <gBuf_tof>>
8000b768:	a0 f3       	mov.a %a3,15
8000b76a:	04 2f       	ld.bu %d15,[%a2+]
8000b76c:	24 ff       	st.b [%a15+],%d15
8000b76e:	fc 3e       	loop %a3,8000b76a <getTofDistance+0xe>
/*    1,   0  */
static int verifyCheckSum(unsigned char data[])
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
8000b770:	19 a5 04 00 	ld.w %d5,[%sp]4
8000b774:	54 a2       	ld.w %d2,[%sp]
8000b776:	7b f0 f7 f7 	movh %d15,32639
8000b77a:	1b ff f7 f7 	addi %d15,%d15,32639
8000b77e:	0f f5 80 30 	and %d3,%d5,%d15
8000b782:	0f f2 80 40 	and %d4,%d2,%d15
8000b786:	42 34       	add %d4,%d3
8000b788:	c6 52       	xor %d2,%d5
8000b78a:	8b ff 1f 31 	rsub %d3,%d15,-1
8000b78e:	26 32       	and %d2,%d3
8000b790:	19 a5 08 00 	ld.w %d5,[%sp]8
8000b794:	c6 42       	xor %d2,%d4
8000b796:	0f f2 80 40 	and %d4,%d2,%d15
8000b79a:	c6 52       	xor %d2,%d5
8000b79c:	26 5f       	and %d15,%d5
8000b79e:	26 23       	and %d3,%d2
8000b7a0:	42 4f       	add %d15,%d4
8000b7a2:	c6 3f       	xor %d15,%d3
8000b7a4:	39 a2 0c 00 	ld.bu %d2,[%sp]12
8000b7a8:	39 a3 0d 00 	ld.bu %d3,[%sp]13
8000b7ac:	42 23       	add %d3,%d2
8000b7ae:	39 a2 0e 00 	ld.bu %d2,[%sp]14
8000b7b2:	42 23       	add %d3,%d2
8000b7b4:	37 0f 68 24 	extr.u %d2,%d15,8,8
8000b7b8:	42 f3       	add %d3,%d15
8000b7ba:	42 23       	add %d3,%d2
8000b7bc:	37 0f 68 28 	extr.u %d2,%d15,16,8
8000b7c0:	37 0f 68 fc 	extr.u %d15,%d15,24,8
8000b7c4:	42 32       	add %d2,%d3
8000b7c6:	42 2f       	add %d15,%d2
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b7c8:	14 a2       	ld.bu %d2,[%sp]
/*    1,   0  */
static int verifyCheckSum(unsigned char data[])
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
8000b7ca:	16 ff       	and %d15,255
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b7cc:	8b 72 25 32 	ne %d3,%d2,87
//     for (int i = 0; i < 16; i++) {
//         my_printf("%.2X ", buf_ToF[i]);
//     }

    if (!verifyCheckSum(buf_ToF)) {
		return -1;
8000b7d0:	82 f2       	mov %d2,-1
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b7d2:	76 32       	jz %d3,8000b7d6 <getTofDistance+0x7a>
	}

    TOF_distance = buf_ToF[8] | (buf_ToF[9] << 8) | (buf_ToF[10] << 16);

    return TOF_distance;
}
8000b7d4:	00 90       	ret 
{
	unsigned char checksum = 0;
	for (int i = 0; i < TOF_length - 1; i++) {
		checksum += data[i];
	}
	if (data[0] == 0x57 && data[1] == 0x0 && data[2] == 0xFF) {
8000b7d6:	39 a3 01 00 	ld.bu %d3,[%sp]1
8000b7da:	df 03 fd ff 	jne %d3,0,8000b7d4 <getTofDistance+0x78>
8000b7de:	39 a3 02 00 	ld.bu %d3,[%sp]2
8000b7e2:	8b f3 2f 32 	ne %d3,%d3,255
8000b7e6:	df 03 f7 ff 	jne %d3,0,8000b7d4 <getTofDistance+0x78>
    /* for debugging */
//     for (int i = 0; i < 16; i++) {
//         my_printf("%.2X ", buf_ToF[i]);
//     }

    if (!verifyCheckSum(buf_ToF)) {
8000b7ea:	39 a3 0f 00 	ld.bu %d3,[%sp]15
8000b7ee:	5f f3 f3 ff 	jne %d3,%d15,8000b7d4 <getTofDistance+0x78>
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b7f2:	0c a9       	ld.bu %d15,[%sp]9
	int TOF_signal_strength = data[12] | (data[13] << 8);
8000b7f4:	39 a3 0d 00 	ld.bu %d3,[%sp]13
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b7f8:	8f 8f 00 20 	sh %d2,%d15,8
8000b7fc:	0c aa       	ld.bu %d15,[%sp]10
	int TOF_signal_strength = data[12] | (data[13] << 8);
	/* when distance over 2m - out of range */
	if (TOF_signal_strength != 0 && TOF_distance != 0xFFFFF6u) {
8000b7fe:	7b 00 10 40 	movh %d4,256
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b802:	8f 0f 01 f0 	sh %d15,%d15,16
8000b806:	a6 2f       	or %d15,%d2
8000b808:	39 a2 08 00 	ld.bu %d2,[%sp]8
	int TOF_signal_strength = data[12] | (data[13] << 8);
	/* when distance over 2m - out of range */
	if (TOF_signal_strength != 0 && TOF_distance != 0xFFFFF6u) {
8000b80c:	1b 64 ff 4f 	addi %d4,%d4,-10
}

/*    1 ,   0  */
static int checkTofStrength(unsigned char data[])
{
	int TOF_distance = data[8] | (data[9] << 8) | (data[10] << 16);
8000b810:	a6 2f       	or %d15,%d2
	int TOF_signal_strength = data[12] | (data[13] << 8);
8000b812:	8f 83 00 20 	sh %d2,%d3,8
8000b816:	39 a3 0c 00 	ld.bu %d3,[%sp]12
8000b81a:	a6 23       	or %d3,%d2
	/* when distance over 2m - out of range */
	if (TOF_signal_strength != 0 && TOF_distance != 0xFFFFF6u) {
8000b81c:	8b 03 20 22 	ne %d2,%d3,0
8000b820:	0b 4f 10 22 	and.ne %d2,%d15,%d4

    if (!verifyCheckSum(buf_ToF)) {
		return -1;
	}
	if (!checkTofStrength(buf_ToF)) {
		return -2;
8000b824:	ab ef 9f 22 	sel %d2,%d2,%d15,-2
	}

    TOF_distance = buf_ToF[8] | (buf_ToF[9] << 8) | (buf_ToF[10] << 16);

    return TOF_distance;
}
8000b828:	00 90       	ret 

8000b82a <InterruptInit>:
	Return:		void
---------------------------------------------------------------------*/
void InterruptInit(void)
{
	/* basic initialisation of vector tables */
	_init_vectab();
8000b82a:	6d 00 2f 2d 	call 80011288 <_init_vectab>
}

static __inline__ __attribute__((__always_inline__))
void _enable (void)
{
  __asm__ volatile ("enable" ::: "memory");
8000b82e:	0d 00 00 03 	enable 
8000b832:	00 90       	ret 

8000b834 <InterruptInstall>:
				int prio         - priority (1-255)
				int arg          - argument for service routine
	Return:		void
---------------------------------------------------------------------*/
void InterruptInstall(int irqNum, isrhnd_t isrProc, int prio, int arg)
{
8000b834:	02 4f       	mov %d15,%d4
8000b836:	02 58       	mov %d8,%d5

static __inline__ __attribute__((__always_inline__))
unsigned _mfcr (const unsigned __regaddr)
{
  unsigned __res;
  __asm__ volatile ("mfcr %0, LO:%1"
8000b838:	4d c0 e1 9f 	mfcr %d9,$core_id
	unsigned int coreId = _mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK;

	if ((irqNum < 0) || (IRQ_ID_MAX_NUM <= irqNum))
8000b83c:	3b 40 77 20 	mov %d2,1908
8000b840:	3f 24 03 80 	jlt.u %d4,%d2,8000b846 <InterruptInstall+0x12>
8000b844:	00 90       	ret 
	{
		return;
	}

	/* install the service routine */
	_install_int_handler(prio, isrProc, arg);
8000b846:	0b 56 10 48 	mov %e4,%d6,%d5
8000b84a:	6d 00 0c 2d 	call 80011262 <_install_int_handler>

	/* set processor and priority values */
	tabSRC[irqNum].B.TOS  = coreId;
8000b84e:	06 2f       	sh %d15,2
8000b850:	60 f2       	mov.a %a2,%d15
	tabSRC[irqNum].B.SRPN = prio;
8000b852:	8f f8 0f 81 	and %d8,%d8,255

	/* install the service routine */
	_install_int_handler(prio, isrProc, arg);

	/* set processor and priority values */
	tabSRC[irqNum].B.TOS  = coreId;
8000b856:	d9 2f 00 08 	lea %a15,[%a2]-32768
8000b85a:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000b85e:	4c f0       	ld.w %d15,[%a15]0
8000b860:	37 9f 82 95 	insert %d9,%d15,%d9,11,2
8000b864:	68 09       	st.w [%a15]0,%d9
	tabSRC[irqNum].B.SRPN = prio;
8000b866:	4c f0       	ld.w %d15,[%a15]0
8000b868:	8f ff cf f1 	andn %d15,%d15,255
8000b86c:	a6 f8       	or %d8,%d15
8000b86e:	68 08       	st.w [%a15]0,%d8
	/* ... and enable it */
	tabSRC[irqNum].B.SRE = 1;
8000b870:	4c f0       	ld.w %d15,[%a15]0
8000b872:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000b876:	68 0f       	st.w [%a15]0,%d15
8000b878:	00 90       	ret 

8000b87a <SYSTEM_Init>:
8000b87a:	4d c0 e1 ff 	mfcr %d15,$core_id
 */
static void SYSTEM_InitExt(const PllInitValue_t *pPllInitValue)
{
#ifndef SYSTEM_DONT_SET_PLL
	/* initialise PLL (only done by CPU0) */
	if (0 == (_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
8000b87e:	16 07       	and %d15,7
8000b880:	6e 02       	jz %d15,8000b884 <SYSTEM_Init+0xa>
8000b882:	00 90       	ret 
{
	unsigned int k;

	unlock_safety_wdtcon();

	pSCU->OSCCON.U = pPllInitValue->valOSCCON;
8000b884:	7b 70 00 f0 	movh %d15,7
8000b888:	91 30 00 ff 	movh.a %a15,61443
8000b88c:	1b cf 01 f0 	addi %d15,%d15,28
8000b890:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>

static void system_set_pll(const PllInitValue_t *pPllInitValue)
{
	unsigned int k;

	unlock_safety_wdtcon();
8000b894:	6d 00 7c 2d 	call 8001138c <unlock_safety_wdtcon>

	pSCU->OSCCON.U = pPllInitValue->valOSCCON;
8000b898:	68 4f       	st.w [%a15]16,%d15

	while (pSCU->CCUCON1.B.LCK)
8000b89a:	4c fd       	ld.w %d15,[%a15]52
8000b89c:	bf 0f ff 7f 	jlt %d15,0,8000b89a <SYSTEM_Init+0x20>
		;
	pSCU->CCUCON1.U = pPllInitValue->valCCUCON1 | (1 << IFX_SCU_CCUCON1_UP_OFF);
8000b8a0:	7b 10 00 f5 	movh %d15,20481
8000b8a4:	91 30 00 ff 	movh.a %a15,61443
8000b8a8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b8ac:	1b 2f 24 f2 	addi %d15,%d15,8770
8000b8b0:	68 df       	st.w [%a15]52,%d15

	while (pSCU->CCUCON2.B.LCK)
8000b8b2:	40 f2       	mov.aa %a2,%a15
8000b8b4:	19 2f 00 10 	ld.w %d15,[%a2]64 <70000040 <__DSPR0_START+0x40>>
8000b8b8:	91 30 00 ff 	movh.a %a15,61443
8000b8bc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b8c0:	bf 0f fa 7f 	jlt %d15,0,8000b8b4 <SYSTEM_Init+0x3a>
		;
	pSCU->CCUCON2.U = pPllInitValue->valCCUCON2 | (1 << IFX_SCU_CCUCON2_UP_OFF);
8000b8c4:	7b 00 00 f4 	movh %d15,16384
8000b8c8:	c2 2f       	add %d15,2
8000b8ca:	59 ff 00 10 	st.w [%a15]64 <f0030040 <_SMALL_DATA4_+0x40028040>>,%d15

	pSCU->PLLCON0.U |= ((1 << IFX_SCU_PLLCON0_VCOBYP_OFF) | (1 << IFX_SCU_PLLCON0_SETFINDIS_OFF));
8000b8ce:	4c f6       	ld.w %d15,[%a15]24
8000b8d0:	96 11       	or %d15,17
8000b8d2:	68 6f       	st.w [%a15]24,%d15
	pSCU->PLLCON1.U =  pPllInitValue->valPLLCON1;				/* set Kn divider */
8000b8d4:	7b 20 00 f0 	movh %d15,2
8000b8d8:	1b 5f 50 f0 	addi %d15,%d15,1285
8000b8dc:	68 7f       	st.w [%a15]28,%d15
	pSCU->PLLCON0.U =  pPllInitValue->valPLLCON0				/* set P,N divider */
8000b8de:	7b 10 10 f0 	movh %d15,257
8000b8e2:	1b 1f 62 f7 	addi %d15,%d15,30241
8000b8e6:	68 6f       	st.w [%a15]24,%d15
					| ((1 << IFX_SCU_PLLCON0_VCOBYP_OFF) | (1 << IFX_SCU_PLLCON0_CLRFINDIS_OFF));

	while (pSCU->CCUCON0.B.LCK)
8000b8e8:	4c fc       	ld.w %d15,[%a15]48
8000b8ea:	bf 0f ff 7f 	jlt %d15,0,8000b8e8 <SYSTEM_Init+0x6e>
		;
	pSCU->CCUCON0.U =  pPllInitValue->valCCUCON0 | (1 << IFX_SCU_CCUCON0_UP_OFF);
8000b8ee:	7b 20 21 f5 	movh %d15,21010
8000b8f2:	91 30 00 ff 	movh.a %a15,61443
8000b8f6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b8fa:	1b 2f 11 f0 	addi %d15,%d15,274
8000b8fe:	68 cf       	st.w [%a15]48,%d15

	lock_safety_wdtcon();
8000b900:	6d 00 56 2d 	call 800113ac <lock_safety_wdtcon>

	if (0 == (pPllInitValue->valPLLCON0 & (1 << IFX_SCU_PLLCON0_VCOBYP_OFF)))	/* no prescaler mode requested */
	{
#ifndef SYSTEM_PLL_HAS_NO_LOCK
		/* wait for PLL locked */
		while (0 == pSCU->PLLSTAT.B.VCOLOCK)
8000b904:	40 f2       	mov.aa %a2,%a15
8000b906:	4c 25       	ld.w %d15,[%a2]20
8000b908:	91 30 00 ff 	movh.a %a15,61443
8000b90c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b910:	6f 2f fb 7f 	jz.t %d15,2,8000b906 <SYSTEM_Init+0x8c>
			;
#endif

		unlock_safety_wdtcon();
8000b914:	6d 00 3c 2d 	call 8001138c <unlock_safety_wdtcon>
		pSCU->PLLCON0.B.VCOBYP = 0;			/* disable VCO bypass */
8000b918:	4c f6       	ld.w %d15,[%a15]24
8000b91a:	8f 1f c0 f1 	andn %d15,%d15,1
8000b91e:	68 6f       	st.w [%a15]24,%d15
		lock_safety_wdtcon();
8000b920:	6d 00 46 2d 	call 800113ac <lock_safety_wdtcon>
	}

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
8000b924:	48 79       	ld.w %d9,[%a15]28
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b926:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b928:	7b 60 5f 20 	movh %d2,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b92c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
		pSCU->PLLCON0.B.VCOBYP = 0;			/* disable VCO bypass */
		lock_safety_wdtcon();
	}

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
8000b930:	8f f9 07 91 	and %d9,%d9,127
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b934:	1b 02 10 2e 	addi %d2,%d2,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b938:	df 1f bd 00 	jeq %d15,1,8000bab2 <SYSTEM_Init+0x238>
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000b93c:	91 30 00 ff 	movh.a %a15,61443
8000b940:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000b944:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
8000b946:	82 03       	mov %d3,0
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000b948:	37 0f 64 f4 	extr.u %d15,%d15,8,4
	if (0 == divider)
8000b94c:	6e 15       	jz %d15,8000b976 <SYSTEM_Init+0xfc>
		return 0;
	return (frequency / divider);
8000b94e:	4b f2 11 22 	div.u %e2,%d2,%d15
8000b952:	7b c0 1e f5 	movh %d15,20972
8000b956:	1b ff 51 f8 	addi %d15,%d15,-31457
8000b95a:	73 f2 68 20 	mul.u %e2,%d2,%d15
8000b95e:	8f b3 1f 20 	sh %d2,%d3,-5
8000b962:	53 42 26 f0 	mul %d15,%d2,100
8000b966:	7b 70 1b 2d 	movh %d2,53687
8000b96a:	1b 92 75 21 	addi %d2,%d2,5977
8000b96e:	73 2f 68 20 	mul.u %e2,%d15,%d2
8000b972:	8f 33 1f 30 	sh %d3,%d3,-13
{
	unsigned int fSTM = (unsigned int)SYSTEM_GetStmClock();
	unsigned int stmWaitCount = (fSTM / TIME_SCALE_DN) * time / TIME_SCALE_UP;

	/* prepare compare register */
	STM0_CMP0.U = STM0_TIM0.U + stmWaitCount;
8000b976:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000b97a:	42 3f       	add %d15,%d3
8000b97c:	a5 ff 30 00 	st.w f0000030 <_SMALL_DATA4_+0x3fff8030>,%d15
	STM0_CMCON.U = 31;
8000b980:	da 1f       	mov %d15,31
8000b982:	a5 ff 38 00 	st.w f0000038 <_SMALL_DATA4_+0x3fff8038>,%d15
	/* Attention: keep this order, otherwise first match will trigger too soon */
	/* reset interrupt flag */
	STM0_ISCR.U = (IFX_STM_ISCR_CMP0IRR_MSK << IFX_STM_ISCR_CMP0IRR_OFF);
8000b986:	82 1f       	mov %d15,1
8000b988:	a5 ff 00 10 	st.w f0000040 <_SMALL_DATA4_+0x3fff8040>,%d15
	/* enable compare match */
	STM0_ICR.B.CMP0EN = 1;
8000b98c:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000b990:	96 01       	or %d15,1
8000b992:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15
	/* wait for compare match */
	while (0 == STM0_ICR.B.CMP0IR)
8000b996:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000b99a:	6f 1f fe 7f 	jz.t %d15,1,8000b996 <SYSTEM_Init+0x11c>
		;
	STM0_ICR.B.CMP0EN = 0;
8000b99e:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000b9a2:	8f 1f c0 f1 	andn %d15,%d15,1
8000b9a6:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
	/* wait some time (100 us) */
	wait(100);
	while (k > pPllInitValue->finalK)
8000b9aa:	bf 39 6c ff 	jlt.u %d9,3,8000b882 <SYSTEM_Init+0x8>
	{
		Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000b9ae:	91 30 00 ff 	movh.a %a15,61443
8000b9b2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000b9b6:	7b 10 13 c0 	movh %d12,305
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000b9ba:	7b f0 fa d2 	movh %d13,12207
8000b9be:	c2 f9       	add %d9,-1
#if (USE_OLD_CLOCK_SCHEME == 0)
		/* A step devices don't have this field */
		pllcon1.B.K3DIV = k;
#endif /* USE_OLD_CLOCK_SCHEME == 0 */
		/* wait until K2 operation is stable */
		while (0 == pSCU->PLLSTAT.B.K2RDY)
8000b9c0:	40 fc       	mov.aa %a12,%a15
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000b9c2:	1b 0c d0 c2 	addi %d12,%d12,11520
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000b9c6:	1b 0d 80 d0 	addi %d13,%d13,2048
	unsigned int fSTM = (unsigned int)SYSTEM_GetStmClock();
	unsigned int stmWaitCount = (fSTM / TIME_SCALE_DN) * time / TIME_SCALE_UP;

	/* prepare compare register */
	STM0_CMP0.U = STM0_TIM0.U + stmWaitCount;
	STM0_CMCON.U = 31;
8000b9ca:	3b f0 01 b0 	mov %d11,31
	k = pSCU->PLLCON1.B.K2DIV;
	/* wait some time (100 us) */
	wait(100);
	while (k > pPllInitValue->finalK)
	{
		Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000b9ce:	48 78       	ld.w %d8,[%a15]28

		--k;
		/* prepare value to write */
		pllcon1.B.K2DIV = k;
8000b9d0:	8f f9 07 a1 	and %d10,%d9,127
#if (USE_OLD_CLOCK_SCHEME == 0)
		/* A step devices don't have this field */
		pllcon1.B.K3DIV = k;
#endif /* USE_OLD_CLOCK_SCHEME == 0 */
		/* wait until K2 operation is stable */
		while (0 == pSCU->PLLSTAT.B.K2RDY)
8000b9d4:	4c f5       	ld.w %d15,[%a15]20
8000b9d6:	6f 5f ff 7f 	jz.t %d15,5,8000b9d4 <SYSTEM_Init+0x15a>
			;
		unlock_safety_wdtcon();
		pSCU->PLLCON1 = pllcon1;
8000b9da:	37 a8 07 80 	insert %d8,%d8,%d10,0,7
8000b9de:	37 a8 07 84 	insert %d8,%d8,%d10,8,7
		pllcon1.B.K3DIV = k;
#endif /* USE_OLD_CLOCK_SCHEME == 0 */
		/* wait until K2 operation is stable */
		while (0 == pSCU->PLLSTAT.B.K2RDY)
			;
		unlock_safety_wdtcon();
8000b9e2:	6d 00 d5 2c 	call 8001138c <unlock_safety_wdtcon>
		pSCU->PLLCON1 = pllcon1;
8000b9e6:	59 c8 1c 00 	st.w [%a12]28 <f003001c <_SMALL_DATA4_+0x4002801c>>,%d8
		lock_safety_wdtcon();
8000b9ea:	6d 00 e1 2c 	call 800113ac <lock_safety_wdtcon>
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b9ee:	4c cc       	ld.w %d15,[%a12]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b9f0:	7b 60 5f 20 	movh %d2,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b9f4:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000b9f8:	1b 02 10 2e 	addi %d2,%d2,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000b9fc:	df 1f 38 00 	jeq %d15,1,8000ba6c <SYSTEM_Init+0x1f2>
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000ba00:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
8000ba02:	82 03       	mov %d3,0
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000ba04:	37 0f 64 f4 	extr.u %d15,%d15,8,4
	if (0 == divider)
8000ba08:	6e 15       	jz %d15,8000ba32 <SYSTEM_Init+0x1b8>
		return 0;
	return (frequency / divider);
8000ba0a:	4b f2 11 22 	div.u %e2,%d2,%d15
8000ba0e:	7b c0 1e f5 	movh %d15,20972
8000ba12:	1b ff 51 f8 	addi %d15,%d15,-31457
8000ba16:	73 f2 68 20 	mul.u %e2,%d2,%d15
8000ba1a:	8f b3 1f 20 	sh %d2,%d3,-5
8000ba1e:	53 42 26 f0 	mul %d15,%d2,100
8000ba22:	7b 70 1b 2d 	movh %d2,53687
8000ba26:	1b 92 75 21 	addi %d2,%d2,5977
8000ba2a:	73 2f 68 20 	mul.u %e2,%d15,%d2
8000ba2e:	8f 33 1f 30 	sh %d3,%d3,-13
{
	unsigned int fSTM = (unsigned int)SYSTEM_GetStmClock();
	unsigned int stmWaitCount = (fSTM / TIME_SCALE_DN) * time / TIME_SCALE_UP;

	/* prepare compare register */
	STM0_CMP0.U = STM0_TIM0.U + stmWaitCount;
8000ba32:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
8000ba36:	42 3f       	add %d15,%d3
8000ba38:	a5 ff 30 00 	st.w f0000030 <_SMALL_DATA4_+0x3fff8030>,%d15
	STM0_CMCON.U = 31;
8000ba3c:	a5 fb 38 00 	st.w f0000038 <_SMALL_DATA4_+0x3fff8038>,%d11
	/* Attention: keep this order, otherwise first match will trigger too soon */
	/* reset interrupt flag */
	STM0_ISCR.U = (IFX_STM_ISCR_CMP0IRR_MSK << IFX_STM_ISCR_CMP0IRR_OFF);
8000ba40:	82 1f       	mov %d15,1
8000ba42:	a5 ff 00 10 	st.w f0000040 <_SMALL_DATA4_+0x3fff8040>,%d15
	/* enable compare match */
	STM0_ICR.B.CMP0EN = 1;
8000ba46:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000ba4a:	96 01       	or %d15,1
8000ba4c:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15
	/* wait for compare match */
	while (0 == STM0_ICR.B.CMP0IR)
8000ba50:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000ba54:	6f 1f fe 7f 	jz.t %d15,1,8000ba50 <SYSTEM_Init+0x1d6>
		;
	STM0_ICR.B.CMP0EN = 0;
8000ba58:	85 ff 3c 00 	ld.w %d15,f000003c <_SMALL_DATA4_+0x3fff803c>
8000ba5c:	c2 f9       	add %d9,-1
8000ba5e:	8f 1f c0 f1 	andn %d15,%d15,1
8000ba62:	a5 ff 3c 00 	st.w f000003c <_SMALL_DATA4_+0x3fff803c>,%d15

	/* update K dividers for stepping up to final clock */
	k = pSCU->PLLCON1.B.K2DIV;
	/* wait some time (100 us) */
	wait(100);
	while (k > pPllInitValue->finalK)
8000ba66:	df 19 b4 ff 	jne %d9,1,8000b9ce <SYSTEM_Init+0x154>
8000ba6a:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000ba6c:	19 c3 14 00 	ld.w %d3,[%a12]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000ba70:	19 c2 18 00 	ld.w %d2,[%a12]24
8000ba74:	37 02 e7 44 	extr.u %d4,%d2,9,7
8000ba78:	37 02 64 7c 	extr.u %d7,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000ba7c:	19 c2 1c 00 	ld.w %d2,[%a12]28
8000ba80:	8f f2 07 61 	and %d6,%d2,127
8000ba84:	37 02 67 58 	extr.u %d5,%d2,16,7

	if (0 == (pllstat.B.VCOBYST))
8000ba88:	6f 03 0d 80 	jnz.t %d3,0,8000baa2 <SYSTEM_Init+0x228>
	{
		if (0 == (pllstat.B.FINDIS))
8000ba8c:	6f 33 0f 80 	jnz.t %d3,3,8000baaa <SYSTEM_Init+0x230>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000ba90:	03 c4 0a 4c 	madd %d4,%d12,%d4,%d12
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000ba94:	9a 17       	add %d15,%d7,1
8000ba96:	4b f4 11 42 	div.u %e4,%d4,%d15
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000ba9a:	9a 16       	add %d15,%d6,1
8000ba9c:	4b f4 11 22 	div.u %e2,%d4,%d15
8000baa0:	3c b0       	j 8000ba00 <SYSTEM_Init+0x186>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000baa2:	9a 15       	add %d15,%d5,1
8000baa4:	4b fc 11 22 	div.u %e2,%d12,%d15
8000baa8:	3c ac       	j 8000ba00 <SYSTEM_Init+0x186>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000baaa:	9a 16       	add %d15,%d6,1
8000baac:	4b fd 11 22 	div.u %e2,%d13,%d15
8000bab0:	3c a8       	j 8000ba00 <SYSTEM_Init+0x186>

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bab2:	48 53       	ld.w %d3,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bab4:	4c f6       	ld.w %d15,[%a15]24
8000bab6:	37 0f e7 54 	extr.u %d5,%d15,9,7
8000baba:	37 0f 64 7c 	extr.u %d7,%d15,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000babe:	4c f7       	ld.w %d15,[%a15]28
8000bac0:	8f ff 07 61 	and %d6,%d15,127
8000bac4:	37 0f 67 28 	extr.u %d2,%d15,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bac8:	6f 03 14 80 	jnz.t %d3,0,8000baf0 <SYSTEM_Init+0x276>
	{
		if (0 == (pllstat.B.FINDIS))
8000bacc:	6f 33 1b 80 	jnz.t %d3,3,8000bb02 <SYSTEM_Init+0x288>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bad0:	7b 10 13 20 	movh %d2,305
8000bad4:	1b 02 d0 22 	addi %d2,%d2,11520
8000bad8:	03 25 0a 22 	madd %d2,%d2,%d5,%d2
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000badc:	1b 17 00 40 	addi %d4,%d7,1
8000bae0:	4b 42 11 42 	div.u %e4,%d2,%d4
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bae4:	1b 16 00 20 	addi %d2,%d6,1
8000bae8:	4b 24 11 22 	div.u %e2,%d4,%d2
8000baec:	1d ff 28 ff 	j 8000b93c <SYSTEM_Init+0xc2>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000baf0:	7b 10 13 30 	movh %d3,305
8000baf4:	c2 12       	add %d2,1
8000baf6:	1b 03 d0 32 	addi %d3,%d3,11520
8000bafa:	4b 23 11 22 	div.u %e2,%d3,%d2
8000bafe:	1d ff 1f ff 	j 8000b93c <SYSTEM_Init+0xc2>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bb02:	7b f0 fa f2 	movh %d15,12207
8000bb06:	1b 16 00 20 	addi %d2,%d6,1
8000bb0a:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bb0e:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bb12:	1d ff 15 ff 	j 8000b93c <SYSTEM_Init+0xc2>

8000bb16 <SYSTEM_GetExtClock>:
}

unsigned long SYSTEM_GetExtClock(void)
{
	return EXTCLK;
}
8000bb16:	7b 10 13 20 	movh %d2,305
8000bb1a:	1b 02 d0 22 	addi %d2,%d2,11520
8000bb1e:	00 90       	ret 

8000bb20 <SYSTEM_GetCpuClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bb20:	91 30 00 ff 	movh.a %a15,61443
8000bb24:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bb28:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bb2a:	7b 60 5f 40 	movh %d4,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bb2e:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bb32:	1b 04 10 4e 	addi %d4,%d4,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bb36:	9e 1f       	jeq %d15,1,8000bb74 <SYSTEM_GetCpuClock+0x54>
	unsigned long divider;

	unsigned long cpudiv = 0;
	/* B + C Step devices */
	/* fCPU = fSRI */
	divider = pSCU->CCUCON0.B.SRIDIV;
8000bb38:	91 30 00 ff 	movh.a %a15,61443
8000bb3c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bb40:	4c fc       	ld.w %d15,[%a15]48

	if (0 == divider)
		return 0;
8000bb42:	82 02       	mov %d2,0
	unsigned long divider;

	unsigned long cpudiv = 0;
	/* B + C Step devices */
	/* fCPU = fSRI */
	divider = pSCU->CCUCON0.B.SRIDIV;
8000bb44:	37 0f 64 f4 	extr.u %d15,%d15,8,4

	if (0 == divider)
8000bb48:	6e 15       	jz %d15,8000bb72 <SYSTEM_GetCpuClock+0x52>
		return 0;
	frequency /= divider;
8000bb4a:	4b f4 11 42 	div.u %e4,%d4,%d15
8000bb4e:	02 42       	mov %d2,%d4
8000bb50:	4d c0 e1 ff 	mfcr %d15,$core_id

#if (USE_OLD_CLOCK_SCHEME == 0)
	/* determine correct CPU<n>DIV field */
	switch ((_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
8000bb54:	16 07       	and %d15,7
8000bb56:	df 1f 2c 00 	jeq %d15,1,8000bbae <SYSTEM_GetCpuClock+0x8e>
8000bb5a:	6e 36       	jz %d15,8000bbc6 <SYSTEM_GetCpuClock+0xa6>
8000bb5c:	5e 2a       	jne %d15,2,8000bb70 <SYSTEM_GetCpuClock+0x50>
	{
		case 0 : cpudiv = pSCU->CCUCON6.B.CPU0DIV; break;
		case 1 : cpudiv = pSCU->CCUCON7.B.CPU1DIV; break;
		case 2 : cpudiv = pSCU->CCUCON8.B.CPU2DIV; break;
8000bb5e:	19 ff 08 20 	ld.w %d15,[%a15]136 <f0030088 <_SMALL_DATA4_+0x40028088>>
8000bb62:	16 3f       	and %d15,63
	}

	if (cpudiv != 0)
8000bb64:	6e 07       	jz %d15,8000bb72 <SYSTEM_GetCpuClock+0x52>
	{
		frequency *= (64 - cpudiv);
8000bb66:	8b 0f 04 f1 	rsub %d15,%d15,64
8000bb6a:	e2 f2       	mul %d2,%d15
		frequency /= 64;
8000bb6c:	06 a2       	sh %d2,-6
8000bb6e:	00 90       	ret 
	/* fCPU = fSRI */
	divider = pSCU->CCUCON0.B.SRIDIV;

	if (0 == divider)
		return 0;
	frequency /= divider;
8000bb70:	02 42       	mov %d2,%d4
		frequency /= 64;
	}
#endif /* USE_OLD_CLOCK_SCHEME == 0 */

	return frequency;
}
8000bb72:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bb74:	48 53       	ld.w %d3,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bb76:	4c f6       	ld.w %d15,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bb78:	48 74       	ld.w %d4,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bb7a:	37 0f e7 54 	extr.u %d5,%d15,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bb7e:	8f f4 07 01 	and %d0,%d4,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bb82:	37 0f 64 7c 	extr.u %d7,%d15,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bb86:	37 04 67 48 	extr.u %d4,%d4,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bb8a:	6f 03 16 80 	jnz.t %d3,0,8000bbb6 <SYSTEM_GetCpuClock+0x96>
	{
		if (0 == (pllstat.B.FINDIS))
8000bb8e:	6f 33 20 80 	jnz.t %d3,3,8000bbce <SYSTEM_GetCpuClock+0xae>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bb92:	7b 10 13 f0 	movh %d15,305
8000bb96:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bb9a:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bb9e:	1b 17 00 40 	addi %d4,%d7,1
8000bba2:	4b 4f 11 62 	div.u %e6,%d15,%d4
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bba6:	9a 10       	add %d15,%d0,1
8000bba8:	4b f6 11 42 	div.u %e4,%d6,%d15
8000bbac:	3c c6       	j 8000bb38 <SYSTEM_GetCpuClock+0x18>
#if (USE_OLD_CLOCK_SCHEME == 0)
	/* determine correct CPU<n>DIV field */
	switch ((_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
	{
		case 0 : cpudiv = pSCU->CCUCON6.B.CPU0DIV; break;
		case 1 : cpudiv = pSCU->CCUCON7.B.CPU1DIV; break;
8000bbae:	19 ff 04 20 	ld.w %d15,[%a15]132
8000bbb2:	16 3f       	and %d15,63
8000bbb4:	3c d8       	j 8000bb64 <SYSTEM_GetCpuClock+0x44>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bbb6:	7b 10 13 f0 	movh %d15,305
8000bbba:	c2 14       	add %d4,1
8000bbbc:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bbc0:	4b 4f 11 42 	div.u %e4,%d15,%d4
8000bbc4:	3c ba       	j 8000bb38 <SYSTEM_GetCpuClock+0x18>

#if (USE_OLD_CLOCK_SCHEME == 0)
	/* determine correct CPU<n>DIV field */
	switch ((_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK))
	{
		case 0 : cpudiv = pSCU->CCUCON6.B.CPU0DIV; break;
8000bbc6:	19 ff 00 20 	ld.w %d15,[%a15]128
8000bbca:	16 3f       	and %d15,63
8000bbcc:	3c cc       	j 8000bb64 <SYSTEM_GetCpuClock+0x44>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bbce:	7b f0 fa f2 	movh %d15,12207
8000bbd2:	1b 10 00 40 	addi %d4,%d0,1
8000bbd6:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bbda:	4b 4f 11 42 	div.u %e4,%d15,%d4
8000bbde:	3c ad       	j 8000bb38 <SYSTEM_GetCpuClock+0x18>

8000bbe0 <SYSTEM_GetSysClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bbe0:	91 30 00 ff 	movh.a %a15,61443
8000bbe4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bbe8:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bbea:	7b 60 5f 30 	movh %d3,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bbee:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bbf2:	1b 03 10 3e 	addi %d3,%d3,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bbf6:	1e 1d       	jeq %d15,1,8000bc10 <SYSTEM_GetSysClock+0x30>
}

unsigned long SYSTEM_GetSysClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON0.B.SPBDIV;
8000bbf8:	91 30 00 ff 	movh.a %a15,61443
8000bbfc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bc00:	4c fc       	ld.w %d15,[%a15]48
	if (0 == divider)
		return 0;
8000bc02:	82 02       	mov %d2,0
}

unsigned long SYSTEM_GetSysClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON0.B.SPBDIV;
8000bc04:	37 0f 64 f8 	extr.u %d15,%d15,16,4
	if (0 == divider)
8000bc08:	6e 03       	jz %d15,8000bc0e <SYSTEM_GetSysClock+0x2e>
		return 0;
	return (frequency / divider);
8000bc0a:	4b f3 11 22 	div.u %e2,%d3,%d15
}
8000bc0e:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bc10:	48 54       	ld.w %d4,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bc12:	48 62       	ld.w %d2,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bc14:	48 73       	ld.w %d3,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bc16:	37 02 e7 54 	extr.u %d5,%d2,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bc1a:	8f f3 07 61 	and %d6,%d3,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bc1e:	37 02 64 2c 	extr.u %d2,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bc22:	37 03 67 38 	extr.u %d3,%d3,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bc26:	6f 04 12 80 	jnz.t %d4,0,8000bc4a <SYSTEM_GetSysClock+0x6a>
	{
		if (0 == (pllstat.B.FINDIS))
8000bc2a:	6f 34 19 80 	jnz.t %d4,3,8000bc5c <SYSTEM_GetSysClock+0x7c>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bc2e:	7b 10 13 f0 	movh %d15,305
8000bc32:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bc36:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bc3a:	c2 12       	add %d2,1
8000bc3c:	4b 2f 11 42 	div.u %e4,%d15,%d2
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bc40:	9a 16       	add %d15,%d6,1
8000bc42:	4b f4 11 22 	div.u %e2,%d4,%d15
8000bc46:	02 23       	mov %d3,%d2
8000bc48:	3c d8       	j 8000bbf8 <SYSTEM_GetSysClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bc4a:	7b 10 13 f0 	movh %d15,305
8000bc4e:	c2 13       	add %d3,1
8000bc50:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bc54:	4b 3f 11 22 	div.u %e2,%d15,%d3
8000bc58:	02 23       	mov %d3,%d2
8000bc5a:	3c cf       	j 8000bbf8 <SYSTEM_GetSysClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bc5c:	7b f0 fa f2 	movh %d15,12207
8000bc60:	1b 16 00 20 	addi %d2,%d6,1
8000bc64:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bc68:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bc6c:	02 23       	mov %d3,%d2
8000bc6e:	3c c5       	j 8000bbf8 <SYSTEM_GetSysClock+0x18>

8000bc70 <SYSTEM_GetStmClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bc70:	91 30 00 ff 	movh.a %a15,61443
8000bc74:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bc78:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bc7a:	7b 60 5f 30 	movh %d3,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bc7e:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bc82:	1b 03 10 3e 	addi %d3,%d3,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bc86:	1e 1d       	jeq %d15,1,8000bca0 <SYSTEM_GetStmClock+0x30>
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000bc88:	91 30 00 ff 	movh.a %a15,61443
8000bc8c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bc90:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
		return 0;
8000bc92:	82 02       	mov %d2,0
}

unsigned long SYSTEM_GetStmClock(void)
{
	unsigned long frequency = system_GetIntClock();
	unsigned long divider = pSCU->CCUCON1.B.STMDIV;
8000bc94:	37 0f 64 f4 	extr.u %d15,%d15,8,4
	if (0 == divider)
8000bc98:	6e 03       	jz %d15,8000bc9e <SYSTEM_GetStmClock+0x2e>
		return 0;
	return (frequency / divider);
8000bc9a:	4b f3 11 22 	div.u %e2,%d3,%d15
}
8000bc9e:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bca0:	48 54       	ld.w %d4,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bca2:	48 62       	ld.w %d2,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bca4:	48 73       	ld.w %d3,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bca6:	37 02 e7 54 	extr.u %d5,%d2,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bcaa:	8f f3 07 61 	and %d6,%d3,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bcae:	37 02 64 2c 	extr.u %d2,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bcb2:	37 03 67 38 	extr.u %d3,%d3,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bcb6:	6f 04 12 80 	jnz.t %d4,0,8000bcda <SYSTEM_GetStmClock+0x6a>
	{
		if (0 == (pllstat.B.FINDIS))
8000bcba:	6f 34 19 80 	jnz.t %d4,3,8000bcec <SYSTEM_GetStmClock+0x7c>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bcbe:	7b 10 13 f0 	movh %d15,305
8000bcc2:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bcc6:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bcca:	c2 12       	add %d2,1
8000bccc:	4b 2f 11 42 	div.u %e4,%d15,%d2
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bcd0:	9a 16       	add %d15,%d6,1
8000bcd2:	4b f4 11 22 	div.u %e2,%d4,%d15
8000bcd6:	02 23       	mov %d3,%d2
8000bcd8:	3c d8       	j 8000bc88 <SYSTEM_GetStmClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bcda:	7b 10 13 f0 	movh %d15,305
8000bcde:	c2 13       	add %d3,1
8000bce0:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bce4:	4b 3f 11 22 	div.u %e2,%d15,%d3
8000bce8:	02 23       	mov %d3,%d2
8000bcea:	3c cf       	j 8000bc88 <SYSTEM_GetStmClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bcec:	7b f0 fa f2 	movh %d15,12207
8000bcf0:	1b 16 00 20 	addi %d2,%d6,1
8000bcf4:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bcf8:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bcfc:	02 23       	mov %d3,%d2
8000bcfe:	3c c5       	j 8000bc88 <SYSTEM_GetStmClock+0x18>

8000bd00 <SYSTEM_GetCanClock>:
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bd00:	91 30 00 ff 	movh.a %a15,61443
8000bd04:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bd08:	4c fc       	ld.w %d15,[%a15]48
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bd0a:	7b 60 5f 30 	movh %d3,1526
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bd0e:	37 0f 62 fe 	extr.u %d15,%d15,28,2
	{
		default:
		case 0:  /* back-up clock (typ. 100 MHz) */
			frequency = 100000000ul;
8000bd12:	1b 03 10 3e 	addi %d3,%d3,-7936
}

static unsigned long system_GetIntClock(void)
{
	unsigned long frequency = 0;
	switch (pSCU->CCUCON0.B.CLKSEL)
8000bd16:	1e 1c       	jeq %d15,1,8000bd2e <SYSTEM_GetCanClock+0x2e>

unsigned long SYSTEM_GetCanClock(void)
{
	unsigned long frequency = system_GetIntClock();
    unsigned long divider;
    divider = pSCU->CCUCON1.B.CANDIV;
8000bd18:	91 30 00 ff 	movh.a %a15,61443
8000bd1c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bd20:	4c fd       	ld.w %d15,[%a15]52
	if (0 == divider)
		return 0;
8000bd22:	82 02       	mov %d2,0

unsigned long SYSTEM_GetCanClock(void)
{
	unsigned long frequency = system_GetIntClock();
    unsigned long divider;
    divider = pSCU->CCUCON1.B.CANDIV;
8000bd24:	16 0f       	and %d15,15
	if (0 == divider)
8000bd26:	6e 03       	jz %d15,8000bd2c <SYSTEM_GetCanClock+0x2c>
		return 0;
	return (frequency / divider);
8000bd28:	4b f3 11 22 	div.u %e2,%d3,%d15
}
8000bd2c:	00 90       	ret 

static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
8000bd2e:	48 54       	ld.w %d4,[%a15]20
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bd30:	48 62       	ld.w %d2,[%a15]24
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bd32:	48 73       	ld.w %d3,[%a15]28
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bd34:	37 02 e7 54 	extr.u %d5,%d2,9,7
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bd38:	8f f3 07 61 	and %d6,%d3,127
static unsigned long system_GetPllClock(void)
{
	unsigned int frequency = EXTCLK;	/* fOSC */

	Ifx_SCU_PLLSTAT pllstat = pSCU->PLLSTAT;
	Ifx_SCU_PLLCON0 pllcon0 = pSCU->PLLCON0;
8000bd3c:	37 02 64 2c 	extr.u %d2,%d2,24,4
	Ifx_SCU_PLLCON1 pllcon1 = pSCU->PLLCON1;
8000bd40:	37 03 67 38 	extr.u %d3,%d3,16,7

	if (0 == (pllstat.B.VCOBYST))
8000bd44:	6f 04 12 80 	jnz.t %d4,0,8000bd68 <SYSTEM_GetCanClock+0x68>
	{
		if (0 == (pllstat.B.FINDIS))
8000bd48:	6f 34 19 80 	jnz.t %d4,3,8000bd7a <SYSTEM_GetCanClock+0x7a>
		{
			/* normal mode */
			frequency *= (pllcon0.B.NDIV + 1);		/* fOSC*N */
8000bd4c:	7b 10 13 f0 	movh %d15,305
8000bd50:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bd54:	03 f5 0a ff 	madd %d15,%d15,%d5,%d15
			frequency /= (pllcon0.B.PDIV + 1);		/* .../P  */
8000bd58:	c2 12       	add %d2,1
8000bd5a:	4b 2f 11 42 	div.u %e4,%d15,%d2
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bd5e:	9a 16       	add %d15,%d6,1
8000bd60:	4b f4 11 22 	div.u %e2,%d4,%d15
8000bd64:	02 23       	mov %d3,%d2
8000bd66:	3c d9       	j 8000bd18 <SYSTEM_GetCanClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
	}
	else	/* prescaler mode */
	{
		frequency /= (pllcon1.B.K1DIV + 1);		/* fOSC/K1 */
8000bd68:	7b 10 13 f0 	movh %d15,305
8000bd6c:	c2 13       	add %d3,1
8000bd6e:	1b 0f d0 f2 	addi %d15,%d15,11520
8000bd72:	4b 3f 11 22 	div.u %e2,%d15,%d3
8000bd76:	02 23       	mov %d3,%d2
8000bd78:	3c d0       	j 8000bd18 <SYSTEM_GetCanClock+0x18>
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
		}
		else	/* freerunning mode */
		{
			frequency = 800000000;		/* fVCOBASE 800 MHz (???) */
			frequency /= (pllcon1.B.K2DIV + 1);		/* .../K2 */
8000bd7a:	7b f0 fa f2 	movh %d15,12207
8000bd7e:	1b 16 00 20 	addi %d2,%d6,1
8000bd82:	1b 0f 80 f0 	addi %d15,%d15,2048
8000bd86:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000bd8a:	02 23       	mov %d3,%d2
8000bd8c:	3c c6       	j 8000bd18 <SYSTEM_GetCanClock+0x18>

8000bd8e <SYSTEM_EnableInterrupts>:
}

static __inline__ __attribute__((__always_inline__))
void _enable (void)
{
  __asm__ volatile ("enable" ::: "memory");
8000bd8e:	0d 00 00 03 	enable 
8000bd92:	00 90       	ret 

8000bd94 <SYSTEM_DisableInterrupts>:
 **********************************************************************/

static __inline__ __attribute__((__always_inline__))
void _disable (void)
{
  __asm__ volatile ("disable" ::: "memory");
8000bd94:	0d 00 40 03 	disable 
8000bd98:	00 90       	ret 

8000bd9a <SYSTEM_EnableProtection>:
	_disable();
}

void SYSTEM_EnableProtection(void)
{
	lock_wdtcon();
8000bd9a:	1d 00 e3 2a 	j 80011360 <lock_wdtcon>

8000bd9e <SYSTEM_DisableProtection>:
}

void SYSTEM_DisableProtection(void)
{
	unlock_wdtcon();
8000bd9e:	1d 00 cb 2a 	j 80011334 <unlock_wdtcon>

8000bda2 <SYSTEM_EnableProtectionExt>:
}

void SYSTEM_EnableProtectionExt(int Sel)
{
	if (Sel < 3)
8000bda2:	bf 34 04 00 	jlt %d4,3,8000bdaa <SYSTEM_EnableProtectionExt+0x8>
		lock_wdtcon();			/* CPU watchdog */
	else
		lock_safety_wdtcon();	/* safety watchdog */
8000bda6:	1d 00 03 2b 	j 800113ac <lock_safety_wdtcon>
}

void SYSTEM_EnableProtectionExt(int Sel)
{
	if (Sel < 3)
		lock_wdtcon();			/* CPU watchdog */
8000bdaa:	1d 00 db 2a 	j 80011360 <lock_wdtcon>

8000bdae <SYSTEM_DisableProtectionExt>:
		lock_safety_wdtcon();	/* safety watchdog */
}

void SYSTEM_DisableProtectionExt(int Sel)
{
	if (Sel < 3)
8000bdae:	bf 34 04 00 	jlt %d4,3,8000bdb6 <SYSTEM_DisableProtectionExt+0x8>
		unlock_wdtcon();		/* CPU watchdog */
	else
		unlock_safety_wdtcon();	/* safety watchdog */
8000bdb2:	1d 00 ed 2a 	j 8001138c <unlock_safety_wdtcon>
}

void SYSTEM_DisableProtectionExt(int Sel)
{
	if (Sel < 3)
		unlock_wdtcon();		/* CPU watchdog */
8000bdb6:	1d 00 bf 2a 	j 80011334 <unlock_wdtcon>

8000bdba <SYSTEM_EnableSecProtection>:
		unlock_safety_wdtcon();	/* safety watchdog */
}

void SYSTEM_EnableSecProtection(void)
{
	lock_safety_wdtcon();
8000bdba:	1d 00 f9 2a 	j 800113ac <lock_safety_wdtcon>

8000bdbe <SYSTEM_DisableSecProtection>:
}

void SYSTEM_DisableSecProtection(void)
{
	unlock_safety_wdtcon();
8000bdbe:	1d 00 e7 2a 	j 8001138c <unlock_safety_wdtcon>

8000bdc2 <SYSTEM_Reset>:


int SYSTEM_Reset(void)
{
	unlock_safety_wdtcon();
	pSCU->SWRSTCON.B.SWRSTREQ = 1;
8000bdc2:	91 30 00 ff 	movh.a %a15,61443
8000bdc6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
}


int SYSTEM_Reset(void)
{
	unlock_safety_wdtcon();
8000bdca:	6d 00 e1 2a 	call 8001138c <unlock_safety_wdtcon>
	pSCU->SWRSTCON.B.SWRSTREQ = 1;
8000bdce:	19 ff 20 10 	ld.w %d15,[%a15]96 <f0030060 <_SMALL_DATA4_+0x40028060>>
8000bdd2:	96 02       	or %d15,2
8000bdd4:	59 ff 20 10 	st.w [%a15]96 <f0030060 <_SMALL_DATA4_+0x40028060>>,%d15
	while (1)
		;
8000bdd8:	3c 00       	j 8000bdd8 <SYSTEM_Reset+0x16>

8000bdda <SYSTEM_IdleExt>:
	return 0;
}

int SYSTEM_IdleExt(int CoreId)
{
8000bdda:	02 4f       	mov %d15,%d4
	unlock_wdtcon();
8000bddc:	6d 00 ac 2a 	call 80011334 <unlock_wdtcon>
	switch (CoreId)
8000bde0:	9e 1d       	jeq %d15,1,8000be1a <SYSTEM_IdleExt+0x40>
8000bde2:	9e 21       	jeq %d15,2,8000be04 <SYSTEM_IdleExt+0x2a>
8000bde4:	6e 05       	jz %d15,8000bdee <SYSTEM_IdleExt+0x14>
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000bde6:	6d 00 bd 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000bdea:	82 02       	mov %d2,0
8000bdec:	00 90       	ret 
{
	unlock_wdtcon();
	switch (CoreId)
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
8000bdee:	91 30 00 ff 	movh.a %a15,61443
8000bdf2:	82 1f       	mov %d15,1
8000bdf4:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000bdf8:	59 ff 14 30 	st.w [%a15]212 <f00300d4 <_SMALL_DATA4_+0x400280d4>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000bdfc:	6d 00 b2 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000be00:	82 02       	mov %d2,0
8000be02:	00 90       	ret 
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
8000be04:	91 30 00 ff 	movh.a %a15,61443
8000be08:	82 1f       	mov %d15,1
8000be0a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be0e:	59 ff 1c 30 	st.w [%a15]220 <f00300dc <_SMALL_DATA4_+0x400280dc>>,%d15
			break;
	}
	lock_wdtcon();
8000be12:	6d 00 a7 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000be16:	82 02       	mov %d2,0
8000be18:	00 90       	ret 
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
8000be1a:	91 30 00 ff 	movh.a %a15,61443
8000be1e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be22:	59 ff 18 30 	st.w [%a15]216 <f00300d8 <_SMALL_DATA4_+0x400280d8>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be26:	6d 00 9d 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000be2a:	82 02       	mov %d2,0
8000be2c:	00 90       	ret 

8000be2e <SYSTEM_Idle>:

static __inline__ __attribute__((__always_inline__))
unsigned _mfcr (const unsigned __regaddr)
{
  unsigned __res;
  __asm__ volatile ("mfcr %0, LO:%1"
8000be2e:	4d c0 e1 ff 	mfcr %d15,$core_id

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
8000be32:	16 07       	and %d15,7
	return 0;
}

int SYSTEM_IdleExt(int CoreId)
{
	unlock_wdtcon();
8000be34:	6d 00 80 2a 	call 80011334 <unlock_wdtcon>
	switch (CoreId)
8000be38:	9e 1d       	jeq %d15,1,8000be72 <SYSTEM_Idle+0x44>
8000be3a:	9e 21       	jeq %d15,2,8000be5c <SYSTEM_Idle+0x2e>
8000be3c:	6e 05       	jz %d15,8000be46 <SYSTEM_Idle+0x18>
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be3e:	6d 00 91 2a 	call 80011360 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be42:	82 02       	mov %d2,0
8000be44:	00 90       	ret 
{
	unlock_wdtcon();
	switch (CoreId)
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
8000be46:	91 30 00 ff 	movh.a %a15,61443
8000be4a:	82 1f       	mov %d15,1
8000be4c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be50:	59 ff 14 30 	st.w [%a15]212 <f00300d4 <_SMALL_DATA4_+0x400280d4>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be54:	6d 00 86 2a 	call 80011360 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be58:	82 02       	mov %d2,0
8000be5a:	00 90       	ret 
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
8000be5c:	91 30 00 ff 	movh.a %a15,61443
8000be60:	82 1f       	mov %d15,1
8000be62:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be66:	59 ff 1c 30 	st.w [%a15]220 <f00300dc <_SMALL_DATA4_+0x400280dc>>,%d15
			break;
	}
	lock_wdtcon();
8000be6a:	6d 00 7b 2a 	call 80011360 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be6e:	82 02       	mov %d2,0
8000be70:	00 90       	ret 
	{
		case 0:
			pSCU->PMCSR[0].U = 1;	/* request CPU idle mode */
			break;
		case 1:
			pSCU->PMCSR[1].U = 1;	/* request CPU idle mode */
8000be72:	91 30 00 ff 	movh.a %a15,61443
8000be76:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be7a:	59 ff 18 30 	st.w [%a15]216 <f00300d8 <_SMALL_DATA4_+0x400280d8>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 1;	/* request CPU idle mode */
			break;
	}
	lock_wdtcon();
8000be7e:	6d 00 71 2a 	call 80011360 <lock_wdtcon>
}

int SYSTEM_Idle(void)
{
	return SYSTEM_IdleExt(_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK);
}
8000be82:	82 02       	mov %d2,0
8000be84:	00 90       	ret 

8000be86 <SYSTEM_Sleep>:

int SYSTEM_Sleep(void)
{
	unlock_wdtcon();
8000be86:	6d 00 57 2a 	call 80011334 <unlock_wdtcon>
8000be8a:	4d c0 e1 ff 	mfcr %d15,$core_id
	switch (_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK)
8000be8e:	16 07       	and %d15,7
8000be90:	9e 18       	jeq %d15,1,8000bec0 <SYSTEM_Sleep+0x3a>
8000be92:	6e 0c       	jz %d15,8000beaa <SYSTEM_Sleep+0x24>
8000be94:	5e 27       	jne %d15,2,8000bea2 <SYSTEM_Sleep+0x1c>
			break;
		case 1:
			pSCU->PMCSR[1].U = 2;	/* request system sleep mode */
			break;
		case 2:
			pSCU->PMCSR[2].U = 2;	/* request system sleep mode */
8000be96:	91 30 00 ff 	movh.a %a15,61443
8000be9a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000be9e:	59 ff 1c 30 	st.w [%a15]220 <f00300dc <_SMALL_DATA4_+0x400280dc>>,%d15
			break;
	}
	lock_wdtcon();
8000bea2:	6d 00 5f 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000bea6:	82 02       	mov %d2,0
8000bea8:	00 90       	ret 
{
	unlock_wdtcon();
	switch (_mfcr(CPU_CORE_ID) & IFX_CPU_CORE_ID_CORE_ID_MSK)
	{
		case 0:
			pSCU->PMCSR[0].U = 2;	/* request system sleep mode */
8000beaa:	91 30 00 ff 	movh.a %a15,61443
8000beae:	82 2f       	mov %d15,2
8000beb0:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000beb4:	59 ff 14 30 	st.w [%a15]212 <f00300d4 <_SMALL_DATA4_+0x400280d4>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 2;	/* request system sleep mode */
			break;
	}
	lock_wdtcon();
8000beb8:	6d 00 54 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000bebc:	82 02       	mov %d2,0
8000bebe:	00 90       	ret 
	{
		case 0:
			pSCU->PMCSR[0].U = 2;	/* request system sleep mode */
			break;
		case 1:
			pSCU->PMCSR[1].U = 2;	/* request system sleep mode */
8000bec0:	91 30 00 ff 	movh.a %a15,61443
8000bec4:	82 2f       	mov %d15,2
8000bec6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
8000beca:	59 ff 18 30 	st.w [%a15]216 <f00300d8 <_SMALL_DATA4_+0x400280d8>>,%d15
			break;
		case 2:
			pSCU->PMCSR[2].U = 2;	/* request system sleep mode */
			break;
	}
	lock_wdtcon();
8000bece:	6d 00 49 2a 	call 80011360 <lock_wdtcon>
	return 0;
}
8000bed2:	82 02       	mov %d2,0
8000bed4:	00 90       	ret 

8000bed6 <SYSTEM_IsCacheEnabled>:
8000bed6:	4d c0 20 f9 	mfcr %d15,$pcon0

int SYSTEM_IsCacheEnabled(void)
{
	unsigned int ui = _mfcr(CPU_PCON0);
	if (ui & 2)
		return 0;	/* Cache is in bypass mode */
8000beda:	82 02       	mov %d2,0


int SYSTEM_IsCacheEnabled(void)
{
	unsigned int ui = _mfcr(CPU_PCON0);
	if (ui & 2)
8000bedc:	ae 17       	jnz.t %d15,1,8000beea <SYSTEM_IsCacheEnabled+0x14>
8000bede:	4d 80 20 29 	mfcr %d2,$pcon2
		return 0;	/* Cache is in bypass mode */
	ui = _mfcr(CPU_PCON2);
	if (0 == (ui & (IFX_CPU_PCON2_PCACHE_SZE_MSK << IFX_CPU_PCON2_PCACHE_SZE_OFF)))
8000bee2:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000bee6:	8b 02 20 22 	ne %d2,%d2,0
		return 0;	/* Cache size is 0 */
	return 1;
}
8000beea:	00 90       	ret 

8000beec <SYSTEM_EnaDisCache>:

void SYSTEM_EnaDisCache(int Enable)
{
8000beec:	02 4f       	mov %d15,%d4
	unlock_wdtcon();
8000beee:	6d 00 23 2a 	call 80011334 <unlock_wdtcon>
	if (Enable)
8000bef2:	ee 0b       	jnz %d15,8000bf08 <SYSTEM_EnaDisCache+0x1c>
  } while (0)

static __inline__ __attribute__((__always_inline__))
void _mtcr (const unsigned __regaddr, const unsigned __val)
{
  __asm__ volatile ("mtcr LO:%0, %1"
8000bef4:	82 2f       	mov %d15,2
8000bef6:	cd cf 20 09 	mtcr $pcon0,%d15
8000befa:	82 32       	mov %d2,3
8000befc:	cd 42 20 09 	mtcr $pcon1,%d2
8000bf00:	cd 0f 04 09 	mtcr $dcon0,%d15
	{
		_mtcr(CPU_PCON0, 2);
		_mtcr(CPU_PCON1, 3);
		_mtcr(CPU_DCON0, 2);
	}
	lock_wdtcon();
8000bf04:	1d 00 2e 2a 	j 80011360 <lock_wdtcon>
8000bf08:	82 0f       	mov %d15,0
8000bf0a:	cd cf 20 09 	mtcr $pcon0,%d15
8000bf0e:	cd 0f 04 09 	mtcr $dcon0,%d15
8000bf12:	1d 00 27 2a 	j 80011360 <lock_wdtcon>

8000bf16 <SYSTEM_DbgBreak>:
{
#ifdef DEBUG
	__asm volatile ("debug");
#else
	while (1)
		;
8000bf16:	3c 00       	j 8000bf16 <SYSTEM_DbgBreak>

8000bf18 <StartupHook>:
{
//	my_printf("Hello world!\n");
	//ActivateTask(Task_Motor);


	ActivateTask(CAN_Tx);
8000bf18:	82 14       	mov %d4,1
8000bf1a:	6d 00 5d 06 	call 8000cbd4 <ActivateTask>
	ActivateTask(UART_Echo);
8000bf1e:	82 24       	mov %d4,2
8000bf20:	1d 00 5a 06 	j 8000cbd4 <ActivateTask>

8000bf24 <FuncCAN_Tx>:
DeclareTask(CAN_Tx);
DeclareTask(UART_Echo);


TASK(CAN_Tx)
{
8000bf24:	91 00 00 d8 	movh.a %a13,32768
8000bf28:	91 00 00 c8 	movh.a %a12,32768
8000bf2c:	91 00 00 f7 	movh.a %a15,28672
8000bf30:	20 08       	sub.a %sp,8
	uint64 cand = 1;
8000bf32:	82 18       	mov %d8,1
8000bf34:	82 0f       	mov %d15,0
8000bf36:	d9 dd 84 50 	lea %a13,[%a13]2372 <80000944 <osEE_sdb_array+0x58>>
8000bf3a:	d9 cc 9a 50 	lea %a12,[%a12]2394 <8000095a <osEE_sdb_array+0x6e>>
8000bf3e:	d9 ff fd e1 	lea %a15,[%a15]8125 <8000095a <osEE_sdb_array+0x6e>>
	while(1){
		delay_ms(1000);
8000bf42:	3b 80 3e 40 	mov %d4,1000
8000bf46:	6d ff af fa 	call 8000b4a4 <delay_ms>

		cand++;
8000bf4a:	8b 18 80 80 	addx %d8,%d8,1
8000bf4e:	8b 0f a0 f0 	addc %d15,%d15,0
		my_printf("can_data at main: %d\n", cand);
8000bf52:	40 d4       	mov.aa %a4,%a13
8000bf54:	74 a8       	st.w [%sp],%d8
8000bf56:	78 01       	st.w [%sp]4,%d15
8000bf58:	6d ff 53 f8 	call 8000affe <my_printf>
		Can_data_disassembler(0x200, cand);
8000bf5c:	0b 8f 10 68 	mov %e6,%d15,%d8
8000bf60:	3b 00 20 40 	mov %d4,512
8000bf64:	6d ff 14 c3 	call 8000458c <Can_data_disassembler>
		ActivateTask(inner_COM);
8000bf68:	82 34       	mov %d4,3
8000bf6a:	6d 00 35 06 	call 8000cbd4 <ActivateTask>
		my_printf("IsDark data: after COM %d\n", im_IsDark_data);
8000bf6e:	79 f2 00 00 	ld.b %d2,[%a15]0
8000bf72:	40 c4       	mov.aa %a4,%a12
8000bf74:	74 a2       	st.w [%sp],%d2
8000bf76:	6d ff 44 f8 	call 8000affe <my_printf>
	}
8000bf7a:	3c e4       	j 8000bf42 <FuncCAN_Tx+0x1e>

8000bf7c <FuncUART_Echo>:
//	while (1) {
//		c = _in_uart3();
//		_out_uart3(c);
//		if (c == '\r') { _out_uart3('\n'); }
//	}
	TerminateTask();
8000bf7c:	1d 00 b7 06 	j 8000ccea <TerminateTask>

8000bf80 <main>:



int main(void)
{
	SYSTEM_Init();
8000bf80:	6d ff 7d fc 	call 8000b87a <SYSTEM_Init>
	InterruptInit();
8000bf84:	6d ff 53 fc 	call 8000b82a <InterruptInit>

	_init_uart3();
8000bf88:	6d ff 60 f4 	call 8000a848 <_init_uart3>

	Init_GPIO();
8000bf8c:	6d ff b7 fa 	call 8000b4fa <Init_GPIO>

	swc_db_init();
8000bf90:	6d ff 40 c6 	call 80004c10 <swc_db_init>
	Driver_Can_Init();
8000bf94:	6d ff de c3 	call 80004750 <Driver_Can_Init>
//	Init_Ultrasonics();
//	Init_Buzzer();
//	Init_Buzzer_PWM();
	//Init_ToF();
//	init_VADC();
	StartOS(OSDEFAULTAPPMODE);
8000bf98:	82 04       	mov %d4,0
8000bf9a:	6d 00 c5 05 	call 8000cb24 <StartOS>

	return 0;
}
8000bf9e:	82 02       	mov %d2,0
8000bfa0:	00 90       	ret 

8000bfa2 <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000bfa2:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000bfa6:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000bfaa:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000bfae:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000bfb2:	54 26       	ld.w %d6,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000bfb4:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000bfb6:	37 06 6e 61 	extr.u %d6,%d6,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000bfba:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000bfbe:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000bfc2:	8f f6 83 61 	xor %d6,%d6,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000bfc6:	8f f8 83 81 	xor %d8,%d8,63
8000bfca:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
8000bfce:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000bfd0:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
8000bfd4:	3b 00 b8 f0 	mov %d15,2944
8000bfd8:	cd 4f e0 0f 	mtcr $psw,%d15
8000bfdc:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000bfe0:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
8000bfe4:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
8000bfe8:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000bfec:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000bff0:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
8000bff4:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
8000bff6:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
8000bffa:	cd 42 20 09 	mtcr $pcon1,%d2
8000bffe:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c002:	53 cf 20 f0 	mul %d15,%d15,12
8000c006:	10 22       	addsc.a %a2,%a2,%d15,0
8000c008:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c00a:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c00c:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c010:	d9 2f 00 46 	lea %a15,[%a2]24832
8000c014:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c018:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000c01a:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c01e:	2e 16       	jz.t %d15,1,8000c02a <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c020:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c024:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c028:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c02a:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c02e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c032:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c034:	4c f0       	ld.w %d15,[%a15]0
8000c036:	6f 0f ff ff 	jnz.t %d15,0,8000c034 <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
8000c03a:	82 0f       	mov %d15,0
8000c03c:	cd cf 20 09 	mtcr $pcon0,%d15
8000c040:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c044:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c046:	2e 16       	jz.t %d15,1,8000c052 <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c048:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c04c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c050:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c052:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c056:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c05a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c05c:	4c f0       	ld.w %d15,[%a15]0
8000c05e:	6f 0f ff 7f 	jz.t %d15,0,8000c05c <osEE_tc_core0_start+0xba>
8000c062:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
8000c066:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c06a:	91 30 00 ff 	movh.a %a15,61443
8000c06e:	53 cf 20 f0 	mul %d15,%d15,12
8000c072:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c076:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c078:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c07a:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
8000c07c:	d9 2f 00 46 	lea %a15,[%a2]24832
8000c080:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000c084:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c088:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000c08a:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c08e:	2e 16       	jz.t %d15,1,8000c09a <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c090:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c094:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c098:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c09a:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c09e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c0a2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c0a4:	4c f0       	ld.w %d15,[%a15]0
8000c0a6:	6f 0f ff ff 	jnz.t %d15,0,8000c0a4 <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
8000c0aa:	82 0f       	mov %d15,0
8000c0ac:	cd 0f 04 09 	mtcr $dcon0,%d15
8000c0b0:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c0b4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c0b6:	2e 16       	jz.t %d15,1,8000c0c2 <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c0b8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c0bc:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c0c0:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c0c2:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c0c6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c0ca:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c0cc:	4c f0       	ld.w %d15,[%a15]0
8000c0ce:	6f 0f ff 7f 	jz.t %d15,0,8000c0cc <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c0d2:	91 30 00 ff 	movh.a %a15,61443
8000c0d6:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c0da:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c0dc:	2e 16       	jz.t %d15,1,8000c0e8 <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c0de:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c0e2:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c0e6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c0e8:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c0ec:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c0f0:	91 30 00 ff 	movh.a %a15,61443
8000c0f4:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c0f8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c0fa:	4c f0       	ld.w %d15,[%a15]0
8000c0fc:	91 30 00 2f 	movh.a %a2,61443
8000c100:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c104:	6f 0f fb ff 	jnz.t %d15,0,8000c0fa <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
8000c108:	7b 00 00 f8 	movh %d15,32768
8000c10c:	1b 0f 10 f1 	addi %d15,%d15,4352
8000c110:	cd 4f e2 0f 	mtcr $btv,%d15
8000c114:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
8000c118:	7b 00 00 f8 	movh %d15,32768
8000c11c:	1b 0f 00 f2 	addi %d15,%d15,8192
8000c120:	cd 0f e2 0f 	mtcr $biv,%d15
8000c124:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
8000c128:	7b 20 00 f7 	movh %d15,28674
8000c12c:	1b 0f b0 f9 	addi %d15,%d15,-25856
8000c130:	cd 8f e2 0f 	mtcr $isp,%d15
8000c134:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c138:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c13a:	2e 16       	jz.t %d15,1,8000c146 <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c13c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c140:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c144:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c146:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c14a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c14e:	91 30 00 ff 	movh.a %a15,61443
8000c152:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c156:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c158:	4c f0       	ld.w %d15,[%a15]0
8000c15a:	6f 0f ff 7f 	jz.t %d15,0,8000c158 <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
8000c15e:	91 10 00 f7 	movh.a %a15,28673
8000c162:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
8000c166:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
8000c168:	91 10 00 f8 	movh.a %a15,32769
8000c16c:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000c170:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
8000c172:	91 10 00 f8 	movh.a %a15,32769
8000c176:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000c17a:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
8000c17c:	91 10 00 fb 	movh.a %a15,45057
8000c180:	d9 ff 00 08 	lea %a15,[%a15]-32768 <b0008000 <_SMALL_DATA4_>>
8000c184:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
8000c186:	7b 20 00 f7 	movh %d15,28674
8000c18a:	7b 20 00 47 	movh %d4,28674
8000c18e:	1b 0f c0 59 	addi %d5,%d15,-25600
8000c192:	1b 04 c0 4b 	addi %d4,%d4,-17408
8000c196:	a2 54       	sub %d4,%d5
8000c198:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
8000c19a:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
8000c19c:	df 04 1b 00 	jeq %d4,0,8000c1d2 <osEE_tc_core0_start+0x230>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
8000c1a0:	9a f4       	add %d15,%d4,-1
8000c1a2:	06 6f       	sh %d15,6
8000c1a4:	12 53       	add %d3,%d15,%d5

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000c1a6:	60 3f       	mov.a %a15,%d3
8000c1a8:	82 00       	mov %d0,0
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
8000c1aa:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c1ae:	37 03 70 73 	extr.u %d7,%d3,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000c1b2:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000c1b4:	60 4f       	mov.a %a15,%d4
8000c1b6:	1b 0f fc ff 	addi %d15,%d15,-64
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c1ba:	37 27 10 28 	insert %d2,%d7,%d2,16,16
8000c1be:	42 5f       	add %d15,%d5

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000c1c0:	82 53       	mov %d3,5
8000c1c2:	b0 ff       	add.a %a15,-1
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
8000c1c4:	8f 4f 1e 50 	sh %d5,%d15,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c1c8:	37 0f 70 43 	extr.u %d4,%d15,6,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000c1cc:	c2 f3       	add %d3,-1
8000c1ce:	fd f0 11 01 	loop %a15,8000c3f0 <osEE_tc_core0_start+0x44e>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
8000c1d2:	cd 82 e3 0f 	mtcr $fcx,%d2
8000c1d6:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c1da:	91 30 00 ff 	movh.a %a15,61443
8000c1de:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c1e2:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c1e4:	2e 16       	jz.t %d15,1,8000c1f0 <osEE_tc_core0_start+0x24e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c1e6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c1ea:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c1ee:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000c1f0:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c1f4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c1f8:	91 30 00 ff 	movh.a %a15,61443
8000c1fc:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c200:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000c202:	40 f2       	mov.aa %a2,%a15
8000c204:	4c 20       	ld.w %d15,[%a2]0
8000c206:	91 30 00 ff 	movh.a %a15,61443
8000c20a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c20e:	6f 0f fb ff 	jnz.t %d15,0,8000c204 <osEE_tc_core0_start+0x262>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
8000c212:	4c f1       	ld.w %d15,[%a15]4
8000c214:	96 08       	or %d15,8
8000c216:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000c218:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000c21a:	2e 16       	jz.t %d15,1,8000c226 <osEE_tc_core0_start+0x284>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000c21c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000c220:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000c224:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000c226:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000c22a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000c22e:	91 30 00 ff 	movh.a %a15,61443
8000c232:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000c236:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000c238:	4c f0       	ld.w %d15,[%a15]0
8000c23a:	6f 0f ff 7f 	jz.t %d15,0,8000c238 <osEE_tc_core0_start+0x296>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c23e:	91 30 00 ff 	movh.a %a15,61443
8000c242:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c246:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c248:	2e 16       	jz.t %d15,1,8000c254 <osEE_tc_core0_start+0x2b2>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c24a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c24e:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c252:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
8000c254:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
8000c258:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000c25c:	91 30 00 ff 	movh.a %a15,61443
8000c260:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c264:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
8000c266:	40 f2       	mov.aa %a2,%a15
8000c268:	4c 20       	ld.w %d15,[%a2]0
8000c26a:	91 30 00 ff 	movh.a %a15,61443
8000c26e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c272:	6f 0f fb ff 	jnz.t %d15,0,8000c268 <osEE_tc_core0_start+0x2c6>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
8000c276:	4c f1       	ld.w %d15,[%a15]4
8000c278:	96 08       	or %d15,8
8000c27a:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c27c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c27e:	2e 16       	jz.t %d15,1,8000c28a <osEE_tc_core0_start+0x2e8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c280:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c284:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c288:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000c28a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
8000c28e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
8000c292:	91 30 00 ff 	movh.a %a15,61443
8000c296:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c29a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000c29c:	4c f0       	ld.w %d15,[%a15]0
8000c29e:	6f 0f ff 7f 	jz.t %d15,0,8000c29c <osEE_tc_core0_start+0x2fa>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
8000c2a2:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
8000c2a6:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
8000c2a8:	d9 44 e0 70 	lea %a4,[%a4]3552 <80000de0 <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
8000c2ac:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
8000c2ae:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
8000c2b0:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
8000c2b2:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
8000c2b4:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
8000c2b6:	9e f6       	jeq %d15,-1,8000c2e2 <osEE_tc_core0_start+0x340>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
8000c2b8:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000c2bc:	76 49       	jz %d4,8000c2ce <osEE_tc_core0_start+0x32c>
        *block_to_clear.p_ull = 0ULL;
8000c2be:	60 4f       	mov.a %a15,%d4
8000c2c0:	40 32       	mov.aa %a2,%a3
8000c2c2:	b0 ff       	add.a %a15,-1
8000c2c4:	89 22 48 01 	st.d [%a2+]8,%e2
8000c2c8:	fc fe       	loop %a15,8000c2c4 <osEE_tc_core0_start+0x322>
8000c2ca:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
8000c2ce:	2e 22       	jz.t %d15,2,8000c2d2 <osEE_tc_core0_start+0x330>
        *block_to_clear.p_ui = 0x0U;
8000c2d0:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
8000c2d2:	2e 12       	jz.t %d15,1,8000c2d6 <osEE_tc_core0_start+0x334>
        *block_to_clear.p_us = 0x0U;
8000c2d4:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
8000c2d6:	2e 02       	jz.t %d15,0,8000c2da <osEE_tc_core0_start+0x338>
        *block_to_clear.p_uc = 0x0U;
8000c2d8:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
8000c2da:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
8000c2de:	bd 04 ea ff 	jnz.a %a4,8000c2b2 <osEE_tc_core0_start+0x310>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
8000c2e2:	91 00 00 68 	movh.a %a6,32768
8000c2e6:	d9 66 c8 90 	lea %a6,[%a6]3656 <80000e48 <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
8000c2ea:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
8000c2ec:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
8000c2ee:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
8000c2f2:	df ff 21 00 	jeq %d15,-1,8000c334 <osEE_tc_core0_start+0x392>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
8000c2f6:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000c2fa:	76 4f       	jz %d4,8000c318 <osEE_tc_core0_start+0x376>
8000c2fc:	60 4f       	mov.a %a15,%d4
8000c2fe:	40 43       	mov.aa %a3,%a4
8000c300:	40 52       	mov.aa %a2,%a5
8000c302:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
8000c304:	09 22 48 01 	ld.d %e2,[%a2+]8
8000c308:	89 32 48 01 	st.d [%a3+]8,%e2
8000c30c:	fc fc       	loop %a15,8000c304 <osEE_tc_core0_start+0x362>
8000c30e:	06 34       	sh %d4,3
8000c310:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
8000c314:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
8000c318:	2e 23       	jz.t %d15,2,8000c31e <osEE_tc_core0_start+0x37c>
        *block_dest.p_ui = *block_src.p_ui;
8000c31a:	44 52       	ld.w %d2,[%a5+]
8000c31c:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
8000c31e:	2e 14       	jz.t %d15,1,8000c326 <osEE_tc_core0_start+0x384>
        *block_dest.p_us = *block_src.p_us;
8000c320:	09 52 c2 00 	ld.hu %d2,[%a5+]2
8000c324:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
8000c326:	2e 03       	jz.t %d15,0,8000c32c <osEE_tc_core0_start+0x38a>
        *block_dest.p_uc = *block_src.p_uc;
8000c328:	0c 50       	ld.bu %d15,[%a5]0
8000c32a:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
8000c32c:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
8000c330:	bd 06 dd ff 	jnz.a %a6,8000c2ea <osEE_tc_core0_start+0x348>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c334:	91 30 00 ff 	movh.a %a15,61443
8000c338:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c33c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c33e:	2e 16       	jz.t %d15,1,8000c34a <osEE_tc_core0_start+0x3a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c340:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c344:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c348:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
8000c34a:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
8000c34e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000c352:	91 30 00 ff 	movh.a %a15,61443
8000c356:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c35a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
8000c35c:	4c f0       	ld.w %d15,[%a15]0
8000c35e:	6f 0f ff ff 	jnz.t %d15,0,8000c35c <osEE_tc_core0_start+0x3ba>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
8000c362:	7b 20 22 f1 	movh %d15,4642
8000c366:	91 30 00 ff 	movh.a %a15,61443
8000c36a:	1b 1f 10 f0 	addi %d15,%d15,257
8000c36e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000c372:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
8000c374:	7b 00 00 f5 	movh %d15,20480
8000c378:	91 30 00 ff 	movh.a %a15,61443
8000c37c:	1b 0f 10 f1 	addi %d15,%d15,4352
8000c380:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000c384:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
8000c386:	7b 70 00 f0 	movh %d15,7
8000c38a:	91 30 00 ff 	movh.a %a15,61443
8000c38e:	1b cf 01 f0 	addi %d15,%d15,28
8000c392:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
8000c396:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
8000c398:	4c f0       	ld.w %d15,[%a15]0
8000c39a:	6f 1f ff 7f 	jz.t %d15,1,8000c398 <osEE_tc_core0_start+0x3f6>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
8000c39e:	91 30 00 ff 	movh.a %a15,61443
8000c3a2:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
8000c3a6:	4c f0       	ld.w %d15,[%a15]0
8000c3a8:	6f 8f ff 7f 	jz.t %d15,8,8000c3a6 <osEE_tc_core0_start+0x404>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
8000c3ac:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000c3b0:	91 30 00 ff 	movh.a %a15,61443
8000c3b4:	1b 04 20 4c 	addi %d4,%d4,-15872
8000c3b8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c3bc:	6d 00 9a 00 	call 8000c4f0 <osEE_tc_set_pll_fsource>
8000c3c0:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000c3c2:	2e 16       	jz.t %d15,1,8000c3ce <osEE_tc_core0_start+0x42c>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000c3c4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000c3c8:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000c3cc:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000c3ce:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
8000c3d2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
8000c3d6:	91 30 00 ff 	movh.a %a15,61443
8000c3da:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000c3de:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000c3e0:	4c f0       	ld.w %d15,[%a15]0
8000c3e2:	6f 0f ff 7f 	jz.t %d15,0,8000c3e0 <osEE_tc_core0_start+0x43e>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
8000c3e6:	6d ff cd fd 	call 8000bf80 <main>
8000c3ea:	02 24       	mov %d4,%d2
8000c3ec:	1d 00 f0 27 	j 800113cc <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000c3f0:	60 f2       	mov.a %a2,%d15
8000c3f2:	74 22       	st.w [%a2],%d2
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000c3f4:	37 54 10 28 	insert %d2,%d4,%d5,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
8000c3f8:	76 35       	jz %d3,8000c402 <osEE_tc_core0_start+0x460>
8000c3fa:	1b 0f fc ff 	addi %d15,%d15,-64
8000c3fe:	1d ff e3 fe 	j 8000c1c4 <osEE_tc_core0_start+0x222>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
8000c402:	cd c2 e3 0f 	mtcr $lcx,%d2
8000c406:	0d 00 c0 04 	isync 
8000c40a:	3c f8       	j 8000c3fa <osEE_tc_core0_start+0x458>

8000c40c <osEE_tricore_system_timer_handler>:
8000c40c:	4d c0 e1 4f 	mfcr %d4,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c410:	91 00 00 f7 	movh.a %a15,28672
8000c414:	19 ff a0 14 	ld.w %d15,[%a15]18528 <70004860 <osEE_tc_stm_freq_khz>>
8000c418:	3b 80 3e 50 	mov %d5,1000
8000c41c:	37 04 48 40 	extr %d4,%d4,0,8
8000c420:	3f 5f 0b 80 	jlt.u %d15,%d5,8000c436 <osEE_tricore_system_timer_handler+0x2a>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c424:	7b 20 06 21 	movh %d2,4194
8000c428:	1b 32 dd 24 	addi %d2,%d2,19923
8000c42c:	73 2f 68 20 	mul.u %e2,%d15,%d2
8000c430:	8f a3 1f f0 	sh %d15,%d3,-6
8000c434:	e2 5f       	mul %d15,%d5
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
8000c436:	8f 34 00 41 	and %d4,%d4,3
8000c43a:	9b 04 0f 40 	addih %d4,%d4,240
8000c43e:	8f 84 00 40 	sh %d4,%d4,8
8000c442:	60 4f       	mov.a %a15,%d4
8000c444:	48 c2       	ld.w %d2,[%a15]48
8000c446:	42 2f       	add %d15,%d2
8000c448:	68 cf       	st.w [%a15]48,%d15
      break;
  }
#endif /* OSEE_SINGLECORE */

  p_cdb = osEE_get_curr_core();
  osEE_counter_increment(p_cdb->p_sys_counter_db);
8000c44a:	91 00 00 f8 	movh.a %a15,32768
8000c44e:	d9 ff 74 b0 	lea %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000c452:	c8 24       	ld.a %a4,[%a15]8
8000c454:	1d 00 96 0a 	j 8000d980 <osEE_counter_increment>

8000c458 <osEE_tc_initialize_system_timer>:
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000c458:	39 42 1c 00 	ld.bu %d2,[%a4]28
 * @brief  Used to set STM suspension when OCDS take control
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_stm_ocds_suspend_control(OsEE_reg stm_id)
{
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_OCS_OFF) =
8000c45c:	7b 00 20 31 	movh %d3,4608
8000c460:	8f f2 07 21 	and %d2,%d2,127
8000c464:	1b 12 00 70 	addi %d7,%d2,1
8000c468:	a5 f3 28 30 	st.w f00000e8 <_SMALL_DATA4_+0x3fff80e8>,%d3
8000c46c:	4d c0 e1 2f 	mfcr %d2,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c470:	91 00 00 f7 	movh.a %a15,28672
8000c474:	19 ff a0 14 	ld.w %d15,[%a15]18528 <70004860 <osEE_tc_stm_freq_khz>>
8000c478:	3b 80 3e 60 	mov %d6,1000
8000c47c:	37 02 48 30 	extr %d3,%d2,0,8
8000c480:	3f 6f 0b 80 	jlt.u %d15,%d6,8000c496 <osEE_tc_initialize_system_timer+0x3e>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c484:	7b 20 06 41 	movh %d4,4194
8000c488:	1b 34 dd 44 	addi %d4,%d4,19923
8000c48c:	73 4f 68 40 	mul.u %e4,%d15,%d4
8000c490:	8f a5 1f f0 	sh %d15,%d5,-6
8000c494:	e2 6f       	mul %d15,%d6
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
8000c496:	8f 33 00 31 	and %d3,%d3,3
8000c49a:	9b 03 0f 50 	addih %d5,%d3,240
8000c49e:	8f 85 00 50 	sh %d5,%d5,8
8000c4a2:	60 5f       	mov.a %a15,%d5
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000c4a4:	0f 0f b0 41 	clz %d4,%d15
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
8000c4a8:	48 45       	ld.w %d5,[%a15]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
8000c4aa:	8b f4 01 41 	rsub %d4,%d4,31

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
8000c4ae:	42 5f       	add %d15,%d5
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
8000c4b0:	68 cf       	st.w [%a15]48,%d15
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
8000c4b2:	48 e5       	ld.w %d5,[%a15]56
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
8000c4b4:	06 33       	sh %d3,3
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
8000c4b6:	b7 05 05 54 	insert %d5,%d5,0,8,5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000c4ba:	60 32       	mov.a %a2,%d3
8000c4bc:	68 e5       	st.w [%a15]56,%d5
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
8000c4be:	4c fe       	ld.w %d15,[%a15]56
8000c4c0:	8f 32 00 21 	and %d2,%d2,3
8000c4c4:	37 4f 05 40 	insert %d4,%d15,%d4,0,5
8000c4c8:	b7 87 99 f3 	insert %d15,%d7,8,7,25
8000c4cc:	68 e4       	st.w [%a15]56,%d4
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
8000c4ce:	48 f4       	ld.w %d4,[%a15]60
8000c4d0:	8f b2 00 20 	sh %d2,%d2,11
8000c4d4:	8f 44 c0 41 	andn %d4,%d4,4
8000c4d8:	68 f4       	st.w [%a15]60,%d4
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
8000c4da:	48 f4       	ld.w %d4,[%a15]60
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000c4dc:	a6 f2       	or %d2,%d15
8000c4de:	8f 14 40 41 	or %d4,%d4,1
8000c4e2:	68 f4       	st.w [%a15]60,%d4
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000c4e4:	d9 2f 50 28 	lea %a15,[%a2]-31600
8000c4e8:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000c4ec:	68 02       	st.w [%a15]0,%d2
8000c4ee:	00 90       	ret 

8000c4f0 <osEE_tc_set_pll_fsource>:

  bestK2 = 0U;
  bestN  = 0U;
  bestP  = 0U;
  /* K2+1 div should be even for 50% duty cycle */
  k2Steps = 2;
8000c4f0:	7b e0 e4 30 	movh %d3,3662
8000c4f4:	1b 13 c0 31 	addi %d3,%d3,7169
8000c4f8:	82 1f       	mov %d15,1
8000c4fa:	0b 34 50 21 	ge.u %d2,%d4,%d3
8000c4fe:	7b c0 be 50 	movh %d5,3052
8000c502:	ab 2f 80 22 	sel %d2,%d2,%d15,2
8000c506:	1b 05 20 5c 	addi %d5,%d5,-15872
8000c50a:	53 f2 20 70 	mul %d7,%d2,15
8000c50e:	3b 00 01 a0 	mov %d10,16
8000c512:	02 56       	mov %d6,%d5
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000c514:	c2 fa       	add %d10,-1
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000c516:	8b 06 20 f2 	ne %d15,%d6,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000c51a:	7b 10 13 c0 	movh %d12,305

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000c51e:	91 40 0f 50 	movh.a %a5,244
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000c522:	a0 03       	mov.a %a3,0
8000c524:	91 80 82 2e 	movh.a %a2,59432
8000c528:	91 80 7d 61 	movh.a %a6,6104
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000c52c:	8b 0a 20 f4 	and.ne %d15,%d10,0

  bestK2 = 0U;
  bestN  = 0U;
  bestP  = 0U;
  /* K2+1 div should be even for 50% duty cycle */
  k2Steps = 2;
8000c530:	60 2f       	mov.a %a15,%d2
8000c532:	60 74       	mov.a %a4,%d7
8000c534:	d2 00       	mov %e0,0
8000c536:	82 08       	mov %d8,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000c538:	1b 0c d0 c2 	addi %d12,%d12,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000c53c:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000c540:	b0 f3       	add.a %a3,-1
8000c542:	d9 22 c0 07 	lea %a2,[%a2]31744 <e8287c00 <_SMALL_DATA4_+0x3827fc00>>
8000c546:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000c54a:	6e 55       	jz %d15,8000c5f4 <osEE_tc_set_pll_fsource+0x104>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000c54c:	4b ac 11 22 	div.u %e2,%d12,%d10

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000c550:	7b 60 f8 7f 	movh %d7,65414
8000c554:	1b 07 e0 7e 	addi %d7,%d7,-4608
8000c558:	0b 72 40 70 	addx %d7,%d2,%d7
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
8000c55c:	82 03       	mov %d3,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000c55e:	8b f3 bf 20 	addc %d2,%d3,-1
8000c562:	80 5e       	mov.d %d14,%a5
8000c564:	ba 02       	eq %d15,%d2,0
8000c566:	0b e7 50 f2 	and.ge.u %d15,%d7,%d14
8000c56a:	8b 02 00 f5 	or.ne %d15,%d2,0
8000c56e:	ee 3b       	jnz %d15,8000c5e4 <osEE_tc_set_pll_fsource+0xf4>
8000c570:	02 ab       	mov %d11,%d10
8000c572:	82 19       	mov %d9,1
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000c574:	80 3f       	mov.d %d15,%a3
8000c576:	80 2e       	mov.d %d14,%a2
8000c578:	80 67       	mov.d %d7,%a6
8000c57a:	03 49 68 2e 	madd.u %e2,%e14,%d9,%d4
8000c57e:	8b 06 20 d2 	ne %d13,%d6,0
8000c582:	ba 03       	eq %d15,%d3,0
8000c584:	0b 72 30 f2 	and.lt.u %d15,%d2,%d7
8000c588:	6e 25       	jz %d15,8000c5d2 <osEE_tc_set_pll_fsource+0xe2>
        {
          for (
8000c58a:	df 06 2d 00 	jeq %d6,0,8000c5e4 <osEE_tc_set_pll_fsource+0xf4>
8000c58e:	82 12       	mov %d2,1
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
8000c590:	4b b2 11 62 	div.u %e6,%d2,%d11
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
8000c594:	82 13       	mov %d3,1
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
8000c596:	02 6f       	mov %d15,%d6
8000c598:	e2 cf       	mul %d15,%d12
8000c59a:	a2 4f       	sub %d15,%d4
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
8000c59c:	0b 5f 30 32 	and.lt.u %d3,%d15,%d5
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
8000c5a0:	53 1f 40 60 	mul.u %e6,%d15,1
8000c5a4:	2b f5 50 53 	seln %d5,%d3,%d5,%d15
8000c5a8:	2b a1 50 13 	seln %d1,%d3,%d1,%d10
8000c5ac:	2b 20 50 03 	seln %d0,%d3,%d0,%d2
8000c5b0:	2b 98 50 83 	seln %d8,%d3,%d8,%d9
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
8000c5b4:	ee 05       	jnz %d15,8000c5be <osEE_tc_set_pll_fsource+0xce>
8000c5b6:	0b 2a 10 08 	mov %e0,%d10,%d2
8000c5ba:	02 98       	mov %d8,%d9
8000c5bc:	82 05       	mov %d5,0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
8000c5be:	c2 12       	add %d2,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
8000c5c0:	8b 12 68 32 	lt.u %d3,%d2,129
8000c5c4:	8b 0f 20 34 	and.ne %d3,%d15,0
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
8000c5c8:	8b 0f 20 d2 	ne %d13,%d15,0
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
8000c5cc:	df 03 e2 ff 	jne %d3,0,8000c590 <osEE_tc_set_pll_fsource+0xa0>
8000c5d0:	a6 76       	or %d6,%d7
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
8000c5d2:	80 fe       	mov.d %d14,%a15
8000c5d4:	80 4f       	mov.d %d15,%a4
8000c5d6:	42 e9       	add %d9,%d14
8000c5d8:	42 fb       	add %d11,%d15

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
8000c5da:	8b d9 61 f2 	lt.u %d15,%d9,29
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
8000c5de:	26 fd       	and %d13,%d15
8000c5e0:	df 0d ca ff 	jne %d13,0,8000c574 <osEE_tc_set_pll_fsource+0x84>
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
8000c5e4:	c2 fa       	add %d10,-1
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
8000c5e6:	8b 06 20 f2 	ne %d15,%d6,0
8000c5ea:	8b 0a 20 f4 	and.ne %d15,%d10,0
8000c5ee:	01 f4 20 40 	sub.a %a4,%a4,%a15
8000c5f2:	ee ad       	jnz %d15,8000c54c <osEE_tc_set_pll_fsource+0x5c>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
8000c5f4:	7b c0 1e 25 	movh %d2,20972
8000c5f8:	06 14       	sh %d4,1
8000c5fa:	1b f2 51 28 	addi %d2,%d2,-31457
8000c5fe:	73 24 68 20 	mul.u %e2,%d4,%d2
8000c602:	8f b3 1f f0 	sh %d15,%d3,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
8000c606:	7f f5 65 80 	jge.u %d5,%d15,8000c6d0 <osEE_tc_set_pll_fsource+0x1e0>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
8000c60a:	91 30 00 ff 	movh.a %a15,61443
8000c60e:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000c612:	4c f0       	ld.w %d15,[%a15]0
8000c614:	c2 f8       	add %d8,-1
8000c616:	37 8f 07 80 	insert %d8,%d15,%d8,0,7
8000c61a:	68 08       	st.w [%a15]0,%d8

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
8000c61c:	91 30 00 ff 	movh.a %a15,61443
8000c620:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c624:	4c f0       	ld.w %d15,[%a15]0
8000c626:	6f 5f ff 7f 	jz.t %d15,5,8000c624 <osEE_tc_set_pll_fsource+0x134>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
8000c62a:	91 30 00 ff 	movh.a %a15,61443
8000c62e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000c632:	4c f0       	ld.w %d15,[%a15]0
8000c634:	96 01       	or %d15,1
8000c636:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
8000c638:	91 30 00 ff 	movh.a %a15,61443
8000c63c:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c640:	4c f0       	ld.w %d15,[%a15]0
8000c642:	6f 0f ff 7f 	jz.t %d15,0,8000c640 <osEE_tc_set_pll_fsource+0x150>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000c646:	91 30 00 ff 	movh.a %a15,61443
8000c64a:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000c64e:	4c f0       	ld.w %d15,[%a15]0
8000c650:	c2 f1       	add %d1,-1
8000c652:	37 1f 04 1c 	insert %d1,%d15,%d1,24,4
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
8000c656:	c2 f0       	add %d0,-1
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000c658:	68 01       	st.w [%a15]0,%d1
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
8000c65a:	4c f0       	ld.w %d15,[%a15]0
8000c65c:	37 0f 87 04 	insert %d0,%d15,%d0,9,7
8000c660:	68 00       	st.w [%a15]0,%d0

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
8000c662:	4c f0       	ld.w %d15,[%a15]0
8000c664:	8f 2f c0 f1 	andn %d15,%d15,2
8000c668:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
8000c66a:	4c f0       	ld.w %d15,[%a15]0
8000c66c:	96 40       	or %d15,64
8000c66e:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
8000c670:	4c f0       	ld.w %d15,[%a15]0
8000c672:	96 20       	or %d15,32
8000c674:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
8000c676:	91 30 00 ff 	movh.a %a15,61443
8000c67a:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c67e:	4c f0       	ld.w %d15,[%a15]0
8000c680:	6f 3f ff ff 	jnz.t %d15,3,8000c67e <osEE_tc_set_pll_fsource+0x18e>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
8000c684:	91 30 00 ff 	movh.a %a15,61443
8000c688:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000c68c:	4c f0       	ld.w %d15,[%a15]0
8000c68e:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
8000c692:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
8000c694:	91 30 00 ff 	movh.a %a15,61443
8000c698:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c69c:	4c f0       	ld.w %d15,[%a15]0
8000c69e:	6f 2f ff 7f 	jz.t %d15,2,8000c69c <osEE_tc_set_pll_fsource+0x1ac>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
8000c6a2:	91 30 00 ff 	movh.a %a15,61443
8000c6a6:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000c6aa:	4c f0       	ld.w %d15,[%a15]0
8000c6ac:	8f 1f c0 f1 	andn %d15,%d15,1
8000c6b0:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
8000c6b2:	91 30 00 ff 	movh.a %a15,61443
8000c6b6:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c6ba:	4c f0       	ld.w %d15,[%a15]0
8000c6bc:	6f 0f ff ff 	jnz.t %d15,0,8000c6ba <osEE_tc_set_pll_fsource+0x1ca>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
8000c6c0:	91 30 00 ff 	movh.a %a15,61443
8000c6c4:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000c6c8:	4c f0       	ld.w %d15,[%a15]0
8000c6ca:	8f 0f c4 f1 	andn %d15,%d15,64
8000c6ce:	68 0f       	st.w [%a15]0,%d15
8000c6d0:	00 90       	ret 

8000c6d2 <osEE_tc_get_fsource>:

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000c6d2:	91 30 00 ff 	movh.a %a15,61443
8000c6d6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000c6da:	4c f0       	ld.w %d15,[%a15]0
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
8000c6dc:	7b 60 5f 20 	movh %d2,1526

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000c6e0:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
8000c6e4:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000c6e8:	ee 02       	jnz %d15,8000c6ec <osEE_tc_get_fsource+0x1a>
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
8000c6ea:	00 90       	ret 
  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
8000c6ec:	91 30 00 ff 	movh.a %a15,61443
8000c6f0:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c6f4:	4c f0       	ld.w %d15,[%a15]0
8000c6f6:	6f 0f 2d 80 	jnz.t %d15,0,8000c750 <osEE_tc_get_fsource+0x7e>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000c6fa:	4c f0       	ld.w %d15,[%a15]0
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c6fc:	91 30 00 ff 	movh.a %a15,61443
8000c700:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000c704:	6f 3f 1b 80 	jnz.t %d15,3,8000c73a <osEE_tc_get_fsource+0x68>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c708:	4c f0       	ld.w %d15,[%a15]0
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000c70a:	91 30 00 ff 	movh.a %a15,61443
8000c70e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c712:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000c716:	4c f0       	ld.w %d15,[%a15]0
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000c718:	48 02       	ld.w %d2,[%a15]0
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000c71a:	37 0f 64 3c 	extr.u %d3,%d15,24,4
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c71e:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000c720:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000c724:	37 02 e7 44 	extr.u %d4,%d2,9,7

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000c728:	7b 10 13 20 	movh %d2,305
8000c72c:	1b 02 d0 22 	addi %d2,%d2,11520
8000c730:	4b f2 11 22 	div.u %e2,%d2,%d15
8000c734:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
8000c738:	00 90       	ret 
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c73a:	48 02       	ld.w %d2,[%a15]0
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000c73c:	7b 10 13 f0 	movh %d15,305
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c740:	8f f2 07 21 	and %d2,%d2,127
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000c744:	1b 0f d0 f2 	addi %d15,%d15,11520
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c748:	c2 12       	add %d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000c74a:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000c74e:	00 90       	ret 
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000c750:	91 30 00 ff 	movh.a %a15,61443
8000c754:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000c758:	48 02       	ld.w %d2,[%a15]0
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000c75a:	7b 10 13 f0 	movh %d15,305
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000c75e:	37 02 67 28 	extr.u %d2,%d2,16,7
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000c762:	1b 0f d0 f2 	addi %d15,%d15,11520
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000c766:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
8000c768:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000c76c:	00 90       	ret 

8000c76e <osEE_tc_stm_set_clockpersec>:

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
8000c76e:	91 30 00 ff 	movh.a %a15,61443
8000c772:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000c776:	48 02       	ld.w %d2,[%a15]0
8000c778:	7b 60 5f f0 	movh %d15,1526
8000c77c:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000c780:	1b 1f 10 fe 	addi %d15,%d15,-7935
8000c784:	df 02 18 80 	jne %d2,0,8000c7b4 <osEE_tc_stm_set_clockpersec+0x46>
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
8000c788:	91 30 00 ff 	movh.a %a15,61443
8000c78c:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000c790:	48 02       	ld.w %d2,[%a15]0

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
8000c792:	91 00 00 f7 	movh.a %a15,28672
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
8000c796:	37 02 64 24 	extr.u %d2,%d2,8,4
8000c79a:	4b 2f 11 22 	div.u %e2,%d15,%d2

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
8000c79e:	7b 20 06 f1 	movh %d15,4194
8000c7a2:	1b 3f dd f4 	addi %d15,%d15,19923
8000c7a6:	73 f2 68 20 	mul.u %e2,%d2,%d15
8000c7aa:	8f a3 1f f0 	sh %d15,%d3,-6
8000c7ae:	59 ff a0 14 	st.w [%a15]18528 <70004860 <osEE_tc_stm_freq_khz>>,%d15
8000c7b2:	00 90       	ret 
  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
8000c7b4:	91 30 00 ff 	movh.a %a15,61443
8000c7b8:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000c7bc:	4c f0       	ld.w %d15,[%a15]0
8000c7be:	6f 0f 2f 80 	jnz.t %d15,0,8000c81c <osEE_tc_stm_set_clockpersec+0xae>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000c7c2:	4c f0       	ld.w %d15,[%a15]0
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c7c4:	91 30 00 ff 	movh.a %a15,61443
8000c7c8:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000c7cc:	6f 3f 1c 80 	jnz.t %d15,3,8000c804 <osEE_tc_stm_set_clockpersec+0x96>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c7d0:	4c f0       	ld.w %d15,[%a15]0
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000c7d2:	91 30 00 ff 	movh.a %a15,61443
8000c7d6:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c7da:	8f ff 07 31 	and %d3,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000c7de:	4c f0       	ld.w %d15,[%a15]0
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000c7e0:	48 04       	ld.w %d4,[%a15]0
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
8000c7e2:	37 0f 64 2c 	extr.u %d2,%d15,24,4
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c7e6:	9a 13       	add %d15,%d3,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000c7e8:	03 f2 0a ff 	madd %d15,%d15,%d2,%d15
8000c7ec:	7b 10 13 20 	movh %d2,305
8000c7f0:	1b 02 d0 22 	addi %d2,%d2,11520
8000c7f4:	4b f2 11 22 	div.u %e2,%d2,%d15
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000c7f8:	37 04 e7 44 	extr.u %d4,%d4,9,7

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
8000c7fc:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
8000c800:	9a 12       	add %d15,%d2,1
8000c802:	3c c3       	j 8000c788 <osEE_tc_stm_set_clockpersec+0x1a>
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c804:	48 02       	ld.w %d2,[%a15]0
8000c806:	8f f2 07 21 	and %d2,%d2,127
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000c80a:	7b 10 13 f0 	movh %d15,305
8000c80e:	1b 0f d0 f2 	addi %d15,%d15,11520
      fsource = OSEE_TC_BOARD_FOSC / k1;
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
8000c812:	c2 12       	add %d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
8000c814:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000c818:	9a 12       	add %d15,%d2,1
8000c81a:	3c b7       	j 8000c788 <osEE_tc_stm_set_clockpersec+0x1a>
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
8000c81c:	91 30 00 ff 	movh.a %a15,61443
8000c820:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000c824:	48 02       	ld.w %d2,[%a15]0
8000c826:	37 02 67 28 	extr.u %d2,%d2,16,7
8000c82a:	3c f0       	j 8000c80a <osEE_tc_stm_set_clockpersec+0x9c>

8000c82c <osEE_tc_stm_set_sr1>:
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000c82c:	4d c0 e1 3f 	mfcr %d3,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c830:	91 00 00 f7 	movh.a %a15,28672
8000c834:	19 f2 a0 14 	ld.w %d2,[%a15]18528 <70004860 <osEE_tc_stm_freq_khz>>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c838:	7b 20 06 61 	movh %d6,4194
8000c83c:	1b 36 dd 64 	addi %d6,%d6,19923
8000c840:	73 62 68 60 	mul.u %e6,%d2,%d6
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c844:	3b 80 3e 10 	mov %d1,1000
8000c848:	37 03 48 00 	extr %d0,%d3,0,8
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c84c:	8f a7 1f f0 	sh %d15,%d7,-6
8000c850:	e2 4f       	mul %d15,%d4
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c852:	7f 12 0e 80 	jge.u %d2,%d1,8000c86e <osEE_tc_stm_set_sr1+0x42>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000c856:	7b 20 06 f1 	movh %d15,4194
8000c85a:	1b 3f dd f4 	addi %d15,%d15,19923
8000c85e:	73 24 0a 60 	mul %d6,%d4,%d2
8000c862:	73 f6 68 60 	mul.u %e6,%d6,%d15
8000c866:	8f a7 1f f0 	sh %d15,%d7,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
8000c86a:	7f 14 1c 80 	jge.u %d4,%d1,8000c8a2 <osEE_tc_stm_set_sr1+0x76>
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
8000c86e:	8f 30 00 21 	and %d2,%d0,3
8000c872:	9b 02 0f 60 	addih %d6,%d2,240
8000c876:	8f 86 00 60 	sh %d6,%d6,8
8000c87a:	60 6f       	mov.a %a15,%d6
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000c87c:	0f 0f b0 41 	clz %d4,%d15
8000c880:	48 46       	ld.w %d6,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
8000c882:	42 6f       	add %d15,%d6
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
8000c884:	68 df       	st.w [%a15]52,%d15
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
8000c886:	df 05 18 80 	jne %d5,0,8000c8b6 <osEE_tc_stm_set_sr1+0x8a>
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
8000c88a:	4c ff       	ld.w %d15,[%a15]60
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
8000c88c:	06 32       	sh %d2,3
8000c88e:	60 22       	mov.a %a2,%d2
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
8000c890:	8f 0f c1 f1 	andn %d15,%d15,16
8000c894:	68 ff       	st.w [%a15]60,%d15
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
8000c896:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000c89a:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000c89e:	68 05       	st.w [%a15]0,%d5
8000c8a0:	00 90       	ret 
static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
8000c8a2:	7b 20 06 61 	movh %d6,4194
8000c8a6:	1b 36 dd 64 	addi %d6,%d6,19923
8000c8aa:	73 64 68 60 	mul.u %e6,%d4,%d6
8000c8ae:	8f a7 1f f0 	sh %d15,%d7,-6
8000c8b2:	e2 2f       	mul %d15,%d2
8000c8b4:	3c dd       	j 8000c86e <osEE_tc_stm_set_sr1+0x42>
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000c8b6:	4c fe       	ld.w %d15,[%a15]56
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
8000c8b8:	8b f4 01 41 	rsub %d4,%d4,31
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000c8bc:	b7 0f 05 fc 	insert %d15,%d15,0,24,5
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
8000c8c0:	06 32       	sh %d2,3
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000c8c2:	68 ef       	st.w [%a15]56,%d15
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
8000c8c4:	4c fe       	ld.w %d15,[%a15]56
8000c8c6:	60 22       	mov.a %a2,%d2
8000c8c8:	37 4f 05 48 	insert %d4,%d15,%d4,16,5
8000c8cc:	b7 85 99 53 	insert %d5,%d5,8,7,25
8000c8d0:	68 e4       	st.w [%a15]56,%d4
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
8000c8d2:	4c ff       	ld.w %d15,[%a15]60
8000c8d4:	8f 33 00 31 	and %d3,%d3,3
8000c8d8:	96 40       	or %d15,64
8000c8da:	68 ff       	st.w [%a15]60,%d15
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
8000c8dc:	4c ff       	ld.w %d15,[%a15]60
8000c8de:	8f b3 00 30 	sh %d3,%d3,11
8000c8e2:	96 10       	or %d15,16
8000c8e4:	68 ff       	st.w [%a15]60,%d15
8000c8e6:	d9 2f 54 28 	lea %a15,[%a2]-31596
8000c8ea:	11 4f 00 ff 	addih.a %a15,%a15,61444
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000c8ee:	a6 35       	or %d5,%d3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000c8f0:	68 05       	st.w [%a15]0,%d5
8000c8f2:	00 90       	ret 

8000c8f4 <osEE_tc_stm_set_sr1_next_match>:
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000c8f4:	4d c0 e1 6f 	mfcr %d6,$core_id
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c8f8:	91 00 00 f7 	movh.a %a15,28672
8000c8fc:	19 ff a0 14 	ld.w %d15,[%a15]18528 <70004860 <osEE_tc_stm_freq_khz>>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c900:	7b 20 06 21 	movh %d2,4194
8000c904:	1b 32 dd 24 	addi %d2,%d2,19923
8000c908:	73 2f 68 20 	mul.u %e2,%d15,%d2
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c90c:	3b 80 3e 50 	mov %d5,1000
8000c910:	37 06 48 60 	extr %d6,%d6,0,8
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c914:	8f a3 1f 20 	sh %d2,%d3,-6
8000c918:	e2 42       	mul %d2,%d4
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c91a:	7f 5f 0e 80 	jge.u %d15,%d5,8000c936 <osEE_tc_stm_set_sr1_next_match+0x42>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000c91e:	7b 20 06 31 	movh %d3,4194
8000c922:	73 f4 0a 20 	mul %d2,%d4,%d15
8000c926:	1b 33 dd 34 	addi %d3,%d3,19923
8000c92a:	73 32 68 20 	mul.u %e2,%d2,%d3
8000c92e:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
8000c932:	7f 54 0d 80 	jge.u %d4,%d5,8000c94c <osEE_tc_stm_set_sr1_next_match+0x58>
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
8000c936:	8f 36 00 61 	and %d6,%d6,3
8000c93a:	9b 06 0f 60 	addih %d6,%d6,240
8000c93e:	8f 86 00 60 	sh %d6,%d6,8
8000c942:	60 6f       	mov.a %a15,%d6
8000c944:	4c fd       	ld.w %d15,[%a15]52
8000c946:	42 f2       	add %d2,%d15
8000c948:	68 d2       	st.w [%a15]52,%d2
8000c94a:	00 90       	ret 
static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
8000c94c:	7b 20 06 21 	movh %d2,4194
8000c950:	1b 32 dd 24 	addi %d2,%d2,19923
8000c954:	73 24 68 40 	mul.u %e4,%d4,%d2
8000c958:	8f a5 1f 20 	sh %d2,%d5,-6
8000c95c:	e2 f2       	mul %d2,%d15
8000c95e:	3c ec       	j 8000c936 <osEE_tc_stm_set_sr1_next_match+0x42>

8000c960 <osEE_tc_delay>:
8000c960:	4d c0 e1 ff 	mfcr %d15,$core_id
8000c964:	16 03       	and %d15,3
8000c966:	9b 0f 0f f0 	addih %d15,%d15,240
8000c96a:	8f 8f 00 f0 	sh %d15,%d15,8
8000c96e:	60 f2       	mov.a %a2,%d15
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c970:	7b 20 06 61 	movh %d6,4194
8000c974:	d9 2f 10 00 	lea %a15,[%a2]16
8000c978:	19 23 10 00 	ld.w %d3,[%a2]16
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c97c:	91 00 00 27 	movh.a %a2,28672
8000c980:	19 22 a0 14 	ld.w %d2,[%a2]18528 <70004860 <osEE_tc_stm_freq_khz>>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c984:	1b 36 dd 64 	addi %d6,%d6,19923
8000c988:	73 62 68 60 	mul.u %e6,%d2,%d6
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c98c:	3b 80 3e 50 	mov %d5,1000
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
8000c990:	8f a7 1f f0 	sh %d15,%d7,-6
8000c994:	e2 4f       	mul %d15,%d4
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
8000c996:	7f 52 17 80 	jge.u %d2,%d5,8000c9c4 <osEE_tc_delay+0x64>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000c99a:	7b 20 06 f1 	movh %d15,4194
8000c99e:	1b 3f dd f4 	addi %d15,%d15,19923
8000c9a2:	73 24 0a 60 	mul %d6,%d4,%d2
8000c9a6:	73 f6 68 60 	mul.u %e6,%d6,%d15
8000c9aa:	8f a7 1f f0 	sh %d15,%d7,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
8000c9ae:	3f 54 0b 80 	jlt.u %d4,%d5,8000c9c4 <osEE_tc_delay+0x64>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
8000c9b2:	7b 20 06 f1 	movh %d15,4194
8000c9b6:	1b 3f dd f4 	addi %d15,%d15,19923
8000c9ba:	73 f4 68 40 	mul.u %e4,%d4,%d15
8000c9be:	8f a5 1f f0 	sh %d15,%d5,-6
8000c9c2:	e2 2f       	mul %d15,%d2
8000c9c4:	48 02       	ld.w %d2,[%a15]0
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
8000c9c6:	a2 32       	sub %d2,%d3
8000c9c8:	3f f2 fe ff 	jlt.u %d2,%d15,8000c9c4 <osEE_tc_delay+0x64>
    ; /* Wait */
  }
}
8000c9cc:	00 90       	ret 

8000c9ce <osEE_tc_isr2_wrapper>:
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
8000c9ce:	6d 00 68 06 	call 8000d69e <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
8000c9d2:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000c9d6:	00 80       	rfe 
8000c9d8:	00 90       	ret 
	...

8000c9dc <DisableAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000c9dc:	91 00 00 f8 	movh.a %a15,32768
8000c9e0:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000c9e4:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
8000c9e8:	82 1f       	mov %d15,1
8000c9ea:	e9 ff 1e 00 	st.b [%a15]30,%d15
8000c9ee:	00 90       	ret 

8000c9f0 <EnableAllInterrupts>:
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000c9f0:	91 00 00 f8 	movh.a %a15,32768
8000c9f4:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
8000c9f8:	39 ff 1e 00 	ld.bu %d15,[%a15]30 <800006f4 <osEE_cdb_var>>
8000c9fc:	6e 06       	jz %d15,8000ca08 <EnableAllInterrupts+0x18>
    p_ccb->d_isr_all_cnt = 0U;
8000c9fe:	82 0f       	mov %d15,0
8000ca00:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000ca04:	0d 00 00 03 	enable 
8000ca08:	00 90       	ret 

8000ca0a <SuspendAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000ca0a:	91 00 00 f8 	movh.a %a15,32768
8000ca0e:	d9 f2 74 b0 	lea %a2,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000ca12:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
8000ca16:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800006f4 <osEE_cdb_var>>
8000ca1a:	6e 09       	jz %d15,8000ca2c <SuspendAllInterrupts+0x22>
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
    ++p_ccb->s_isr_all_cnt;
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
8000ca1c:	8b ff 0f 22 	eq %d2,%d15,255
8000ca20:	df 02 11 80 	jne %d2,0,8000ca42 <SuspendAllInterrupts+0x38>
    ++p_ccb->s_isr_all_cnt;
8000ca24:	c2 1f       	add %d15,1
8000ca26:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000ca2a:	00 90       	ret 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ca2c:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000ca30:	0d 00 40 03 	disable 
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
8000ca34:	68 5f       	st.w [%a15]20,%d15
    ++p_ccb->s_isr_all_cnt;
8000ca36:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000ca3a:	c2 1f       	add %d15,1
8000ca3c:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000ca40:	00 90       	ret 
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000ca42:	82 32       	mov %d2,3
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000ca44:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000ca48:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000ca4c:	3b 90 01 20 	mov %d2,25
8000ca50:	e9 f2 12 00 	st.b [%a15]18,%d2

  if (os_status == OSEE_KERNEL_STARTED) {
8000ca54:	1e 22       	jeq %d15,2,8000ca58 <SuspendAllInterrupts+0x4e>
8000ca56:	3c 00       	j 8000ca56 <SuspendAllInterrupts+0x4c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000ca58:	99 24 04 00 	ld.a %a4,[%a2]4
8000ca5c:	6d 00 b7 08 	call 8000dbca <osEE_idle_task_terminate>
8000ca60:	3c fb       	j 8000ca56 <SuspendAllInterrupts+0x4c>

8000ca62 <ResumeAllInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000ca62:	91 00 00 f8 	movh.a %a15,32768
8000ca66:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
8000ca6a:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800006f4 <osEE_cdb_var>>
8000ca6e:	6e 0b       	jz %d15,8000ca84 <ResumeAllInterrupts+0x22>
    --p_ccb->s_isr_all_cnt;
8000ca70:	c2 ff       	add %d15,-1
8000ca72:	16 ff       	and %d15,255
8000ca74:	e9 ff 1c 00 	st.b [%a15]28,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
8000ca78:	ee 06       	jnz %d15,8000ca84 <ResumeAllInterrupts+0x22>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ca7a:	4c f5       	ld.w %d15,[%a15]20
8000ca7c:	cd cf e2 0f 	mtcr $icr,%d15
8000ca80:	0d 00 c0 04 	isync 
8000ca84:	00 90       	ret 

8000ca86 <SuspendOSInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000ca86:	91 00 00 f8 	movh.a %a15,32768
8000ca8a:	d9 f2 74 b0 	lea %a2,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000ca8e:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
8000ca92:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800006f4 <osEE_cdb_var>>
8000ca96:	ee 14       	jnz %d15,8000cabe <SuspendOSInterrupts+0x38>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ca98:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000ca9c:	8f ff 0f 21 	and %d2,%d15,255
8000caa0:	f6 28       	jnz %d2,8000cab0 <SuspendOSInterrupts+0x2a>
    OsEE_icr icr_temp = icr;
8000caa2:	02 f2       	mov %d2,%d15
8000caa4:	b7 12 08 20 	insert %d2,%d2,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000caa8:	cd c2 e2 0f 	mtcr $icr,%d2
8000caac:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
8000cab0:	68 6f       	st.w [%a15]24,%d15
    ++p_ccb->s_isr_os_cnt;
8000cab2:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000cab6:	c2 1f       	add %d15,1
8000cab8:	e9 ff 1d 00 	st.b [%a15]29,%d15
8000cabc:	00 90       	ret 
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
8000cabe:	8b ff 0f 22 	eq %d2,%d15,255
8000cac2:	f6 25       	jnz %d2,8000cacc <SuspendOSInterrupts+0x46>
    ++p_ccb->s_isr_os_cnt;
8000cac4:	c2 1f       	add %d15,1
8000cac6:	e9 ff 1d 00 	st.b [%a15]29,%d15
8000caca:	00 90       	ret 
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000cacc:	82 32       	mov %d2,3
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000cace:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000cad2:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000cad6:	3b 90 01 20 	mov %d2,25
8000cada:	e9 f2 12 00 	st.b [%a15]18,%d2

  if (os_status == OSEE_KERNEL_STARTED) {
8000cade:	1e 22       	jeq %d15,2,8000cae2 <SuspendOSInterrupts+0x5c>
8000cae0:	3c 00       	j 8000cae0 <SuspendOSInterrupts+0x5a>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000cae2:	99 24 04 00 	ld.a %a4,[%a2]4
8000cae6:	6d 00 72 08 	call 8000dbca <osEE_idle_task_terminate>
8000caea:	3c fb       	j 8000cae0 <SuspendOSInterrupts+0x5a>

8000caec <ResumeOSInterrupts>:
(
  void
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000caec:	91 00 00 f8 	movh.a %a15,32768
8000caf0:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
8000caf4:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800006f4 <osEE_cdb_var>>
8000caf8:	6e 15       	jz %d15,8000cb22 <ResumeOSInterrupts+0x36>
    --p_ccb->s_isr_os_cnt;
8000cafa:	c2 ff       	add %d15,-1
8000cafc:	16 ff       	and %d15,255
8000cafe:	e9 ff 1d 00 	st.b [%a15]29,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
8000cb02:	ee 10       	jnz %d15,8000cb22 <ResumeOSInterrupts+0x36>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
8000cb04:	48 62       	ld.w %d2,[%a15]24
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cb06:	4d c0 e2 ff 	mfcr %d15,$icr
8000cb0a:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000cb0e:	8f f2 0f 21 	and %d2,%d2,255
8000cb12:	5f 23 08 00 	jeq %d3,%d2,8000cb22 <ResumeOSInterrupts+0x36>
8000cb16:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cb1a:	cd cf e2 0f 	mtcr $icr,%d15
8000cb1e:	0d 00 c0 04 	isync 
8000cb22:	00 90       	ret 

8000cb24 <StartOS>:
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cb24:	91 00 00 c8 	movh.a %a12,32768
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
8000cb28:	02 49       	mov %d9,%d4
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000cb2a:	99 cf 74 b0 	ld.a %a15,[%a12]1780 <800006f4 <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cb2e:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cb32:	8f ff 0f 81 	and %d8,%d15,255
8000cb36:	f6 87       	jnz %d8,8000cb44 <StartOS+0x20>
8000cb38:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cb3c:	cd cf e2 0f 	mtcr $icr,%d15
8000cb40:	0d 00 c0 04 	isync 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000cb44:	39 ff 10 00 	ld.bu %d15,[%a15]16
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
8000cb48:	82 13       	mov %d3,1
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000cb4a:	6e 0f       	jz %d15,8000cb68 <StartOS+0x44>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cb4c:	4d c0 e2 ff 	mfcr %d15,$icr
8000cb50:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000cb54:	5f 28 08 00 	jeq %d8,%d2,8000cb64 <StartOS+0x40>
8000cb58:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cb5c:	cd cf e2 0f 	mtcr $icr,%d15
8000cb60:	0d 00 c0 04 	isync 
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
8000cb64:	02 32       	mov %d2,%d3
8000cb66:	00 90       	ret 
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
8000cb68:	6d 00 42 08 	call 8000dbec <osEE_cpu_startos>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
8000cb6c:	3b 80 01 30 	mov %d3,24
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
8000cb70:	df 02 ee 7f 	jeq %d2,0,8000cb4c <StartOS+0x28>
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
8000cb74:	82 1f       	mov %d15,1
8000cb76:	e9 ff 10 00 	st.b [%a15]16,%d15
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
8000cb7a:	d9 cc 74 b0 	lea %a12,[%a12]1780
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
    p_ccb->app_mode                 = real_mode;
8000cb7e:	e9 f9 11 00 	st.b [%a15]17,%d9
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
8000cb82:	99 cc 04 00 	ld.a %a12,[%a12]4
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
/* Touch unused parameter */
  ((void)p_ccb);
  StartupHook();
8000cb86:	6d ff c9 f9 	call 8000bf18 <StartupHook>
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
8000cb8a:	39 ff 10 00 	ld.bu %d15,[%a15]16
8000cb8e:	5e 14       	jne %d15,1,8000cb96 <StartOS+0x72>
      p_ccb->os_status = OSEE_KERNEL_STARTED;
8000cb90:	82 2f       	mov %d15,2
8000cb92:	e9 ff 10 00 	st.b [%a15]16,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000cb96:	39 ff 10 00 	ld.bu %d15,[%a15]16
8000cb9a:	1e 24       	jeq %d15,2,8000cba2 <StartOS+0x7e>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000cb9c:	0d 00 40 03 	disable 
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
8000cba0:	3c 00       	j 8000cba0 <StartOS+0x7c>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
8000cba2:	99 c5 04 00 	ld.a %a5,[%a12]4
8000cba6:	40 c4       	mov.aa %a4,%a12
8000cba8:	40 56       	mov.aa %a6,%a5
8000cbaa:	6d 00 8f 08 	call 8000dcc8 <osEE_hal_save_ctx_and_ready2stacked>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
8000cbae:	40 c4       	mov.aa %a4,%a12
8000cbb0:	6d 00 5b 05 	call 8000d666 <osEE_task_end>
8000cbb4:	0d 00 40 03 	disable 
8000cbb8:	3c f4       	j 8000cba0 <StartOS+0x7c>

8000cbba <GetActiveApplicationMode>:
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
8000cbba:	91 00 00 f8 	movh.a %a15,32768
8000cbbe:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
8000cbc2:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
8000cbc6:	39 ff 10 00 	ld.bu %d15,[%a15]16
8000cbca:	ee 02       	jnz %d15,8000cbce <GetActiveApplicationMode+0x14>
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
8000cbcc:	00 90       	ret 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
    app_mode = p_ccb->app_mode;
8000cbce:	39 f2 11 00 	ld.bu %d2,[%a15]17
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
8000cbd2:	00 90       	ret 

8000cbd4 <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
8000cbd4:	91 00 00 f8 	movh.a %a15,32768
8000cbd8:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000cbdc:	48 22       	ld.w %d2,[%a15]8
    ev = E_OS_ID;
8000cbde:	82 3f       	mov %d15,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000cbe0:	3f 24 04 80 	jlt.u %d4,%d2,8000cbe8 <ActivateTask+0x14>
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000cbe4:	02 f2       	mov %d2,%d15
8000cbe6:	00 90       	ret 
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000cbe8:	c8 12       	ld.a %a2,[%a15]4
8000cbea:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000cbee:	d4 2c       	ld.a %a12,[%a2]

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000cbf0:	39 c2 14 00 	ld.bu %d2,[%a12]20
8000cbf4:	ff 22 f8 ff 	jge.u %d2,2,8000cbe4 <ActivateTask+0x10>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cbf8:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cbfc:	8f ff 0f 81 	and %d8,%d15,255
8000cc00:	f6 87       	jnz %d8,8000cc0e <ActivateTask+0x3a>
8000cc02:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cc06:	cd cf e2 0f 	mtcr $icr,%d15
8000cc0a:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
8000cc0e:	40 c4       	mov.aa %a4,%a12
8000cc10:	6d 00 1f 05 	call 8000d64e <osEE_task_activated>
8000cc14:	02 2f       	mov %d15,%d2

      if (ev == E_OK) {
8000cc16:	76 2e       	jz %d2,8000cc32 <ActivateTask+0x5e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cc18:	4d c0 e2 2f 	mfcr %d2,$icr
8000cc1c:	8f f2 0f 31 	and %d3,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000cc20:	5f 83 e2 7f 	jeq %d3,%d8,8000cbe4 <ActivateTask+0x10>
8000cc24:	37 82 08 20 	insert %d2,%d2,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cc28:	cd c2 e2 0f 	mtcr $icr,%d2
8000cc2c:	0d 00 c0 04 	isync 
8000cc30:	3c da       	j 8000cbe4 <ActivateTask+0x10>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
8000cc32:	40 f4       	mov.aa %a4,%a15
8000cc34:	40 c5       	mov.aa %a5,%a12
8000cc36:	6d 00 43 05 	call 8000d6bc <osEE_scheduler_task_activated>
8000cc3a:	3c ef       	j 8000cc18 <ActivateTask+0x44>

8000cc3c <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
8000cc3c:	91 00 00 f8 	movh.a %a15,32768
8000cc40:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
8000cc44:	91 00 00 c8 	movh.a %a12,32768
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000cc48:	4c f2       	ld.w %d15,[%a15]8
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
8000cc4a:	99 c4 74 b0 	ld.a %a4,[%a12]1780 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000cc4e:	d4 43       	ld.a %a3,[%a4]
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000cc50:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000cc52:	3f f4 03 80 	jlt.u %d4,%d15,8000cc58 <ChainTask+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
8000cc56:	00 90       	ret 
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000cc58:	c8 12       	ld.a %a2,[%a15]4
8000cc5a:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000cc5e:	d4 2d       	ld.a %a13,[%a2]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000cc60:	39 df 14 00 	ld.bu %d15,[%a13]20
8000cc64:	ff 2f f9 ff 	jge.u %d15,2,8000cc56 <ChainTask+0x1a>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
8000cc68:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000cc6c:	6e 09       	jz %d15,8000cc7e <ChainTask+0x42>
        p_ccb->s_isr_all_cnt = 0U;
8000cc6e:	82 0f       	mov %d15,0
8000cc70:	e9 4f 1c 00 	st.b [%a4]28,%d15
8000cc74:	4c 45       	ld.w %d15,[%a4]20
8000cc76:	cd cf e2 0f 	mtcr $icr,%d15
8000cc7a:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000cc7e:	39 4f 1e 00 	ld.bu %d15,[%a4]30
8000cc82:	6e 06       	jz %d15,8000cc8e <ChainTask+0x52>
        p_ccb->d_isr_all_cnt = 0U;
8000cc84:	82 0f       	mov %d15,0
8000cc86:	e9 4f 1e 00 	st.b [%a4]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000cc8a:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cc8e:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cc92:	8f ff 0f 81 	and %d8,%d15,255
8000cc96:	f6 87       	jnz %d8,8000cca4 <ChainTask+0x68>
8000cc98:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cc9c:	cd cf e2 0f 	mtcr $icr,%d15
8000cca0:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
8000cca4:	7d 3d 14 00 	jeq.a %a13,%a3,8000cccc <ChainTask+0x90>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
8000cca8:	40 d4       	mov.aa %a4,%a13
8000ccaa:	6d 00 d2 04 	call 8000d64e <osEE_task_activated>
        if (ev == E_OK) {
8000ccae:	df 02 19 00 	jeq %d2,0,8000cce0 <ChainTask+0xa4>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ccb2:	4d c0 e2 ff 	mfcr %d15,$icr
8000ccb6:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000ccba:	5f 83 ce 7f 	jeq %d3,%d8,8000cc56 <ChainTask+0x1a>
8000ccbe:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ccc2:	cd cf e2 0f 	mtcr $icr,%d15
8000ccc6:	0d 00 c0 04 	isync 
8000ccca:	00 90       	ret 

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
8000cccc:	cc d3       	ld.a %a15,[%a13]12
8000ccce:	82 5f       	mov %d15,5
8000ccd0:	28 2f       	st.b [%a15]2,%d15
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000ccd2:	99 cf 74 b0 	ld.a %a15,[%a12]1780
8000ccd6:	c8 0f       	ld.a %a15,[%a15]0
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
8000ccd8:	c8 14       	ld.a %a4,[%a15]4
8000ccda:	a0 05       	mov.a %a5,0
8000ccdc:	1d 00 2d 08 	j 8000dd36 <osEE_hal_terminate_ctx>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
        if (ev == E_OK) {
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
8000cce0:	40 f4       	mov.aa %a4,%a15
8000cce2:	40 d5       	mov.aa %a5,%a13
8000cce4:	6d 00 1e 05 	call 8000d720 <osEE_scheduler_task_insert>
8000cce8:	3c f5       	j 8000ccd2 <ChainTask+0x96>

8000ccea <TerminateTask>:
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
8000ccea:	91 00 00 f8 	movh.a %a15,32768
8000ccee:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000ccf2:	c8 02       	ld.a %a2,[%a15]0
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
8000ccf4:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800006f4 <osEE_cdb_var>>
8000ccf8:	6e 09       	jz %d15,8000cd0a <TerminateTask+0x20>
        p_ccb->s_isr_all_cnt = 0U;
8000ccfa:	82 0f       	mov %d15,0
8000ccfc:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000cd00:	4c f5       	ld.w %d15,[%a15]20
8000cd02:	cd cf e2 0f 	mtcr $icr,%d15
8000cd06:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000cd0a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000cd0e:	6e 06       	jz %d15,8000cd1a <TerminateTask+0x30>
        p_ccb->d_isr_all_cnt = 0U;
8000cd10:	82 0f       	mov %d15,0
8000cd12:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000cd16:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cd1a:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cd1e:	8f ff 0f 21 	and %d2,%d15,255
8000cd22:	f6 27       	jnz %d2,8000cd30 <TerminateTask+0x46>
8000cd24:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cd28:	cd cf e2 0f 	mtcr $icr,%d15
8000cd2c:	0d 00 c0 04 	isync 
8000cd30:	99 24 04 00 	ld.a %a4,[%a2]4
8000cd34:	a0 05       	mov.a %a5,0
8000cd36:	1d 00 00 08 	j 8000dd36 <osEE_hal_terminate_ctx>

8000cd3a <Schedule>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
8000cd3a:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
8000cd3e:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000cd42:	c8 0f       	ld.a %a15,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
8000cd44:	c8 3c       	ld.a %a12,[%a15]12
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
8000cd46:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800006f4 <osEE_cdb_var>>
8000cd4a:	39 c2 01 00 	ld.bu %d2,[%a12]1 <800006f4 <osEE_cdb_var>>
8000cd4e:	5f f2 04 00 	jeq %d2,%d15,8000cd56 <Schedule+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000cd52:	82 02       	mov %d2,0
8000cd54:	00 90       	ret 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cd56:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cd5a:	8f ff 0f 81 	and %d8,%d15,255
8000cd5e:	df 08 1c 00 	jeq %d8,0,8000cd96 <Schedule+0x5c>
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
8000cd62:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
8000cd66:	91 00 00 48 	movh.a %a4,32768
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
8000cd6a:	2c c1       	st.b [%a12]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
8000cd6c:	d9 44 50 b0 	lea %a4,[%a4]1744 <800006d0 <osEE_kdb_var>>
8000cd70:	6d 00 56 05 	call 8000d81c <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
8000cd74:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000cd78:	2c c1       	st.b [%a12]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cd7a:	4d c0 e2 ff 	mfcr %d15,$icr
8000cd7e:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000cd82:	5f 82 e8 7f 	jeq %d2,%d8,8000cd52 <Schedule+0x18>
8000cd86:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cd8a:	cd cf e2 0f 	mtcr $icr,%d15
8000cd8e:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
8000cd92:	82 02       	mov %d2,0
8000cd94:	00 90       	ret 
8000cd96:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000cd9a:	cd cf e2 0f 	mtcr $icr,%d15
8000cd9e:	0d 00 c0 04 	isync 
8000cda2:	3c e0       	j 8000cd62 <Schedule+0x28>

8000cda4 <GetResource>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000cda4:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000cda8:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000cdac:	c8 04       	ld.a %a4,[%a15]0
8000cdae:	91 00 00 f8 	movh.a %a15,32768
8000cdb2:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000cdb6:	4c f4       	ld.w %d15,[%a15]16
    ev = E_OS_ID;
8000cdb8:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000cdba:	3f f4 03 80 	jlt.u %d4,%d15,8000cdc0 <GetResource+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
8000cdbe:	00 90       	ret 
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
8000cdc0:	c8 3f       	ld.a %a15,[%a15]12
8000cdc2:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000cdc6:	c8 02       	ld.a %a2,[%a15]0
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
8000cdc8:	cc 43       	ld.a %a15,[%a4]12
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
8000cdca:	d4 23       	ld.a %a3,[%a2]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
    CONST(TaskPrio, AUTOMATIC)
      reso_prio     = p_reso_db->prio;
8000cdcc:	39 23 04 00 	ld.bu %d3,[%a2]4
    CONST(TaskPrio, AUTOMATIC)
      current_prio  = p_curr_tcb->current_prio;
8000cdd0:	08 14       	ld.bu %d4,[%a15]1
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cdd2:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cdd6:	8f f2 0f 51 	and %d5,%d2,255
8000cdda:	02 2f       	mov %d15,%d2
8000cddc:	f6 58       	jnz %d5,8000cdec <GetResource+0x48>
8000cdde:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cde2:	cd cf e2 0f 	mtcr $icr,%d15
8000cde6:	0d 00 c0 04 	isync 
8000cdea:	02 2f       	mov %d15,%d2
      ev = E_OS_CORE;
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
8000cdec:	3f 34 18 80 	jlt.u %d4,%d3,8000ce1c <GetResource+0x78>
        p_curr_tcb->current_prio = reso_prio;
        flags = osEE_hal_prepare_ipl(flags, reso_prio);
      }

      p_reso_cb->p_owner    = p_curr;
8000cdf0:	b5 34 08 00 	st.a [%a3]8,%a4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cdf4:	4d c0 e2 2f 	mfcr %d2,$icr
8000cdf8:	8f f2 0f 31 	and %d3,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000cdfc:	16 ff       	and %d15,255
8000cdfe:	5f f3 08 00 	jeq %d3,%d15,8000ce0e <GetResource+0x6a>
8000ce02:	37 f2 08 20 	insert %d2,%d2,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ce06:	cd c2 e2 0f 	mtcr $icr,%d2
8000ce0a:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
8000ce0e:	4c f1       	ld.w %d15,[%a15]4
      p_reso_cb->prev_prio  = current_prio;
8000ce10:	e9 34 04 00 	st.b [%a3]4,%d4

      p_reso_cb->p_owner    = p_curr;

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
8000ce14:	6c 30       	st.w [%a3]0,%d15
      p_reso_cb->prev_prio  = current_prio;
      p_curr_tcb->p_last_m  = p_reso_db;
8000ce16:	e8 12       	st.a [%a15]4,%a2

      ev = E_OK;
8000ce18:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
8000ce1a:	00 90       	ret 
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000ce1c:	8f f3 07 f1 	and %d15,%d3,127
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000ce20:	8f f2 cf 51 	andn %d5,%d2,255

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000ce24:	37 03 48 60 	extr %d6,%d3,0,8
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000ce28:	c2 1f       	add %d15,1
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000ce2a:	8b f3 2f 72 	ne %d7,%d3,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000ce2e:	a6 5f       	or %d15,%d5
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000ce30:	8f 02 d0 21 	andn %d2,%d2,256
8000ce34:	2b 2f 40 f7 	sel %d15,%d7,%d15,%d2
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000ce38:	8b 06 40 62 	lt %d6,%d6,0
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
        p_curr_tcb->current_prio = reso_prio;
8000ce3c:	28 13       	st.b [%a15]1,%d3
8000ce3e:	2b 5f 40 f6 	sel %d15,%d6,%d15,%d5
8000ce42:	3c d7       	j 8000cdf0 <GetResource+0x4c>

8000ce44 <ReleaseResource>:
FUNC(StatusType, OS_CODE)
  ReleaseResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
8000ce44:	91 00 00 48 	movh.a %a4,32768
8000ce48:	d9 44 50 b0 	lea %a4,[%a4]1744 <800006d0 <osEE_kdb_var>>
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000ce4c:	91 00 00 f8 	movh.a %a15,32768
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000ce50:	4c 44       	ld.w %d15,[%a4]16
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_curr = p_ccb->p_curr;
8000ce52:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000ce56:	c8 03       	ld.a %a3,[%a15]0
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
8000ce58:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000ce5a:	3f f4 03 80 	jlt.u %d4,%d15,8000ce60 <ReleaseResource+0x1c>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
8000ce5e:	00 90       	ret 
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
8000ce60:	99 42 0c 00 	ld.a %a2,[%a4]12
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
8000ce64:	cc 33       	ld.a %a15,[%a3]12
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
8000ce66:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, TYPEDEF)
      p_reso_cb   = p_reso_db->p_cb;
8000ce6a:	d4 22       	ld.a %a2,[%a2]
8000ce6c:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ce6e:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000ce72:	8f f2 0f f1 	and %d15,%d2,255
8000ce76:	6e 2d       	jz %d15,8000ced0 <ReleaseResource+0x8c>
    {
      VAR(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      /* Pop the Resources head */
      p_curr_tcb->p_last_m = p_curr_tcb->p_last_m->p_cb->p_next;
8000ce78:	c8 15       	ld.a %a5,[%a15]4
8000ce7a:	d4 55       	ld.a %a5,[%a5]
8000ce7c:	4c 50       	ld.w %d15,[%a5]0
8000ce7e:	68 1f       	st.w [%a15]4,%d15

      if (p_curr_tcb->p_last_m != NULL) {
8000ce80:	6e 30       	jz %d15,8000cee0 <ReleaseResource+0x9c>
        CONST(TaskPrio, AUTOMATIC)
          prev_prio = p_reso_cb->prev_prio;
8000ce82:	0c 24       	ld.bu %d15,[%a2]4
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;

        p_curr_tcb->current_prio = dispatch_prio;
8000ce84:	28 1f       	st.b [%a15]1,%d15
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
8000ce86:	8b ff 2f 52 	ne %d5,%d15,255

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000ce8a:	37 0f 48 40 	extr %d4,%d15,0,8
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000ce8e:	16 7f       	and %d15,127
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000ce90:	8f f2 cf 31 	andn %d3,%d2,255
8000ce94:	c2 1f       	add %d15,1
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000ce96:	a6 3f       	or %d15,%d3
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000ce98:	8f 02 d0 21 	andn %d2,%d2,256
8000ce9c:	2b 2f 40 f5 	sel %d15,%d5,%d15,%d2
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_reso_cb->p_owner = NULL;
8000cea0:	82 02       	mov %d2,0
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
8000cea2:	8b 04 40 42 	lt %d4,%d4,0
8000cea6:	59 22 08 00 	st.w [%a2]8,%d2
8000ceaa:	2b 3f 40 f4 	sel %d15,%d4,%d15,%d3

      /* Preemption point */
      (void)osEE_scheduler_task_preemption_point(p_kdb);
8000ceae:	6d 00 b7 04 	call 8000d81c <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ceb2:	4d c0 e2 2f 	mfcr %d2,$icr
8000ceb6:	8f f2 0f 31 	and %d3,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000ceba:	16 ff       	and %d15,255
8000cebc:	5f f3 08 00 	jeq %d3,%d15,8000cecc <ReleaseResource+0x88>
8000cec0:	37 f2 08 20 	insert %d2,%d2,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cec4:	cd c2 e2 0f 	mtcr $icr,%d2
8000cec8:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      ev = E_OK;
8000cecc:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
8000cece:	00 90       	ret 
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
    OsEE_icr icr_temp = icr;
8000ced0:	02 2f       	mov %d15,%d2
8000ced2:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ced6:	cd cf e2 0f 	mtcr $icr,%d15
8000ceda:	0d 00 c0 04 	isync 
8000cede:	3c cd       	j 8000ce78 <ReleaseResource+0x34>

        p_curr_tcb->current_prio = prev_prio;
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;
8000cee0:	39 3f 1d 00 	ld.bu %d15,[%a3]29
8000cee4:	3c d0       	j 8000ce84 <ReleaseResource+0x40>

8000cee6 <ShutdownOS>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000cee6:	91 00 00 f8 	movh.a %a15,32768
8000ceea:	99 f2 74 b0 	ld.a %a2,[%a15]1780 <800006f4 <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ceee:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000cef2:	8f ff 0f 21 	and %d2,%d15,255
8000cef6:	f6 27       	jnz %d2,8000cf04 <ShutdownOS+0x1e>
8000cef8:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cefc:	cd cf e2 0f 	mtcr $icr,%d15
8000cf00:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000cf04:	39 2f 10 00 	ld.bu %d15,[%a2]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
8000cf08:	c2 ff       	add %d15,-1
8000cf0a:	bf 2f 10 80 	jlt.u %d15,2,8000cf2a <ShutdownOS+0x44>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000cf0e:	4d c0 e2 ff 	mfcr %d15,$icr
8000cf12:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000cf16:	5f 23 08 00 	jeq %d3,%d2,8000cf26 <ShutdownOS+0x40>
8000cf1a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000cf1e:	cd cf e2 0f 	mtcr $icr,%d15
8000cf22:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
8000cf26:	82 72       	mov %d2,7
8000cf28:	00 90       	ret 
8000cf2a:	d9 f2 74 b0 	lea %a2,[%a15]1780
8000cf2e:	99 ff 74 b0 	ld.a %a15,[%a15]1780
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000cf32:	82 32       	mov %d2,3
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000cf34:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000cf38:	e9 f4 12 00 	st.b [%a15]18,%d4
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
8000cf3c:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;

  if (os_status == OSEE_KERNEL_STARTED) {
8000cf40:	1e 22       	jeq %d15,2,8000cf44 <ShutdownOS+0x5e>
8000cf42:	3c 00       	j 8000cf42 <ShutdownOS+0x5c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
8000cf44:	99 24 04 00 	ld.a %a4,[%a2]4
8000cf48:	6d 00 41 06 	call 8000dbca <osEE_idle_task_terminate>
8000cf4c:	3c fb       	j 8000cf42 <ShutdownOS+0x5c>

8000cf4e <GetTaskID>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000cf4e:	91 00 00 f8 	movh.a %a15,32768
8000cf52:	19 ff 74 b0 	ld.w %d15,[%a15]1780 <800006f4 <osEE_cdb_var>>
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
8000cf56:	20 08       	sub.a %sp,8
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000cf58:	78 01       	st.w [%sp]4,%d15
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
8000cf5a:	3b e0 00 20 	mov %d2,14
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
8000cf5e:	bc 4c       	jz.a %a4,8000cf76 <GetTaskID+0x28>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
8000cf60:	60 f2       	mov.a %a2,%d15
8000cf62:	cc 20       	ld.a %a15,[%a2]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000cf64:	39 f2 14 00 	ld.bu %d2,[%a15]20
8000cf68:	bf 22 17 80 	jlt.u %d2,2,8000cf96 <GetTaskID+0x48>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000cf6c:	82 ff       	mov %d15,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000cf6e:	df 22 05 00 	jeq %d2,2,8000cf78 <GetTaskID+0x2a>
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
8000cf72:	6c 40       	st.w [%a4]0,%d15
    ev = E_OK;
8000cf74:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
8000cf76:	00 90       	ret 
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
8000cf78:	99 a2 04 00 	ld.a %a2,[%sp]4
8000cf7c:	cc 23       	ld.a %a15,[%a2]12
8000cf7e:	c8 0f       	ld.a %a15,[%a15]0

      while (p_sn != NULL) {
8000cf80:	7c f4       	jnz.a %a15,8000cf88 <GetTaskID+0x3a>
8000cf82:	3c f8       	j 8000cf72 <GetTaskID+0x24>
          p_searched_tdb = p_sn->p_tdb;
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
          tid = p_searched_tdb->tid;
          break;
        } else {
          p_sn = p_sn->p_next;
8000cf84:	c8 0f       	ld.a %a15,[%a15]0
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
8000cf86:	bc fc       	jz.a %a15,8000cf9e <GetTaskID+0x50>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
8000cf88:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000cf8a:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000cf8e:	ff 2f fb ff 	jge.u %d15,2,8000cf84 <GetTaskID+0x36>
          tid = p_searched_tdb->tid;
8000cf92:	4c 24       	ld.w %d15,[%a2]16
          break;
8000cf94:	3c ef       	j 8000cf72 <GetTaskID+0x24>
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
8000cf96:	4c f4       	ld.w %d15,[%a15]16
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
    ev = E_OK;
8000cf98:	82 02       	mov %d2,0
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
8000cf9a:	6c 40       	st.w [%a4]0,%d15
8000cf9c:	3c ed       	j 8000cf76 <GetTaskID+0x28>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000cf9e:	82 ff       	mov %d15,-1
8000cfa0:	3c e9       	j 8000cf72 <GetTaskID+0x24>

8000cfa2 <GetTaskState>:
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
8000cfa2:	3b e0 00 20 	mov %d2,14
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
8000cfa6:	bc 49       	jz.a %a4,8000cfb8 <GetTaskState+0x16>
8000cfa8:	91 00 00 f8 	movh.a %a15,32768
8000cfac:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000cfb0:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_ID;
8000cfb2:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000cfb4:	3f f4 03 80 	jlt.u %d4,%d15,8000cfba <GetTaskState+0x18>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
8000cfb8:	00 90       	ret 
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000cfba:	c8 1f       	ld.a %a15,[%a15]4
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000cfbc:	82 02       	mov %d2,0
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000cfbe:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
8000cfc2:	c8 0f       	ld.a %a15,[%a15]0
8000cfc4:	c8 3f       	ld.a %a15,[%a15]12
    switch (local_state) {
8000cfc6:	0c f2       	ld.bu %d15,[%a15]2
8000cfc8:	ff 6f f8 ff 	jge.u %d15,6,8000cfb8 <GetTaskState+0x16>
8000cfcc:	91 10 00 f8 	movh.a %a15,32769
8000cfd0:	d9 ff d8 fc 	lea %a15,[%a15]-12328 <8000cfd8 <GetTaskState+0x36>>
8000cfd4:	90 ff       	addsc.a %a15,%a15,%d15,2
8000cfd6:	dc 0f       	ji %a15
8000cfd8:	1d 00 14 00 	j 8000d000 <GetTaskState+0x5e>
8000cfdc:	1d 00 0e 00 	j 8000cff8 <GetTaskState+0x56>
8000cfe0:	1d 00 0c 00 	j 8000cff8 <GetTaskState+0x56>
8000cfe4:	1d 00 06 00 	j 8000cff0 <GetTaskState+0x4e>
8000cfe8:	1d 00 10 00 	j 8000d008 <GetTaskState+0x66>
8000cfec:	1d 00 0e 00 	j 8000d008 <GetTaskState+0x66>
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
8000cff0:	82 3f       	mov %d15,3
8000cff2:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000cff4:	82 02       	mov %d2,0
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
8000cff6:	00 90       	ret 
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
8000cff8:	82 1f       	mov %d15,1
8000cffa:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000cffc:	82 02       	mov %d2,0
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
8000cffe:	00 90       	ret 
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
8000d000:	82 0f       	mov %d15,0
8000d002:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d004:	82 02       	mov %d2,0
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
8000d006:	00 90       	ret 
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
8000d008:	82 4f       	mov %d15,4
8000d00a:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000d00c:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
8000d00e:	00 90       	ret 

8000d010 <SetRelAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  increment,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
8000d010:	91 00 00 f8 	movh.a %a15,32768
8000d014:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d018:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d01a:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d01c:	3f f4 03 80 	jlt.u %d4,%d15,8000d022 <SetRelAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetRelAlarm);

  return ev;
}
8000d020:	00 90       	ret 
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d022:	c8 7f       	ld.a %a15,[%a15]28
8000d024:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d028:	c8 05       	ld.a %a5,[%a15]0
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
8000d02a:	99 54 04 00 	ld.a %a4,[%a5]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d02e:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d032:	8f ff 0f 81 	and %d8,%d15,255
8000d036:	df 08 13 00 	jeq %d8,0,8000d05c <SetRelAlarm+0x4c>
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_rel(p_counter_db, p_alarm_db, increment, cycle);
8000d03a:	0b 56 10 48 	mov %e4,%d6,%d5
8000d03e:	6d 00 4b 05 	call 8000dad4 <osEE_alarm_set_rel>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d042:	4d c0 e2 ff 	mfcr %d15,$icr
8000d046:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d04a:	5f 83 eb 7f 	jeq %d3,%d8,8000d020 <SetRelAlarm+0x10>
8000d04e:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d052:	cd cf e2 0f 	mtcr $icr,%d15
8000d056:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetRelAlarm);

  return ev;
}
8000d05a:	00 90       	ret 
8000d05c:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000d060:	cd cf e2 0f 	mtcr $icr,%d15
8000d064:	0d 00 c0 04 	isync 
8000d068:	3c e9       	j 8000d03a <SetRelAlarm+0x2a>

8000d06a <SetAbsAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  start,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
8000d06a:	91 00 00 f8 	movh.a %a15,32768
8000d06e:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d072:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d074:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d076:	3f f4 03 80 	jlt.u %d4,%d15,8000d07c <SetAbsAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetAbsAlarm);

  return ev;
}
8000d07a:	00 90       	ret 
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d07c:	c8 7f       	ld.a %a15,[%a15]28
8000d07e:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d082:	c8 05       	ld.a %a5,[%a15]0
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
8000d084:	99 54 04 00 	ld.a %a4,[%a5]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d088:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d08c:	8f ff 0f 81 	and %d8,%d15,255
8000d090:	df 08 13 00 	jeq %d8,0,8000d0b6 <SetAbsAlarm+0x4c>
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_abs(p_counter_db, p_alarm_db, start, cycle);
8000d094:	0b 56 10 48 	mov %e4,%d6,%d5
8000d098:	6d 00 43 05 	call 8000db1e <osEE_alarm_set_abs>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d09c:	4d c0 e2 ff 	mfcr %d15,$icr
8000d0a0:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d0a4:	5f 83 eb 7f 	jeq %d3,%d8,8000d07a <SetAbsAlarm+0x10>
8000d0a8:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d0ac:	cd cf e2 0f 	mtcr $icr,%d15
8000d0b0:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetAbsAlarm);

  return ev;
}
8000d0b4:	00 90       	ret 
8000d0b6:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000d0ba:	cd cf e2 0f 	mtcr $icr,%d15
8000d0be:	0d 00 c0 04 	isync 
8000d0c2:	3c e9       	j 8000d094 <SetAbsAlarm+0x2a>

8000d0c4 <CancelAlarm>:
FUNC(StatusType, OS_CODE)
  CancelAlarm
(
  VAR(AlarmType, AUTOMATIC) AlarmID
)
{
8000d0c4:	91 00 00 f8 	movh.a %a15,32768
8000d0c8:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d0cc:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d0ce:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d0d0:	3f f4 03 80 	jlt.u %d4,%d15,8000d0d6 <CancelAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_CancelAlarm);

  return ev;
}
8000d0d4:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db  = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d0d6:	c8 7f       	ld.a %a15,[%a15]28
8000d0d8:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d0dc:	c8 04       	ld.a %a4,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d0de:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d0e2:	8f ff 0f 81 	and %d8,%d15,255
8000d0e6:	df 08 11 00 	jeq %d8,0,8000d108 <CancelAlarm+0x44>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_cancel(p_alarm_db);
8000d0ea:	6d 00 2d 05 	call 8000db44 <osEE_alarm_cancel>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d0ee:	4d c0 e2 ff 	mfcr %d15,$icr
8000d0f2:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d0f6:	5f 83 ef 7f 	jeq %d3,%d8,8000d0d4 <CancelAlarm+0x10>
8000d0fa:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d0fe:	cd cf e2 0f 	mtcr $icr,%d15
8000d102:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_CancelAlarm);

  return ev;
}
8000d106:	00 90       	ret 
8000d108:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000d10c:	cd cf e2 0f 	mtcr $icr,%d15
8000d110:	0d 00 c0 04 	isync 
8000d114:	3c eb       	j 8000d0ea <CancelAlarm+0x26>

8000d116 <GetAlarm>:
  GetAlarm
(
  VAR(AlarmType, AUTOMATIC)   AlarmID,
  VAR(TickRefType, AUTOMATIC) Tick
)
{
8000d116:	91 00 00 f8 	movh.a %a15,32768
8000d11a:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d11e:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d120:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d122:	3f f4 03 80 	jlt.u %d4,%d15,8000d128 <GetAlarm+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarm);

  return ev;
}
8000d126:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d128:	3b e0 00 20 	mov %d2,14
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
8000d12c:	bd 04 fd 7f 	jz.a %a4,8000d126 <GetAlarm+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d130:	c8 7f       	ld.a %a15,[%a15]28
8000d132:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d136:	c8 0f       	ld.a %a15,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d138:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d13c:	8f ff 0f 81 	and %d8,%d15,255
8000d140:	f6 87       	jnz %d8,8000d14e <GetAlarm+0x38>
8000d142:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d146:	cd cf e2 0f 	mtcr $icr,%d15
8000d14a:	0d 00 c0 04 	isync 
8000d14e:	40 45       	mov.aa %a5,%a4
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_get(p_alarm_db, Tick);
8000d150:	40 f4       	mov.aa %a4,%a15
8000d152:	6d 00 0d 05 	call 8000db6c <osEE_alarm_get>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d156:	4d c0 e2 ff 	mfcr %d15,$icr
8000d15a:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d15e:	5f 83 e4 7f 	jeq %d3,%d8,8000d126 <GetAlarm+0x10>
8000d162:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d166:	cd cf e2 0f 	mtcr $icr,%d15
8000d16a:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarm);

  return ev;
}
8000d16e:	00 90       	ret 

8000d170 <GetAlarmBase>:
  GetAlarmBase
(
  VAR(AlarmType, AUTOMATIC)         AlarmID,
  VAR(AlarmBaseRefType, AUTOMATIC)  Info
)
{
8000d170:	91 00 00 f8 	movh.a %a15,32768
8000d174:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d178:	4c f8       	ld.w %d15,[%a15]32
    ev = E_OS_ID;
8000d17a:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000d17c:	3f f4 03 80 	jlt.u %d4,%d15,8000d182 <GetAlarmBase+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarmBase);

  return ev;
}
8000d180:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d182:	3b e0 00 20 	mov %d2,14
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
8000d186:	bd 04 fd 7f 	jz.a %a4,8000d180 <GetAlarmBase+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000d18a:	c8 7f       	ld.a %a15,[%a15]28
8000d18c:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
      p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = p_trigger_db->p_counter_db;
8000d190:	c8 0f       	ld.a %a15,[%a15]0

    *Info = p_counter_db->info;
8000d192:	c8 1f       	ld.a %a15,[%a15]4
8000d194:	09 f2 44 09 	ld.d %e2,[%a15]4
8000d198:	89 42 40 09 	st.d [%a4],%e2

    ev = E_OK;
8000d19c:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarmBase);

  return ev;
}
8000d19e:	00 90       	ret 

8000d1a0 <WaitEvent>:
{
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
8000d1a0:	91 00 00 48 	movh.a %a4,32768
8000d1a4:	99 4d 74 b0 	ld.a %a13,[%a4]1780 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000d1a8:	d4 dc       	ld.a %a12,[%a13]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000d1aa:	cc c3       	ld.a %a15,[%a12]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d1ac:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d1b0:	8f ff 0f 81 	and %d8,%d15,255
8000d1b4:	f6 87       	jnz %d8,8000d1c2 <WaitEvent+0x22>
8000d1b6:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d1ba:	cd cf e2 0f 	mtcr $icr,%d15
8000d1be:	0d 00 c0 04 	isync 
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
8000d1c2:	4c f3       	ld.w %d15,[%a15]12
8000d1c4:	26 4f       	and %d15,%d4
8000d1c6:	6e 0f       	jz %d15,8000d1e4 <WaitEvent+0x44>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d1c8:	4d c0 e2 ff 	mfcr %d15,$icr
8000d1cc:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d1d0:	5f 82 08 00 	jeq %d2,%d8,8000d1e0 <WaitEvent+0x40>
8000d1d4:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d1d8:	cd cf e2 0f 	mtcr $icr,%d15
8000d1dc:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
8000d1e0:	82 02       	mov %d2,0
8000d1e2:	00 90       	ret 
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
8000d1e4:	68 24       	st.w [%a15]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000d1e6:	d9 44 74 b0 	lea %a4,[%a4]1780
8000d1ea:	d9 d5 04 00 	lea %a5,[%a13]4
8000d1ee:	6d 00 fa 01 	call 8000d5e2 <osEE_scheduler_core_pop_running>

      p_curr_tcb->status = OSEE_TASK_WAITING;

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
8000d1f2:	d4 d5       	ld.a %a5,[%a13]
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
8000d1f4:	82 32       	mov %d2,3
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
8000d1f6:	e8 42       	st.a [%a15]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
8000d1f8:	28 22       	st.b [%a15]2,%d2

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
8000d1fa:	40 c4       	mov.aa %a4,%a12
8000d1fc:	6d 00 d0 04 	call 8000db9c <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
8000d200:	68 2f       	st.w [%a15]8,%d15
8000d202:	3c e3       	j 8000d1c8 <WaitEvent+0x28>

8000d204 <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000d204:	91 00 00 f8 	movh.a %a15,32768
8000d208:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d20c:	4c f2       	ld.w %d15,[%a15]8
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000d20e:	20 08       	sub.a %sp,8
8000d210:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d212:	7f f4 2b 80 	jge.u %d4,%d15,8000d268 <SetEvent+0x64>
    ev = E_OS_ID;
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d216:	c8 12       	ld.a %a2,[%a15]4
8000d218:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000d21c:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d21e:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d222:	8f ff 0f 81 	and %d8,%d15,255
8000d226:	f6 87       	jnz %d8,8000d234 <SetEvent+0x30>
8000d228:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d22c:	cd cf e2 0f 	mtcr $icr,%d15
8000d230:	0d 00 c0 04 	isync 
8000d234:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
8000d236:	d9 a5 07 00 	lea %a5,[%sp]7
8000d23a:	6d 00 22 02 	call 8000d67e <osEE_task_event_set_mask>

    if (p_sn != NULL) {
8000d23e:	bc 27       	jz.a %a2,8000d24c <SetEvent+0x48>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
8000d240:	40 f4       	mov.aa %a4,%a15
8000d242:	40 25       	mov.aa %a5,%a2
8000d244:	6d 00 82 02 	call 8000d748 <osEE_scheduler_task_unblocked>
8000d248:	df 02 11 80 	jne %d2,0,8000d26a <SetEvent+0x66>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d24c:	4d c0 e2 ff 	mfcr %d15,$icr
8000d250:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d254:	5f 82 08 00 	jeq %d2,%d8,8000d264 <SetEvent+0x60>
8000d258:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d25c:	cd cf e2 0f 	mtcr $icr,%d15
8000d260:	0d 00 c0 04 	isync 
8000d264:	39 a2 07 00 	ld.bu %d2,[%sp]7
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d268:	00 90       	ret 

    if (p_sn != NULL) {
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000d26a:	40 f4       	mov.aa %a4,%a15
8000d26c:	6d 00 d8 02 	call 8000d81c <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d270:	4d c0 e2 ff 	mfcr %d15,$icr
8000d274:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d278:	5f 82 f0 ff 	jne %d2,%d8,8000d258 <SetEvent+0x54>
8000d27c:	3c f4       	j 8000d264 <SetEvent+0x60>

8000d27e <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
8000d27e:	91 00 00 f8 	movh.a %a15,32768
8000d282:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d286:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_ID;
8000d288:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000d28a:	3f f4 03 80 	jlt.u %d4,%d15,8000d290 <GetEvent+0x12>
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d28e:	00 90       	ret 
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d290:	c8 1f       	ld.a %a15,[%a15]4
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
8000d292:	3b e0 00 20 	mov %d2,14
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000d296:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
8000d29a:	c8 0f       	ld.a %a15,[%a15]0
8000d29c:	c8 3f       	ld.a %a15,[%a15]12
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
8000d29e:	bd 04 f8 7f 	jz.a %a4,8000d28e <GetEvent+0x10>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
8000d2a2:	4c f3       	ld.w %d15,[%a15]12

      ev = E_OK;
8000d2a4:	82 02       	mov %d2,0
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
8000d2a6:	6c 40       	st.w [%a4]0,%d15
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000d2a8:	00 90       	ret 

8000d2aa <ClearEvent>:
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
8000d2aa:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000d2ae:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000d2b2:	c8 0f       	ld.a %a15,[%a15]0
8000d2b4:	c8 3f       	ld.a %a15,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d2b6:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d2ba:	8f ff 0f 21 	and %d2,%d15,255
8000d2be:	f6 27       	jnz %d2,8000d2cc <ClearEvent+0x22>
8000d2c0:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d2c4:	cd cf e2 0f 	mtcr $icr,%d15
8000d2c8:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
8000d2cc:	4c f3       	ld.w %d15,[%a15]12
8000d2ce:	0f 4f e0 40 	andn %d4,%d15,%d4
8000d2d2:	68 34       	st.w [%a15]12,%d4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d2d4:	4d c0 e2 ff 	mfcr %d15,$icr
8000d2d8:	8f ff 0f 31 	and %d3,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d2dc:	5f 23 08 00 	jeq %d3,%d2,8000d2ec <ClearEvent+0x42>
8000d2e0:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d2e4:	cd cf e2 0f 	mtcr $icr,%d15
8000d2e8:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
8000d2ec:	82 02       	mov %d2,0
8000d2ee:	00 90       	ret 

8000d2f0 <GetCounterValue>:
  GetCounterValue
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value
)
{
8000d2f0:	91 00 00 f8 	movh.a %a15,32768
8000d2f4:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d2f8:	4c f6       	ld.w %d15,[%a15]24
    ev = E_OS_ID;
8000d2fa:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d2fc:	3f f4 03 80 	jlt.u %d4,%d15,8000d302 <GetCounterValue+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetCounterValue);

  return ev;
}
8000d300:	00 90       	ret 
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
    ev = E_OS_PARAM_POINTER;
8000d302:	3b e0 00 20 	mov %d2,14
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
8000d306:	bd 04 fd 7f 	jz.a %a4,8000d300 <GetCounterValue+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d30a:	c8 5f       	ld.a %a15,[%a15]20
    wraps at its modulus. (SRS_Frt_00030, SRS_Frt_00031) */
/* EG  TODO: Add support for HARDWARE counters */

      (*Value) = p_counter_db->p_counter_cb->value;

      ev = E_OK;
8000d30c:	82 02       	mov %d2,0
  if (Value == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d30e:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    of hardware timers (which drive counters) in such that the lowest value is
    zero and consecutive reads return an increasing count value until the timer
    wraps at its modulus. (SRS_Frt_00030, SRS_Frt_00031) */
/* EG  TODO: Add support for HARDWARE counters */

      (*Value) = p_counter_db->p_counter_cb->value;
8000d312:	c8 0f       	ld.a %a15,[%a15]0
8000d314:	c8 0f       	ld.a %a15,[%a15]0
8000d316:	4c f1       	ld.w %d15,[%a15]4
8000d318:	6c 40       	st.w [%a4]0,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetCounterValue);

  return ev;
}
8000d31a:	00 90       	ret 

8000d31c <GetElapsedValue>:
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value,
  VAR(TickRefType, AUTOMATIC) ElapsedValue
)
{
8000d31c:	91 00 00 f8 	movh.a %a15,32768
8000d320:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d324:	4c f6       	ld.w %d15,[%a15]24
    ev = E_OS_ID;
8000d326:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d328:	3f f4 03 80 	jlt.u %d4,%d15,8000d32e <GetElapsedValue+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetElapsedValue);

  return ev;
}
8000d32c:	00 90       	ret 
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
8000d32e:	80 43       	mov.d %d3,%a4
8000d330:	80 55       	mov.d %d5,%a5
8000d332:	ba 03       	eq %d15,%d3,0
8000d334:	8b 05 e0 f4 	or.eq %d15,%d5,0
    ev = E_OS_PARAM_POINTER;
8000d338:	3b e0 00 20 	mov %d2,14
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
8000d33c:	ee f8       	jnz %d15,8000d32c <GetElapsedValue+0x10>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d33e:	c8 5f       	ld.a %a15,[%a15]20
    CONST(TickType, AUTOMATIC)
      local_value = (*Value);
8000d340:	54 42       	ld.w %d2,[%a4]
  if ((Value == NULL) || (ElapsedValue == NULL)) {
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d342:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d346:	c8 0f       	ld.a %a15,[%a15]0
/* [SWS_Os_00382] If the input parameters in a call of GetElapsedValue()
     are valid, GetElapsedValue() shall return the number of elapsed ticks
     since the given <Value> value via <ElapsedValue> and shall return
     E_OK. (SRS_Frt_00034) */
      CONST(TickType, AUTOMATIC)
        local_curr_value = p_counter_db->p_counter_cb->value;
8000d348:	c8 02       	ld.a %a2,[%a15]0
8000d34a:	4c 21       	ld.w %d15,[%a2]4
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
        /* Timer did not pass the <value> yet */
        (local_curr_value - local_value):
8000d34c:	3f 2f 07 80 	jlt.u %d15,%d2,8000d35a <GetElapsedValue+0x3e>
8000d350:	52 22       	sub %d2,%d15,%d2

/* [SWS_Os_00533] Caveats of GetElapsedValue(): If the timer already passed the
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
8000d352:	74 52       	st.w [%a5],%d2
        ((p_counter_db->info.maxallowedvalue -
          (local_value - local_curr_value)) + 1U);

/* [SWS_Os_00460] GetElapsedValue() shall return the current tick value of the
    counter in the <Value> parameter. */
      (*Value) = local_curr_value;
8000d354:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
8000d356:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetElapsedValue);

  return ev;
}
8000d358:	00 90       	ret 
8000d35a:	48 13       	ld.w %d3,[%a15]4
8000d35c:	42 f3       	add %d3,%d15
8000d35e:	c2 13       	add %d3,1
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
        /* Timer did not pass the <value> yet */
        (local_curr_value - local_value):
8000d360:	0b 23 80 20 	sub %d2,%d3,%d2
8000d364:	3c f7       	j 8000d352 <GetElapsedValue+0x36>

8000d366 <IncrementCounter>:
FUNC(StatusType, OS_CODE)
  IncrementCounter
(
  VAR(CounterType, AUTOMATIC) CounterID
)
{
8000d366:	91 00 00 f8 	movh.a %a15,32768
8000d36a:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d36e:	4c f6       	ld.w %d15,[%a15]24
    ev = E_OS_ID;
8000d370:	82 32       	mov %d2,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000d372:	3f f4 03 80 	jlt.u %d4,%d15,8000d378 <IncrementCounter+0x12>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_IncrementCounter);

  return ev;
}
8000d376:	00 90       	ret 
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000d378:	c8 52       	ld.a %a2,[%a15]20
8000d37a:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000d37e:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d380:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d384:	8f ff 0f 81 	and %d8,%d15,255
8000d388:	df 08 1b 00 	jeq %d8,0,8000d3be <IncrementCounter+0x58>
      CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();

/* N.B. Multi-core critical sections are handled inside
   TODO: Pass flags to osEE_counter_increment so it could re-enable
         interrupts/lower IPL outside critical sections. */
      osEE_counter_increment(p_counter_db);
8000d38c:	6d 00 fa 02 	call 8000d980 <osEE_counter_increment>
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000d390:	91 00 00 28 	movh.a %a2,32768
8000d394:	99 22 74 b0 	ld.a %a2,[%a2]1780 <800006f4 <osEE_cdb_var>>

/* [SWS_Os_00529] Caveats of IncrementCounter(): If called from a task,
    rescheduling may take place. */
      if (osEE_get_curr_task()->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000d398:	d4 22       	ld.a %a2,[%a2]
8000d39a:	39 2f 14 00 	ld.bu %d15,[%a2]20 <800006f4 <osEE_cdb_var>>
8000d39e:	bf 2f 17 80 	jlt.u %d15,2,8000d3cc <IncrementCounter+0x66>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d3a2:	4d c0 e2 ff 	mfcr %d15,$icr
8000d3a6:	8f ff 0f 21 	and %d2,%d15,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000d3aa:	5f 82 08 00 	jeq %d2,%d8,8000d3ba <IncrementCounter+0x54>
8000d3ae:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d3b2:	cd cf e2 0f 	mtcr $icr,%d15
8000d3b6:	0d 00 c0 04 	isync 
        (void)osEE_scheduler_task_preemption_point(p_kdb);
      }

      osEE_end_primitive(flags);

      ev = E_OK;
8000d3ba:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_IncrementCounter);

  return ev;
}
8000d3bc:	00 90       	ret 
8000d3be:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
8000d3c2:	cd cf e2 0f 	mtcr $icr,%d15
8000d3c6:	0d 00 c0 04 	isync 
8000d3ca:	3c e1       	j 8000d38c <IncrementCounter+0x26>
      osEE_counter_increment(p_counter_db);

/* [SWS_Os_00529] Caveats of IncrementCounter(): If called from a task,
    rescheduling may take place. */
      if (osEE_get_curr_task()->task_type <= OSEE_TASK_TYPE_EXTENDED) {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000d3cc:	40 f4       	mov.aa %a4,%a15
8000d3ce:	6d 00 27 02 	call 8000d81c <osEE_scheduler_task_preemption_point>
8000d3d2:	3c e8       	j 8000d3a2 <IncrementCounter+0x3c>

8000d3d4 <GetISRID>:
8000d3d4:	91 00 00 f8 	movh.a %a15,32768
8000d3d8:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
8000d3dc:	c8 0f       	ld.a %a15,[%a15]0
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
8000d3de:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000d3e0:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000d3e4:	1e 22       	jeq %d15,2,8000d3e8 <GetISRID+0x14>
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
8000d3e6:	00 90       	ret 
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
    isr_id = p_tdb->tid;
8000d3e8:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
8000d3ea:	00 90       	ret 

8000d3ec <osEE_scheduler_task_wrapper_restore>:
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000d3ec:	cc 43       	ld.a %a15,[%a4]12
8000d3ee:	82 4f       	mov %d15,4
8000d3f0:	28 2f       	st.b [%a15]2,%d15
8000d3f2:	00 90       	ret 

8000d3f4 <osEE_scheduler_task_wrapper_run>:
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
8000d3f4:	cc 43       	ld.a %a15,[%a4]12
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000d3f6:	82 4f       	mov %d15,4
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
8000d3f8:	40 4c       	mov.aa %a12,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
8000d3fa:	08 12       	ld.bu %d2,[%a15]1
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000d3fc:	28 2f       	st.b [%a15]2,%d15
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_priority < OSEE_ISR_ALL_PRIO) {
8000d3fe:	8b f2 0f f2 	eq %d15,%d2,255
8000d402:	ee 10       	jnz %d15,8000d422 <osEE_scheduler_task_wrapper_run+0x2e>
8000d404:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
8000d408:	37 02 48 30 	extr %d3,%d2,0,8
8000d40c:	82 04       	mov %d4,0
8000d40e:	bf 03 4d 00 	jlt %d3,0,8000d4a8 <osEE_scheduler_task_wrapper_run+0xb4>
8000d412:	37 4f 08 f0 	insert %d15,%d15,%d4,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d416:	cd cf e2 0f 	mtcr $icr,%d15
8000d41a:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000d41e:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000d422:	cc c6       	ld.a %a15,[%a12]24

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
8000d424:	82 0f       	mov %d15,0
  if (task_priority < OSEE_ISR_ALL_PRIO) {
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000d426:	2d 0f 00 00 	calli %a15
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000d42a:	91 00 00 f8 	movh.a %a15,32768
8000d42e:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000d432:	39 f2 1c 00 	ld.bu %d2,[%a15]28 <800006f4 <osEE_cdb_var>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
8000d436:	e9 ff 1d 00 	st.b [%a15]29 <800006f4 <osEE_cdb_var>>,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000d43a:	76 28       	jz %d2,8000d44a <osEE_scheduler_task_wrapper_run+0x56>
    p_ccb->s_isr_all_cnt = 0U;
8000d43c:	e9 ff 1c 00 	st.b [%a15]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d440:	4c f5       	ld.w %d15,[%a15]20
8000d442:	cd cf e2 0f 	mtcr $icr,%d15
8000d446:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
8000d44a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000d44e:	6e 06       	jz %d15,8000d45a <osEE_scheduler_task_wrapper_run+0x66>
    p_ccb->d_isr_all_cnt = 0U;
8000d450:	82 0f       	mov %d15,0
8000d452:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000d456:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000d45a:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000d45e:	8f ff 0f 21 	and %d2,%d15,255
8000d462:	f6 27       	jnz %d2,8000d470 <osEE_scheduler_task_wrapper_run+0x7c>
8000d464:	b7 1f 08 f0 	insert %d15,%d15,1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000d468:	cd cf e2 0f 	mtcr $icr,%d15
8000d46c:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000d470:	39 cf 14 00 	ld.bu %d15,[%a12]20
8000d474:	99 c2 0c 00 	ld.a %a2,[%a12]12
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d478:	cc 21       	ld.a %a15,[%a2]4

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000d47a:	1e 2e       	jeq %d15,2,8000d496 <osEE_scheduler_task_wrapper_run+0xa2>
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d47c:	bc f8       	jz.a %a15,8000d48c <osEE_scheduler_task_wrapper_run+0x98>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000d47e:	82 0f       	mov %d15,0
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
8000d480:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000d482:	68 2f       	st.w [%a15]8,%d15
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
8000d484:	c8 0f       	ld.a %a15,[%a15]0
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d486:	bd 0f fd ff 	jnz.a %a15,8000d480 <osEE_scheduler_task_wrapper_run+0x8c>
8000d48a:	ec 21       	st.a [%a2]4,%a15
8000d48c:	99 c4 04 00 	ld.a %a4,[%a12]4
8000d490:	a0 05       	mov.a %a5,0
8000d492:	1d 00 52 04 	j 8000dd36 <osEE_hal_terminate_ctx>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000d496:	82 0f       	mov %d15,0
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d498:	bd 0f fa 7f 	jz.a %a15,8000d48c <osEE_scheduler_task_wrapper_run+0x98>
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
8000d49c:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000d49e:	68 2f       	st.w [%a15]8,%d15
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
8000d4a0:	c8 0f       	ld.a %a15,[%a15]0
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000d4a2:	bd 0f fd ff 	jnz.a %a15,8000d49c <osEE_scheduler_task_wrapper_run+0xa8>
8000d4a6:	3c f2       	j 8000d48a <osEE_scheduler_task_wrapper_run+0x96>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000d4a8:	8f f2 07 21 	and %d2,%d2,127
8000d4ac:	1b 12 00 40 	addi %d4,%d2,1
8000d4b0:	3c b1       	j 8000d412 <osEE_scheduler_task_wrapper_run+0x1e>

8000d4b2 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
8000d4b2:	91 00 00 28 	movh.a %a2,32768
8000d4b6:	99 2f 74 b0 	ld.a %a15,[%a2]1780 <800006f4 <osEE_cdb_var>>
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000d4ba:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800006f4 <osEE_cdb_var>>
8000d4be:	df 2f fe 7f 	jeq %d15,2,8000d4ba <osEE_idle_hook_wrapper+0x8>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
8000d4c2:	d9 22 74 b0 	lea %a2,[%a2]1780 <800006f4 <osEE_cdb_var>>
8000d4c6:	99 24 04 00 	ld.a %a4,[%a2]4 <80000004 <BootModeHeader0+0x4>>
8000d4ca:	1d 00 80 03 	j 8000dbca <osEE_idle_task_terminate>

8000d4ce <osEE_scheduler_rq_insert>:
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
  p_sn_new->p_tdb = p_tdb_new;
8000d4ce:	b5 56 04 00 	st.a [%a5]4,%a6
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000d4d2:	d4 42       	ld.a %a2,[%a4]
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000d4d4:	39 62 1c 00 	ld.bu %d2,[%a6]28
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d4d8:	bd 02 15 00 	jz.a %a2,8000d502 <osEE_scheduler_rq_insert+0x34>
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
8000d4dc:	cc 21       	ld.a %a15,[%a2]4
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
8000d4de:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000d4e2:	7f 2f 09 80 	jge.u %d15,%d2,8000d4f4 <osEE_scheduler_rq_insert+0x26>
8000d4e6:	3c 0e       	j 8000d502 <osEE_scheduler_rq_insert+0x34>
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
8000d4e8:	c8 13       	ld.a %a3,[%a15]4
8000d4ea:	39 3f 1c 00 	ld.bu %d15,[%a3]28
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
8000d4ee:	3f 2f 06 80 	jlt.u %d15,%d2,8000d4fa <osEE_scheduler_rq_insert+0x2c>
8000d4f2:	40 f2       	mov.aa %a2,%a15
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000d4f4:	cc 20       	ld.a %a15,[%a2]0
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d4f6:	bd 0f f9 ff 	jnz.a %a15,8000d4e8 <osEE_scheduler_rq_insert+0x1a>
      break;
    }
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
8000d4fa:	f4 25       	st.a [%a2],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000d4fc:	82 02       	mov %d2,0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
8000d4fe:	ec 50       	st.a [%a5]0,%a15
8000d500:	00 90       	ret 
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000d502:	f4 45       	st.a [%a4],%a5
8000d504:	40 2f       	mov.aa %a15,%a2
    head_changed  = OSEE_TRUE;
8000d506:	82 12       	mov %d2,1
8000d508:	3c fb       	j 8000d4fe <osEE_scheduler_rq_insert+0x30>

8000d50a <osEE_scheduler_core_rq_preempt_stk>:
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000d50a:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
8000d50c:	99 32 0c 00 	ld.a %a2,[%a3]12
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000d510:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000d512:	bd 02 26 00 	jz.a %a2,8000d55e <osEE_scheduler_core_rq_preempt_stk+0x54>
    p_ret_tdb = p_ret_sn->p_tdb;
8000d516:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
8000d51a:	bd 0f 1f 00 	jz.a %a15,8000d558 <osEE_scheduler_core_rq_preempt_stk+0x4e>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000d51e:	c8 16       	ld.a %a6,[%a15]4

  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000d520:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000d524:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000d528:	39 42 01 00 	ld.bu %d2,[%a4]1
8000d52c:	0c 61       	ld.bu %d15,[%a6]1
8000d52e:	7f f2 15 80 	jge.u %d2,%d15,8000d558 <osEE_scheduler_core_rq_preempt_stk+0x4e>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000d532:	82 2f       	mov %d15,2
8000d534:	2c 42       	st.b [%a4]2,%d15
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000d536:	4c f0       	ld.w %d15,[%a15]0
8000d538:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000d53a:	c8 14       	ld.a %a4,[%a15]4
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000d53c:	4c 33       	ld.w %d15,[%a3]12
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000d53e:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000d542:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000d544:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000d546:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000d548:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000d54c:	39 52 01 00 	ld.bu %d2,[%a5]1
8000d550:	7f f2 06 80 	jge.u %d2,%d15,8000d55c <osEE_scheduler_core_rq_preempt_stk+0x52>
      p_tcb->current_prio = dispatch_prio;
8000d554:	2c 51       	st.b [%a5]1,%d15
8000d556:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000d558:	a0 02       	mov.a %a2,0
8000d55a:	00 90       	ret 
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
8000d55c:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000d55e:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000d560:	bd 0f fe 7f 	jz.a %a15,8000d55c <osEE_scheduler_core_rq_preempt_stk+0x52>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
8000d564:	99 42 04 00 	ld.a %a2,[%a4]4
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000d568:	99 24 0c 00 	ld.a %a4,[%a2]12
8000d56c:	3c e3       	j 8000d532 <osEE_scheduler_core_rq_preempt_stk+0x28>

8000d56e <osEE_sn_priority_insert>:
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
8000d56e:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
8000d570:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000d572:	df 04 1b 00 	jeq %d4,0,8000d5a8 <osEE_sn_priority_insert+0x3a>
8000d576:	39 f2 1c 00 	ld.bu %d2,[%a15]28
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000d57a:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d57c:	a0 02       	mov.a %a2,0
8000d57e:	7c fa       	jnz.a %a15,8000d592 <osEE_sn_priority_insert+0x24>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000d580:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
8000d582:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
8000d584:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000d586:	00 90       	ret 
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000d588:	c8 03       	ld.a %a3,[%a15]0
8000d58a:	40 f2       	mov.aa %a2,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d58c:	bd 03 28 00 	jz.a %a3,8000d5dc <osEE_sn_priority_insert+0x6e>
8000d590:	40 3f       	mov.aa %a15,%a3
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
8000d592:	c8 13       	ld.a %a3,[%a15]4
    } else {
      prio_to_check = p_cur_tcb->current_prio;
    }

    if (new_task_prio <= prio_to_check)
8000d594:	39 3f 1c 00 	ld.bu %d15,[%a3]28
8000d598:	7f 2f f8 ff 	jge.u %d15,%d2,8000d588 <osEE_sn_priority_insert+0x1a>
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
8000d59c:	bd 02 f2 7f 	jz.a %a2,8000d580 <osEE_sn_priority_insert+0x12>
    p_prev->p_next = p_sn_new;
8000d5a0:	f4 25       	st.a [%a2],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000d5a2:	82 02       	mov %d2,0
  } else {
    (*pp_first)   = p_sn_new;
    head_changed  = OSEE_TRUE;
  }

  p_sn_new->p_next = p_curr;
8000d5a4:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000d5a6:	00 90       	ret 
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000d5a8:	cc 40       	ld.a %a15,[%a4]0
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000d5aa:	39 22 01 00 	ld.bu %d2,[%a2]1
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d5ae:	a0 02       	mov.a %a2,0
8000d5b0:	bd 0f e8 7f 	jz.a %a15,8000d580 <osEE_sn_priority_insert+0x12>
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000d5b4:	c8 13       	ld.a %a3,[%a15]4

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000d5b6:	99 33 0c 00 	ld.a %a3,[%a3]12
    }

    if (new_task_prio <= prio_to_check)
8000d5ba:	0c 31       	ld.bu %d15,[%a3]1
8000d5bc:	3f 2f f0 ff 	jlt.u %d15,%d2,8000d59c <osEE_sn_priority_insert+0x2e>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000d5c0:	c8 03       	ld.a %a3,[%a15]0
8000d5c2:	40 f2       	mov.aa %a2,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d5c4:	bc 3c       	jz.a %a3,8000d5dc <osEE_sn_priority_insert+0x6e>
8000d5c6:	40 3f       	mov.aa %a15,%a3
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000d5c8:	c8 13       	ld.a %a3,[%a15]4

    if (as_ready) {
      prio_to_check = p_cur_tdb->ready_prio;
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000d5ca:	99 33 0c 00 	ld.a %a3,[%a3]12
    }

    if (new_task_prio <= prio_to_check)
8000d5ce:	0c 31       	ld.bu %d15,[%a3]1
8000d5d0:	3f 2f e6 ff 	jlt.u %d15,%d2,8000d59c <osEE_sn_priority_insert+0x2e>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000d5d4:	c8 03       	ld.a %a3,[%a15]0
8000d5d6:	40 f2       	mov.aa %a2,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000d5d8:	bd 03 f7 ff 	jnz.a %a3,8000d5c6 <osEE_sn_priority_insert+0x58>
8000d5dc:	40 f2       	mov.aa %a2,%a15
8000d5de:	a0 0f       	mov.a %a15,0
8000d5e0:	3c e0       	j 8000d5a0 <osEE_sn_priority_insert+0x32>

8000d5e2 <osEE_scheduler_core_pop_running>:
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
8000d5e2:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
8000d5e4:	99 32 0c 00 	ld.a %a2,[%a3]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;
8000d5e8:	d4 26       	ld.a %a6,[%a2]

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
8000d5ea:	b5 36 0c 00 	st.a [%a3]12,%a6
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000d5ee:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000d5f0:	bd 06 27 00 	jz.a %a6,8000d63e <osEE_scheduler_core_pop_running+0x5c>
    p_ret_tdb = p_ret_sn->p_tdb;
8000d5f4:	99 64 04 00 	ld.a %a4,[%a6]4
    if (p_rq_sn != NULL) {
8000d5f8:	bd 0f 20 00 	jz.a %a15,8000d638 <osEE_scheduler_core_pop_running+0x56>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000d5fc:	c8 17       	ld.a %a7,[%a15]4

  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000d5fe:	99 44 0c 00 	ld.a %a4,[%a4]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000d602:	99 77 0c 00 	ld.a %a7,[%a7]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000d606:	39 42 01 00 	ld.bu %d2,[%a4]1
8000d60a:	0c 71       	ld.bu %d15,[%a7]1
8000d60c:	7f f2 16 80 	jge.u %d2,%d15,8000d638 <osEE_scheduler_core_pop_running+0x56>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000d610:	82 2f       	mov %d15,2
8000d612:	2c 42       	st.b [%a4]2,%d15
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000d614:	4c f0       	ld.w %d15,[%a15]0
8000d616:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000d618:	c8 14       	ld.a %a4,[%a15]4
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000d61a:	4c 33       	ld.w %d15,[%a3]12
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000d61c:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000d620:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000d622:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000d624:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000d626:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000d62a:	39 52 01 00 	ld.bu %d2,[%a5]1
8000d62e:	7f f2 04 80 	jge.u %d2,%d15,8000d636 <osEE_scheduler_core_pop_running+0x54>
      p_tcb->current_prio = dispatch_prio;
8000d632:	2c 51       	st.b [%a5]1,%d15
8000d634:	00 90       	ret 
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
8000d636:	00 90       	ret 
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
8000d638:	4c 61       	ld.w %d15,[%a6]4
      } else {
        /* Resume IDLE TASK */
        p_tdb_stk = p_cdb->p_idle_task;
      }

      p_ccb->p_curr            = p_tdb_stk;
8000d63a:	6c 30       	st.w [%a3]0,%d15
8000d63c:	00 90       	ret 

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000d63e:	bc f6       	jz.a %a15,8000d64a <osEE_scheduler_core_pop_running+0x68>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000d640:	99 44 04 00 	ld.a %a4,[%a4]4
8000d644:	99 44 0c 00 	ld.a %a4,[%a4]12
8000d648:	3c e4       	j 8000d610 <osEE_scheduler_core_pop_running+0x2e>
      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
      } else {
        /* Resume IDLE TASK */
        p_tdb_stk = p_cdb->p_idle_task;
8000d64a:	4c 41       	ld.w %d15,[%a4]4
8000d64c:	3c f7       	j 8000d63a <osEE_scheduler_core_pop_running+0x58>

8000d64e <osEE_task_activated>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
8000d64e:	cc 43       	ld.a %a15,[%a4]12
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000d650:	39 43 1e 00 	ld.bu %d3,[%a4]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
8000d654:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000d656:	0c f0       	ld.bu %d15,[%a15]0
8000d658:	3f 3f 03 80 	jlt.u %d15,%d3,8000d65e <osEE_task_activated+0x10>
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000d65c:	00 90       	ret 
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
    ++p_tcb_act->current_num_of_act;
8000d65e:	c2 1f       	add %d15,1
8000d660:	28 0f       	st.b [%a15]0,%d15
    ev = E_OK;
8000d662:	82 02       	mov %d2,0
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000d664:	00 90       	ret 

8000d666 <osEE_task_end>:
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000d666:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
8000d668:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000d66c:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
8000d66e:	0c f0       	ld.bu %d15,[%a15]0
8000d670:	c2 ff       	add %d15,-1
8000d672:	16 ff       	and %d15,255
8000d674:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
8000d676:	8b 0f 20 f2 	ne %d15,%d15,0
8000d67a:	28 2f       	st.b [%a15]2,%d15
8000d67c:	00 90       	ret 

8000d67e <osEE_task_event_set_mask>:
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
8000d67e:	cc 43       	ld.a %a15,[%a4]12
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000d680:	02 42       	mov %d2,%d4
8000d682:	02 43       	mov %d3,%d4

    *p_ev = E_OK;
8000d684:	82 0f       	mov %d15,0
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000d686:	49 f2 4c 08 	ldmst [%a15]12,%e2

    *p_ev = E_OK;
8000d68a:	2c 50       	st.b [%a5]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000d68c:	4c f2       	ld.w %d15,[%a15]8
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000d68e:	a0 02       	mov.a %a2,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000d690:	26 f4       	and %d4,%d15
8000d692:	76 45       	jz %d4,8000d69c <osEE_task_event_set_mask+0x1e>
      p_own_sn = p_tcb_waking_up->p_own_sn;
8000d694:	c8 42       	ld.a %a2,[%a15]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
8000d696:	bc 23       	jz.a %a2,8000d69c <osEE_task_event_set_mask+0x1e>
        p_tcb_waking_up->p_own_sn = NULL;
8000d698:	82 0f       	mov %d15,0
8000d69a:	68 4f       	st.w [%a15]16,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
8000d69c:	00 90       	ret 

8000d69e <osEE_activate_isr2>:
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000d69e:	91 00 00 48 	movh.a %a4,32768
8000d6a2:	d9 44 50 b0 	lea %a4,[%a4]1744 <800006d0 <osEE_kdb_var>>
8000d6a6:	cc 41       	ld.a %a15,[%a4]4
    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000d6a8:	a0 06       	mov.a %a6,0
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000d6aa:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000d6ae:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
8000d6b0:	cc 53       	ld.a %a15,[%a5]12
8000d6b2:	0c f0       	ld.bu %d15,[%a15]0
8000d6b4:	c2 1f       	add %d15,1
8000d6b6:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000d6b8:	1d 00 c4 00 	j 8000d840 <osEE_scheduler_task_set_running>

8000d6bc <osEE_scheduler_task_activated>:
{
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000d6bc:	91 00 00 f8 	movh.a %a15,32768
8000d6c0:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
8000d6c4:	c8 04       	ld.a %a4,[%a15]0
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
8000d6c6:	99 52 0c 00 	ld.a %a2,[%a5]12 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
8000d6ca:	99 43 0c 00 	ld.a %a3,[%a4]12 <800006f4 <osEE_cdb_var>>
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000d6ce:	40 56       	mov.aa %a6,%a5
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
8000d6d0:	0c 21       	ld.bu %d15,[%a2]1
8000d6d2:	39 32 01 00 	ld.bu %d2,[%a3]1
8000d6d6:	3f f2 13 80 	jlt.u %d2,%d15,8000d6fc <osEE_scheduler_task_activated+0x40>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000d6da:	0c 22       	ld.bu %d15,[%a2]2
8000d6dc:	ee 05       	jnz %d15,8000d6e6 <osEE_scheduler_task_activated+0x2a>
    p_tcb_act->status = OSEE_TASK_READY;
8000d6de:	82 12       	mov %d2,1
8000d6e0:	e9 22 02 00 	st.b [%a2]2,%d2
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
8000d6e4:	6c 23       	st.w [%a2]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000d6e6:	c8 25       	ld.a %a5,[%a15]8
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000d6e8:	d9 f4 04 00 	lea %a4,[%a15]4
  (*pp_first)              = p_sn_allocated->p_next;
8000d6ec:	4c 50       	ld.w %d15,[%a5]0
8000d6ee:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000d6f0:	82 0f       	mov %d15,0
8000d6f2:	6c 50       	st.w [%a5]0,%d15
8000d6f4:	6d ff ed fe 	call 8000d4ce <osEE_scheduler_rq_insert>
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
8000d6f8:	82 02       	mov %d2,0
  }

  return is_preemption;
}
8000d6fa:	00 90       	ret 
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000d6fc:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000d6fe:	4c 20       	ld.w %d15,[%a2]0
8000d700:	68 2f       	st.w [%a15]8,%d15
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
8000d702:	82 2f       	mov %d15,2
8000d704:	2c 32       	st.b [%a3]2,%d15

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000d706:	4c f3       	ld.w %d15,[%a15]12

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
8000d708:	b5 25 04 00 	st.a [%a2]4,%a5
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000d70c:	6c 20       	st.w [%a2]0,%d15
    p_ccb->p_stk_sn             = p_new_stk;
8000d70e:	e8 32       	st.a [%a15]12,%a2
    p_ccb->p_curr               = p_tdb_act;
8000d710:	e8 05       	st.a [%a15]0,%a5
8000d712:	cc 53       	ld.a %a15,[%a5]12
8000d714:	82 0f       	mov %d15,0
8000d716:	68 3f       	st.w [%a15]12,%d15
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
8000d718:	6d 00 42 02 	call 8000db9c <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000d71c:	82 12       	mov %d2,1
8000d71e:	00 90       	ret 

8000d720 <osEE_scheduler_task_insert>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
8000d720:	cc 53       	ld.a %a15,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000d722:	91 00 00 28 	movh.a %a2,32768
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000d726:	40 56       	mov.aa %a6,%a5
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000d728:	0c f2       	ld.bu %d15,[%a15]2
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000d72a:	99 24 74 b0 	ld.a %a4,[%a2]1780 <800006f4 <osEE_cdb_var>>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000d72e:	ee 04       	jnz %d15,8000d736 <osEE_scheduler_task_insert+0x16>
    p_tcb_act->status = OSEE_TASK_READY;
8000d730:	82 12       	mov %d2,1
8000d732:	28 22       	st.b [%a15]2,%d2
8000d734:	68 3f       	st.w [%a15]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000d736:	99 45 08 00 	ld.a %a5,[%a4]8 <80000003 <BootModeHeader0+0x3>>
  (*pp_first)              = p_sn_allocated->p_next;
8000d73a:	4c 50       	ld.w %d15,[%a5]0
8000d73c:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
8000d73e:	82 0f       	mov %d15,0
8000d740:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000d742:	b0 44       	add.a %a4,4
8000d744:	1d ff c5 fe 	j 8000d4ce <osEE_scheduler_rq_insert>

8000d748 <osEE_scheduler_task_unblocked>:
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
8000d748:	99 56 04 00 	ld.a %a6,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000d74c:	91 00 00 28 	movh.a %a2,32768
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
8000d750:	cc 63       	ld.a %a15,[%a6]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000d752:	19 2f 74 b0 	ld.w %d15,[%a2]1780
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
8000d756:	20 08       	sub.a %sp,8
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000d758:	78 01       	st.w [%sp]4,%d15

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
8000d75a:	82 2f       	mov %d15,2
8000d75c:	28 2f       	st.b [%a15]2,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000d75e:	99 a4 04 00 	ld.a %a4,[%sp]4
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000d762:	39 6f 1c 00 	ld.bu %d15,[%a6]28
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000d766:	b0 44       	add.a %a4,4
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000d768:	28 1f       	st.b [%a15]1,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000d76a:	6d ff b2 fe 	call 8000d4ce <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
8000d76e:	82 0f       	mov %d15,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
8000d770:	df 12 0c 80 	jne %d2,1,8000d788 <osEE_scheduler_task_unblocked+0x40>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
8000d774:	99 a3 04 00 	ld.a %a3,[%sp]4
8000d778:	d4 32       	ld.a %a2,[%a3]
8000d77a:	99 22 0c 00 	ld.a %a2,[%a2]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
8000d77e:	0c f1       	ld.bu %d15,[%a15]1
8000d780:	39 22 01 00 	ld.bu %d2,[%a2]1
8000d784:	0b f2 30 f1 	lt.u %d15,%d2,%d15
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
8000d788:	02 f2       	mov %d2,%d15
8000d78a:	00 90       	ret 

8000d78c <osEE_scheduler_task_terminated>:
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000d78c:	91 00 00 f8 	movh.a %a15,32768
8000d790:	99 fc 74 b0 	ld.a %a12,[%a15]1780 <800006f4 <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
8000d794:	d4 c6       	ld.a %a6,[%a12]
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000d796:	d9 fd 74 b0 	lea %a13,[%a15]1780 <800006f4 <osEE_cdb_var>>
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
8000d79a:	cc 63       	ld.a %a15,[%a6]12

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
8000d79c:	f4 56       	st.a [%a5],%a6
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
8000d79e:	20 08       	sub.a %sp,8
      p_tcb_term  = p_tdb_term->p_tcb;

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
8000d7a0:	0c f2       	ld.bu %d15,[%a15]2
8000d7a2:	9e 4c       	jeq %d15,4,8000d7da <osEE_scheduler_task_terminated+0x4e>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
8000d7a4:	99 c5 0c 00 	ld.a %a5,[%a12]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
8000d7a8:	4c 50       	ld.w %d15,[%a5]0
8000d7aa:	6c c3       	st.w [%a12]12,%d15
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
8000d7ac:	39 6f 1c 00 	ld.bu %d15,[%a6]28
8000d7b0:	28 1f       	st.b [%a15]1,%d15
      p_tcb_term->status = OSEE_TASK_READY;
8000d7b2:	82 1f       	mov %d15,1
8000d7b4:	28 2f       	st.b [%a15]2,%d15
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
8000d7b6:	0c f0       	ld.bu %d15,[%a15]0
8000d7b8:	1e 1e       	jeq %d15,1,8000d7d4 <osEE_scheduler_task_terminated+0x48>
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
8000d7ba:	d9 cf 04 00 	lea %a15,[%a12]4
8000d7be:	40 f4       	mov.aa %a4,%a15
8000d7c0:	6d ff 87 fe 	call 8000d4ce <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000d7c4:	40 d4       	mov.aa %a4,%a13
8000d7c6:	40 f5       	mov.aa %a5,%a15
8000d7c8:	6d ff a1 fe 	call 8000d50a <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
8000d7cc:	bd 02 20 00 	jz.a %a2,8000d80c <osEE_scheduler_task_terminated+0x80>
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
          p_ccb->p_curr           = p_tdb_to;
        } else {
          p_tdb_to = p_ccb->p_curr;
8000d7d0:	d4 c2       	ld.a %a2,[%a12]
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
8000d7d2:	00 90       	ret 
8000d7d4:	82 0f       	mov %d15,0
8000d7d6:	68 3f       	st.w [%a15]12,%d15
8000d7d8:	3c f1       	j 8000d7ba <osEE_scheduler_task_terminated+0x2e>
    (*pp_tdb_from) = p_tdb_term;

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000d7da:	40 d4       	mov.aa %a4,%a13
8000d7dc:	d9 c5 04 00 	lea %a5,[%a12]4
8000d7e0:	b5 a6 04 00 	st.a [%sp]4,%a6
8000d7e4:	6d ff ff fe 	call 8000d5e2 <osEE_scheduler_core_pop_running>

      p_tdb_to = p_ccb->p_curr;

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000d7e8:	99 a6 04 00 	ld.a %a6,[%sp]4
    (*pp_tdb_from) = p_tdb_term;

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000d7ec:	40 2d       	mov.aa %a13,%a2

      p_tdb_to = p_ccb->p_curr;
8000d7ee:	d4 c2       	ld.a %a2,[%a12]

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000d7f0:	7d 26 12 00 	jeq.a %a6,%a2,8000d814 <osEE_scheduler_task_terminated+0x88>
        osEE_task_end(p_tdb_term);
8000d7f4:	40 64       	mov.aa %a4,%a6
8000d7f6:	b5 a2 04 00 	st.a [%sp]4,%a2
8000d7fa:	6d ff 36 ff 	call 8000d666 <osEE_task_end>
8000d7fe:	99 a2 04 00 	ld.a %a2,[%sp]4
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
8000d802:	4c c2       	ld.w %d15,[%a12]8
8000d804:	6c d0       	st.w [%a13]0,%d15
  (*pp_first)       = p_to_free;
8000d806:	b5 cd 08 00 	st.a [%a12]8,%a13
8000d80a:	00 90       	ret 

        if (p_prev == NULL) {
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
8000d80c:	cc c3       	ld.a %a15,[%a12]12
8000d80e:	c8 12       	ld.a %a2,[%a15]4
          p_ccb->p_curr           = p_tdb_to;
8000d810:	f4 c2       	st.a [%a12],%a2
8000d812:	00 90       	ret 
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
8000d814:	0c f0       	ld.bu %d15,[%a15]0
8000d816:	c2 ff       	add %d15,-1
8000d818:	28 0f       	st.b [%a15]0,%d15
8000d81a:	3c f4       	j 8000d802 <osEE_scheduler_task_terminated+0x76>

8000d81c <osEE_scheduler_task_preemption_point>:
)
{
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000d81c:	91 00 00 48 	movh.a %a4,32768
8000d820:	99 4f 74 b0 	ld.a %a15,[%a4]1780 <800006f4 <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000d824:	d9 44 74 b0 	lea %a4,[%a4]1780 <800006f4 <osEE_cdb_var>>
8000d828:	d9 f5 04 00 	lea %a5,[%a15]4 <800006f4 <osEE_cdb_var>>
8000d82c:	6d ff 6f fe 	call 8000d50a <osEE_scheduler_core_rq_preempt_stk>

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
8000d830:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
8000d832:	bc 26       	jz.a %a2,8000d83e <osEE_scheduler_task_preemption_point+0x22>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
8000d834:	c8 05       	ld.a %a5,[%a15]0
8000d836:	40 24       	mov.aa %a4,%a2
8000d838:	6d 00 b2 01 	call 8000db9c <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000d83c:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
8000d83e:	00 90       	ret 

8000d840 <osEE_scheduler_task_set_running>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000d840:	91 00 00 f8 	movh.a %a15,32768
8000d844:	99 ff 74 b0 	ld.a %a15,[%a15]1780 <800006f4 <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
8000d848:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000d84a:	99 42 0c 00 	ld.a %a2,[%a4]12 <800006f4 <osEE_cdb_var>>
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
8000d84e:	48 32       	ld.w %d2,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000d850:	0c 22       	ld.bu %d15,[%a2]2
8000d852:	1e 49       	jeq %d15,4,8000d864 <osEE_scheduler_task_set_running+0x24>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
  }
  p_ccb->p_curr                 = p_tdb;
8000d854:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000d856:	bc 6c       	jz.a %a6,8000d86e <osEE_scheduler_task_set_running+0x2e>
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
8000d858:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000d85a:	b5 65 04 00 	st.a [%a6]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000d85e:	74 62       	st.w [%a6],%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000d860:	1d 00 9e 01 	j 8000db9c <osEE_change_context_from_running>
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000d864:	82 2f       	mov %d15,2
8000d866:	2c 22       	st.b [%a2]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
8000d868:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000d86a:	bd 06 f7 ff 	jnz.a %a6,8000d858 <osEE_scheduler_task_set_running+0x18>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000d86e:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000d870:	4c 20       	ld.w %d15,[%a2]0
8000d872:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
8000d874:	f4 26       	st.a [%a2],%a6
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
8000d876:	e8 32       	st.a [%a15]12,%a2
8000d878:	40 26       	mov.aa %a6,%a2
  } else {
    p_ccb->p_stk_sn             = p_sn;
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000d87a:	b5 65 04 00 	st.a [%a6]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000d87e:	74 62       	st.w [%a6],%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
8000d880:	1d 00 8e 01 	j 8000db9c <osEE_change_context_from_running>

8000d884 <osEE_counter_insert_rel_trigger>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       delta
)
{
8000d884:	d4 46       	ld.a %a6,[%a4]
8000d886:	4c 41       	ld.w %d15,[%a4]4
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000d888:	cc 60       	ld.a %a15,[%a6]0
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000d88a:	19 65 04 00 	ld.w %d5,[%a6]4

  if ((maxallowedvalue - delta) >= value) {
8000d88e:	52 43       	sub %d3,%d15,%d4
8000d890:	1b f5 ff 6f 	addi %d6,%d5,-1
8000d894:	42 46       	add %d6,%d4
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000d896:	d4 54       	ld.a %a4,[%a5]
    when = value + delta;
8000d898:	0b 54 00 20 	add %d2,%d4,%d5
8000d89c:	5a f6       	sub %d15,%d6,%d15
8000d89e:	0b 53 30 41 	lt.u %d4,%d3,%d5
8000d8a2:	2b 2f 40 44 	sel %d4,%d4,%d15,%d2
8000d8a6:	59 44 04 00 	st.w [%a4]4,%d4
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000d8aa:	82 12       	mov %d2,1
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000d8ac:	a0 03       	mov.a %a3,0
8000d8ae:	01 0f 90 34 	nez.a %d3,%a15
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000d8b2:	0b 45 50 61 	ge.u %d6,%d5,%d4
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000d8b6:	26 32       	and %d2,%d3
8000d8b8:	df 02 14 00 	jeq %d2,0,8000d8e0 <osEE_counter_insert_rel_trigger+0x5c>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000d8bc:	c8 02       	ld.a %a2,[%a15]0
8000d8be:	4c 21       	ld.w %d15,[%a2]4

    if (current_when > counter_value) {
8000d8c0:	7f f5 15 80 	jge.u %d5,%d15,8000d8ea <osEE_counter_insert_rel_trigger+0x66>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000d8c4:	02 62       	mov %d2,%d6
8000d8c6:	0b f4 c0 22 	or.ge.u %d2,%d4,%d15
8000d8ca:	02 2f       	mov %d15,%d2
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000d8cc:	82 02       	mov %d2,0
  while ((p_current != NULL) && work_not_done) {
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;

    if (current_when > counter_value) {
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000d8ce:	6e f4       	jz %d15,8000d8b6 <osEE_counter_insert_rel_trigger+0x32>
      if ((when <= counter_value) && (when >= current_when)) {
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000d8d0:	40 f3       	mov.aa %a3,%a15
8000d8d2:	cc 20       	ld.a %a15,[%a2]0
8000d8d4:	82 12       	mov %d2,1
8000d8d6:	01 0f 90 34 	nez.a %d3,%a15
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000d8da:	26 32       	and %d2,%d3
8000d8dc:	df 02 f0 ff 	jne %d2,0,8000d8bc <osEE_counter_insert_rel_trigger+0x38>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000d8e0:	bc 3b       	jz.a %a3,8000d8f6 <osEE_counter_insert_rel_trigger+0x72>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000d8e2:	d4 32       	ld.a %a2,[%a3]
8000d8e4:	f4 25       	st.a [%a2],%a5
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000d8e6:	ec 40       	st.a [%a4]0,%a15
8000d8e8:	00 90       	ret 
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000d8ea:	0b f4 50 f1 	ge.u %d15,%d4,%d15
8000d8ee:	26 6f       	and %d15,%d6
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000d8f0:	82 02       	mov %d2,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000d8f2:	6e e2       	jz %d15,8000d8b6 <osEE_counter_insert_rel_trigger+0x32>
8000d8f4:	3c ee       	j 8000d8d0 <osEE_counter_insert_rel_trigger+0x4c>
  }

  if (p_previous != NULL) {
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000d8f6:	f4 65       	st.a [%a6],%a5
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000d8f8:	ec 40       	st.a [%a4]0,%a15
8000d8fa:	00 90       	ret 

8000d8fc <osEE_counter_insert_abs_trigger>:
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       when
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
8000d8fc:	d4 44       	ld.a %a4,[%a4]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000d8fe:	cc 40       	ld.a %a15,[%a4]0
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000d900:	d4 56       	ld.a %a6,[%a5]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
8000d902:	19 45 04 00 	ld.w %d5,[%a4]4
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000d906:	82 12       	mov %d2,1

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000d908:	59 64 04 00 	st.w [%a6]4,%d4
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000d90c:	a0 03       	mov.a %a3,0
8000d90e:	01 0f 90 34 	nez.a %d3,%a15
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000d912:	0b 45 50 61 	ge.u %d6,%d5,%d4
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000d916:	26 32       	and %d2,%d3
8000d918:	df 02 14 00 	jeq %d2,0,8000d940 <osEE_counter_insert_abs_trigger+0x44>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000d91c:	c8 02       	ld.a %a2,[%a15]0
8000d91e:	4c 21       	ld.w %d15,[%a2]4

    if (current_when > counter_value) {
8000d920:	7f f5 15 80 	jge.u %d5,%d15,8000d94a <osEE_counter_insert_abs_trigger+0x4e>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000d924:	02 62       	mov %d2,%d6
8000d926:	0b f4 c0 22 	or.ge.u %d2,%d4,%d15
8000d92a:	02 2f       	mov %d15,%d2
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000d92c:	82 02       	mov %d2,0
  while ((p_current != NULL) && work_not_done) {
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;

    if (current_when > counter_value) {
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000d92e:	6e f4       	jz %d15,8000d916 <osEE_counter_insert_abs_trigger+0x1a>
8000d930:	40 f3       	mov.aa %a3,%a15
      if ((when <= counter_value) && (when >= current_when)) {
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000d932:	cc 20       	ld.a %a15,[%a2]0
8000d934:	82 12       	mov %d2,1
8000d936:	01 0f 90 34 	nez.a %d3,%a15
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000d93a:	26 32       	and %d2,%d3
8000d93c:	df 02 f0 ff 	jne %d2,0,8000d91c <osEE_counter_insert_abs_trigger+0x20>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000d940:	bc 3b       	jz.a %a3,8000d956 <osEE_counter_insert_abs_trigger+0x5a>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000d942:	d4 32       	ld.a %a2,[%a3]
8000d944:	f4 25       	st.a [%a2],%a5
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000d946:	ec 60       	st.a [%a6]0,%a15
8000d948:	00 90       	ret 
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000d94a:	0b f4 50 f1 	ge.u %d15,%d4,%d15
8000d94e:	26 6f       	and %d15,%d6
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000d950:	82 02       	mov %d2,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000d952:	6e e2       	jz %d15,8000d916 <osEE_counter_insert_abs_trigger+0x1a>
8000d954:	3c ee       	j 8000d930 <osEE_counter_insert_abs_trigger+0x34>
  }

  if (p_previous != NULL) {
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000d956:	f4 45       	st.a [%a4],%a5
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000d958:	ec 60       	st.a [%a6]0,%a15
8000d95a:	00 90       	ret 

8000d95c <osEE_counter_cancel_trigger>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
8000d95c:	cc 40       	ld.a %a15,[%a4]0
  osEE_counter_cancel_trigger
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db
)
{
8000d95e:	80 53       	mov.d %d3,%a5
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb  = p_trigger_db->p_trigger_cb;
8000d960:	d4 52       	ld.a %a2,[%a5]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000d962:	4c f0       	ld.w %d15,[%a15]0

  if (p_current == p_trigger_db) {
8000d964:	3e 3b       	jeq %d15,%d3,8000d97a <osEE_counter_cancel_trigger+0x1e>
    p_counter_cb->trigger_queue = p_trigger_cb->p_next;
  } else {
    P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_previous;
    do {
      p_previous = p_current;
      p_current  = p_current->p_trigger_cb->p_next;
8000d966:	60 f3       	mov.a %a3,%d15
8000d968:	cc 30       	ld.a %a15,[%a3]0
8000d96a:	4c f0       	ld.w %d15,[%a15]0
    } while ((p_current != NULL) && (p_current != p_trigger_db));
8000d96c:	8b 0f 20 22 	ne %d2,%d15,0
8000d970:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000d974:	df 02 f9 ff 	jne %d2,0,8000d966 <osEE_counter_cancel_trigger+0xa>

    if (p_current != NULL) {
8000d978:	6e 03       	jz %d15,8000d97e <osEE_counter_cancel_trigger+0x22>
      /* Remove p_trigger_db from the list */
      p_previous->p_trigger_cb->p_next = p_trigger_cb->p_next;
8000d97a:	4c 20       	ld.w %d15,[%a2]0
8000d97c:	68 0f       	st.w [%a15]0,%d15
8000d97e:	00 90       	ret 

8000d980 <osEE_counter_increment>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb = p_counter_db->p_counter_cb;
8000d980:	d4 47       	ld.a %a7,[%a4]
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
8000d982:	19 43 04 00 	ld.w %d3,[%a4]4
            to not have nested critical sections.
            To handle possible races due to cycling triggers a state
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;
8000d986:	cc 70       	ld.a %a15,[%a7]0
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
8000d988:	19 72 04 00 	ld.w %d2,[%a7]4
FUNC(void, OS_CODE)
  osEE_counter_increment
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
8000d98c:	20 08       	sub.a %sp,8
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
      counter_value       = 0U;
      p_counter_cb->value = 0U;
    } else {
      ++p_counter_cb->value;
8000d98e:	9a 12       	add %d15,%d2,1
8000d990:	0b 32 30 21 	lt.u %d2,%d2,%d3
8000d994:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000d998:	59 72 04 00 	st.w [%a7]4,%d2
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;

    if (p_triggered_db != NULL) {
8000d99c:	bc f4       	jz.a %a15,8000d9a4 <osEE_counter_increment+0x24>
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;
8000d99e:	c8 02       	ld.a %a2,[%a15]0

      if (p_triggered_cb->when == counter_value) {
8000d9a0:	4c 21       	ld.w %d15,[%a2]4
8000d9a2:	3e 22       	jeq %d15,%d2,8000d9a6 <osEE_counter_increment+0x26>
8000d9a4:	00 90       	ret 
8000d9a6:	40 23       	mov.aa %a3,%a2
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
8000d9a8:	82 32       	mov %d2,3
8000d9aa:	3c 06       	j 8000d9b6 <osEE_counter_increment+0x36>
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
          (p_current->p_trigger_cb->when == counter_value));
8000d9ac:	d4 56       	ld.a %a6,[%a5]
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
8000d9ae:	19 63 04 00 	ld.w %d3,[%a6]4
8000d9b2:	7e 37       	jne %d15,%d3,8000d9c0 <osEE_counter_increment+0x40>
8000d9b4:	40 63       	mov.aa %a3,%a6
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
8000d9b6:	d4 35       	ld.a %a5,[%a3]
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
8000d9b8:	e9 32 08 00 	st.b [%a3]8,%d2
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
          (p_current->p_trigger_cb->when == counter_value));
8000d9bc:	bd 05 f8 ff 	jnz.a %a5,8000d9ac <osEE_counter_increment+0x2c>

        /* I set the end of handled queue */
        p_previous->p_trigger_cb->p_next = NULL;
8000d9c0:	82 0f       	mov %d15,0
8000d9c2:	6c 30       	st.w [%a3]0,%d15
8000d9c4:	91 10 00 d8 	movh.a %a13,32769

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);

      if (p_sn != NULL) {
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000d9c8:	7b 00 00 98 	movh %d9,32768
8000d9cc:	40 4e       	mov.aa %a14,%a4

        /* I set the end of handled queue */
        p_previous->p_trigger_cb->p_next = NULL;
        /* I set the head of the trigger queue to the current value
           (maybe NULL) */
        p_counter_cb->trigger_queue = p_current;
8000d9ce:	f4 75       	st.a [%a7],%a5
8000d9d0:	d9 dd ac 7d 	lea %a13,[%a13]-9748 <8000d9ec <osEE_counter_increment+0x6c>>
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
8000d9d4:	82 08       	mov %d8,0

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);

      if (p_sn != NULL) {
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000d9d6:	1b 09 6d 90 	addi %d9,%d9,1744
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
  switch (p_action->type) {
8000d9da:	39 ff 18 00 	ld.bu %d15,[%a15]24
#endif /* OSEE_HAS_ALARMS || OSEE_HAS_SCHEDULE_TABLES */

          /* Prepare next trigger to be handled here, before actually handle
           * the current one, otherwise cycling triggers will mess with the
           * list of triggers that have to be handled now */
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
8000d9de:	d4 2c       	ld.a %a12,[%a2]
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
8000d9e0:	e9 a8 07 00 	st.b [%sp]7,%d8
  switch (p_action->type) {
8000d9e4:	ff 4f 10 80 	jge.u %d15,4,8000da04 <osEE_counter_increment+0x84>
8000d9e8:	90 d2       	addsc.a %a2,%a13,%d15,2
8000d9ea:	dc 02       	ji %a2
8000d9ec:	1d 00 29 00 	j 8000da3e <osEE_counter_increment+0xbe>
8000d9f0:	1d 00 15 00 	j 8000da1a <osEE_counter_increment+0x9a>
8000d9f4:	1d 00 04 00 	j 8000d9fc <osEE_counter_increment+0x7c>
8000d9f8:	1d 00 1e 00 	j 8000da34 <osEE_counter_increment+0xb4>
      }
    }
    break;
#endif /* OSEE_HAS_EVENTS */
    case OSEE_ACTION_COUNTER:
      osEE_counter_increment(p_action->param.p_counter_db);
8000d9fc:	c8 44       	ld.a %a4,[%a15]16
8000d9fe:	6d ff c1 ff 	call 8000d980 <osEE_counter_increment>
8000da02:	c8 02       	ld.a %a2,[%a15]0
  /* Re-enter in critical section to reinsert alarm-trigger if needed */
  p_cdb = osEE_lock_and_get_curr_core();

  p_trigger_to_be_handled_cb = p_trigger_to_be_handled_db->p_trigger_cb;

  if (p_trigger_to_be_handled_cb->status == OSEE_TRIGGER_EXPIRED) {
8000da04:	0c 28       	ld.bu %d15,[%a2]8
8000da06:	1e 36       	jeq %d15,3,8000da12 <osEE_counter_increment+0x92>
#elif (defined(OSEE_HAS_SCHEDULE_TABLES))
          osEE_counter_handle_st_expiry_point(p_counter_db,
            p_trigger_to_be_handled_db);
#endif /* OSEE_COUNTER_TRIGGER_TYPES elif OSEE_HAS_ALARMS elif
          OSEE_HAS_SCHEDULE_TABLES */
        } while (p_triggered_db != NULL);
8000da08:	bd 0c ce 7f 	jz.a %a12,8000d9a4 <osEE_counter_increment+0x24>
8000da0c:	d4 c2       	ld.a %a2,[%a12]
8000da0e:	40 cf       	mov.aa %a15,%a12
8000da10:	3c e5       	j 8000d9da <osEE_counter_increment+0x5a>
  p_cdb = osEE_lock_and_get_curr_core();

  p_trigger_to_be_handled_cb = p_trigger_to_be_handled_db->p_trigger_cb;

  if (p_trigger_to_be_handled_cb->status == OSEE_TRIGGER_EXPIRED) {
    CONST(TickType, AUTOMATIC) cycle = osEE_alarm_get_cb(
8000da12:	4c 23       	ld.w %d15,[%a2]12
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
8000da14:	ee 23       	jnz %d15,8000da5a <osEE_counter_increment+0xda>
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
      osEE_counter_insert_rel_trigger(p_counter_db,
        p_trigger_to_be_handled_db, cycle);
    } else {
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_INACTIVE;
8000da16:	2c 28       	st.b [%a2]8,%d15
8000da18:	3c f8       	j 8000da08 <osEE_counter_increment+0x88>
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb = p_action->param.p_tdb;
      CONST(EventMaskType, AUTOMATIC)
        mask = p_action->param.mask;

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);
8000da1a:	c8 34       	ld.a %a4,[%a15]12
8000da1c:	48 54       	ld.w %d4,[%a15]20
8000da1e:	d9 a5 07 00 	lea %a5,[%sp]7
8000da22:	6d ff 2e fe 	call 8000d67e <osEE_task_event_set_mask>

      if (p_sn != NULL) {
8000da26:	bc 2a       	jz.a %a2,8000da3a <osEE_counter_increment+0xba>
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000da28:	60 94       	mov.a %a4,%d9
8000da2a:	40 25       	mov.aa %a5,%a2
8000da2c:	6d ff 8e fe 	call 8000d748 <osEE_scheduler_task_unblocked>
8000da30:	c8 02       	ld.a %a2,[%a15]0
8000da32:	3c e9       	j 8000da04 <osEE_counter_increment+0x84>
      CONST(OsEE_os_context, AUTOMATIC)
        prev_os_context = p_ccb->os_context;

      p_ccb->os_context = OSEE_ALARMCALLBACK_CTX;
#endif /* OSEE_HAS_CONTEXT */
      p_action->param.f();
8000da34:	c8 22       	ld.a %a2,[%a15]8
8000da36:	2d 02 00 00 	calli %a2
8000da3a:	c8 02       	ld.a %a2,[%a15]0
8000da3c:	3c e4       	j 8000da04 <osEE_counter_increment+0x84>
  VAR(StatusType, AUTOMATIC) ev = E_OK;
  switch (p_action->type) {
    case OSEE_ACTION_TASK:
    {
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb     = p_action->param.p_tdb;
8000da3e:	4c f3       	ld.w %d15,[%a15]12

      ev = osEE_task_activated(p_tdb);
8000da40:	60 f4       	mov.a %a4,%d15
8000da42:	6d ff 06 fe 	call 8000d64e <osEE_task_activated>
8000da46:	e9 a2 07 00 	st.b [%sp]7,%d2
      if (ev == E_OK) {
8000da4a:	df 02 f8 ff 	jne %d2,0,8000da3a <osEE_counter_increment+0xba>
        (void)osEE_scheduler_task_insert(osEE_get_kernel(), p_tdb);
8000da4e:	60 94       	mov.a %a4,%d9
8000da50:	60 f5       	mov.a %a5,%d15
8000da52:	6d ff 67 fe 	call 8000d720 <osEE_scheduler_task_insert>
8000da56:	c8 02       	ld.a %a2,[%a15]0
8000da58:	3c d6       	j 8000da04 <osEE_counter_increment+0x84>
8000da5a:	d4 e7       	ld.a %a7,[%a14]
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
      /* Reinsert the trigger in timer wheel as relative with delta equal to
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
8000da5c:	82 22       	mov %d2,2
8000da5e:	e9 22 08 00 	st.b [%a2]8,%d2
8000da62:	19 e2 04 00 	ld.w %d2,[%a14]4
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000da66:	19 75 04 00 	ld.w %d5,[%a7]4

  if ((maxallowedvalue - delta) >= value) {
8000da6a:	0b f2 80 40 	sub %d4,%d2,%d15
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000da6e:	d4 73       	ld.a %a3,[%a7]
    when = value + delta;
8000da70:	46 02       	not %d2
8000da72:	0b 54 30 31 	lt.u %d3,%d4,%d5
8000da76:	42 5f       	add %d15,%d5
8000da78:	2b 2f 00 43 	cadd %d4,%d3,%d15,%d2
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000da7c:	59 24 04 00 	st.w [%a2]4,%d4
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000da80:	82 12       	mov %d2,1
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000da82:	a0 06       	mov.a %a6,0
8000da84:	01 03 90 34 	nez.a %d3,%a3
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000da88:	0b 45 50 61 	ge.u %d6,%d5,%d4
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000da8c:	26 32       	and %d2,%d3
8000da8e:	df 02 14 00 	jeq %d2,0,8000dab6 <osEE_counter_increment+0x136>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000da92:	d4 35       	ld.a %a5,[%a3]
8000da94:	4c 51       	ld.w %d15,[%a5]4

    if (current_when > counter_value) {
8000da96:	7f f5 15 80 	jge.u %d5,%d15,8000dac0 <osEE_counter_increment+0x140>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000da9a:	02 62       	mov %d2,%d6
8000da9c:	0b f4 c0 22 	or.ge.u %d2,%d4,%d15
8000daa0:	02 2f       	mov %d15,%d2
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000daa2:	82 02       	mov %d2,0
  while ((p_current != NULL) && work_not_done) {
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;

    if (current_when > counter_value) {
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000daa4:	6e f4       	jz %d15,8000da8c <osEE_counter_increment+0x10c>
      if ((when <= counter_value) && (when >= current_when)) {
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000daa6:	40 36       	mov.aa %a6,%a3
8000daa8:	d4 53       	ld.a %a3,[%a5]
8000daaa:	82 12       	mov %d2,1
8000daac:	01 03 90 34 	nez.a %d3,%a3
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000dab0:	26 32       	and %d2,%d3
8000dab2:	df 02 f0 ff 	jne %d2,0,8000da92 <osEE_counter_increment+0x112>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000dab6:	bc 6b       	jz.a %a6,8000dacc <osEE_counter_increment+0x14c>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000dab8:	d4 64       	ld.a %a4,[%a6]
8000daba:	ec 40       	st.a [%a4]0,%a15
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000dabc:	f4 23       	st.a [%a2],%a3
8000dabe:	3c a5       	j 8000da08 <osEE_counter_increment+0x88>
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000dac0:	0b f4 50 f1 	ge.u %d15,%d4,%d15
8000dac4:	26 6f       	and %d15,%d6
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000dac6:	82 02       	mov %d2,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000dac8:	6e e2       	jz %d15,8000da8c <osEE_counter_increment+0x10c>
8000daca:	3c ee       	j 8000daa6 <osEE_counter_increment+0x126>
  }

  if (p_previous != NULL) {
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000dacc:	ec 70       	st.a [%a7]0,%a15
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000dace:	f4 23       	st.a [%a2],%a3
8000dad0:	3c 9c       	j 8000da08 <osEE_counter_increment+0x88>
	...

8000dad4 <osEE_alarm_set_rel>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      increment,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
8000dad4:	cc 50       	ld.a %a15,[%a5]0
8000dad6:	02 4f       	mov %d15,%d4
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
8000dad8:	82 72       	mov %d2,7
    counter_core_id = p_counter_db->core_id;
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000dada:	08 83       	ld.bu %d3,[%a15]8
8000dadc:	bf 23 03 80 	jlt.u %d3,2,8000dae2 <osEE_alarm_set_rel+0xe>
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000dae0:	00 90       	ret 
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
8000dae2:	68 35       	st.w [%a15]12,%d5
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
8000dae4:	df 13 17 80 	jne %d3,1,8000db12 <osEE_alarm_set_rel+0x3e>
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000dae8:	d4 42       	ld.a %a2,[%a4]
8000daea:	19 44 04 00 	ld.w %d4,[%a4]4
8000daee:	19 23 04 00 	ld.w %d3,[%a2]4

  if ((maxallowedvalue - delta) >= value) {
8000daf2:	0b f4 80 50 	sub %d5,%d4,%d15
8000daf6:	1b f3 ff 2f 	addi %d2,%d3,-1
8000dafa:	42 f2       	add %d2,%d15
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
8000dafc:	a2 42       	sub %d2,%d4
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
8000dafe:	42 3f       	add %d15,%d3
8000db00:	0b 35 30 31 	lt.u %d3,%d5,%d3
8000db04:	2b f2 40 23 	sel %d2,%d3,%d2,%d15
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       'here' when based on increment */
    p_trigger_cb->when   = osEE_counter_eval_when(p_counter_db, increment);
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000db08:	82 4f       	mov %d15,4
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       'here' when based on increment */
    p_trigger_cb->when   = osEE_counter_eval_when(p_counter_db, increment);
8000db0a:	68 12       	st.w [%a15]4,%d2
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000db0c:	28 8f       	st.b [%a15]8,%d15

    ev = E_OK;
8000db0e:	82 02       	mov %d2,0
8000db10:	00 90       	ret 
  } else {
    p_alarm_cb->cycle = cycle;
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000db12:	82 2f       	mov %d15,2
8000db14:	28 8f       	st.b [%a15]8,%d15
 
    osEE_counter_insert_rel_trigger(
8000db16:	6d ff b7 fe 	call 8000d884 <osEE_counter_insert_rel_trigger>
      p_counter_db, p_trigger_db, increment
    );
 
    ev = E_OK;
8000db1a:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000db1c:	00 90       	ret 

8000db1e <osEE_alarm_set_abs>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      start,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
8000db1e:	cc 50       	ld.a %a15,[%a5]0
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
8000db20:	82 72       	mov %d2,7
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000db22:	0c f8       	ld.bu %d15,[%a15]8
8000db24:	bf 2f 03 80 	jlt.u %d15,2,8000db2a <osEE_alarm_set_abs+0xc>
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000db28:	00 90       	ret 
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
8000db2a:	68 35       	st.w [%a15]12,%d5
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
8000db2c:	1e 17       	jeq %d15,1,8000db3a <osEE_alarm_set_abs+0x1c>

    ev = E_OK;
  } else {
    p_alarm_cb->cycle = cycle;
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000db2e:	82 2f       	mov %d15,2
8000db30:	28 8f       	st.b [%a15]8,%d15

    osEE_counter_insert_abs_trigger(
8000db32:	6d ff e5 fe 	call 8000d8fc <osEE_counter_insert_abs_trigger>
      p_counter_db, p_trigger_db, start
    );

    ev = E_OK;
8000db36:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000db38:	00 90       	ret 
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       here 'when' based on start */
    p_trigger_cb->when   = start;
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000db3a:	82 4f       	mov %d15,4
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
    p_alarm_cb->cycle = cycle;
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       here 'when' based on start */
    p_trigger_cb->when   = start;
8000db3c:	68 14       	st.w [%a15]4,%d4
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000db3e:	28 8f       	st.b [%a15]8,%d15

    ev = E_OK;
8000db40:	82 02       	mov %d2,0
8000db42:	00 90       	ret 

8000db44 <osEE_alarm_cancel>:
{
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000db44:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
8000db46:	99 42 04 00 	ld.a %a2,[%a4]4
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
    ev = E_OS_NOFUNC;
8000db4a:	82 52       	mov %d2,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000db4c:	0c f8       	ld.bu %d15,[%a15]8
8000db4e:	bf 2f 0e 80 	jlt.u %d15,2,8000db6a <osEE_alarm_cancel+0x26>
    ev = E_OS_NOFUNC;
  } else if (p_trigger_cb->status >= OSEE_TRIGGER_EXPIRED) {
8000db52:	1e 25       	jeq %d15,2,8000db5c <osEE_alarm_cancel+0x18>
    p_trigger_cb->status = OSEE_TRIGGER_CANCELED;
8000db54:	82 1f       	mov %d15,1
8000db56:	28 8f       	st.b [%a15]8,%d15
    ev = E_OK;
8000db58:	82 02       	mov %d2,0
8000db5a:	00 90       	ret 
  } else {
    p_trigger_cb->status = OSEE_TRIGGER_INACTIVE;
8000db5c:	82 0f       	mov %d15,0
8000db5e:	40 45       	mov.aa %a5,%a4
8000db60:	28 8f       	st.b [%a15]8,%d15
    osEE_counter_cancel_trigger(p_counter_db, p_trigger_db);
8000db62:	40 24       	mov.aa %a4,%a2
8000db64:	6d ff fc fe 	call 8000d95c <osEE_counter_cancel_trigger>
    ev = E_OK;
8000db68:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000db6a:	00 90       	ret 

8000db6c <osEE_alarm_get>:
{
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000db6c:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
8000db6e:	99 42 04 00 	ld.a %a2,[%a4]4
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
    ev = E_OS_NOFUNC;
8000db72:	82 52       	mov %d2,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000db74:	0c f8       	ld.bu %d15,[%a15]8
8000db76:	bf 2f 12 80 	jlt.u %d15,2,8000db9a <osEE_alarm_get+0x2e>
    ev = E_OS_NOFUNC;
  } else {
    *p_tick = osEE_counter_eval_delta(p_counter_db, p_trigger_cb->when);
8000db7a:	48 13       	ld.w %d3,[%a15]4
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000db7c:	cc 20       	ld.a %a15,[%a2]0
8000db7e:	4c 21       	ld.w %d15,[%a2]4
8000db80:	1b 13 00 40 	addi %d4,%d3,1
8000db84:	48 12       	ld.w %d2,[%a15]4
8000db86:	42 4f       	add %d15,%d4

  if (when > value) {
    delta = when - value;
  } else {
    delta = (maxallowedvalue - value) + when + 1U;
8000db88:	a2 2f       	sub %d15,%d2
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if (when > value) {
    delta = when - value;
8000db8a:	0b 23 80 40 	sub %d4,%d3,%d2
8000db8e:	0b 32 50 21 	ge.u %d2,%d2,%d3
8000db92:	2b 4f 40 f2 	sel %d15,%d2,%d15,%d4
8000db96:	6c 50       	st.w [%a5]0,%d15
    ev = E_OK;
8000db98:	82 02       	mov %d2,0
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000db9a:	00 90       	ret 

8000db9c <osEE_change_context_from_running>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000db9c:	99 52 0c 00 	ld.a %a2,[%a5]12
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000dba0:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000dba2:	c8 16       	ld.a %a6,[%a15]4
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000dba4:	0c 22       	ld.bu %d15,[%a2]2
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000dba6:	40 54       	mov.aa %a4,%a5
8000dba8:	99 55 04 00 	ld.a %a5,[%a5]4
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000dbac:	1e 23       	jeq %d15,2,8000dbb2 <osEE_change_context_from_running+0x16>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
8000dbae:	1d 00 8d 00 	j 8000dcc8 <osEE_hal_save_ctx_and_ready2stacked>
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000dbb2:	1d 00 6c 00 	j 8000dc8a <osEE_hal_save_ctx_and_restore_ctx>

8000dbb6 <osEE_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000dbb6:	cc 53       	ld.a %a15,[%a5]12
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000dbb8:	40 54       	mov.aa %a4,%a5
8000dbba:	99 55 04 00 	ld.a %a5,[%a5]4
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000dbbe:	0c f2       	ld.bu %d15,[%a15]2
8000dbc0:	1e 23       	jeq %d15,2,8000dbc6 <osEE_change_context_from_task_end+0x10>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
8000dbc2:	1d 00 95 00 	j 8000dcec <osEE_hal_ready2stacked>
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000dbc6:	1d 00 74 00 	j 8000dcae <osEE_hal_restore_ctx>

8000dbca <osEE_idle_task_terminate>:
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000dbca:	cc 40       	ld.a %a15,[%a4]0
{
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
8000dbcc:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000dbd0:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000dbd2:	cc 50       	ld.a %a15,[%a5]0
8000dbd4:	3c 02       	j 8000dbd8 <osEE_idle_task_terminate+0xe>
8000dbd6:	60 ff       	mov.a %a15,%d15

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000dbd8:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
8000dbda:	8b 0f 20 22 	ne %d2,%d15,0
8000dbde:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000dbe2:	df 02 fa ff 	jne %d2,0,8000dbd6 <osEE_idle_task_terminate+0xc>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000dbe6:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
8000dbe8:	1d 00 63 00 	j 8000dcae <osEE_hal_restore_ctx>

8000dbec <osEE_cpu_startos>:
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000dbec:	4d c0 e1 bf 	mfcr %d11,$core_id
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000dbf0:	91 00 00 f8 	movh.a %a15,32768
8000dbf4:	d9 ff 50 b0 	lea %a15,[%a15]1744 <800006d0 <osEE_kdb_var>>

#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_0) {
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_SYSTEM_TIMER))
    osEE_tc_stm_set_clockpersec();
8000dbf8:	6d ff bb f5 	call 8000c76e <osEE_tc_stm_set_clockpersec>
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000dbfc:	48 28       	ld.w %d8,[%a15]8
8000dbfe:	c2 f8       	add %d8,-1
  for (i = 0U; i < tdb_size; ++i) {
8000dc00:	df 08 2f 00 	jeq %d8,0,8000dc5e <osEE_cpu_startos+0x72>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000dc04:	8f 3b 00 b1 	and %d11,%d11,3
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
8000dc08:	7b 10 00 a8 	movh %d10,32769
8000dc0c:	c8 1c       	ld.a %a12,[%a15]4
8000dc0e:	8f bb 00 b0 	sh %d11,%d11,11
8000dc12:	82 0f       	mov %d15,0
8000dc14:	1b ca 40 ac 	addi %d10,%d10,-15348
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000dc18:	bb f0 ff 9f 	mov.u %d9,65535
8000dc1c:	3c 04       	j 8000dc24 <osEE_cpu_startos+0x38>
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000dc1e:	c2 1f       	add %d15,1
8000dc20:	5f f8 1f 00 	jeq %d8,%d15,8000dc5e <osEE_cpu_startos+0x72>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000dc24:	90 cf       	addsc.a %a15,%a12,%d15,2
8000dc26:	c8 04       	ld.a %a4,[%a15]0
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000dc28:	39 42 14 00 	ld.bu %d2,[%a4]20
8000dc2c:	df 22 f9 ff 	jne %d2,2,8000dc1e <osEE_cpu_startos+0x32>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
8000dc30:	19 42 18 00 	ld.w %d2,[%a4]24
8000dc34:	5f a2 17 00 	jeq %d2,%d10,8000dc62 <osEE_cpu_startos+0x76>
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000dc38:	b9 42 08 00 	ld.hu %d2,[%a4]8
8000dc3c:	5f 92 f1 7f 	jeq %d2,%d9,8000dc1e <osEE_cpu_startos+0x32>
8000dc40:	60 22       	mov.a %a2,%d2
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000dc42:	39 42 1c 00 	ld.bu %d2,[%a4]28
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000dc46:	d9 2f 00 08 	lea %a15,[%a2]-32768
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000dc4a:	c2 12       	add %d2,1
8000dc4c:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000dc50:	11 4f 00 ff 	addih.a %a15,%a15,61444
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000dc54:	a6 b2       	or %d2,%d11
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000dc56:	68 02       	st.w [%a15]0,%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000dc58:	c2 1f       	add %d15,1
8000dc5a:	5f f8 e5 ff 	jne %d8,%d15,8000dc24 <osEE_cpu_startos+0x38>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000dc5e:	82 12       	mov %d2,1
8000dc60:	00 90       	ret 
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
8000dc62:	6d ff fb f3 	call 8000c458 <osEE_tc_initialize_system_timer>
8000dc66:	3c dc       	j 8000dc1e <osEE_cpu_startos+0x32>

8000dc68 <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000dc68:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000dc6c:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000dc6e:	0c 22       	ld.bu %d15,[%a2]2
8000dc70:	1e 27       	jeq %d15,2,8000dc7e <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000dc72:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000dc74:	c8 1f       	ld.a %a15,[%a15]4
8000dc76:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
8000dc78:	1d 00 3a 00 	j 8000dcec <osEE_hal_ready2stacked>
8000dc7c:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
8000dc7e:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000dc80:	c8 1f       	ld.a %a15,[%a15]4
8000dc82:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000dc84:	1d 00 15 00 	j 8000dcae <osEE_hal_restore_ctx>
8000dc88:	00 90       	ret 

8000dc8a <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000dc8a:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000dc8c:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000dc90:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000dc92:	4c 60       	ld.w %d15,[%a6]0
8000dc94:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000dc98:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000dc9c:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000dca0:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000dca2:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000dca6:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
8000dca8:	1d 00 03 00 	j 8000dcae <osEE_hal_restore_ctx>
8000dcac:	00 90       	ret 

8000dcae <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
8000dcae:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000dcb0:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
8000dcb2:	4c f2       	ld.w %d15,[%a15]8
8000dcb4:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000dcb6:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000dcba:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
8000dcbe:	4c f0       	ld.w %d15,[%a15]0
8000dcc0:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
8000dcc2:	1d ff 95 fb 	j 8000d3ec <osEE_scheduler_task_wrapper_restore>
8000dcc6:	00 90       	ret 

8000dcc8 <osEE_hal_save_ctx_and_ready2stacked>:
8000dcc8:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000dcca:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000dcce:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000dcd0:	4c 60       	ld.w %d15,[%a6]0
8000dcd2:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000dcd6:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000dcda:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000dcde:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000dce0:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000dce4:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
8000dce6:	1d 00 03 00 	j 8000dcec <osEE_hal_ready2stacked>
8000dcea:	00 90       	ret 

8000dcec <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000dcec:	cc 50       	ld.a %a15,[%a5]0
8000dcee:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
8000dcf0:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000dcf4:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000dcf6:	d9 f2 f0 ff 	lea %a2,[%a15]-16
8000dcfa:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000dcfc:	4c 50       	ld.w %d15,[%a5]0
8000dcfe:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000dd02:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000dd06:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000dd0a:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000dd0c:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000dd10:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000dd12:	1d ff 71 fb 	j 8000d3f4 <osEE_scheduler_task_wrapper_run>
8000dd16:	00 90       	ret 

8000dd18 <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
8000dd18:	4d 40 e0 ff 	mfcr %d15,$psw
8000dd1c:	8f ff c7 f1 	andn %d15,%d15,127
8000dd20:	cd 4f e0 0f 	mtcr $psw,%d15
8000dd24:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000dd28:	91 10 00 f8 	movh.a %a15,32769
8000dd2c:	d9 ff e8 1d 	lea %a15,[%a15]-9112 <8000dc68 <osEE_tc_change_context_from_task_end>>
8000dd30:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000dd32:	00 80       	rfe 
8000dd34:	00 90       	ret 

8000dd36 <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000dd36:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
8000dd38:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000dd3c:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
8000dd40:	cc 40       	ld.a %a15,[%a4]0
8000dd42:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000dd44:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000dd48:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000dd4c:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000dd4e:	8f c3 01 30 	sh %d3,%d3,28
8000dd52:	a6 43       	or %d3,%d4
8000dd54:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000dd56:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
8000dd58:	bc f3       	jz.a %a15,8000dd5e <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
8000dd5a:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
8000dd5c:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
8000dd5e:	cd 8f e3 0f 	mtcr $fcx,%d15
8000dd62:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000dd66:	cd 03 e0 0f 	mtcr $pcxi,%d3
8000dd6a:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
8000dd6e:	cc 40       	ld.a %a15,[%a4]0
8000dd70:	4c f0       	ld.w %d15,[%a15]0
8000dd72:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000dd74:	91 00 00 48 	movh.a %a4,32768
8000dd78:	d9 44 50 b0 	lea %a4,[%a4]1744 <800006d0 <osEE_kdb_var>>
8000dd7c:	d9 a5 04 00 	lea %a5,[%sp]4 <800006d0 <osEE_kdb_var>>
8000dd80:	6d ff 06 fd 	call 8000d78c <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000dd84:	d8 01       	ld.a %a15,[%sp]4
8000dd86:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000dd8a:	1e 25       	jeq %d15,2,8000dd94 <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
8000dd8c:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
8000dd8e:	1d ff 6d ff 	j 8000dc68 <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000dd92:	3c 00       	j 8000dd92 <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000dd94:	40 24       	mov.aa %a4,%a2
8000dd96:	6d ff c1 ff 	call 8000dd18 <osEE_tc_change_context_from_isr2_end>
8000dd9a:	3c fc       	j 8000dd92 <osEE_hal_terminate_ctx+0x5c>

8000dd9c <__interrupt_1>:
8000dd9c:	0d 00 80 04 	dsync 
8000dda0:	e0 01       	bisr 1
8000dda2:	91 00 00 f7 	movh.a %a15,28672
8000dda6:	d9 ff a8 24 	lea %a15,[%a15]18600 <700048a8 <Cdisptab>>
8000ddaa:	c8 2e       	ld.a %a14,[%a15]8
8000ddac:	48 34       	ld.w %d4,[%a15]12
8000ddae:	2d 0e 00 00 	calli %a14
8000ddb2:	0d 00 40 02 	rslcx 
8000ddb6:	00 80       	rfe 

8000ddb8 <__trap_6>:
8000ddb8:	0d 00 80 04 	dsync 
8000ddbc:	4d 00 e0 8f 	mfcr %d8,$pcxi
8000ddc0:	ef 78 04 00 	jz.t %d8,23,8000ddc8 <__trap_6+0x10>
8000ddc4:	0d 00 00 03 	enable 
8000ddc8:	0d 00 00 02 	svlcx 
8000ddcc:	91 00 00 f7 	movh.a %a15,28672
8000ddd0:	19 f4 00 35 	ld.w %d4,[%a15]20672 <700050c0 <Tdisptab+0x18>>
8000ddd4:	60 4f       	mov.a %a15,%d4
8000ddd6:	02 f4       	mov %d4,%d15
8000ddd8:	2d 0f 00 00 	calli %a15
8000dddc:	0d 00 40 02 	rslcx 
8000dde0:	00 80       	rfe 

8000dde2 <atoi>:
8000dde2:	a0 05       	mov.a %a5,0
8000dde4:	3b a0 00 40 	mov %d4,10
8000dde8:	1d 00 9d 00 	j 8000df22 <strtol>

8000ddec <strchr>:
8000ddec:	8f f4 0f 41 	and %d4,%d4,255
8000ddf0:	0c 40       	ld.bu %d15,[%a4]0
8000ddf2:	6e 06       	jz %d15,8000ddfe <strchr+0x12>
8000ddf4:	3e 43       	jeq %d15,%d4,8000ddfa <strchr+0xe>
8000ddf6:	b0 14       	add.a %a4,1
8000ddf8:	3c fc       	j 8000ddf0 <strchr+0x4>
8000ddfa:	40 42       	mov.aa %a2,%a4
8000ddfc:	00 90       	ret 
8000ddfe:	80 4f       	mov.d %d15,%a4
8000de00:	ab 0f a0 f4 	seln %d15,%d4,%d15,0
8000de04:	60 f2       	mov.a %a2,%d15
8000de06:	00 90       	ret 

8000de08 <strlen>:
8000de08:	80 42       	mov.d %d2,%a4
8000de0a:	80 4f       	mov.d %d15,%a4
8000de0c:	60 ff       	mov.a %a15,%d15
8000de0e:	79 f3 00 00 	ld.b %d3,[%a15]0
8000de12:	76 33       	jz %d3,8000de18 <strlen+0x10>
8000de14:	c2 1f       	add %d15,1
8000de16:	3c fb       	j 8000de0c <strlen+0x4>
8000de18:	52 22       	sub %d2,%d15,%d2
8000de1a:	00 90       	ret 

8000de1c <_strtol_r>:
8000de1c:	91 00 00 f7 	movh.a %a15,28672
8000de20:	99 f7 60 11 	ld.a %a7,[%a15]5216 <70001460 <__ctype_ptr__>>
8000de24:	40 52       	mov.aa %a2,%a5
8000de26:	79 2f 00 00 	ld.b %d15,[%a2]0
8000de2a:	d9 2f 01 00 	lea %a15,[%a2]1
8000de2e:	10 73       	addsc.a %a3,%a7,%d15,0
8000de30:	39 32 01 00 	ld.bu %d2,[%a3]1
8000de34:	6f 32 04 00 	jz.t %d2,3,8000de3c <_strtol_r+0x20>
8000de38:	40 f2       	mov.aa %a2,%a15
8000de3a:	3c f6       	j 8000de26 <_strtol_r+0xa>
8000de3c:	8b df 22 22 	ne %d2,%d15,45
8000de40:	f6 27       	jnz %d2,8000de4e <_strtol_r+0x32>
8000de42:	d9 2f 02 00 	lea %a15,[%a2]2 <80000002 <BootModeHeader0+0x2>>
8000de46:	79 2f 01 00 	ld.b %d15,[%a2]1 <80000001 <BootModeHeader0+0x1>>
8000de4a:	82 12       	mov %d2,1
8000de4c:	3c 09       	j 8000de5e <_strtol_r+0x42>
8000de4e:	8b bf 22 52 	ne %d5,%d15,43
8000de52:	82 02       	mov %d2,0
8000de54:	f6 55       	jnz %d5,8000de5e <_strtol_r+0x42>
8000de56:	79 2f 01 00 	ld.b %d15,[%a2]1 <80000001 <BootModeHeader0+0x1>>
8000de5a:	d9 2f 02 00 	lea %a15,[%a2]2 <80000002 <BootModeHeader0+0x2>>
8000de5e:	8f 04 c1 51 	andn %d5,%d4,16
8000de62:	df 05 19 80 	jne %d5,0,8000de94 <_strtol_r+0x78>
8000de66:	8b 0f 23 32 	ne %d3,%d15,48
8000de6a:	8b 04 00 62 	eq %d6,%d4,0
8000de6e:	df 03 11 80 	jne %d3,0,8000de90 <_strtol_r+0x74>
8000de72:	79 f5 00 00 	ld.b %d5,[%a15]0 <70000000 <__DSPR0_START>>
8000de76:	ab 84 a0 46 	seln %d4,%d6,%d4,8
8000de7a:	8f 05 c2 51 	andn %d5,%d5,32
8000de7e:	8b 85 25 52 	ne %d5,%d5,88
8000de82:	f6 59       	jnz %d5,8000de94 <_strtol_r+0x78>
8000de84:	79 ff 01 00 	ld.b %d15,[%a15]1 <70000001 <__DSPR0_START+0x1>>
8000de88:	3b 00 01 40 	mov %d4,16
8000de8c:	b0 2f       	add.a %a15,2
8000de8e:	3c 03       	j 8000de94 <_strtol_r+0x78>
8000de90:	ab a4 a0 46 	seln %d4,%d6,%d4,10
8000de94:	7b 00 00 68 	movh %d6,32768
8000de98:	1b f6 ff 3f 	addi %d3,%d6,-1
8000de9c:	2b 36 40 62 	sel %d6,%d2,%d6,%d3
8000dea0:	4b 46 11 62 	div.u %e6,%d6,%d4
8000dea4:	82 05       	mov %d5,0
8000dea6:	82 03       	mov %d3,0
8000dea8:	02 70       	mov %d0,%d7
8000deaa:	3b 70 03 10 	mov %d1,55
8000deae:	10 72       	addsc.a %a2,%a7,%d15,0
8000deb0:	39 27 01 00 	ld.bu %d7,[%a2]1
8000deb4:	6f 27 05 00 	jz.t %d7,2,8000debe <_strtol_r+0xa2>
8000deb8:	1b 0f fd ff 	addi %d15,%d15,-48
8000debc:	3c 0a       	j 8000ded0 <_strtol_r+0xb4>
8000debe:	8f 37 00 71 	and %d7,%d7,3
8000dec2:	df 07 1b 00 	jeq %d7,0,8000def8 <_strtol_r+0xdc>
8000dec6:	8b 17 00 72 	eq %d7,%d7,1
8000deca:	ab 71 85 77 	sel %d7,%d7,%d1,87
8000dece:	a2 7f       	sub %d15,%d7
8000ded0:	7f 4f 14 00 	jge %d15,%d4,8000def8 <_strtol_r+0xdc>
8000ded4:	0b 36 30 71 	lt.u %d7,%d6,%d3
8000ded8:	8b 05 20 75 	or.lt %d7,%d5,0
8000dedc:	82 f5       	mov %d5,-1
8000dede:	f6 79       	jnz %d7,8000def0 <_strtol_r+0xd4>
8000dee0:	0b 63 00 71 	eq %d7,%d3,%d6
8000dee4:	0b f0 20 72 	and.lt %d7,%d0,%d15
8000dee8:	f6 74       	jnz %d7,8000def0 <_strtol_r+0xd4>
8000deea:	03 43 0a 3f 	madd %d3,%d15,%d3,%d4
8000deee:	82 15       	mov %d5,1
8000def0:	79 ff 00 00 	ld.b %d15,[%a15]0
8000def4:	b0 1f       	add.a %a15,1
8000def6:	3c dc       	j 8000deae <_strtol_r+0x92>
8000def8:	df f5 0b 80 	jne %d5,-1,8000df0e <_strtol_r+0xf2>
8000defc:	7b 00 00 38 	movh %d3,32768
8000df00:	9a f3       	add %d15,%d3,-1
8000df02:	2b f3 40 22 	sel %d2,%d2,%d3,%d15
8000df06:	da 22       	mov %d15,34
8000df08:	6c 40       	st.w [%a4]0,%d15
8000df0a:	7c 68       	jnz.a %a6,8000df1a <_strtol_r+0xfe>
8000df0c:	00 90       	ret 
8000df0e:	8b 03 00 f1 	rsub %d15,%d3,0
8000df12:	2b 3f 40 22 	sel %d2,%d2,%d15,%d3
8000df16:	bc 65       	jz.a %a6,8000df20 <_strtol_r+0x104>
8000df18:	76 53       	jz %d5,8000df1e <_strtol_r+0x102>
8000df1a:	d9 f5 ff ff 	lea %a5,[%a15]-1
8000df1e:	f4 65       	st.a [%a6],%a5
8000df20:	00 90       	ret 

8000df22 <strtol>:
8000df22:	91 00 00 27 	movh.a %a2,28672
8000df26:	40 4f       	mov.aa %a15,%a4
8000df28:	99 24 68 11 	ld.a %a4,[%a2]5224 <70001468 <_impure_ptr>>
8000df2c:	40 56       	mov.aa %a6,%a5
8000df2e:	40 f5       	mov.aa %a5,%a15
8000df30:	1d ff 76 ff 	j 8000de1c <_strtol_r>

8000df34 <_vsprintf_r>:
8000df34:	20 68       	sub.a %sp,104
8000df36:	3b 80 20 f0 	mov %d15,520
8000df3a:	ac a6       	st.h [%sp]12,%d15
8000df3c:	82 ff       	mov %d15,-1
8000df3e:	06 ff       	sh %d15,-1
8000df40:	f4 a5       	st.a [%sp],%a5
8000df42:	b5 a5 10 00 	st.a [%sp]16,%a5
8000df46:	78 02       	st.w [%sp]8,%d15
8000df48:	78 05       	st.w [%sp]20,%d15
8000df4a:	40 a5       	mov.aa %a5,%sp
8000df4c:	82 ff       	mov %d15,-1
8000df4e:	ac a7       	st.h [%sp]14,%d15
8000df50:	6d 00 12 00 	call 8000df74 <_svfprintf_r>
8000df54:	d8 00       	ld.a %a15,[%sp]0
8000df56:	82 0f       	mov %d15,0
8000df58:	28 0f       	st.b [%a15]0,%d15
8000df5a:	00 90       	ret 

8000df5c <vsprintf>:
8000df5c:	91 00 00 37 	movh.a %a3,28672
8000df60:	40 42       	mov.aa %a2,%a4
8000df62:	99 34 68 11 	ld.a %a4,[%a3]5224 <70001468 <_impure_ptr>>
8000df66:	40 5f       	mov.aa %a15,%a5
8000df68:	40 67       	mov.aa %a7,%a6
8000df6a:	40 25       	mov.aa %a5,%a2
8000df6c:	40 f6       	mov.aa %a6,%a15
8000df6e:	1d ff e3 ff 	j 8000df34 <_vsprintf_r>
	...

8000df74 <_svfprintf_r>:
8000df74:	20 d0       	sub.a %sp,208
8000df76:	80 5b       	mov.d %d11,%a5
8000df78:	80 4c       	mov.d %d12,%a4
8000df7a:	b5 a6 18 00 	st.a [%sp]24,%a6
8000df7e:	40 7f       	mov.aa %a15,%a7
8000df80:	6d 00 c4 0f 	call 8000ff08 <_localeconv_r>
8000df84:	d4 22       	ld.a %a2,[%a2]
8000df86:	40 24       	mov.aa %a4,%a2
8000df88:	b5 a2 34 00 	st.a [%sp]52,%a2
8000df8c:	6d ff 3e ff 	call 8000de08 <strlen>
8000df90:	60 b2       	mov.a %a2,%d11
8000df92:	59 a2 20 00 	st.w [%sp]32,%d2
8000df96:	8c 26       	ld.h %d15,[%a2]12
8000df98:	6f 7f 16 00 	jz.t %d15,7,8000dfc4 <_svfprintf_r+0x50>
8000df9c:	4c 24       	ld.w %d15,[%a2]16
8000df9e:	ee 13       	jnz %d15,8000dfc4 <_svfprintf_r+0x50>
8000dfa0:	60 c4       	mov.a %a4,%d12
8000dfa2:	3b 00 04 40 	mov %d4,64
8000dfa6:	6d 00 b6 0f 	call 8000ff12 <_malloc_r>
8000dfaa:	60 b3       	mov.a %a3,%d11
8000dfac:	f4 32       	st.a [%a3],%a2
8000dfae:	b5 32 10 00 	st.a [%a3]16,%a2
8000dfb2:	7c 26       	jnz.a %a2,8000dfbe <_svfprintf_r+0x4a>
8000dfb4:	60 cf       	mov.a %a15,%d12
8000dfb6:	da 0c       	mov %d15,12
8000dfb8:	68 0f       	st.w [%a15]0,%d15
8000dfba:	82 f2       	mov %d2,-1
8000dfbc:	00 90       	ret 
8000dfbe:	60 b2       	mov.a %a2,%d11
8000dfc0:	da 40       	mov %d15,64
8000dfc2:	6c 25       	st.w [%a2]20,%d15
8000dfc4:	82 0f       	mov %d15,0
8000dfc6:	d9 a2 10 20 	lea %a2,[%sp]144
8000dfca:	a0 03       	mov.a %a3,0
8000dfcc:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000dfd0:	78 19       	st.w [%sp]100,%d15
8000dfd2:	78 18       	st.w [%sp]96,%d15
8000dfd4:	78 05       	st.w [%sp]20,%d15
8000dfd6:	78 0b       	st.w [%sp]44,%d15
8000dfd8:	78 0c       	st.w [%sp]48,%d15
8000dfda:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000dfde:	78 0e       	st.w [%sp]56,%d15
8000dfe0:	78 0a       	st.w [%sp]40,%d15
8000dfe2:	40 2e       	mov.aa %a14,%a2
8000dfe4:	99 ac 18 00 	ld.a %a12,[%sp]24
8000dfe8:	79 cf 00 00 	ld.b %d15,[%a12]0
8000dfec:	8b 0f 20 32 	ne %d3,%d15,0
8000dff0:	8b 5f 22 34 	and.ne %d3,%d15,37
8000dff4:	76 33       	jz %d3,8000dffa <_svfprintf_r+0x86>
8000dff6:	b0 1c       	add.a %a12,1
8000dff8:	3c f8       	j 8000dfe8 <_svfprintf_r+0x74>
8000dffa:	99 a3 18 00 	ld.a %a3,[%sp]24
8000dffe:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000e002:	80 3f       	mov.d %d15,%a3
8000e004:	6e 23       	jz %d15,8000e04a <_svfprintf_r+0xd6>
8000e006:	19 a3 24 10 	ld.w %d3,[%sp]100
8000e00a:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e00e:	42 f3       	add %d3,%d15
8000e010:	59 a3 24 10 	st.w [%sp]100,%d3
8000e014:	19 a3 20 10 	ld.w %d3,[%sp]96
8000e018:	f4 e3       	st.a [%a14],%a3
8000e01a:	c2 13       	add %d3,1
8000e01c:	6c e1       	st.w [%a14]4,%d15
8000e01e:	59 a3 20 10 	st.w [%sp]96,%d3
8000e022:	8b 83 80 32 	ge %d3,%d3,8
8000e026:	d9 ee 08 00 	lea %a14,[%a14]8
8000e02a:	76 3b       	jz %d3,8000e040 <_svfprintf_r+0xcc>
8000e02c:	60 c4       	mov.a %a4,%d12
8000e02e:	60 b5       	mov.a %a5,%d11
8000e030:	d9 a6 1c 10 	lea %a6,[%sp]92
8000e034:	6d 00 db 14 	call 800109ea <__ssprint_r>
8000e038:	df 02 69 88 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000e03c:	d9 ae 10 20 	lea %a14,[%sp]144
8000e040:	19 a2 28 00 	ld.w %d2,[%sp]40
8000e044:	42 f2       	add %d2,%d15
8000e046:	59 a2 28 00 	st.w [%sp]40,%d2
8000e04a:	79 cf 00 00 	ld.b %d15,[%a12]0
8000e04e:	df 0f 56 08 	jeq %d15,0,8000f0fa <_svfprintf_r+0x1186>
8000e052:	82 0f       	mov %d15,0
8000e054:	82 02       	mov %d2,0
8000e056:	e9 af 01 10 	st.b [%sp]65,%d15
8000e05a:	d9 c2 01 00 	lea %a2,[%a12]1
8000e05e:	82 0f       	mov %d15,0
8000e060:	82 fe       	mov %d14,-1
8000e062:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e066:	82 0a       	mov %d10,0
8000e068:	79 22 00 00 	ld.b %d2,[%a2]0
8000e06c:	d9 23 01 00 	lea %a3,[%a2]1
8000e070:	b5 a3 18 00 	st.a [%sp]24,%a3
8000e074:	59 a2 10 00 	st.w [%sp]16,%d2
8000e078:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e07c:	1b 02 fe 3f 	addi %d3,%d2,-32
8000e080:	8b 93 a5 42 	ge.u %d4,%d3,89
8000e084:	df 04 19 84 	jne %d4,0,8000e8b6 <_svfprintf_r+0x942>
8000e088:	91 10 00 28 	movh.a %a2,32769
8000e08c:	d9 22 18 2e 	lea %a2,[%a2]-8040 <8000e098 <_svfprintf_r+0x124>>
8000e090:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000e094:	dc 07       	ji %a7
8000e096:	00 00       	nop 
8000e098:	1d 00 c3 00 	j 8000e21e <_svfprintf_r+0x2aa>
8000e09c:	1d 00 0d 04 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0a0:	1d 00 0b 04 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0a4:	1d 00 c0 00 	j 8000e224 <_svfprintf_r+0x2b0>
8000e0a8:	1d 00 07 04 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0ac:	1d 00 05 04 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0b0:	1d 00 03 04 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0b4:	1d 00 01 04 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0b8:	1d 00 ff 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0bc:	1d 00 fd 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0c0:	1d 00 b5 00 	j 8000e22a <_svfprintf_r+0x2b6>
8000e0c4:	1d 00 9c 00 	j 8000e1fc <_svfprintf_r+0x288>
8000e0c8:	1d 00 f7 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0cc:	1d 00 b8 00 	j 8000e23c <_svfprintf_r+0x2c8>
8000e0d0:	1d 00 b9 00 	j 8000e242 <_svfprintf_r+0x2ce>
8000e0d4:	1d 00 f1 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e0d8:	1d 00 de 00 	j 8000e294 <_svfprintf_r+0x320>
8000e0dc:	1d 00 df 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0e0:	1d 00 dd 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0e4:	1d 00 db 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0e8:	1d 00 d9 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0ec:	1d 00 d7 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0f0:	1d 00 d5 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0f4:	1d 00 d3 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0f8:	1d 00 d1 00 	j 8000e29a <_svfprintf_r+0x326>
8000e0fc:	1d 00 cf 00 	j 8000e29a <_svfprintf_r+0x326>
8000e100:	1d 00 db 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e104:	1d 00 d9 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e108:	1d 00 d7 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e10c:	1d 00 d5 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e110:	1d 00 d3 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e114:	1d 00 d1 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e118:	1d 00 cf 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e11c:	1d 00 cd 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e120:	1d 00 cb 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e124:	1d 00 c9 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e128:	1d 00 f9 00 	j 8000e31a <_svfprintf_r+0x3a6>
8000e12c:	1d 00 21 01 	j 8000e36e <_svfprintf_r+0x3fa>
8000e130:	1d 00 c3 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e134:	1d 00 1d 01 	j 8000e36e <_svfprintf_r+0x3fa>
8000e138:	1d 00 bf 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e13c:	1d 00 bd 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e140:	1d 00 bb 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e144:	1d 00 b9 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e148:	1d 00 c6 00 	j 8000e2d4 <_svfprintf_r+0x360>
8000e14c:	1d 00 b5 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e150:	1d 00 b3 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e154:	1d 00 92 02 	j 8000e678 <_svfprintf_r+0x704>
8000e158:	1d 00 af 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e15c:	1d 00 ad 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e160:	1d 00 ab 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e164:	1d 00 a9 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e168:	1d 00 a7 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e16c:	1d 00 d0 02 	j 8000e70c <_svfprintf_r+0x798>
8000e170:	1d 00 a3 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e174:	1d 00 a1 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e178:	1d 00 4b 00 	j 8000e20e <_svfprintf_r+0x29a>
8000e17c:	1d 00 9d 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e180:	1d 00 9b 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e184:	1d 00 99 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e188:	1d 00 97 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e18c:	1d 00 95 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e190:	1d 00 93 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e194:	1d 00 91 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e198:	1d 00 8f 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e19c:	1d 00 8d 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1a0:	1d 00 8b 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1a4:	1d 00 b0 00 	j 8000e304 <_svfprintf_r+0x390>
8000e1a8:	1d 00 2f 00 	j 8000e206 <_svfprintf_r+0x292>
8000e1ac:	1d 00 e1 00 	j 8000e36e <_svfprintf_r+0x3fa>
8000e1b0:	1d 00 df 00 	j 8000e36e <_svfprintf_r+0x3fa>
8000e1b4:	1d 00 dd 00 	j 8000e36e <_svfprintf_r+0x3fa>
8000e1b8:	1d 00 91 00 	j 8000e2da <_svfprintf_r+0x366>
8000e1bc:	1d 00 25 00 	j 8000e206 <_svfprintf_r+0x292>
8000e1c0:	1d 00 7b 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1c4:	1d 00 79 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1c8:	1d 00 8c 00 	j 8000e2e0 <_svfprintf_r+0x36c>
8000e1cc:	1d 00 75 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1d0:	1d 00 39 02 	j 8000e642 <_svfprintf_r+0x6ce>
8000e1d4:	1d 00 54 02 	j 8000e67c <_svfprintf_r+0x708>
8000e1d8:	1d 00 66 02 	j 8000e6a4 <_svfprintf_r+0x730>
8000e1dc:	1d 00 90 00 	j 8000e2fc <_svfprintf_r+0x388>
8000e1e0:	1d 00 6b 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1e4:	1d 00 77 02 	j 8000e6d2 <_svfprintf_r+0x75e>
8000e1e8:	1d 00 67 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1ec:	1d 00 92 02 	j 8000e710 <_svfprintf_r+0x79c>
8000e1f0:	1d 00 63 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1f4:	1d 00 61 03 	j 8000e8b6 <_svfprintf_r+0x942>
8000e1f8:	1d 00 a0 02 	j 8000e738 <_svfprintf_r+0x7c4>
8000e1fc:	da 2b       	mov %d15,43
8000e1fe:	99 a2 18 00 	ld.a %a2,[%sp]24
8000e202:	1d ff 33 ff 	j 8000e068 <_svfprintf_r+0xf4>
8000e206:	e9 af 01 10 	st.b [%sp]65,%d15
8000e20a:	1d 00 8c 00 	j 8000e322 <_svfprintf_r+0x3ae>
8000e20e:	e9 af 01 10 	st.b [%sp]65,%d15
8000e212:	7b 00 00 f8 	movh %d15,32768
8000e216:	1b 0f c1 f0 	addi %d15,%d15,3088
8000e21a:	1d 00 95 02 	j 8000e744 <_svfprintf_r+0x7d0>
8000e21e:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000e222:	3c ee       	j 8000e1fe <_svfprintf_r+0x28a>
8000e224:	8f 1a 40 a1 	or %d10,%d10,1
8000e228:	3c eb       	j 8000e1fe <_svfprintf_r+0x28a>
8000e22a:	48 02       	ld.w %d2,[%a15]0
8000e22c:	b0 4f       	add.a %a15,4
8000e22e:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e232:	ff 02 e6 7f 	jge %d2,0,8000e1fe <_svfprintf_r+0x28a>
8000e236:	32 52       	rsub %d2
8000e238:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e23c:	8f 4a 40 a1 	or %d10,%d10,4
8000e240:	3c df       	j 8000e1fe <_svfprintf_r+0x28a>
8000e242:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e246:	99 a2 18 00 	ld.a %a2,[%sp]24
8000e24a:	79 32 00 00 	ld.b %d2,[%a3]0
8000e24e:	b0 12       	add.a %a2,1
8000e250:	59 a2 10 00 	st.w [%sp]16,%d2
8000e254:	8b a2 02 32 	eq %d3,%d2,42
8000e258:	f6 33       	jnz %d3,8000e25e <_svfprintf_r+0x2ea>
8000e25a:	82 05       	mov %d5,0
8000e25c:	3c 08       	j 8000e26c <_svfprintf_r+0x2f8>
8000e25e:	48 0e       	ld.w %d14,[%a15]0
8000e260:	b5 a2 18 00 	st.a [%sp]24,%a2
8000e264:	b0 4f       	add.a %a15,4
8000e266:	8b fe 5f e3 	max %d14,%d14,-1
8000e26a:	3c ca       	j 8000e1fe <_svfprintf_r+0x28a>
8000e26c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e270:	1b 02 fd 3f 	addi %d3,%d2,-48
8000e274:	ff a3 0a 80 	jge.u %d3,10,8000e288 <_svfprintf_r+0x314>
8000e278:	79 22 00 00 	ld.b %d2,[%a2]0
8000e27c:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000e280:	59 a2 10 00 	st.w [%sp]16,%d2
8000e284:	b0 12       	add.a %a2,1
8000e286:	3c f3       	j 8000e26c <_svfprintf_r+0x2f8>
8000e288:	8b f5 5f e3 	max %d14,%d5,-1
8000e28c:	b5 a2 18 00 	st.a [%sp]24,%a2
8000e290:	1d ff f4 fe 	j 8000e078 <_svfprintf_r+0x104>
8000e294:	8f 0a 48 a1 	or %d10,%d10,128
8000e298:	3c b3       	j 8000e1fe <_svfprintf_r+0x28a>
8000e29a:	82 02       	mov %d2,0
8000e29c:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e2a0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e2a4:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e2a8:	1b 02 fd 4f 	addi %d4,%d2,-48
8000e2ac:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000e2b0:	99 a2 18 00 	ld.a %a2,[%sp]24
8000e2b4:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000e2b8:	b0 12       	add.a %a2,1
8000e2ba:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e2be:	79 32 00 00 	ld.b %d2,[%a3]0
8000e2c2:	b5 a2 18 00 	st.a [%sp]24,%a2
8000e2c6:	59 a2 10 00 	st.w [%sp]16,%d2
8000e2ca:	1b 02 fd 4f 	addi %d4,%d2,-48
8000e2ce:	bf a4 e9 ff 	jlt.u %d4,10,8000e2a0 <_svfprintf_r+0x32c>
8000e2d2:	3c dd       	j 8000e28c <_svfprintf_r+0x318>
8000e2d4:	8f 8a 40 a1 	or %d10,%d10,8
8000e2d8:	3c 93       	j 8000e1fe <_svfprintf_r+0x28a>
8000e2da:	8f 0a 44 a1 	or %d10,%d10,64
8000e2de:	3c 90       	j 8000e1fe <_svfprintf_r+0x28a>
8000e2e0:	99 a3 18 00 	ld.a %a3,[%sp]24
8000e2e4:	79 33 00 00 	ld.b %d3,[%a3]0
8000e2e8:	8b c3 26 32 	ne %d3,%d3,108
8000e2ec:	f6 35       	jnz %d3,8000e2f6 <_svfprintf_r+0x382>
8000e2ee:	b0 13       	add.a %a3,1
8000e2f0:	b5 a3 18 00 	st.a [%sp]24,%a3
8000e2f4:	3c 04       	j 8000e2fc <_svfprintf_r+0x388>
8000e2f6:	8f 0a 41 a1 	or %d10,%d10,16
8000e2fa:	3c 82       	j 8000e1fe <_svfprintf_r+0x28a>
8000e2fc:	8f 0a 42 a1 	or %d10,%d10,32
8000e300:	1d ff 7f ff 	j 8000e1fe <_svfprintf_r+0x28a>
8000e304:	48 03       	ld.w %d3,[%a15]0
8000e306:	d9 fc 04 00 	lea %a12,[%a15]4
8000e30a:	e9 a3 28 10 	st.b [%sp]104,%d3
8000e30e:	82 03       	mov %d3,0
8000e310:	e9 a3 01 10 	st.b [%sp]65,%d3
8000e314:	60 ad       	mov.a %a13,%d10
8000e316:	1d 00 dc 02 	j 8000e8ce <_svfprintf_r+0x95a>
8000e31a:	e9 af 01 10 	st.b [%sp]65,%d15
8000e31e:	8f 0a 41 a1 	or %d10,%d10,16
8000e322:	60 ad       	mov.a %a13,%d10
8000e324:	6f 5a 07 00 	jz.t %d10,5,8000e332 <_svfprintf_r+0x3be>
8000e328:	d9 fc 08 00 	lea %a12,[%a15]8
8000e32c:	09 f8 40 09 	ld.d %e8,[%a15]
8000e330:	3c 12       	j 8000e354 <_svfprintf_r+0x3e0>
8000e332:	d9 f2 04 00 	lea %a2,[%a15]4
8000e336:	6f 4a 05 00 	jz.t %d10,4,8000e340 <_svfprintf_r+0x3cc>
8000e33a:	40 2c       	mov.aa %a12,%a2
8000e33c:	48 08       	ld.w %d8,[%a15]0
8000e33e:	3c 09       	j 8000e350 <_svfprintf_r+0x3dc>
8000e340:	48 03       	ld.w %d3,[%a15]0
8000e342:	40 2c       	mov.aa %a12,%a2
8000e344:	0b 30 00 88 	mov %e8,%d3
8000e348:	6f 6a 06 00 	jz.t %d10,6,8000e354 <_svfprintf_r+0x3e0>
8000e34c:	37 03 50 80 	extr %d8,%d3,0,16
8000e350:	0b 80 00 88 	mov %e8,%d8
8000e354:	82 13       	mov %d3,1
8000e356:	ff 09 1d 02 	jge %d9,0,8000e790 <_svfprintf_r+0x81c>
8000e35a:	32 59       	rsub %d9
8000e35c:	32 58       	rsub %d8
8000e35e:	3b d0 02 70 	mov %d7,45
8000e362:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000e366:	e9 a7 01 10 	st.b [%sp]65,%d7
8000e36a:	1d 00 13 02 	j 8000e790 <_svfprintf_r+0x81c>
8000e36e:	e9 af 01 10 	st.b [%sp]65,%d15
8000e372:	4c f0       	ld.w %d15,[%a15]0
8000e374:	d9 fc 08 00 	lea %a12,[%a15]8
8000e378:	78 0b       	st.w [%sp]44,%d15
8000e37a:	4c f1       	ld.w %d15,[%a15]4
8000e37c:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000e380:	78 0c       	st.w [%sp]48,%d15
8000e382:	19 a5 30 00 	ld.w %d5,[%sp]48
8000e386:	6d 00 02 13 	call 8001098a <__fpclassifyd>
8000e38a:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000e38e:	19 a5 30 00 	ld.w %d5,[%sp]48
8000e392:	df 12 18 80 	jne %d2,1,8000e3c2 <_svfprintf_r+0x44e>
8000e396:	d2 06       	mov %e6,0
8000e398:	6d 00 36 1b 	call 80011a04 <__ltdf2>
8000e39c:	ce 25       	jgez %d2,8000e3a6 <_svfprintf_r+0x432>
8000e39e:	3b d0 02 30 	mov %d3,45
8000e3a2:	e9 a3 01 10 	st.b [%sp]65,%d3
8000e3a6:	58 04       	ld.w %d15,[%sp]16
8000e3a8:	7b 00 00 78 	movh %d7,32768
8000e3ac:	8b 8f 84 32 	ge %d3,%d15,72
8000e3b0:	1b 47 c0 d0 	addi %d13,%d7,3076
8000e3b4:	df 03 17 80 	jne %d3,0,8000e3e2 <_svfprintf_r+0x46e>
8000e3b8:	7b 00 00 78 	movh %d7,32768
8000e3bc:	1b 07 c0 d0 	addi %d13,%d7,3072
8000e3c0:	3c 11       	j 8000e3e2 <_svfprintf_r+0x46e>
8000e3c2:	6d 00 e4 12 	call 8001098a <__fpclassifyd>
8000e3c6:	58 04       	ld.w %d15,[%sp]16
8000e3c8:	df 02 13 80 	jne %d2,0,8000e3ee <_svfprintf_r+0x47a>
8000e3cc:	7b 00 00 78 	movh %d7,32768
8000e3d0:	8b 8f 84 32 	ge %d3,%d15,72
8000e3d4:	1b c7 c0 d0 	addi %d13,%d7,3084
8000e3d8:	f6 35       	jnz %d3,8000e3e2 <_svfprintf_r+0x46e>
8000e3da:	7b 00 00 78 	movh %d7,32768
8000e3de:	1b 87 c0 d0 	addi %d13,%d7,3080
8000e3e2:	8f 0a c8 a1 	andn %d10,%d10,128
8000e3e6:	60 ad       	mov.a %a13,%d10
8000e3e8:	82 39       	mov %d9,3
8000e3ea:	1d 00 78 02 	j 8000e8da <_svfprintf_r+0x966>
8000e3ee:	8f 0f c2 f1 	andn %d15,%d15,32
8000e3f2:	78 01       	st.w [%sp]4,%d15
8000e3f4:	df fe 09 00 	jeq %d14,-1,8000e406 <_svfprintf_r+0x492>
8000e3f8:	8b 0e 00 72 	eq %d7,%d14,0
8000e3fc:	8b 7f 04 74 	and.eq %d7,%d15,71
8000e400:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000e404:	3c 02       	j 8000e408 <_svfprintf_r+0x494>
8000e406:	82 6e       	mov %d14,6
8000e408:	19 a3 30 00 	ld.w %d3,[%sp]48
8000e40c:	8f 0a 50 21 	or %d2,%d10,256
8000e410:	60 2d       	mov.a %a13,%d2
8000e412:	d8 0b       	ld.a %a15,[%sp]44
8000e414:	82 0f       	mov %d15,0
8000e416:	ce 34       	jgez %d3,8000e41e <_svfprintf_r+0x4aa>
8000e418:	9b 03 00 38 	addih %d3,%d3,32768
8000e41c:	da 2d       	mov %d15,45
8000e41e:	78 09       	st.w [%sp]36,%d15
8000e420:	58 01       	ld.w %d15,[%sp]4
8000e422:	02 e9       	mov %d9,%d14
8000e424:	8b 6f 04 22 	eq %d2,%d15,70
8000e428:	82 36       	mov %d6,3
8000e42a:	f6 28       	jnz %d2,8000e43a <_svfprintf_r+0x4c6>
8000e42c:	8b 5f 24 12 	ne %d1,%d15,69
8000e430:	1b 1e 00 50 	addi %d5,%d14,1
8000e434:	82 26       	mov %d6,2
8000e436:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000e43a:	60 c4       	mov.a %a4,%d12
8000e43c:	80 f4       	mov.d %d4,%a15
8000e43e:	02 35       	mov %d5,%d3
8000e440:	02 97       	mov %d7,%d9
8000e442:	d9 a5 04 10 	lea %a5,[%sp]68
8000e446:	d9 a6 08 10 	lea %a6,[%sp]72
8000e44a:	d9 a7 14 10 	lea %a7,[%sp]84
8000e44e:	59 a2 0c 00 	st.w [%sp]12,%d2
8000e452:	59 a3 08 00 	st.w [%sp]8,%d3
8000e456:	6d 00 ef 06 	call 8000f234 <_dtoa_r>
8000e45a:	58 01       	ld.w %d15,[%sp]4
8000e45c:	80 2d       	mov.d %d13,%a2
8000e45e:	8b 7f 24 12 	ne %d1,%d15,71
8000e462:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000e466:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e46a:	df 01 11 80 	jne %d1,0,8000e48c <_svfprintf_r+0x518>
8000e46e:	6f 0a 0f 80 	jnz.t %d10,0,8000e48c <_svfprintf_r+0x518>
8000e472:	19 a2 14 10 	ld.w %d2,[%sp]84
8000e476:	58 01       	ld.w %d15,[%sp]4
8000e478:	a2 d2       	sub %d2,%d13
8000e47a:	59 a2 14 00 	st.w [%sp]20,%d2
8000e47e:	8b 7f 04 42 	eq %d4,%d15,71
8000e482:	19 a5 04 10 	ld.w %d5,[%sp]68
8000e486:	df 04 36 80 	jne %d4,0,8000e4f2 <_svfprintf_r+0x57e>
8000e48a:	3c 3e       	j 8000e506 <_svfprintf_r+0x592>
8000e48c:	0b 9d 00 80 	add %d8,%d13,%d9
8000e490:	df 02 1c 00 	jeq %d2,0,8000e4c8 <_svfprintf_r+0x554>
8000e494:	60 d2       	mov.a %a2,%d13
8000e496:	80 f4       	mov.d %d4,%a15
8000e498:	79 20 00 00 	ld.b %d0,[%a2]0
8000e49c:	d2 06       	mov %e6,0
8000e49e:	02 35       	mov %d5,%d3
8000e4a0:	8b 00 03 f2 	eq %d15,%d0,48
8000e4a4:	59 a3 08 00 	st.w [%sp]8,%d3
8000e4a8:	6d 00 4e 1a 	call 80011944 <__nedf2>
8000e4ac:	8b 02 20 22 	ne %d2,%d2,0
8000e4b0:	0f 2f 80 00 	and %d0,%d15,%d2
8000e4b4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e4b8:	76 05       	jz %d0,8000e4c2 <_svfprintf_r+0x54e>
8000e4ba:	8b 19 00 01 	rsub %d0,%d9,1
8000e4be:	59 a0 04 10 	st.w [%sp]68,%d0
8000e4c2:	19 a2 04 10 	ld.w %d2,[%sp]68
8000e4c6:	42 28       	add %d8,%d2
8000e4c8:	80 f4       	mov.d %d4,%a15
8000e4ca:	d2 06       	mov %e6,0
8000e4cc:	02 35       	mov %d5,%d3
8000e4ce:	6d 00 1b 1a 	call 80011904 <__eqdf2>
8000e4d2:	f6 23       	jnz %d2,8000e4d8 <_svfprintf_r+0x564>
8000e4d4:	59 a8 14 10 	st.w [%sp]84,%d8
8000e4d8:	3b 00 03 00 	mov %d0,48
8000e4dc:	19 a3 14 10 	ld.w %d3,[%sp]84
8000e4e0:	7f 83 c9 ff 	jge.u %d3,%d8,8000e472 <_svfprintf_r+0x4fe>
8000e4e4:	1b 13 00 10 	addi %d1,%d3,1
8000e4e8:	60 32       	mov.a %a2,%d3
8000e4ea:	59 a1 14 10 	st.w [%sp]84,%d1
8000e4ee:	34 20       	st.b [%a2],%d0
8000e4f0:	3c f6       	j 8000e4dc <_svfprintf_r+0x568>
8000e4f2:	0b 5e 20 31 	lt %d3,%d14,%d5
8000e4f6:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000e4fa:	df 03 88 00 	jeq %d3,0,8000e60a <_svfprintf_r+0x696>
8000e4fe:	58 04       	ld.w %d15,[%sp]16
8000e500:	c2 ef       	add %d15,-2
8000e502:	78 04       	st.w [%sp]16,%d15
8000e504:	3c 06       	j 8000e510 <_svfprintf_r+0x59c>
8000e506:	58 04       	ld.w %d15,[%sp]16
8000e508:	8b 6f 86 32 	ge %d3,%d15,102
8000e50c:	df 03 69 80 	jne %d3,0,8000e5de <_svfprintf_r+0x66a>
8000e510:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e514:	9a f5       	add %d15,%d5,-1
8000e516:	78 11       	st.w [%sp]68,%d15
8000e518:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000e51c:	3b b0 02 30 	mov %d3,43
8000e520:	ce f4       	jgez %d15,8000e528 <_svfprintf_r+0x5b4>
8000e522:	32 5f       	rsub %d15
8000e524:	3b d0 02 30 	mov %d3,45
8000e528:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000e52c:	8b af 40 32 	lt %d3,%d15,10
8000e530:	df 03 3e 80 	jne %d3,0,8000e5ac <_svfprintf_r+0x638>
8000e534:	82 06       	mov %d6,0
8000e536:	3b a0 00 00 	mov %d0,10
8000e53a:	4b 0f 01 42 	div %e4,%d15,%d0
8000e53e:	8b 66 00 71 	rsub %d7,%d6,6
8000e542:	60 72       	mov.a %a2,%d7
8000e544:	d9 af 14 10 	lea %a15,[%sp]84
8000e548:	1b 05 03 30 	addi %d3,%d5,48
8000e54c:	30 2f       	add.a %a15,%a2
8000e54e:	28 03       	st.b [%a15]0,%d3
8000e550:	8b a4 80 32 	ge %d3,%d4,10
8000e554:	02 4f       	mov %d15,%d4
8000e556:	c2 16       	add %d6,1
8000e558:	df 03 f1 ff 	jne %d3,0,8000e53a <_svfprintf_r+0x5c6>
8000e55c:	60 74       	mov.a %a4,%d7
8000e55e:	d9 a2 10 30 	lea %a2,[%sp]208
8000e562:	1b 04 03 f0 	addi %d15,%d4,48
8000e566:	30 42       	add.a %a2,%a4
8000e568:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000e56c:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000e570:	80 22       	mov.d %d2,%a2
8000e572:	d9 af 1b 10 	lea %a15,[%sp]91
8000e576:	80 ff       	mov.d %d15,%a15
8000e578:	1b 32 f8 4f 	addi %d4,%d2,-125
8000e57c:	82 03       	mov %d3,0
8000e57e:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000e582:	3f 4f 08 80 	jlt.u %d15,%d4,8000e592 <_svfprintf_r+0x61e>
8000e586:	80 a2       	mov.d %d2,%sp
8000e588:	1b 02 0d 20 	addi %d2,%d2,208
8000e58c:	8b 52 07 42 	eq %d4,%d2,117
8000e590:	76 46       	jz %d4,8000e59c <_svfprintf_r+0x628>
8000e592:	a0 03       	mov.a %a3,0
8000e594:	3c 04       	j 8000e59c <_svfprintf_r+0x628>
8000e596:	0c 70       	ld.bu %d15,[%a7]0
8000e598:	b0 17       	add.a %a7,1
8000e59a:	28 0f       	st.b [%a15]0,%d15
8000e59c:	60 3f       	mov.a %a15,%d3
8000e59e:	d9 a2 0d 10 	lea %a2,[%sp]77
8000e5a2:	b0 2f       	add.a %a15,2
8000e5a4:	30 2f       	add.a %a15,%a2
8000e5a6:	c2 13       	add %d3,1
8000e5a8:	fc 37       	loop %a3,8000e596 <_svfprintf_r+0x622>
8000e5aa:	3c 0b       	j 8000e5c0 <_svfprintf_r+0x64c>
8000e5ac:	3b 00 03 30 	mov %d3,48
8000e5b0:	1b 0f 03 f0 	addi %d15,%d15,48
8000e5b4:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000e5b8:	e9 af 10 10 	st.b [%sp]80,%d15
8000e5bc:	d9 af 11 10 	lea %a15,[%sp]81
8000e5c0:	d9 a7 0d 10 	lea %a7,[%sp]77
8000e5c4:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000e5c8:	80 79       	mov.d %d9,%a7
8000e5ca:	58 05       	ld.w %d15,[%sp]20
8000e5cc:	b5 a7 38 00 	st.a [%sp]56,%a7
8000e5d0:	42 f9       	add %d9,%d15
8000e5d2:	ff 2f 04 00 	jge %d15,2,8000e5da <_svfprintf_r+0x666>
8000e5d6:	6f 0a 2c 00 	jz.t %d10,0,8000e62e <_svfprintf_r+0x6ba>
8000e5da:	c2 19       	add %d9,1
8000e5dc:	3c 29       	j 8000e62e <_svfprintf_r+0x6ba>
8000e5de:	58 04       	ld.w %d15,[%sp]16
8000e5e0:	8b 6f 26 42 	ne %d4,%d15,102
8000e5e4:	df 04 15 80 	jne %d4,0,8000e60e <_svfprintf_r+0x69a>
8000e5e8:	02 59       	mov %d9,%d5
8000e5ea:	8e 59       	jlez %d5,8000e5fc <_svfprintf_r+0x688>
8000e5ec:	f6 e3       	jnz %d14,8000e5f2 <_svfprintf_r+0x67e>
8000e5ee:	6f 0a 20 00 	jz.t %d10,0,8000e62e <_svfprintf_r+0x6ba>
8000e5f2:	1b 1e 00 30 	addi %d3,%d14,1
8000e5f6:	0b 35 00 90 	add %d9,%d5,%d3
8000e5fa:	3c 1a       	j 8000e62e <_svfprintf_r+0x6ba>
8000e5fc:	f6 e4       	jnz %d14,8000e604 <_svfprintf_r+0x690>
8000e5fe:	82 19       	mov %d9,1
8000e600:	6f 0a 17 00 	jz.t %d10,0,8000e62e <_svfprintf_r+0x6ba>
8000e604:	1b 2e 00 90 	addi %d9,%d14,2
8000e608:	3c 13       	j 8000e62e <_svfprintf_r+0x6ba>
8000e60a:	da 67       	mov %d15,103
8000e60c:	78 04       	st.w [%sp]16,%d15
8000e60e:	58 05       	ld.w %d15,[%sp]20
8000e610:	8f 1a 00 a1 	and %d10,%d10,1
8000e614:	0b a5 00 90 	add %d9,%d5,%d10
8000e618:	7f f5 0b 00 	jge %d5,%d15,8000e62e <_svfprintf_r+0x6ba>
8000e61c:	8b 15 40 92 	lt %d9,%d5,1
8000e620:	8b 25 00 31 	rsub %d3,%d5,2
8000e624:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000e628:	19 a9 14 00 	ld.w %d9,[%sp]20
8000e62c:	42 39       	add %d9,%d3
8000e62e:	58 09       	ld.w %d15,[%sp]36
8000e630:	82 0e       	mov %d14,0
8000e632:	df 0f 55 01 	jeq %d15,0,8000e8dc <_svfprintf_r+0x968>
8000e636:	3b d0 02 70 	mov %d7,45
8000e63a:	e9 a7 01 10 	st.b [%sp]65,%d7
8000e63e:	1d 00 4f 01 	j 8000e8dc <_svfprintf_r+0x968>
8000e642:	e9 af 01 10 	st.b [%sp]65,%d15
8000e646:	d9 f2 04 00 	lea %a2,[%a15]4
8000e64a:	6f 5a 09 00 	jz.t %d10,5,8000e65c <_svfprintf_r+0x6e8>
8000e64e:	58 0a       	ld.w %d15,[%sp]40
8000e650:	c8 03       	ld.a %a3,[%a15]0
8000e652:	0b f0 00 48 	mov %e4,%d15
8000e656:	89 34 40 09 	st.d [%a3],%e4
8000e65a:	3c 0c       	j 8000e672 <_svfprintf_r+0x6fe>
8000e65c:	6f 4a 08 80 	jnz.t %d10,4,8000e66c <_svfprintf_r+0x6f8>
8000e660:	6f 6a 06 00 	jz.t %d10,6,8000e66c <_svfprintf_r+0x6f8>
8000e664:	c8 03       	ld.a %a3,[%a15]0
8000e666:	58 0a       	ld.w %d15,[%sp]40
8000e668:	ac 30       	st.h [%a3]0,%d15
8000e66a:	3c 04       	j 8000e672 <_svfprintf_r+0x6fe>
8000e66c:	c8 03       	ld.a %a3,[%a15]0
8000e66e:	58 0a       	ld.w %d15,[%sp]40
8000e670:	6c 30       	st.w [%a3]0,%d15
8000e672:	40 2f       	mov.aa %a15,%a2
8000e674:	1d ff b8 fc 	j 8000dfe4 <_svfprintf_r+0x70>
8000e678:	8f 0a 41 a1 	or %d10,%d10,16
8000e67c:	6f 5a 07 00 	jz.t %d10,5,8000e68a <_svfprintf_r+0x716>
8000e680:	d9 fc 08 00 	lea %a12,[%a15]8
8000e684:	09 f8 40 09 	ld.d %e8,[%a15]
8000e688:	3c 0c       	j 8000e6a0 <_svfprintf_r+0x72c>
8000e68a:	d9 fc 04 00 	lea %a12,[%a15]4
8000e68e:	6f 4a 07 80 	jnz.t %d10,4,8000e69c <_svfprintf_r+0x728>
8000e692:	6f 6a 05 00 	jz.t %d10,6,8000e69c <_svfprintf_r+0x728>
8000e696:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000e69a:	3c 02       	j 8000e69e <_svfprintf_r+0x72a>
8000e69c:	48 08       	ld.w %d8,[%a15]0
8000e69e:	82 09       	mov %d9,0
8000e6a0:	82 03       	mov %d3,0
8000e6a2:	3c 73       	j 8000e788 <_svfprintf_r+0x814>
8000e6a4:	3b 00 03 40 	mov %d4,48
8000e6a8:	7b 00 00 f8 	movh %d15,32768
8000e6ac:	1b 1f c2 f0 	addi %d15,%d15,3105
8000e6b0:	e9 a4 02 10 	st.b [%sp]66,%d4
8000e6b4:	3b 80 07 40 	mov %d4,120
8000e6b8:	78 0f       	st.w [%sp]60,%d15
8000e6ba:	02 4f       	mov %d15,%d4
8000e6bc:	d9 fc 04 00 	lea %a12,[%a15]4
8000e6c0:	48 08       	ld.w %d8,[%a15]0
8000e6c2:	82 09       	mov %d9,0
8000e6c4:	8f 2a 40 a1 	or %d10,%d10,2
8000e6c8:	e9 a4 03 10 	st.b [%sp]67,%d4
8000e6cc:	82 23       	mov %d3,2
8000e6ce:	78 04       	st.w [%sp]16,%d15
8000e6d0:	3c 5c       	j 8000e788 <_svfprintf_r+0x814>
8000e6d2:	82 07       	mov %d7,0
8000e6d4:	48 0d       	ld.w %d13,[%a15]0
8000e6d6:	e9 a7 01 10 	st.b [%sp]65,%d7
8000e6da:	02 e9       	mov %d9,%d14
8000e6dc:	60 ad       	mov.a %a13,%d10
8000e6de:	d9 fc 04 00 	lea %a12,[%a15]4
8000e6e2:	60 d4       	mov.a %a4,%d13
8000e6e4:	0e ef       	jltz %d14,8000e702 <_svfprintf_r+0x78e>
8000e6e6:	82 04       	mov %d4,0
8000e6e8:	02 e5       	mov %d5,%d14
8000e6ea:	6d 00 61 0e 	call 800103ac <memchr>
8000e6ee:	bd 02 f6 00 	jz.a %a2,8000e8da <_svfprintf_r+0x966>
8000e6f2:	60 d4       	mov.a %a4,%d13
8000e6f4:	01 42 20 30 	sub.a %a3,%a2,%a4
8000e6f8:	80 32       	mov.d %d2,%a3
8000e6fa:	0b e2 80 91 	min %d9,%d2,%d14
8000e6fe:	1d 00 ee 00 	j 8000e8da <_svfprintf_r+0x966>
8000e702:	6d ff 83 fb 	call 8000de08 <strlen>
8000e706:	02 29       	mov %d9,%d2
8000e708:	1d 00 e9 00 	j 8000e8da <_svfprintf_r+0x966>
8000e70c:	8f 0a 41 a1 	or %d10,%d10,16
8000e710:	6f 5a 07 00 	jz.t %d10,5,8000e71e <_svfprintf_r+0x7aa>
8000e714:	d9 fc 08 00 	lea %a12,[%a15]8
8000e718:	09 f8 40 09 	ld.d %e8,[%a15]
8000e71c:	3c 0c       	j 8000e734 <_svfprintf_r+0x7c0>
8000e71e:	d9 fc 04 00 	lea %a12,[%a15]4
8000e722:	6f 4a 07 80 	jnz.t %d10,4,8000e730 <_svfprintf_r+0x7bc>
8000e726:	6f 6a 05 00 	jz.t %d10,6,8000e730 <_svfprintf_r+0x7bc>
8000e72a:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000e72e:	3c 02       	j 8000e732 <_svfprintf_r+0x7be>
8000e730:	48 08       	ld.w %d8,[%a15]0
8000e732:	82 09       	mov %d9,0
8000e734:	82 13       	mov %d3,1
8000e736:	3c 29       	j 8000e788 <_svfprintf_r+0x814>
8000e738:	e9 af 01 10 	st.b [%sp]65,%d15
8000e73c:	7b 00 00 f8 	movh %d15,32768
8000e740:	1b 1f c2 f0 	addi %d15,%d15,3105
8000e744:	78 0f       	st.w [%sp]60,%d15
8000e746:	6f 5a 07 00 	jz.t %d10,5,8000e754 <_svfprintf_r+0x7e0>
8000e74a:	d9 fc 08 00 	lea %a12,[%a15]8
8000e74e:	09 f8 40 09 	ld.d %e8,[%a15]
8000e752:	3c 0c       	j 8000e76a <_svfprintf_r+0x7f6>
8000e754:	d9 fc 04 00 	lea %a12,[%a15]4
8000e758:	6f 4a 07 80 	jnz.t %d10,4,8000e766 <_svfprintf_r+0x7f2>
8000e75c:	6f 6a 05 00 	jz.t %d10,6,8000e766 <_svfprintf_r+0x7f2>
8000e760:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000e764:	3c 02       	j 8000e768 <_svfprintf_r+0x7f4>
8000e766:	48 08       	ld.w %d8,[%a15]0
8000e768:	82 09       	mov %d9,0
8000e76a:	82 23       	mov %d3,2
8000e76c:	6f 0a 0e 00 	jz.t %d10,0,8000e788 <_svfprintf_r+0x814>
8000e770:	0f 89 a0 40 	or %d4,%d9,%d8
8000e774:	76 4a       	jz %d4,8000e788 <_svfprintf_r+0x814>
8000e776:	58 04       	ld.w %d15,[%sp]16
8000e778:	3b 00 03 70 	mov %d7,48
8000e77c:	e9 a7 02 10 	st.b [%sp]66,%d7
8000e780:	e9 af 03 10 	st.b [%sp]67,%d15
8000e784:	8f 2a 40 a1 	or %d10,%d10,2
8000e788:	82 07       	mov %d7,0
8000e78a:	60 ad       	mov.a %a13,%d10
8000e78c:	e9 a7 01 10 	st.b [%sp]65,%d7
8000e790:	80 d2       	mov.d %d2,%a13
8000e792:	8b 0e 80 72 	ge %d7,%d14,0
8000e796:	8f 02 c8 41 	andn %d4,%d2,128
8000e79a:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000e79e:	0f 98 a0 60 	or %d6,%d8,%d9
8000e7a2:	8b 0e 20 42 	ne %d4,%d14,0
8000e7a6:	8b 06 00 45 	or.ne %d4,%d6,0
8000e7aa:	60 2d       	mov.a %a13,%d2
8000e7ac:	df 04 72 00 	jeq %d4,0,8000e890 <_svfprintf_r+0x91c>
8000e7b0:	df 13 06 00 	jeq %d3,1,8000e7bc <_svfprintf_r+0x848>
8000e7b4:	df 23 57 00 	jeq %d3,2,8000e862 <_svfprintf_r+0x8ee>
8000e7b8:	82 03       	mov %d3,0
8000e7ba:	3c 03       	j 8000e7c0 <_svfprintf_r+0x84c>
8000e7bc:	82 04       	mov %d4,0
8000e7be:	3c 22       	j 8000e802 <_svfprintf_r+0x88e>
8000e7c0:	8b 73 02 71 	rsub %d7,%d3,39
8000e7c4:	60 72       	mov.a %a2,%d7
8000e7c6:	8f 78 00 41 	and %d4,%d8,7
8000e7ca:	d9 a3 28 10 	lea %a3,[%sp]104
8000e7ce:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000e7d2:	30 23       	add.a %a3,%a2
8000e7d4:	1b 04 03 40 	addi %d4,%d4,48
8000e7d8:	06 d9       	sh %d9,-3
8000e7da:	34 34       	st.b [%a3],%d4
8000e7dc:	0f 89 a0 60 	or %d6,%d9,%d8
8000e7e0:	c2 13       	add %d3,1
8000e7e2:	df 06 ef ff 	jne %d6,0,8000e7c0 <_svfprintf_r+0x84c>
8000e7e6:	80 d2       	mov.d %d2,%a13
8000e7e8:	80 3d       	mov.d %d13,%a3
8000e7ea:	6f 02 61 00 	jz.t %d2,0,8000e8ac <_svfprintf_r+0x938>
8000e7ee:	8b 04 03 42 	eq %d4,%d4,48
8000e7f2:	df 04 5d 80 	jne %d4,0,8000e8ac <_svfprintf_r+0x938>
8000e7f6:	3b 00 03 70 	mov %d7,48
8000e7fa:	c2 fd       	add %d13,-1
8000e7fc:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000e800:	3c 56       	j 8000e8ac <_svfprintf_r+0x938>
8000e802:	8b 84 02 71 	rsub %d7,%d4,40
8000e806:	8b 09 00 32 	eq %d3,%d9,0
8000e80a:	60 73       	mov.a %a3,%d7
8000e80c:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000e810:	d9 a7 28 10 	lea %a7,[%sp]104
8000e814:	8b 09 00 35 	or.ne %d3,%d9,0
8000e818:	30 37       	add.a %a7,%a3
8000e81a:	1b 14 00 d0 	addi %d13,%d4,1
8000e81e:	df 03 1b 00 	jeq %d3,0,8000e854 <_svfprintf_r+0x8e0>
8000e822:	8b 74 02 41 	rsub %d4,%d4,39
8000e826:	60 42       	mov.a %a2,%d4
8000e828:	fb a0 00 60 	mov %e6,10
8000e82c:	0b 89 10 48 	mov %e4,%d9,%d8
8000e830:	d9 af 28 10 	lea %a15,[%sp]104
8000e834:	30 2f       	add.a %a15,%a2
8000e836:	6d 00 bb 19 	call 80011bac <__umoddi3>
8000e83a:	0b 89 10 48 	mov %e4,%d9,%d8
8000e83e:	1b 02 03 20 	addi %d2,%d2,48
8000e842:	fb a0 00 60 	mov %e6,10
8000e846:	28 02       	st.b [%a15]0,%d2
8000e848:	6d 00 62 19 	call 80011b0c <__udivdi3>
8000e84c:	02 d4       	mov %d4,%d13
8000e84e:	0b 23 10 88 	mov %e8,%d3,%d2
8000e852:	3c d8       	j 8000e802 <_svfprintf_r+0x88e>
8000e854:	80 7d       	mov.d %d13,%a7
8000e856:	1b 08 03 80 	addi %d8,%d8,48
8000e85a:	c2 fd       	add %d13,-1
8000e85c:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000e860:	3c 26       	j 8000e8ac <_svfprintf_r+0x938>
8000e862:	82 03       	mov %d3,0
8000e864:	d8 0f       	ld.a %a15,[%sp]60
8000e866:	80 ad       	mov.d %d13,%sp
8000e868:	8f f8 00 f1 	and %d15,%d8,15
8000e86c:	8b 73 02 71 	rsub %d7,%d3,39
8000e870:	1b 8d 06 d0 	addi %d13,%d13,104
8000e874:	10 f7       	addsc.a %a7,%a15,%d15,0
8000e876:	42 7d       	add %d13,%d7
8000e878:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000e87c:	0c 70       	ld.bu %d15,[%a7]0
8000e87e:	60 d2       	mov.a %a2,%d13
8000e880:	06 c9       	sh %d9,-4
8000e882:	2c 20       	st.b [%a2]0,%d15
8000e884:	0f 89 a0 40 	or %d4,%d9,%d8
8000e888:	c2 13       	add %d3,1
8000e88a:	df 04 ed ff 	jne %d4,0,8000e864 <_svfprintf_r+0x8f0>
8000e88e:	3c 0f       	j 8000e8ac <_svfprintf_r+0x938>
8000e890:	80 a2       	mov.d %d2,%sp
8000e892:	1b 02 09 d0 	addi %d13,%d2,144
8000e896:	f6 3b       	jnz %d3,8000e8ac <_svfprintf_r+0x938>
8000e898:	80 df       	mov.d %d15,%a13
8000e89a:	2e 09       	jz.t %d15,0,8000e8ac <_svfprintf_r+0x938>
8000e89c:	1b 02 0d d0 	addi %d13,%d2,208
8000e8a0:	60 d2       	mov.a %a2,%d13
8000e8a2:	3b 00 03 70 	mov %d7,48
8000e8a6:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000e8aa:	80 2d       	mov.d %d13,%a2
8000e8ac:	d9 a3 10 20 	lea %a3,[%sp]144
8000e8b0:	80 39       	mov.d %d9,%a3
8000e8b2:	a2 d9       	sub %d9,%d13
8000e8b4:	3c 14       	j 8000e8dc <_svfprintf_r+0x968>
8000e8b6:	e9 af 01 10 	st.b [%sp]65,%d15
8000e8ba:	58 04       	ld.w %d15,[%sp]16
8000e8bc:	df 0f 1f 04 	jeq %d15,0,8000f0fa <_svfprintf_r+0x1186>
8000e8c0:	82 03       	mov %d3,0
8000e8c2:	60 ad       	mov.a %a13,%d10
8000e8c4:	e9 af 28 10 	st.b [%sp]104,%d15
8000e8c8:	e9 a3 01 10 	st.b [%sp]65,%d3
8000e8cc:	40 fc       	mov.aa %a12,%a15
8000e8ce:	80 a2       	mov.d %d2,%sp
8000e8d0:	82 19       	mov %d9,1
8000e8d2:	82 0e       	mov %d14,0
8000e8d4:	1b 82 06 d0 	addi %d13,%d2,104
8000e8d8:	3c 02       	j 8000e8dc <_svfprintf_r+0x968>
8000e8da:	82 0e       	mov %d14,0
8000e8dc:	79 a7 01 10 	ld.b %d7,[%sp]65
8000e8e0:	80 df       	mov.d %d15,%a13
8000e8e2:	0b e9 a0 a1 	max %d10,%d9,%d14
8000e8e6:	80 d2       	mov.d %d2,%a13
8000e8e8:	16 02       	and %d15,2
8000e8ea:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000e8ee:	60 ff       	mov.a %a15,%d15
8000e8f0:	8a 2a       	cadd %d10,%d15,2
8000e8f2:	8f 42 08 f1 	and %d15,%d2,132
8000e8f6:	ee 48       	jnz %d15,8000e986 <_svfprintf_r+0xa12>
8000e8f8:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000e8fc:	a2 a8       	sub %d8,%d10
8000e8fe:	bf 18 44 00 	jlt %d8,1,8000e986 <_svfprintf_r+0xa12>
8000e902:	91 00 00 28 	movh.a %a2,32768
8000e906:	d9 22 c4 10 	lea %a2,[%a2]3140 <80000c44 <blanks.4035>>
8000e90a:	19 a1 24 10 	ld.w %d1,[%sp]100 <80000c44 <blanks.4035>>
8000e90e:	19 a4 20 10 	ld.w %d4,[%sp]96 <80000c44 <blanks.4035>>
8000e912:	8b 18 81 72 	ge %d7,%d8,17
8000e916:	f4 e2       	st.a [%a14],%a2
8000e918:	df 07 20 00 	jeq %d7,0,8000e958 <_svfprintf_r+0x9e4>
8000e91c:	1b 14 00 00 	addi %d0,%d4,1
8000e920:	3b 00 01 20 	mov %d2,16
8000e924:	1b 01 01 10 	addi %d1,%d1,16
8000e928:	59 e2 04 00 	st.w [%a14]4,%d2
8000e92c:	59 a0 20 10 	st.w [%sp]96,%d0
8000e930:	59 a1 24 10 	st.w [%sp]100,%d1
8000e934:	8b 80 80 02 	ge %d0,%d0,8
8000e938:	d9 ee 08 00 	lea %a14,[%a14]8
8000e93c:	76 0b       	jz %d0,8000e952 <_svfprintf_r+0x9de>
8000e93e:	60 c4       	mov.a %a4,%d12
8000e940:	60 b5       	mov.a %a5,%d11
8000e942:	d9 a6 1c 10 	lea %a6,[%sp]92
8000e946:	6d 00 52 10 	call 800109ea <__ssprint_r>
8000e94a:	df 02 e0 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000e94e:	d9 ae 10 20 	lea %a14,[%sp]144
8000e952:	1b 08 ff 8f 	addi %d8,%d8,-16
8000e956:	3c d6       	j 8000e902 <_svfprintf_r+0x98e>
8000e958:	c2 14       	add %d4,1
8000e95a:	42 81       	add %d1,%d8
8000e95c:	59 e8 04 00 	st.w [%a14]4,%d8
8000e960:	59 a4 20 10 	st.w [%sp]96,%d4
8000e964:	59 a1 24 10 	st.w [%sp]100,%d1
8000e968:	8b 84 80 42 	ge %d4,%d4,8
8000e96c:	d9 ee 08 00 	lea %a14,[%a14]8
8000e970:	76 4b       	jz %d4,8000e986 <_svfprintf_r+0xa12>
8000e972:	60 c4       	mov.a %a4,%d12
8000e974:	60 b5       	mov.a %a5,%d11
8000e976:	d9 a6 1c 10 	lea %a6,[%sp]92
8000e97a:	6d 00 38 10 	call 800109ea <__ssprint_r>
8000e97e:	df 02 c6 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000e982:	d9 ae 10 20 	lea %a14,[%sp]144
8000e986:	79 a4 01 10 	ld.b %d4,[%sp]65
8000e98a:	df 04 21 00 	jeq %d4,0,8000e9cc <_svfprintf_r+0xa58>
8000e98e:	19 a4 24 10 	ld.w %d4,[%sp]100
8000e992:	d9 a7 01 10 	lea %a7,[%sp]65
8000e996:	c2 14       	add %d4,1
8000e998:	59 a4 24 10 	st.w [%sp]100,%d4
8000e99c:	19 a4 20 10 	ld.w %d4,[%sp]96
8000e9a0:	82 17       	mov %d7,1
8000e9a2:	c2 14       	add %d4,1
8000e9a4:	f4 e7       	st.a [%a14],%a7
8000e9a6:	59 e7 04 00 	st.w [%a14]4,%d7
8000e9aa:	59 a4 20 10 	st.w [%sp]96,%d4
8000e9ae:	8b 84 80 42 	ge %d4,%d4,8
8000e9b2:	d9 ee 08 00 	lea %a14,[%a14]8
8000e9b6:	76 4b       	jz %d4,8000e9cc <_svfprintf_r+0xa58>
8000e9b8:	60 c4       	mov.a %a4,%d12
8000e9ba:	60 b5       	mov.a %a5,%d11
8000e9bc:	d9 a6 1c 10 	lea %a6,[%sp]92
8000e9c0:	6d 00 15 10 	call 800109ea <__ssprint_r>
8000e9c4:	df 02 a3 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000e9c8:	d9 ae 10 20 	lea %a14,[%sp]144
8000e9cc:	bd 0f 21 00 	jz.a %a15,8000ea0e <_svfprintf_r+0xa9a>
8000e9d0:	19 a4 24 10 	ld.w %d4,[%sp]100
8000e9d4:	d9 a7 02 10 	lea %a7,[%sp]66
8000e9d8:	c2 24       	add %d4,2
8000e9da:	59 a4 24 10 	st.w [%sp]100,%d4
8000e9de:	19 a4 20 10 	ld.w %d4,[%sp]96
8000e9e2:	82 27       	mov %d7,2
8000e9e4:	c2 14       	add %d4,1
8000e9e6:	f4 e7       	st.a [%a14],%a7
8000e9e8:	59 e7 04 00 	st.w [%a14]4,%d7
8000e9ec:	59 a4 20 10 	st.w [%sp]96,%d4
8000e9f0:	8b 84 80 42 	ge %d4,%d4,8
8000e9f4:	d9 ee 08 00 	lea %a14,[%a14]8
8000e9f8:	76 4b       	jz %d4,8000ea0e <_svfprintf_r+0xa9a>
8000e9fa:	60 c4       	mov.a %a4,%d12
8000e9fc:	60 b5       	mov.a %a5,%d11
8000e9fe:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ea02:	6d 00 f4 0f 	call 800109ea <__ssprint_r>
8000ea06:	df 02 82 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ea0a:	d9 ae 10 20 	lea %a14,[%sp]144
8000ea0e:	8b 0f 28 42 	ne %d4,%d15,128
8000ea12:	df 04 48 80 	jne %d4,0,8000eaa2 <_svfprintf_r+0xb2e>
8000ea16:	58 07       	ld.w %d15,[%sp]28
8000ea18:	7b 00 00 28 	movh %d2,32768
8000ea1c:	60 23       	mov.a %a3,%d2
8000ea1e:	a2 af       	sub %d15,%d10
8000ea20:	d9 3f f4 00 	lea %a15,[%a3]3124
8000ea24:	bf 1f 3f 00 	jlt %d15,1,8000eaa2 <_svfprintf_r+0xb2e>
8000ea28:	19 a7 24 10 	ld.w %d7,[%sp]100
8000ea2c:	19 a4 20 10 	ld.w %d4,[%sp]96
8000ea30:	8b 1f 81 82 	ge %d8,%d15,17
8000ea34:	ec e0       	st.a [%a14]0,%a15
8000ea36:	df 08 20 00 	jeq %d8,0,8000ea76 <_svfprintf_r+0xb02>
8000ea3a:	1b 14 00 00 	addi %d0,%d4,1
8000ea3e:	3b 00 01 20 	mov %d2,16
8000ea42:	1b 07 01 10 	addi %d1,%d7,16
8000ea46:	59 e2 04 00 	st.w [%a14]4,%d2
8000ea4a:	59 a0 20 10 	st.w [%sp]96,%d0
8000ea4e:	59 a1 24 10 	st.w [%sp]100,%d1
8000ea52:	8b 80 80 02 	ge %d0,%d0,8
8000ea56:	d9 ee 08 00 	lea %a14,[%a14]8
8000ea5a:	76 0b       	jz %d0,8000ea70 <_svfprintf_r+0xafc>
8000ea5c:	60 c4       	mov.a %a4,%d12
8000ea5e:	60 b5       	mov.a %a5,%d11
8000ea60:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ea64:	6d 00 c3 0f 	call 800109ea <__ssprint_r>
8000ea68:	df 02 51 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ea6c:	d9 ae 10 20 	lea %a14,[%sp]144
8000ea70:	1b 0f ff ff 	addi %d15,%d15,-16
8000ea74:	3c da       	j 8000ea28 <_svfprintf_r+0xab4>
8000ea76:	c2 14       	add %d4,1
8000ea78:	42 f7       	add %d7,%d15
8000ea7a:	6c e1       	st.w [%a14]4,%d15
8000ea7c:	59 a4 20 10 	st.w [%sp]96,%d4
8000ea80:	59 a7 24 10 	st.w [%sp]100,%d7
8000ea84:	8b 84 80 42 	ge %d4,%d4,8
8000ea88:	d9 ee 08 00 	lea %a14,[%a14]8
8000ea8c:	76 4b       	jz %d4,8000eaa2 <_svfprintf_r+0xb2e>
8000ea8e:	60 c4       	mov.a %a4,%d12
8000ea90:	60 b5       	mov.a %a5,%d11
8000ea92:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ea96:	6d 00 aa 0f 	call 800109ea <__ssprint_r>
8000ea9a:	df 02 38 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ea9e:	d9 ae 10 20 	lea %a14,[%sp]144
8000eaa2:	7b 00 00 88 	movh %d8,32768
8000eaa6:	a2 9e       	sub %d14,%d9
8000eaa8:	1b 48 c3 80 	addi %d8,%d8,3124
8000eaac:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000eab0:	bf 1e 3c 00 	jlt %d14,1,8000eb28 <_svfprintf_r+0xbb4>
8000eab4:	19 a6 24 10 	ld.w %d6,[%sp]100
8000eab8:	19 a4 20 10 	ld.w %d4,[%sp]96
8000eabc:	8b 1e 81 02 	ge %d0,%d14,17
8000eac0:	74 e8       	st.w [%a14],%d8
8000eac2:	df 00 1c 00 	jeq %d0,0,8000eafa <_svfprintf_r+0xb86>
8000eac6:	c2 14       	add %d4,1
8000eac8:	1b 06 01 00 	addi %d0,%d6,16
8000eacc:	ec e1       	st.a [%a14]4,%a15
8000eace:	59 a4 20 10 	st.w [%sp]96,%d4
8000ead2:	59 a0 24 10 	st.w [%sp]100,%d0
8000ead6:	8b 84 80 42 	ge %d4,%d4,8
8000eada:	d9 ee 08 00 	lea %a14,[%a14]8
8000eade:	76 4b       	jz %d4,8000eaf4 <_svfprintf_r+0xb80>
8000eae0:	60 c4       	mov.a %a4,%d12
8000eae2:	60 b5       	mov.a %a5,%d11
8000eae4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000eae8:	6d 00 81 0f 	call 800109ea <__ssprint_r>
8000eaec:	df 02 0f 83 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000eaf0:	d9 ae 10 20 	lea %a14,[%sp]144
8000eaf4:	1b 0e ff ef 	addi %d14,%d14,-16
8000eaf8:	3c de       	j 8000eab4 <_svfprintf_r+0xb40>
8000eafa:	c2 14       	add %d4,1
8000eafc:	42 e6       	add %d6,%d14
8000eafe:	59 ee 04 00 	st.w [%a14]4,%d14
8000eb02:	59 a4 20 10 	st.w [%sp]96,%d4
8000eb06:	59 a6 24 10 	st.w [%sp]100,%d6
8000eb0a:	8b 84 80 42 	ge %d4,%d4,8
8000eb0e:	d9 ee 08 00 	lea %a14,[%a14]8
8000eb12:	76 4b       	jz %d4,8000eb28 <_svfprintf_r+0xbb4>
8000eb14:	60 c4       	mov.a %a4,%d12
8000eb16:	60 b5       	mov.a %a5,%d11
8000eb18:	d9 a6 1c 10 	lea %a6,[%sp]92
8000eb1c:	6d 00 67 0f 	call 800109ea <__ssprint_r>
8000eb20:	df 02 f5 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000eb24:	d9 ae 10 20 	lea %a14,[%sp]144
8000eb28:	80 df       	mov.d %d15,%a13
8000eb2a:	19 ae 24 10 	ld.w %d14,[%sp]100
8000eb2e:	19 a8 20 10 	ld.w %d8,[%sp]96
8000eb32:	6f 8f 1d 80 	jnz.t %d15,8,8000eb6c <_svfprintf_r+0xbf8>
8000eb36:	c2 18       	add %d8,1
8000eb38:	59 e9 04 00 	st.w [%a14]4,%d9
8000eb3c:	42 e9       	add %d9,%d14
8000eb3e:	59 a8 20 10 	st.w [%sp]96,%d8
8000eb42:	74 ed       	st.w [%a14],%d13
8000eb44:	59 a9 24 10 	st.w [%sp]100,%d9
8000eb48:	8b 88 80 82 	ge %d8,%d8,8
8000eb4c:	d9 ef 08 00 	lea %a15,[%a14]8
8000eb50:	df 08 79 02 	jeq %d8,0,8000f042 <_svfprintf_r+0x10ce>
8000eb54:	60 c4       	mov.a %a4,%d12
8000eb56:	60 b5       	mov.a %a5,%d11
8000eb58:	d9 a6 1c 10 	lea %a6,[%sp]92
8000eb5c:	6d 00 47 0f 	call 800109ea <__ssprint_r>
8000eb60:	df 02 d5 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000eb64:	d9 af 10 20 	lea %a15,[%sp]144
8000eb68:	1d 00 6d 02 	j 8000f042 <_svfprintf_r+0x10ce>
8000eb6c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000eb70:	8b 62 46 f2 	lt %d15,%d2,102
8000eb74:	df 0f be 81 	jne %d15,0,8000eef0 <_svfprintf_r+0xf7c>
8000eb78:	d2 06       	mov %e6,0
8000eb7a:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000eb7e:	19 a5 30 00 	ld.w %d5,[%sp]48
8000eb82:	6d 00 c1 16 	call 80011904 <__eqdf2>
8000eb86:	df 02 78 80 	jne %d2,0,8000ec76 <_svfprintf_r+0xd02>
8000eb8a:	7b 00 00 38 	movh %d3,32768
8000eb8e:	1b 23 c3 30 	addi %d3,%d3,3122
8000eb92:	c2 18       	add %d8,1
8000eb94:	74 e3       	st.w [%a14],%d3
8000eb96:	1b 1e 00 90 	addi %d9,%d14,1
8000eb9a:	82 13       	mov %d3,1
8000eb9c:	59 a8 20 10 	st.w [%sp]96,%d8
8000eba0:	59 e3 04 00 	st.w [%a14]4,%d3
8000eba4:	59 a9 24 10 	st.w [%sp]100,%d9
8000eba8:	8b 88 80 82 	ge %d8,%d8,8
8000ebac:	d9 ef 08 00 	lea %a15,[%a14]8
8000ebb0:	76 8b       	jz %d8,8000ebc6 <_svfprintf_r+0xc52>
8000ebb2:	60 c4       	mov.a %a4,%d12
8000ebb4:	60 b5       	mov.a %a5,%d11
8000ebb6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ebba:	6d 00 18 0f 	call 800109ea <__ssprint_r>
8000ebbe:	df 02 a6 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ebc2:	d9 af 10 20 	lea %a15,[%sp]144
8000ebc6:	58 11       	ld.w %d15,[%sp]68
8000ebc8:	19 a2 14 00 	ld.w %d2,[%sp]20
8000ebcc:	3f 2f 05 00 	jlt %d15,%d2,8000ebd6 <_svfprintf_r+0xc62>
8000ebd0:	80 df       	mov.d %d15,%a13
8000ebd2:	6f 0f 38 02 	jz.t %d15,0,8000f042 <_svfprintf_r+0x10ce>
8000ebd6:	58 08       	ld.w %d15,[%sp]32
8000ebd8:	19 a2 20 00 	ld.w %d2,[%sp]32
8000ebdc:	68 1f       	st.w [%a15]4,%d15
8000ebde:	58 19       	ld.w %d15,[%sp]100
8000ebe0:	99 a3 34 00 	ld.a %a3,[%sp]52
8000ebe4:	42 2f       	add %d15,%d2
8000ebe6:	78 19       	st.w [%sp]100,%d15
8000ebe8:	58 18       	ld.w %d15,[%sp]96
8000ebea:	e8 03       	st.a [%a15]0,%a3
8000ebec:	c2 1f       	add %d15,1
8000ebee:	78 18       	st.w [%sp]96,%d15
8000ebf0:	8b 8f 80 f2 	ge %d15,%d15,8
8000ebf4:	d9 ff 08 00 	lea %a15,[%a15]8
8000ebf8:	6e 0b       	jz %d15,8000ec0e <_svfprintf_r+0xc9a>
8000ebfa:	60 c4       	mov.a %a4,%d12
8000ebfc:	60 b5       	mov.a %a5,%d11
8000ebfe:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ec02:	6d 00 f4 0e 	call 800109ea <__ssprint_r>
8000ec06:	df 02 82 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ec0a:	d9 af 10 20 	lea %a15,[%sp]144
8000ec0e:	58 05       	ld.w %d15,[%sp]20
8000ec10:	7b 00 00 88 	movh %d8,32768
8000ec14:	c2 ff       	add %d15,-1
8000ec16:	1b 48 c3 80 	addi %d8,%d8,3124
8000ec1a:	3b 00 01 90 	mov %d9,16
8000ec1e:	bf 1f 12 02 	jlt %d15,1,8000f042 <_svfprintf_r+0x10ce>
8000ec22:	19 a5 24 10 	ld.w %d5,[%sp]100
8000ec26:	19 a3 20 10 	ld.w %d3,[%sp]96
8000ec2a:	8b 1f 81 42 	ge %d4,%d15,17
8000ec2e:	68 08       	st.w [%a15]0,%d8
8000ec30:	df 04 1c 00 	jeq %d4,0,8000ec68 <_svfprintf_r+0xcf4>
8000ec34:	c2 13       	add %d3,1
8000ec36:	1b 05 01 40 	addi %d4,%d5,16
8000ec3a:	68 19       	st.w [%a15]4,%d9
8000ec3c:	59 a3 20 10 	st.w [%sp]96,%d3
8000ec40:	59 a4 24 10 	st.w [%sp]100,%d4
8000ec44:	8b 83 80 32 	ge %d3,%d3,8
8000ec48:	d9 ff 08 00 	lea %a15,[%a15]8
8000ec4c:	76 3b       	jz %d3,8000ec62 <_svfprintf_r+0xcee>
8000ec4e:	60 c4       	mov.a %a4,%d12
8000ec50:	60 b5       	mov.a %a5,%d11
8000ec52:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ec56:	6d 00 ca 0e 	call 800109ea <__ssprint_r>
8000ec5a:	df 02 58 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ec5e:	d9 af 10 20 	lea %a15,[%sp]144
8000ec62:	1b 0f ff ff 	addi %d15,%d15,-16
8000ec66:	3c de       	j 8000ec22 <_svfprintf_r+0xcae>
8000ec68:	12 54       	add %d4,%d15,%d5
8000ec6a:	68 1f       	st.w [%a15]4,%d15
8000ec6c:	59 a4 24 10 	st.w [%sp]100,%d4
8000ec70:	9a 13       	add %d15,%d3,1
8000ec72:	1d 00 e1 01 	j 8000f034 <_svfprintf_r+0x10c0>
8000ec76:	19 a3 04 10 	ld.w %d3,[%sp]68
8000ec7a:	ff 13 8e 00 	jge %d3,1,8000ed96 <_svfprintf_r+0xe22>
8000ec7e:	7b 00 00 38 	movh %d3,32768
8000ec82:	1b 23 c3 30 	addi %d3,%d3,3122
8000ec86:	c2 18       	add %d8,1
8000ec88:	74 e3       	st.w [%a14],%d3
8000ec8a:	1b 1e 00 90 	addi %d9,%d14,1
8000ec8e:	82 13       	mov %d3,1
8000ec90:	59 a8 20 10 	st.w [%sp]96,%d8
8000ec94:	59 e3 04 00 	st.w [%a14]4,%d3
8000ec98:	59 a9 24 10 	st.w [%sp]100,%d9
8000ec9c:	8b 88 80 82 	ge %d8,%d8,8
8000eca0:	d9 ef 08 00 	lea %a15,[%a14]8
8000eca4:	76 8b       	jz %d8,8000ecba <_svfprintf_r+0xd46>
8000eca6:	60 c4       	mov.a %a4,%d12
8000eca8:	60 b5       	mov.a %a5,%d11
8000ecaa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ecae:	6d 00 9e 0e 	call 800109ea <__ssprint_r>
8000ecb2:	df 02 2c 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ecb6:	d9 af 10 20 	lea %a15,[%sp]144
8000ecba:	58 11       	ld.w %d15,[%sp]68
8000ecbc:	19 a2 14 00 	ld.w %d2,[%sp]20
8000ecc0:	a6 2f       	or %d15,%d2
8000ecc2:	ee 04       	jnz %d15,8000ecca <_svfprintf_r+0xd56>
8000ecc4:	80 df       	mov.d %d15,%a13
8000ecc6:	6f 0f be 01 	jz.t %d15,0,8000f042 <_svfprintf_r+0x10ce>
8000ecca:	58 08       	ld.w %d15,[%sp]32
8000eccc:	19 a2 20 00 	ld.w %d2,[%sp]32
8000ecd0:	68 1f       	st.w [%a15]4,%d15
8000ecd2:	58 19       	ld.w %d15,[%sp]100
8000ecd4:	99 a3 34 00 	ld.a %a3,[%sp]52
8000ecd8:	42 2f       	add %d15,%d2
8000ecda:	78 19       	st.w [%sp]100,%d15
8000ecdc:	58 18       	ld.w %d15,[%sp]96
8000ecde:	e8 03       	st.a [%a15]0,%a3
8000ece0:	c2 1f       	add %d15,1
8000ece2:	78 18       	st.w [%sp]96,%d15
8000ece4:	8b 8f 80 f2 	ge %d15,%d15,8
8000ece8:	d9 ff 08 00 	lea %a15,[%a15]8
8000ecec:	6e 0b       	jz %d15,8000ed02 <_svfprintf_r+0xd8e>
8000ecee:	60 c4       	mov.a %a4,%d12
8000ecf0:	60 b5       	mov.a %a5,%d11
8000ecf2:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ecf6:	6d 00 7a 0e 	call 800109ea <__ssprint_r>
8000ecfa:	df 02 08 82 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ecfe:	d9 af 10 20 	lea %a15,[%sp]144
8000ed02:	58 11       	ld.w %d15,[%sp]68
8000ed04:	7b 00 00 88 	movh %d8,32768
8000ed08:	32 5f       	rsub %d15
8000ed0a:	1b 48 c3 80 	addi %d8,%d8,3124
8000ed0e:	3b 00 01 90 	mov %d9,16
8000ed12:	bf 1f 3a 00 	jlt %d15,1,8000ed86 <_svfprintf_r+0xe12>
8000ed16:	19 a5 24 10 	ld.w %d5,[%sp]100
8000ed1a:	19 a3 20 10 	ld.w %d3,[%sp]96
8000ed1e:	8b 1f 81 42 	ge %d4,%d15,17
8000ed22:	68 08       	st.w [%a15]0,%d8
8000ed24:	df 04 1c 00 	jeq %d4,0,8000ed5c <_svfprintf_r+0xde8>
8000ed28:	c2 13       	add %d3,1
8000ed2a:	1b 05 01 40 	addi %d4,%d5,16
8000ed2e:	68 19       	st.w [%a15]4,%d9
8000ed30:	59 a3 20 10 	st.w [%sp]96,%d3
8000ed34:	59 a4 24 10 	st.w [%sp]100,%d4
8000ed38:	8b 83 80 32 	ge %d3,%d3,8
8000ed3c:	d9 ff 08 00 	lea %a15,[%a15]8
8000ed40:	76 3b       	jz %d3,8000ed56 <_svfprintf_r+0xde2>
8000ed42:	60 c4       	mov.a %a4,%d12
8000ed44:	60 b5       	mov.a %a5,%d11
8000ed46:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ed4a:	6d 00 50 0e 	call 800109ea <__ssprint_r>
8000ed4e:	df 02 de 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ed52:	d9 af 10 20 	lea %a15,[%sp]144
8000ed56:	1b 0f ff ff 	addi %d15,%d15,-16
8000ed5a:	3c de       	j 8000ed16 <_svfprintf_r+0xda2>
8000ed5c:	68 1f       	st.w [%a15]4,%d15
8000ed5e:	12 54       	add %d4,%d15,%d5
8000ed60:	9a 13       	add %d15,%d3,1
8000ed62:	78 18       	st.w [%sp]96,%d15
8000ed64:	59 a4 24 10 	st.w [%sp]100,%d4
8000ed68:	8b 8f 80 f2 	ge %d15,%d15,8
8000ed6c:	d9 ff 08 00 	lea %a15,[%a15]8
8000ed70:	6e 0b       	jz %d15,8000ed86 <_svfprintf_r+0xe12>
8000ed72:	60 c4       	mov.a %a4,%d12
8000ed74:	60 b5       	mov.a %a5,%d11
8000ed76:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ed7a:	6d 00 38 0e 	call 800109ea <__ssprint_r>
8000ed7e:	df 02 c6 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ed82:	d9 af 10 20 	lea %a15,[%sp]144
8000ed86:	58 05       	ld.w %d15,[%sp]20
8000ed88:	68 0d       	st.w [%a15]0,%d13
8000ed8a:	68 1f       	st.w [%a15]4,%d15
8000ed8c:	19 a2 14 00 	ld.w %d2,[%sp]20
8000ed90:	58 19       	ld.w %d15,[%sp]100
8000ed92:	1d 00 4d 01 	j 8000f02c <_svfprintf_r+0x10b8>
8000ed96:	58 05       	ld.w %d15,[%sp]20
8000ed98:	74 ed       	st.w [%a14],%d13
8000ed9a:	3f f3 6a 00 	jlt %d3,%d15,8000ee6e <_svfprintf_r+0xefa>
8000ed9e:	02 f9       	mov %d9,%d15
8000eda0:	c2 18       	add %d8,1
8000eda2:	42 e9       	add %d9,%d14
8000eda4:	59 a8 20 10 	st.w [%sp]96,%d8
8000eda8:	6c e1       	st.w [%a14]4,%d15
8000edaa:	59 a9 24 10 	st.w [%sp]100,%d9
8000edae:	8b 88 80 82 	ge %d8,%d8,8
8000edb2:	d9 ef 08 00 	lea %a15,[%a14]8
8000edb6:	76 8b       	jz %d8,8000edcc <_svfprintf_r+0xe58>
8000edb8:	60 c4       	mov.a %a4,%d12
8000edba:	60 b5       	mov.a %a5,%d11
8000edbc:	d9 a6 1c 10 	lea %a6,[%sp]92
8000edc0:	6d 00 15 0e 	call 800109ea <__ssprint_r>
8000edc4:	df 02 a3 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000edc8:	d9 af 10 20 	lea %a15,[%sp]144
8000edcc:	58 11       	ld.w %d15,[%sp]68
8000edce:	19 a2 14 00 	ld.w %d2,[%sp]20
8000edd2:	7b 00 00 88 	movh %d8,32768
8000edd6:	a2 2f       	sub %d15,%d2
8000edd8:	1b 48 c3 80 	addi %d8,%d8,3124
8000eddc:	3b 00 01 90 	mov %d9,16
8000ede0:	bf 1f 3a 00 	jlt %d15,1,8000ee54 <_svfprintf_r+0xee0>
8000ede4:	19 a5 24 10 	ld.w %d5,[%sp]100
8000ede8:	19 a3 20 10 	ld.w %d3,[%sp]96
8000edec:	8b 1f 81 42 	ge %d4,%d15,17
8000edf0:	68 08       	st.w [%a15]0,%d8
8000edf2:	df 04 1c 00 	jeq %d4,0,8000ee2a <_svfprintf_r+0xeb6>
8000edf6:	c2 13       	add %d3,1
8000edf8:	1b 05 01 40 	addi %d4,%d5,16
8000edfc:	68 19       	st.w [%a15]4,%d9
8000edfe:	59 a3 20 10 	st.w [%sp]96,%d3
8000ee02:	59 a4 24 10 	st.w [%sp]100,%d4
8000ee06:	8b 83 80 32 	ge %d3,%d3,8
8000ee0a:	d9 ff 08 00 	lea %a15,[%a15]8
8000ee0e:	76 3b       	jz %d3,8000ee24 <_svfprintf_r+0xeb0>
8000ee10:	60 c4       	mov.a %a4,%d12
8000ee12:	60 b5       	mov.a %a5,%d11
8000ee14:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ee18:	6d 00 e9 0d 	call 800109ea <__ssprint_r>
8000ee1c:	df 02 77 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ee20:	d9 af 10 20 	lea %a15,[%sp]144
8000ee24:	1b 0f ff ff 	addi %d15,%d15,-16
8000ee28:	3c de       	j 8000ede4 <_svfprintf_r+0xe70>
8000ee2a:	68 1f       	st.w [%a15]4,%d15
8000ee2c:	12 54       	add %d4,%d15,%d5
8000ee2e:	9a 13       	add %d15,%d3,1
8000ee30:	78 18       	st.w [%sp]96,%d15
8000ee32:	59 a4 24 10 	st.w [%sp]100,%d4
8000ee36:	8b 8f 80 f2 	ge %d15,%d15,8
8000ee3a:	d9 ff 08 00 	lea %a15,[%a15]8
8000ee3e:	6e 0b       	jz %d15,8000ee54 <_svfprintf_r+0xee0>
8000ee40:	60 c4       	mov.a %a4,%d12
8000ee42:	60 b5       	mov.a %a5,%d11
8000ee44:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ee48:	6d 00 d1 0d 	call 800109ea <__ssprint_r>
8000ee4c:	df 02 5f 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ee50:	d9 af 10 20 	lea %a15,[%sp]144
8000ee54:	80 df       	mov.d %d15,%a13
8000ee56:	6f 0f f6 00 	jz.t %d15,0,8000f042 <_svfprintf_r+0x10ce>
8000ee5a:	99 a3 34 00 	ld.a %a3,[%sp]52
8000ee5e:	58 08       	ld.w %d15,[%sp]32
8000ee60:	19 a2 20 00 	ld.w %d2,[%sp]32
8000ee64:	68 1f       	st.w [%a15]4,%d15
8000ee66:	e8 03       	st.a [%a15]0,%a3
8000ee68:	58 19       	ld.w %d15,[%sp]100
8000ee6a:	1d 00 e1 00 	j 8000f02c <_svfprintf_r+0x10b8>
8000ee6e:	c2 18       	add %d8,1
8000ee70:	59 e3 04 00 	st.w [%a14]4,%d3
8000ee74:	42 e3       	add %d3,%d14
8000ee76:	59 a8 20 10 	st.w [%sp]96,%d8
8000ee7a:	59 a3 24 10 	st.w [%sp]100,%d3
8000ee7e:	8b 88 80 82 	ge %d8,%d8,8
8000ee82:	d9 ef 08 00 	lea %a15,[%a14]8
8000ee86:	76 8b       	jz %d8,8000ee9c <_svfprintf_r+0xf28>
8000ee88:	60 c4       	mov.a %a4,%d12
8000ee8a:	60 b5       	mov.a %a5,%d11
8000ee8c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ee90:	6d 00 ad 0d 	call 800109ea <__ssprint_r>
8000ee94:	df 02 3b 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ee98:	d9 af 10 20 	lea %a15,[%sp]144
8000ee9c:	58 08       	ld.w %d15,[%sp]32
8000ee9e:	19 a2 20 00 	ld.w %d2,[%sp]32
8000eea2:	68 1f       	st.w [%a15]4,%d15
8000eea4:	58 19       	ld.w %d15,[%sp]100
8000eea6:	99 a3 34 00 	ld.a %a3,[%sp]52
8000eeaa:	42 2f       	add %d15,%d2
8000eeac:	78 19       	st.w [%sp]100,%d15
8000eeae:	58 18       	ld.w %d15,[%sp]96
8000eeb0:	99 ae 04 10 	ld.a %a14,[%sp]68
8000eeb4:	c2 1f       	add %d15,1
8000eeb6:	60 d2       	mov.a %a2,%d13
8000eeb8:	e8 03       	st.a [%a15]0,%a3
8000eeba:	78 18       	st.w [%sp]96,%d15
8000eebc:	8b 8f 80 f2 	ge %d15,%d15,8
8000eec0:	30 2e       	add.a %a14,%a2
8000eec2:	d9 ff 08 00 	lea %a15,[%a15]8
8000eec6:	6e 0b       	jz %d15,8000eedc <_svfprintf_r+0xf68>
8000eec8:	60 c4       	mov.a %a4,%d12
8000eeca:	60 b5       	mov.a %a5,%d11
8000eecc:	d9 a6 1c 10 	lea %a6,[%sp]92
8000eed0:	6d 00 8d 0d 	call 800109ea <__ssprint_r>
8000eed4:	df 02 1b 81 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000eed8:	d9 af 10 20 	lea %a15,[%sp]144
8000eedc:	19 a2 14 00 	ld.w %d2,[%sp]20
8000eee0:	58 11       	ld.w %d15,[%sp]68
8000eee2:	e8 0e       	st.a [%a15]0,%a14
8000eee4:	5a f2       	sub %d15,%d2,%d15
8000eee6:	68 1f       	st.w [%a15]4,%d15
8000eee8:	19 a2 24 10 	ld.w %d2,[%sp]100
8000eeec:	1d 00 a0 00 	j 8000f02c <_svfprintf_r+0x10b8>
8000eef0:	c2 18       	add %d8,1
8000eef2:	82 13       	mov %d3,1
8000eef4:	1b 1e 00 90 	addi %d9,%d14,1
8000eef8:	58 05       	ld.w %d15,[%sp]20
8000eefa:	59 a8 20 10 	st.w [%sp]96,%d8
8000eefe:	74 ed       	st.w [%a14],%d13
8000ef00:	59 e3 04 00 	st.w [%a14]4,%d3
8000ef04:	59 a9 24 10 	st.w [%sp]100,%d9
8000ef08:	8b 88 80 82 	ge %d8,%d8,8
8000ef0c:	ff 2f 05 00 	jge %d15,2,8000ef16 <_svfprintf_r+0xfa2>
8000ef10:	80 d2       	mov.d %d2,%a13
8000ef12:	6f 02 81 00 	jz.t %d2,0,8000f014 <_svfprintf_r+0x10a0>
8000ef16:	d9 ef 08 00 	lea %a15,[%a14]8
8000ef1a:	76 8b       	jz %d8,8000ef30 <_svfprintf_r+0xfbc>
8000ef1c:	60 c4       	mov.a %a4,%d12
8000ef1e:	60 b5       	mov.a %a5,%d11
8000ef20:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ef24:	6d 00 63 0d 	call 800109ea <__ssprint_r>
8000ef28:	df 02 f1 80 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ef2c:	d9 af 10 20 	lea %a15,[%sp]144
8000ef30:	58 08       	ld.w %d15,[%sp]32
8000ef32:	19 a2 20 00 	ld.w %d2,[%sp]32
8000ef36:	68 1f       	st.w [%a15]4,%d15
8000ef38:	58 19       	ld.w %d15,[%sp]100
8000ef3a:	99 a3 34 00 	ld.a %a3,[%sp]52
8000ef3e:	42 2f       	add %d15,%d2
8000ef40:	78 19       	st.w [%sp]100,%d15
8000ef42:	58 18       	ld.w %d15,[%sp]96
8000ef44:	e8 03       	st.a [%a15]0,%a3
8000ef46:	c2 1f       	add %d15,1
8000ef48:	78 18       	st.w [%sp]96,%d15
8000ef4a:	8b 8f 80 f2 	ge %d15,%d15,8
8000ef4e:	d9 ff 08 00 	lea %a15,[%a15]8
8000ef52:	6e 0b       	jz %d15,8000ef68 <_svfprintf_r+0xff4>
8000ef54:	60 c4       	mov.a %a4,%d12
8000ef56:	60 b5       	mov.a %a5,%d11
8000ef58:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ef5c:	6d 00 47 0d 	call 800109ea <__ssprint_r>
8000ef60:	df 02 d5 80 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000ef64:	d9 af 10 20 	lea %a15,[%sp]144
8000ef68:	d2 06       	mov %e6,0
8000ef6a:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000ef6e:	19 a5 30 00 	ld.w %d5,[%sp]48
8000ef72:	6d 00 e9 14 	call 80011944 <__nedf2>
8000ef76:	58 05       	ld.w %d15,[%sp]20
8000ef78:	c2 ff       	add %d15,-1
8000ef7a:	76 2c       	jz %d2,8000ef92 <_svfprintf_r+0x101e>
8000ef7c:	19 a2 24 10 	ld.w %d2,[%sp]100
8000ef80:	60 de       	mov.a %a14,%d13
8000ef82:	68 1f       	st.w [%a15]4,%d15
8000ef84:	42 2f       	add %d15,%d2
8000ef86:	78 19       	st.w [%sp]100,%d15
8000ef88:	58 18       	ld.w %d15,[%sp]96
8000ef8a:	b0 1e       	add.a %a14,1
8000ef8c:	e8 0e       	st.a [%a15]0,%a14
8000ef8e:	c2 1f       	add %d15,1
8000ef90:	3c 31       	j 8000eff2 <_svfprintf_r+0x107e>
8000ef92:	7b 00 00 88 	movh %d8,32768
8000ef96:	1b 48 c3 80 	addi %d8,%d8,3124
8000ef9a:	3b 00 01 90 	mov %d9,16
8000ef9e:	bf 1f 3f 00 	jlt %d15,1,8000f01c <_svfprintf_r+0x10a8>
8000efa2:	19 a5 24 10 	ld.w %d5,[%sp]100
8000efa6:	19 a3 20 10 	ld.w %d3,[%sp]96
8000efaa:	8b 1f 81 42 	ge %d4,%d15,17
8000efae:	68 08       	st.w [%a15]0,%d8
8000efb0:	df 04 1c 00 	jeq %d4,0,8000efe8 <_svfprintf_r+0x1074>
8000efb4:	c2 13       	add %d3,1
8000efb6:	1b 05 01 40 	addi %d4,%d5,16
8000efba:	68 19       	st.w [%a15]4,%d9
8000efbc:	59 a3 20 10 	st.w [%sp]96,%d3
8000efc0:	59 a4 24 10 	st.w [%sp]100,%d4
8000efc4:	8b 83 80 32 	ge %d3,%d3,8
8000efc8:	d9 ff 08 00 	lea %a15,[%a15]8
8000efcc:	76 3b       	jz %d3,8000efe2 <_svfprintf_r+0x106e>
8000efce:	60 c4       	mov.a %a4,%d12
8000efd0:	60 b5       	mov.a %a5,%d11
8000efd2:	d9 a6 1c 10 	lea %a6,[%sp]92
8000efd6:	6d 00 0a 0d 	call 800109ea <__ssprint_r>
8000efda:	df 02 98 80 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000efde:	d9 af 10 20 	lea %a15,[%sp]144
8000efe2:	1b 0f ff ff 	addi %d15,%d15,-16
8000efe6:	3c de       	j 8000efa2 <_svfprintf_r+0x102e>
8000efe8:	12 54       	add %d4,%d15,%d5
8000efea:	68 1f       	st.w [%a15]4,%d15
8000efec:	59 a4 24 10 	st.w [%sp]100,%d4
8000eff0:	9a 13       	add %d15,%d3,1
8000eff2:	78 18       	st.w [%sp]96,%d15
8000eff4:	8b 8f 80 f2 	ge %d15,%d15,8
8000eff8:	d9 ff 08 00 	lea %a15,[%a15]8
8000effc:	6e 10       	jz %d15,8000f01c <_svfprintf_r+0x10a8>
8000effe:	60 c4       	mov.a %a4,%d12
8000f000:	60 b5       	mov.a %a5,%d11
8000f002:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f006:	6d 00 f2 0c 	call 800109ea <__ssprint_r>
8000f00a:	df 02 80 80 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000f00e:	d9 af 10 20 	lea %a15,[%sp]144
8000f012:	3c 05       	j 8000f01c <_svfprintf_r+0x10a8>
8000f014:	df 08 f5 ff 	jne %d8,0,8000effe <_svfprintf_r+0x108a>
8000f018:	d9 ef 08 00 	lea %a15,[%a14]8
8000f01c:	58 0e       	ld.w %d15,[%sp]56
8000f01e:	d9 a3 0d 10 	lea %a3,[%sp]77
8000f022:	68 1f       	st.w [%a15]4,%d15
8000f024:	19 a2 38 00 	ld.w %d2,[%sp]56
8000f028:	58 19       	ld.w %d15,[%sp]100
8000f02a:	e8 03       	st.a [%a15]0,%a3
8000f02c:	42 2f       	add %d15,%d2
8000f02e:	78 19       	st.w [%sp]100,%d15
8000f030:	58 18       	ld.w %d15,[%sp]96
8000f032:	c2 1f       	add %d15,1
8000f034:	78 18       	st.w [%sp]96,%d15
8000f036:	8b 8f 80 f2 	ge %d15,%d15,8
8000f03a:	df 0f 8d fd 	jne %d15,0,8000eb54 <_svfprintf_r+0xbe0>
8000f03e:	d9 ff 08 00 	lea %a15,[%a15]8
8000f042:	80 df       	mov.d %d15,%a13
8000f044:	ae 2d       	jnz.t %d15,2,8000f05e <_svfprintf_r+0x10ea>
8000f046:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000f04a:	0b 2a a0 f1 	max %d15,%d10,%d2
8000f04e:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f052:	42 f2       	add %d2,%d15
8000f054:	58 19       	ld.w %d15,[%sp]100
8000f056:	59 a2 28 00 	st.w [%sp]40,%d2
8000f05a:	6e 49       	jz %d15,8000f0ec <_svfprintf_r+0x1178>
8000f05c:	3c 40       	j 8000f0dc <_svfprintf_r+0x1168>
8000f05e:	58 07       	ld.w %d15,[%sp]28
8000f060:	3b 00 01 80 	mov %d8,16
8000f064:	a2 af       	sub %d15,%d10
8000f066:	bf 1f f0 7f 	jlt %d15,1,8000f046 <_svfprintf_r+0x10d2>
8000f06a:	91 00 00 28 	movh.a %a2,32768
8000f06e:	d9 22 c4 10 	lea %a2,[%a2]3140 <80000c44 <blanks.4035>>
8000f072:	19 a5 24 10 	ld.w %d5,[%sp]100 <80000c44 <blanks.4035>>
8000f076:	19 a3 20 10 	ld.w %d3,[%sp]96 <80000c44 <blanks.4035>>
8000f07a:	8b 1f 81 42 	ge %d4,%d15,17
8000f07e:	e8 02       	st.a [%a15]0,%a2
8000f080:	df 04 1c 00 	jeq %d4,0,8000f0b8 <_svfprintf_r+0x1144>
8000f084:	c2 13       	add %d3,1
8000f086:	1b 05 01 40 	addi %d4,%d5,16
8000f08a:	68 18       	st.w [%a15]4,%d8
8000f08c:	59 a3 20 10 	st.w [%sp]96,%d3
8000f090:	59 a4 24 10 	st.w [%sp]100,%d4
8000f094:	8b 83 80 32 	ge %d3,%d3,8
8000f098:	d9 ff 08 00 	lea %a15,[%a15]8
8000f09c:	76 3b       	jz %d3,8000f0b2 <_svfprintf_r+0x113e>
8000f09e:	60 c4       	mov.a %a4,%d12
8000f0a0:	60 b5       	mov.a %a5,%d11
8000f0a2:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f0a6:	6d 00 a2 0c 	call 800109ea <__ssprint_r>
8000f0aa:	df 02 30 80 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000f0ae:	d9 af 10 20 	lea %a15,[%sp]144
8000f0b2:	1b 0f ff ff 	addi %d15,%d15,-16
8000f0b6:	3c da       	j 8000f06a <_svfprintf_r+0x10f6>
8000f0b8:	12 54       	add %d4,%d15,%d5
8000f0ba:	68 1f       	st.w [%a15]4,%d15
8000f0bc:	9a 13       	add %d15,%d3,1
8000f0be:	78 18       	st.w [%sp]96,%d15
8000f0c0:	59 a4 24 10 	st.w [%sp]100,%d4
8000f0c4:	8b 8f 40 f2 	lt %d15,%d15,8
8000f0c8:	ee bf       	jnz %d15,8000f046 <_svfprintf_r+0x10d2>
8000f0ca:	60 c4       	mov.a %a4,%d12
8000f0cc:	60 b5       	mov.a %a5,%d11
8000f0ce:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f0d2:	6d 00 8c 0c 	call 800109ea <__ssprint_r>
8000f0d6:	df 02 b8 7f 	jeq %d2,0,8000f046 <_svfprintf_r+0x10d2>
8000f0da:	3c 18       	j 8000f10a <_svfprintf_r+0x1196>
8000f0dc:	60 c4       	mov.a %a4,%d12
8000f0de:	60 b5       	mov.a %a5,%d11
8000f0e0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f0e4:	6d 00 83 0c 	call 800109ea <__ssprint_r>
8000f0e8:	df 02 11 80 	jne %d2,0,8000f10a <_svfprintf_r+0x1196>
8000f0ec:	82 0f       	mov %d15,0
8000f0ee:	78 18       	st.w [%sp]96,%d15
8000f0f0:	40 cf       	mov.aa %a15,%a12
8000f0f2:	d9 ae 10 20 	lea %a14,[%sp]144
8000f0f6:	1d ff 77 f7 	j 8000dfe4 <_svfprintf_r+0x70>
8000f0fa:	58 19       	ld.w %d15,[%sp]100
8000f0fc:	6e 07       	jz %d15,8000f10a <_svfprintf_r+0x1196>
8000f0fe:	60 c4       	mov.a %a4,%d12
8000f100:	60 b5       	mov.a %a5,%d11
8000f102:	d9 a6 1c 10 	lea %a6,[%sp]92
8000f106:	6d 00 72 0c 	call 800109ea <__ssprint_r>
8000f10a:	60 b3       	mov.a %a3,%d11
8000f10c:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f110:	8c 36       	ld.h %d15,[%a3]12
8000f112:	16 40       	and %d15,64
8000f114:	aa f2       	cmov %d2,%d15,-1
8000f116:	00 90       	ret 

8000f118 <quorem>:
8000f118:	19 58 10 00 	ld.w %d8,[%a5]16
8000f11c:	4c 44       	ld.w %d15,[%a4]16
8000f11e:	82 02       	mov %d2,0
8000f120:	3f 8f 88 00 	jlt %d15,%d8,8000f230 <quorem+0x118>
8000f124:	c2 f8       	add %d8,-1
8000f126:	80 4f       	mov.d %d15,%a4
8000f128:	8f 28 00 20 	sh %d2,%d8,2
8000f12c:	60 2f       	mov.a %a15,%d2
8000f12e:	1b 4f 01 90 	addi %d9,%d15,20
8000f132:	d9 5c 14 00 	lea %a12,[%a5]20
8000f136:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000f13a:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000f13e:	54 dc       	ld.w %d12,[%a13]
8000f140:	4c f0       	ld.w %d15,[%a15]0
8000f142:	c2 1c       	add %d12,1
8000f144:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000f148:	02 ca       	mov %d10,%d12
8000f14a:	df 0c 3d 00 	jeq %d12,0,8000f1c4 <quorem+0xac>
8000f14e:	60 96       	mov.a %a6,%d9
8000f150:	40 c2       	mov.aa %a2,%a12
8000f152:	82 05       	mov %d5,0
8000f154:	82 06       	mov %d6,0
8000f156:	54 22       	ld.w %d2,[%a2]
8000f158:	40 63       	mov.aa %a3,%a6
8000f15a:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000f15e:	8f 02 1f 20 	sh %d2,%d2,-16
8000f162:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000f166:	b0 42       	add.a %a2,4
8000f168:	8f 03 1f 40 	sh %d4,%d3,-16
8000f16c:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000f170:	44 34       	ld.w %d4,[%a3+]
8000f172:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000f176:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000f17a:	8f 02 1f 50 	sh %d5,%d2,-16
8000f17e:	42 f6       	add %d6,%d15
8000f180:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000f184:	0b 36 80 30 	sub %d3,%d6,%d3
8000f188:	8f 04 1f 40 	sh %d4,%d4,-16
8000f18c:	8f 03 3f f0 	sha %d15,%d3,-16
8000f190:	0b 24 80 20 	sub %d2,%d4,%d2
8000f194:	42 f2       	add %d2,%d15
8000f196:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000f19a:	8f 02 3f 60 	sha %d6,%d2,-16
8000f19e:	80 2f       	mov.d %d15,%a2
8000f1a0:	80 d2       	mov.d %d2,%a13
8000f1a2:	74 63       	st.w [%a6],%d3
8000f1a4:	40 36       	mov.aa %a6,%a3
8000f1a6:	7f f2 d8 ff 	jge.u %d2,%d15,8000f156 <quorem+0x3e>
8000f1aa:	4c f0       	ld.w %d15,[%a15]0
8000f1ac:	ee 0c       	jnz %d15,8000f1c4 <quorem+0xac>
8000f1ae:	b0 cf       	add.a %a15,-4
8000f1b0:	80 f2       	mov.d %d2,%a15
8000f1b2:	3f 29 05 80 	jlt.u %d9,%d2,8000f1bc <quorem+0xa4>
8000f1b6:	59 48 10 00 	st.w [%a4]16,%d8
8000f1ba:	3c 05       	j 8000f1c4 <quorem+0xac>
8000f1bc:	4c f0       	ld.w %d15,[%a15]0
8000f1be:	ee fc       	jnz %d15,8000f1b6 <quorem+0x9e>
8000f1c0:	c2 f8       	add %d8,-1
8000f1c2:	3c f6       	j 8000f1ae <quorem+0x96>
8000f1c4:	40 4e       	mov.aa %a14,%a4
8000f1c6:	6d 00 08 0b 	call 800107d6 <__mcmp>
8000f1ca:	bf 02 32 00 	jlt %d2,0,8000f22e <quorem+0x116>
8000f1ce:	60 92       	mov.a %a2,%d9
8000f1d0:	1b 1c 00 a0 	addi %d10,%d12,1
8000f1d4:	82 04       	mov %d4,0
8000f1d6:	40 2f       	mov.aa %a15,%a2
8000f1d8:	44 f3       	ld.w %d3,[%a15+]
8000f1da:	54 c5       	ld.w %d5,[%a12]
8000f1dc:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000f1e0:	8f 05 1f f0 	sh %d15,%d5,-16
8000f1e4:	42 42       	add %d2,%d4
8000f1e6:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000f1ea:	8f 03 1f 30 	sh %d3,%d3,-16
8000f1ee:	a2 42       	sub %d2,%d4
8000f1f0:	8f 02 3f 40 	sha %d4,%d2,-16
8000f1f4:	a2 f3       	sub %d3,%d15
8000f1f6:	42 43       	add %d3,%d4
8000f1f8:	8f 03 3f 40 	sha %d4,%d3,-16
8000f1fc:	b0 4c       	add.a %a12,4
8000f1fe:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000f202:	80 df       	mov.d %d15,%a13
8000f204:	80 c2       	mov.d %d2,%a12
8000f206:	74 23       	st.w [%a2],%d3
8000f208:	40 f2       	mov.aa %a2,%a15
8000f20a:	7f 2f e6 ff 	jge.u %d15,%d2,8000f1d6 <quorem+0xbe>
8000f20e:	60 92       	mov.a %a2,%d9
8000f210:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000f214:	4c f0       	ld.w %d15,[%a15]0
8000f216:	ee 0c       	jnz %d15,8000f22e <quorem+0x116>
8000f218:	b0 cf       	add.a %a15,-4
8000f21a:	80 f2       	mov.d %d2,%a15
8000f21c:	3f 29 05 80 	jlt.u %d9,%d2,8000f226 <quorem+0x10e>
8000f220:	59 e8 10 00 	st.w [%a14]16,%d8
8000f224:	3c 05       	j 8000f22e <quorem+0x116>
8000f226:	4c f0       	ld.w %d15,[%a15]0
8000f228:	ee fc       	jnz %d15,8000f220 <quorem+0x108>
8000f22a:	c2 f8       	add %d8,-1
8000f22c:	3c f6       	j 8000f218 <quorem+0x100>
8000f22e:	02 a2       	mov %d2,%d10
8000f230:	00 90       	ret 
	...

8000f234 <_dtoa_r>:
8000f234:	20 58       	sub.a %sp,88
8000f236:	b5 a5 08 10 	st.a [%sp]72,%a5
8000f23a:	99 45 00 10 	ld.a %a5,[%a4]64
8000f23e:	59 a6 1c 00 	st.w [%sp]28,%d6
8000f242:	59 a7 28 00 	st.w [%sp]40,%d7
8000f246:	b5 a7 38 00 	st.a [%sp]56,%a7
8000f24a:	40 4d       	mov.aa %a13,%a4
8000f24c:	0b 45 10 88 	mov %e8,%d5,%d4
8000f250:	40 6c       	mov.aa %a12,%a6
8000f252:	0b 45 10 c8 	mov %e12,%d5,%d4
8000f256:	bc 5e       	jz.a %a5,8000f272 <_dtoa_r+0x3e>
8000f258:	19 4f 04 10 	ld.w %d15,[%a4]68
8000f25c:	82 12       	mov %d2,1
8000f25e:	0f f2 00 20 	sh %d2,%d2,%d15
8000f262:	6c 51       	st.w [%a5]4,%d15
8000f264:	59 52 08 00 	st.w [%a5]8,%d2
8000f268:	82 0f       	mov %d15,0
8000f26a:	6d 00 e8 08 	call 8001043a <_Bfree>
8000f26e:	59 df 00 10 	st.w [%a13]64,%d15
8000f272:	ce 96       	jgez %d9,8000f27e <_dtoa_r+0x4a>
8000f274:	82 1f       	mov %d15,1
8000f276:	6c c0       	st.w [%a12]0,%d15
8000f278:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000f27c:	3c 03       	j 8000f282 <_dtoa_r+0x4e>
8000f27e:	82 0f       	mov %d15,0
8000f280:	6c c0       	st.w [%a12]0,%d15
8000f282:	7b 00 ff 27 	movh %d2,32752
8000f286:	26 d2       	and %d2,%d13
8000f288:	7b 00 ff 37 	movh %d3,32752
8000f28c:	5f 32 22 80 	jne %d2,%d3,8000f2d0 <_dtoa_r+0x9c>
8000f290:	99 a3 08 10 	ld.a %a3,[%sp]72
8000f294:	3b f0 70 22 	mov %d2,9999
8000f298:	91 00 00 f8 	movh.a %a15,32768
8000f29c:	74 32       	st.w [%a3],%d2
8000f29e:	d9 ff dd 10 	lea %a15,[%a15]3165 <80000c5d <blanks.4035+0x19>>
8000f2a2:	f6 c8       	jnz %d12,8000f2b2 <_dtoa_r+0x7e>
8000f2a4:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000f2a8:	ee 05       	jnz %d15,8000f2b2 <_dtoa_r+0x7e>
8000f2aa:	91 00 00 f8 	movh.a %a15,32768
8000f2ae:	d9 ff d4 10 	lea %a15,[%a15]3156 <80000c54 <blanks.4035+0x10>>
8000f2b2:	99 a3 38 00 	ld.a %a3,[%sp]56 <80000c54 <blanks.4035+0x10>>
8000f2b6:	40 f2       	mov.aa %a2,%a15
8000f2b8:	bd 03 26 06 	jz.a %a3,8000ff04 <_dtoa_r+0xcd0>
8000f2bc:	80 ff       	mov.d %d15,%a15
8000f2be:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000f2c2:	1b 8f 00 20 	addi %d2,%d15,8
8000f2c6:	c2 3f       	add %d15,3
8000f2c8:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000f2cc:	6c 30       	st.w [%a3]0,%d15
8000f2ce:	00 90       	ret 
8000f2d0:	0b cd 10 48 	mov %e4,%d13,%d12
8000f2d4:	d2 06       	mov %e6,0
8000f2d6:	0b cd 10 88 	mov %e8,%d13,%d12
8000f2da:	6d 00 15 13 	call 80011904 <__eqdf2>
8000f2de:	df 02 13 80 	jne %d2,0,8000f304 <_dtoa_r+0xd0>
8000f2e2:	99 a3 08 10 	ld.a %a3,[%sp]72
8000f2e6:	d8 0e       	ld.a %a15,[%sp]56
8000f2e8:	82 1f       	mov %d15,1
8000f2ea:	91 00 00 28 	movh.a %a2,32768
8000f2ee:	6c 30       	st.w [%a3]0,%d15
8000f2f0:	d9 22 e1 10 	lea %a2,[%a2]3169 <80000c61 <blanks.4035+0x1d>>
8000f2f4:	bd 0f 08 06 	jz.a %a15,8000ff04 <_dtoa_r+0xcd0>
8000f2f8:	7b 00 00 f8 	movh %d15,32768
8000f2fc:	1b 2f c6 f0 	addi %d15,%d15,3170
8000f300:	68 0f       	st.w [%a15]0,%d15
8000f302:	00 90       	ret 
8000f304:	0b cd 10 48 	mov %e4,%d13,%d12
8000f308:	40 d4       	mov.aa %a4,%a13
8000f30a:	d9 a5 14 10 	lea %a5,[%sp]84
8000f30e:	d9 a6 10 10 	lea %a6,[%sp]80
8000f312:	6d 00 e8 0a 	call 800108e2 <__d2b>
8000f316:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000f31a:	40 2e       	mov.aa %a14,%a2
8000f31c:	19 aa 10 10 	ld.w %d10,[%sp]80
8000f320:	76 bd       	jz %d11,8000f33a <_dtoa_r+0x106>
8000f322:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000f326:	0b cd 10 48 	mov %e4,%d13,%d12
8000f32a:	7b 00 ff 23 	movh %d2,16368
8000f32e:	0f 2f a0 50 	or %d5,%d15,%d2
8000f332:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000f336:	82 0f       	mov %d15,0
8000f338:	3c 22       	j 8000f37c <_dtoa_r+0x148>
8000f33a:	19 ab 14 10 	ld.w %d11,[%sp]84
8000f33e:	3b e0 be 4f 	mov %d4,-1042
8000f342:	42 ab       	add %d11,%d10
8000f344:	a2 b4       	sub %d4,%d11
8000f346:	3b f0 be 2f 	mov %d2,-1041
8000f34a:	0f 4c 00 40 	sh %d4,%d12,%d4
8000f34e:	3f 2b 0f 00 	jlt %d11,%d2,8000f36c <_dtoa_r+0x138>
8000f352:	1b 2b 41 30 	addi %d3,%d11,1042
8000f356:	3b e0 c0 4f 	mov %d4,-1010
8000f35a:	a2 b4       	sub %d4,%d11
8000f35c:	8b 03 00 21 	rsub %d2,%d3,0
8000f360:	0f 2c 00 20 	sh %d2,%d12,%d2
8000f364:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000f368:	0f f2 a0 40 	or %d4,%d2,%d15
8000f36c:	6d 00 b7 13 	call 80011ada <__floatunsidf>
8000f370:	0b 23 10 48 	mov %e4,%d3,%d2
8000f374:	9b 03 e1 5f 	addih %d5,%d3,65040
8000f378:	c2 fb       	add %d11,-1
8000f37a:	82 1f       	mov %d15,1
8000f37c:	b7 00 ab 69 	imask %e6,0,19,11
8000f380:	78 13       	st.w [%sp]76,%d15
8000f382:	6d 00 43 11 	call 80011608 <__subdf3>
8000f386:	7b 30 fd 73 	movh %d7,16339
8000f38a:	0b 23 10 48 	mov %e4,%d3,%d2
8000f38e:	7b f0 36 66 	movh %d6,25455
8000f392:	1b 77 7a 78 	addi %d7,%d7,-30809
8000f396:	1b 16 36 64 	addi %d6,%d6,17249
8000f39a:	6d 00 57 11 	call 80011648 <__muldf3>
8000f39e:	7b 70 fc 73 	movh %d7,16327
8000f3a2:	0b 23 10 48 	mov %e4,%d3,%d2
8000f3a6:	7b 10 b6 68 	movh %d6,35681
8000f3aa:	1b 87 a2 78 	addi %d7,%d7,-30168
8000f3ae:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000f3b2:	6d 00 0f 11 	call 800115d0 <__adddf3>
8000f3b6:	02 b4       	mov %d4,%d11
8000f3b8:	0b 23 10 88 	mov %e8,%d3,%d2
8000f3bc:	6d 00 44 13 	call 80011a44 <__floatsidf>
8000f3c0:	7b 30 fd 73 	movh %d7,16339
8000f3c4:	0b 23 10 48 	mov %e4,%d3,%d2
8000f3c8:	7b f0 09 65 	movh %d6,20639
8000f3cc:	1b 37 41 74 	addi %d7,%d7,17427
8000f3d0:	1b b6 9f 67 	addi %d6,%d6,31227
8000f3d4:	6d 00 3a 11 	call 80011648 <__muldf3>
8000f3d8:	0b 89 10 48 	mov %e4,%d9,%d8
8000f3dc:	0b 23 10 68 	mov %e6,%d3,%d2
8000f3e0:	6d 00 f8 10 	call 800115d0 <__adddf3>
8000f3e4:	0b 23 10 48 	mov %e4,%d3,%d2
8000f3e8:	0b 23 10 88 	mov %e8,%d3,%d2
8000f3ec:	6d 00 50 13 	call 80011a8c <__fixdfsi>
8000f3f0:	0b 89 10 48 	mov %e4,%d9,%d8
8000f3f4:	d2 06       	mov %e6,0
8000f3f6:	59 a2 08 00 	st.w [%sp]8,%d2
8000f3fa:	6d 00 05 13 	call 80011a04 <__ltdf2>
8000f3fe:	ff 02 12 00 	jge %d2,0,8000f422 <_dtoa_r+0x1ee>
8000f402:	19 a4 08 00 	ld.w %d4,[%sp]8
8000f406:	6d 00 1f 13 	call 80011a44 <__floatsidf>
8000f40a:	0b 89 10 48 	mov %e4,%d9,%d8
8000f40e:	0b 23 10 68 	mov %e6,%d3,%d2
8000f412:	6d 00 99 12 	call 80011944 <__nedf2>
8000f416:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f41a:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000f41e:	59 a3 08 00 	st.w [%sp]8,%d3
8000f422:	19 a2 08 00 	ld.w %d2,[%sp]8
8000f426:	82 13       	mov %d3,1
8000f428:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000f42c:	59 a3 3c 00 	st.w [%sp]60,%d3
8000f430:	ee 18       	jnz %d15,8000f460 <_dtoa_r+0x22c>
8000f432:	91 00 00 f8 	movh.a %a15,32768
8000f436:	d9 ff c4 40 	lea %a15,[%a15]3332 <80000d04 <__mprec_tens>>
8000f43a:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000f43e:	0b cd 10 68 	mov %e6,%d13,%d12
8000f442:	09 f4 40 09 	ld.d %e4,[%a15]
8000f446:	6d 00 9f 12 	call 80011984 <__gtdf2>
8000f44a:	8e 28       	jlez %d2,8000f45a <_dtoa_r+0x226>
8000f44c:	58 02       	ld.w %d15,[%sp]8
8000f44e:	82 02       	mov %d2,0
8000f450:	c2 ff       	add %d15,-1
8000f452:	78 02       	st.w [%sp]8,%d15
8000f454:	59 a2 3c 00 	st.w [%sp]60,%d2
8000f458:	3c 04       	j 8000f460 <_dtoa_r+0x22c>
8000f45a:	82 03       	mov %d3,0
8000f45c:	59 a3 3c 00 	st.w [%sp]60,%d3
8000f460:	0b ba 80 b0 	sub %d11,%d10,%d11
8000f464:	9a fb       	add %d15,%d11,-1
8000f466:	82 02       	mov %d2,0
8000f468:	78 06       	st.w [%sp]24,%d15
8000f46a:	59 a2 14 00 	st.w [%sp]20,%d2
8000f46e:	ce f6       	jgez %d15,8000f47a <_dtoa_r+0x246>
8000f470:	32 5f       	rsub %d15
8000f472:	82 03       	mov %d3,0
8000f474:	78 05       	st.w [%sp]20,%d15
8000f476:	59 a3 18 00 	st.w [%sp]24,%d3
8000f47a:	58 02       	ld.w %d15,[%sp]8
8000f47c:	0e fa       	jltz %d15,8000f490 <_dtoa_r+0x25c>
8000f47e:	19 a2 18 00 	ld.w %d2,[%sp]24
8000f482:	78 0d       	st.w [%sp]52,%d15
8000f484:	42 f2       	add %d2,%d15
8000f486:	82 0f       	mov %d15,0
8000f488:	59 a2 18 00 	st.w [%sp]24,%d2
8000f48c:	78 08       	st.w [%sp]32,%d15
8000f48e:	3c 0d       	j 8000f4a8 <_dtoa_r+0x274>
8000f490:	19 a2 14 00 	ld.w %d2,[%sp]20
8000f494:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f498:	82 0f       	mov %d15,0
8000f49a:	a2 32       	sub %d2,%d3
8000f49c:	32 53       	rsub %d3
8000f49e:	59 a2 14 00 	st.w [%sp]20,%d2
8000f4a2:	59 a3 20 00 	st.w [%sp]32,%d3
8000f4a6:	78 0d       	st.w [%sp]52,%d15
8000f4a8:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000f4ac:	82 18       	mov %d8,1
8000f4ae:	ff a2 46 80 	jge.u %d2,10,8000f53a <_dtoa_r+0x306>
8000f4b2:	bf 62 06 00 	jlt %d2,6,8000f4be <_dtoa_r+0x28a>
8000f4b6:	c2 c2       	add %d2,-4
8000f4b8:	59 a2 1c 00 	st.w [%sp]28,%d2
8000f4bc:	82 08       	mov %d8,0
8000f4be:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000f4c2:	c2 e3       	add %d3,-2
8000f4c4:	ff 43 4b 80 	jge.u %d3,4,8000f55a <_dtoa_r+0x326>
8000f4c8:	91 10 00 f8 	movh.a %a15,32769
8000f4cc:	d9 ff 58 3f 	lea %a15,[%a15]-2856 <8000f4d8 <_dtoa_r+0x2a4>>
8000f4d0:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000f4d4:	dc 0f       	ji %a15
8000f4d6:	00 00       	nop 
8000f4d8:	1d 00 08 00 	j 8000f4e8 <_dtoa_r+0x2b4>
8000f4dc:	1d 00 1c 00 	j 8000f514 <_dtoa_r+0x2e0>
8000f4e0:	1d 00 08 00 	j 8000f4f0 <_dtoa_r+0x2bc>
8000f4e4:	1d 00 1c 00 	j 8000f51c <_dtoa_r+0x2e8>
8000f4e8:	82 03       	mov %d3,0
8000f4ea:	59 a3 24 00 	st.w [%sp]36,%d3
8000f4ee:	3c 03       	j 8000f4f4 <_dtoa_r+0x2c0>
8000f4f0:	82 1f       	mov %d15,1
8000f4f2:	78 09       	st.w [%sp]36,%d15
8000f4f4:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f4f8:	59 a2 2c 00 	st.w [%sp]44,%d2
8000f4fc:	59 a2 10 00 	st.w [%sp]16,%d2
8000f500:	02 23       	mov %d3,%d2
8000f502:	ff 12 38 00 	jge %d2,1,8000f572 <_dtoa_r+0x33e>
8000f506:	82 13       	mov %d3,1
8000f508:	82 1f       	mov %d15,1
8000f50a:	59 a3 2c 00 	st.w [%sp]44,%d3
8000f50e:	78 04       	st.w [%sp]16,%d15
8000f510:	82 12       	mov %d2,1
8000f512:	3c 21       	j 8000f554 <_dtoa_r+0x320>
8000f514:	82 03       	mov %d3,0
8000f516:	59 a3 24 00 	st.w [%sp]36,%d3
8000f51a:	3c 03       	j 8000f520 <_dtoa_r+0x2ec>
8000f51c:	82 1f       	mov %d15,1
8000f51e:	78 09       	st.w [%sp]36,%d15
8000f520:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f524:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f528:	42 32       	add %d2,%d3
8000f52a:	59 a2 2c 00 	st.w [%sp]44,%d2
8000f52e:	c2 12       	add %d2,1
8000f530:	59 a2 10 00 	st.w [%sp]16,%d2
8000f534:	8b 12 40 33 	max %d3,%d2,1
8000f538:	3c 1d       	j 8000f572 <_dtoa_r+0x33e>
8000f53a:	82 0f       	mov %d15,0
8000f53c:	82 12       	mov %d2,1
8000f53e:	82 f3       	mov %d3,-1
8000f540:	78 07       	st.w [%sp]28,%d15
8000f542:	82 ff       	mov %d15,-1
8000f544:	59 a2 24 00 	st.w [%sp]36,%d2
8000f548:	59 a3 2c 00 	st.w [%sp]44,%d3
8000f54c:	78 04       	st.w [%sp]16,%d15
8000f54e:	3b 20 01 30 	mov %d3,18
8000f552:	82 02       	mov %d2,0
8000f554:	59 a2 28 00 	st.w [%sp]40,%d2
8000f558:	3c 0d       	j 8000f572 <_dtoa_r+0x33e>
8000f55a:	82 ff       	mov %d15,-1
8000f55c:	82 13       	mov %d3,1
8000f55e:	78 0b       	st.w [%sp]44,%d15
8000f560:	82 f2       	mov %d2,-1
8000f562:	82 0f       	mov %d15,0
8000f564:	59 a3 24 00 	st.w [%sp]36,%d3
8000f568:	59 a2 10 00 	st.w [%sp]16,%d2
8000f56c:	3b 20 01 30 	mov %d3,18
8000f570:	78 0a       	st.w [%sp]40,%d15
8000f572:	82 05       	mov %d5,0
8000f574:	59 d5 04 10 	st.w [%a13]68,%d5
8000f578:	82 45       	mov %d5,4
8000f57a:	1b 45 01 00 	addi %d0,%d5,20
8000f57e:	3f 03 09 80 	jlt.u %d3,%d0,8000f590 <_dtoa_r+0x35c>
8000f582:	19 d0 04 10 	ld.w %d0,[%a13]68
8000f586:	06 15       	sh %d5,1
8000f588:	c2 10       	add %d0,1
8000f58a:	59 d0 04 10 	st.w [%a13]68,%d0
8000f58e:	3c f6       	j 8000f57a <_dtoa_r+0x346>
8000f590:	40 d4       	mov.aa %a4,%a13
8000f592:	19 d4 04 10 	ld.w %d4,[%a13]68
8000f596:	6d 00 27 07 	call 800103e4 <_Balloc>
8000f59a:	19 a2 10 00 	ld.w %d2,[%sp]16
8000f59e:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000f5a2:	8b f2 60 32 	lt.u %d3,%d2,15
8000f5a6:	b5 d2 00 10 	st.a [%a13]64,%a2
8000f5aa:	26 38       	and %d8,%d3
8000f5ac:	df 08 97 01 	jeq %d8,0,8000f8da <_dtoa_r+0x6a6>
8000f5b0:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f5b4:	89 ac 40 19 	st.d [%sp]64,%e12
8000f5b8:	bf 13 3f 00 	jlt %d3,1,8000f636 <_dtoa_r+0x402>
8000f5bc:	91 00 00 f8 	movh.a %a15,32768
8000f5c0:	8f f3 00 31 	and %d3,%d3,15
8000f5c4:	d9 ff c4 40 	lea %a15,[%a15]3332 <80000d04 <__mprec_tens>>
8000f5c8:	19 ae 08 00 	ld.w %d14,[%sp]8 <80000d04 <__mprec_tens>>
8000f5cc:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000f5d0:	86 ce       	sha %d14,-4
8000f5d2:	09 f8 40 09 	ld.d %e8,[%a15]
8000f5d6:	82 2a       	mov %d10,2
8000f5d8:	6f 4e 11 00 	jz.t %d14,4,8000f5fa <_dtoa_r+0x3c6>
8000f5dc:	91 00 00 f8 	movh.a %a15,32768
8000f5e0:	0b cd 10 48 	mov %e4,%d13,%d12
8000f5e4:	d9 ff dc 30 	lea %a15,[%a15]3292 <80000cdc <__mprec_bigtens>>
8000f5e8:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000f5ec:	6d 00 00 11 	call 800117ec <__divdf3>
8000f5f0:	0b 23 10 c8 	mov %e12,%d3,%d2
8000f5f4:	8f fe 00 e1 	and %d14,%d14,15
8000f5f8:	82 3a       	mov %d10,3
8000f5fa:	7b 00 00 b8 	movh %d11,32768
8000f5fe:	82 0f       	mov %d15,0
8000f600:	1b cb cd b0 	addi %d11,%d11,3292
8000f604:	df 0e 12 00 	jeq %d14,0,8000f628 <_dtoa_r+0x3f4>
8000f608:	6f 0e 0d 00 	jz.t %d14,0,8000f622 <_dtoa_r+0x3ee>
8000f60c:	60 b2       	mov.a %a2,%d11
8000f60e:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000f610:	0b 89 10 48 	mov %e4,%d9,%d8
8000f614:	09 f6 40 09 	ld.d %e6,[%a15]
8000f618:	6d 00 18 10 	call 80011648 <__muldf3>
8000f61c:	0b 23 10 88 	mov %e8,%d3,%d2
8000f620:	c2 1a       	add %d10,1
8000f622:	86 fe       	sha %d14,-1
8000f624:	c2 1f       	add %d15,1
8000f626:	3c ef       	j 8000f604 <_dtoa_r+0x3d0>
8000f628:	0b cd 10 48 	mov %e4,%d13,%d12
8000f62c:	0b 89 10 68 	mov %e6,%d9,%d8
8000f630:	6d 00 de 10 	call 800117ec <__divdf3>
8000f634:	3c 2c       	j 8000f68c <_dtoa_r+0x458>
8000f636:	19 a8 08 00 	ld.w %d8,[%sp]8
8000f63a:	82 2a       	mov %d10,2
8000f63c:	32 58       	rsub %d8
8000f63e:	df 08 29 00 	jeq %d8,0,8000f690 <_dtoa_r+0x45c>
8000f642:	91 00 00 f8 	movh.a %a15,32768
8000f646:	8f f8 00 31 	and %d3,%d8,15
8000f64a:	d9 ff c4 40 	lea %a15,[%a15]3332 <80000d04 <__mprec_tens>>
8000f64e:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000f652:	09 a4 40 19 	ld.d %e4,[%sp]64
8000f656:	09 f6 40 09 	ld.d %e6,[%a15]
8000f65a:	7b 00 00 c8 	movh %d12,32768
8000f65e:	6d 00 f5 0f 	call 80011648 <__muldf3>
8000f662:	82 09       	mov %d9,0
8000f664:	86 c8       	sha %d8,-4
8000f666:	1b cc cd c0 	addi %d12,%d12,3292
8000f66a:	df 08 11 00 	jeq %d8,0,8000f68c <_dtoa_r+0x458>
8000f66e:	6f 08 0c 00 	jz.t %d8,0,8000f686 <_dtoa_r+0x452>
8000f672:	60 c3       	mov.a %a3,%d12
8000f674:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000f678:	0b 23 10 48 	mov %e4,%d3,%d2
8000f67c:	09 f6 40 09 	ld.d %e6,[%a15]
8000f680:	c2 1a       	add %d10,1
8000f682:	6d 00 e3 0f 	call 80011648 <__muldf3>
8000f686:	86 f8       	sha %d8,-1
8000f688:	c2 19       	add %d9,1
8000f68a:	3c f0       	j 8000f66a <_dtoa_r+0x436>
8000f68c:	0b 23 10 c8 	mov %e12,%d3,%d2
8000f690:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000f694:	df 02 23 00 	jeq %d2,0,8000f6da <_dtoa_r+0x4a6>
8000f698:	0b cd 10 48 	mov %e4,%d13,%d12
8000f69c:	b7 00 2a 6a 	imask %e6,0,20,10
8000f6a0:	6d 00 b2 11 	call 80011a04 <__ltdf2>
8000f6a4:	ff 02 20 00 	jge %d2,0,8000f6e4 <_dtoa_r+0x4b0>
8000f6a8:	19 a3 10 00 	ld.w %d3,[%sp]16
8000f6ac:	df 03 21 00 	jeq %d3,0,8000f6ee <_dtoa_r+0x4ba>
8000f6b0:	58 0b       	ld.w %d15,[%sp]44
8000f6b2:	bf 1f 12 01 	jlt %d15,1,8000f8d6 <_dtoa_r+0x6a2>
8000f6b6:	19 a2 08 00 	ld.w %d2,[%sp]8
8000f6ba:	0b cd 10 48 	mov %e4,%d13,%d12
8000f6be:	c2 f2       	add %d2,-1
8000f6c0:	82 06       	mov %d6,0
8000f6c2:	7b 40 02 74 	movh %d7,16420
8000f6c6:	59 a2 30 00 	st.w [%sp]48,%d2
8000f6ca:	6d 00 bf 0f 	call 80011648 <__muldf3>
8000f6ce:	c2 1a       	add %d10,1
8000f6d0:	0b 23 10 c8 	mov %e12,%d3,%d2
8000f6d4:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000f6d8:	3c 10       	j 8000f6f8 <_dtoa_r+0x4c4>
8000f6da:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f6de:	59 a3 30 00 	st.w [%sp]48,%d3
8000f6e2:	3c 03       	j 8000f6e8 <_dtoa_r+0x4b4>
8000f6e4:	58 02       	ld.w %d15,[%sp]8
8000f6e6:	78 0c       	st.w [%sp]48,%d15
8000f6e8:	99 ac 10 00 	ld.a %a12,[%sp]16
8000f6ec:	3c 06       	j 8000f6f8 <_dtoa_r+0x4c4>
8000f6ee:	19 a2 08 00 	ld.w %d2,[%sp]8
8000f6f2:	a0 0c       	mov.a %a12,0
8000f6f4:	59 a2 30 00 	st.w [%sp]48,%d2
8000f6f8:	02 a4       	mov %d4,%d10
8000f6fa:	6d 00 a5 11 	call 80011a44 <__floatsidf>
8000f6fe:	0b cd 10 68 	mov %e6,%d13,%d12
8000f702:	0b 23 10 48 	mov %e4,%d3,%d2
8000f706:	6d 00 a1 0f 	call 80011648 <__muldf3>
8000f70a:	0b 23 10 48 	mov %e4,%d3,%d2
8000f70e:	82 06       	mov %d6,0
8000f710:	7b c0 01 74 	movh %d7,16412
8000f714:	6d 00 5e 0f 	call 800115d0 <__adddf3>
8000f718:	0b 23 10 a8 	mov %e10,%d3,%d2
8000f71c:	0b 23 10 e8 	mov %e14,%d3,%d2
8000f720:	60 b2       	mov.a %a2,%d11
8000f722:	11 02 cc ff 	addih.a %a15,%a2,64704
8000f726:	80 ff       	mov.d %d15,%a15
8000f728:	bd 0c 1e 80 	jnz.a %a12,8000f764 <_dtoa_r+0x530>
8000f72c:	0b cd 10 48 	mov %e4,%d13,%d12
8000f730:	82 06       	mov %d6,0
8000f732:	7b 40 01 74 	movh %d7,16404
8000f736:	6d 00 69 0f 	call 80011608 <__subdf3>
8000f73a:	80 f7       	mov.d %d7,%a15
8000f73c:	0b 23 10 48 	mov %e4,%d3,%d2
8000f740:	02 e6       	mov %d6,%d14
8000f742:	0b 23 10 88 	mov %e8,%d3,%d2
8000f746:	6d 00 1f 11 	call 80011984 <__gtdf2>
8000f74a:	ff 12 8e 02 	jge %d2,1,8000fc66 <_dtoa_r+0xa32>
8000f74e:	0b 89 10 48 	mov %e4,%d9,%d8
8000f752:	02 e6       	mov %d6,%d14
8000f754:	9b 0b cc 77 	addih %d7,%d11,31936
8000f758:	6d 00 56 11 	call 80011a04 <__ltdf2>
8000f75c:	bf 02 7d 02 	jlt %d2,0,8000fc56 <_dtoa_r+0xa22>
8000f760:	1d 00 bb 00 	j 8000f8d6 <_dtoa_r+0x6a2>
8000f764:	80 c5       	mov.d %d5,%a12
8000f766:	91 00 00 f8 	movh.a %a15,32768
8000f76a:	19 a2 24 00 	ld.w %d2,[%sp]36
8000f76e:	d9 ff c4 40 	lea %a15,[%a15]3332 <80000d04 <__mprec_tens>>
8000f772:	c2 f5       	add %d5,-1
8000f774:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000f778:	df 02 57 00 	jeq %d2,0,8000f826 <_dtoa_r+0x5f2>
8000f77c:	b7 00 a9 4a 	imask %e4,0,21,9
8000f780:	09 f6 40 09 	ld.d %e6,[%a15]
8000f784:	6d 00 34 10 	call 800117ec <__divdf3>
8000f788:	0b ef 10 68 	mov %e6,%d15,%d14
8000f78c:	0b 23 10 48 	mov %e4,%d3,%d2
8000f790:	6d 00 3c 0f 	call 80011608 <__subdf3>
8000f794:	d8 03       	ld.a %a15,[%sp]12
8000f796:	0b 23 10 a8 	mov %e10,%d3,%d2
8000f79a:	0b cd 10 48 	mov %e4,%d13,%d12
8000f79e:	80 fe       	mov.d %d14,%a15
8000f7a0:	6d 00 76 11 	call 80011a8c <__fixdfsi>
8000f7a4:	02 24       	mov %d4,%d2
8000f7a6:	02 2f       	mov %d15,%d2
8000f7a8:	6d 00 4e 11 	call 80011a44 <__floatsidf>
8000f7ac:	0b cd 10 48 	mov %e4,%d13,%d12
8000f7b0:	0b 23 10 68 	mov %e6,%d3,%d2
8000f7b4:	c2 1e       	add %d14,1
8000f7b6:	6d 00 29 0f 	call 80011608 <__subdf3>
8000f7ba:	1b 0f 03 50 	addi %d5,%d15,48
8000f7be:	28 05       	st.b [%a15]0,%d5
8000f7c0:	0b ab 10 68 	mov %e6,%d11,%d10
8000f7c4:	0b 23 10 48 	mov %e4,%d3,%d2
8000f7c8:	0b 23 10 88 	mov %e8,%d3,%d2
8000f7cc:	6d 00 1c 11 	call 80011a04 <__ltdf2>
8000f7d0:	bf 02 86 03 	jlt %d2,0,8000fedc <_dtoa_r+0xca8>
8000f7d4:	b7 00 2a 4a 	imask %e4,0,20,10
8000f7d8:	0b 89 10 68 	mov %e6,%d9,%d8
8000f7dc:	6d 00 16 0f 	call 80011608 <__subdf3>
8000f7e0:	0b ab 10 68 	mov %e6,%d11,%d10
8000f7e4:	0b 23 10 48 	mov %e4,%d3,%d2
8000f7e8:	6d 00 0e 11 	call 80011a04 <__ltdf2>
8000f7ec:	bf 02 ea 00 	jlt %d2,0,8000f9c0 <_dtoa_r+0x78c>
8000f7f0:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000f7f4:	02 e5       	mov %d5,%d14
8000f7f6:	80 cf       	mov.d %d15,%a12
8000f7f8:	a2 35       	sub %d5,%d3
8000f7fa:	7f f5 6e 00 	jge %d5,%d15,8000f8d6 <_dtoa_r+0x6a2>
8000f7fe:	0b ab 10 48 	mov %e4,%d11,%d10
8000f802:	82 06       	mov %d6,0
8000f804:	7b 40 02 74 	movh %d7,16420
8000f808:	6d 00 20 0f 	call 80011648 <__muldf3>
8000f80c:	0b 89 10 48 	mov %e4,%d9,%d8
8000f810:	82 06       	mov %d6,0
8000f812:	7b 40 02 74 	movh %d7,16420
8000f816:	0b 23 10 a8 	mov %e10,%d3,%d2
8000f81a:	6d 00 17 0f 	call 80011648 <__muldf3>
8000f81e:	60 ef       	mov.a %a15,%d14
8000f820:	0b 23 10 c8 	mov %e12,%d3,%d2
8000f824:	3c bb       	j 8000f79a <_dtoa_r+0x566>
8000f826:	0b ef 10 68 	mov %e6,%d15,%d14
8000f82a:	09 f4 40 09 	ld.d %e4,[%a15]
8000f82e:	6d 00 0d 0f 	call 80011648 <__muldf3>
8000f832:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000f836:	0b 23 10 a8 	mov %e10,%d3,%d2
8000f83a:	30 c3       	add.a %a3,%a12
8000f83c:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000f840:	80 3e       	mov.d %d14,%a3
8000f842:	0b cd 10 48 	mov %e4,%d13,%d12
8000f846:	d9 cf 01 00 	lea %a15,[%a12]1
8000f84a:	6d 00 21 11 	call 80011a8c <__fixdfsi>
8000f84e:	02 24       	mov %d4,%d2
8000f850:	02 2f       	mov %d15,%d2
8000f852:	6d 00 f9 10 	call 80011a44 <__floatsidf>
8000f856:	0b cd 10 48 	mov %e4,%d13,%d12
8000f85a:	0b 23 10 68 	mov %e6,%d3,%d2
8000f85e:	6d 00 d5 0e 	call 80011608 <__subdf3>
8000f862:	1b 0f 03 50 	addi %d5,%d15,48
8000f866:	0b 23 10 88 	mov %e8,%d3,%d2
8000f86a:	80 f2       	mov.d %d2,%a15
8000f86c:	34 c5       	st.b [%a12],%d5
8000f86e:	5f e2 29 80 	jne %d2,%d14,8000f8c0 <_dtoa_r+0x68c>
8000f872:	0b ab 10 48 	mov %e4,%d11,%d10
8000f876:	b7 00 a9 6a 	imask %e6,0,21,9
8000f87a:	6d 00 ab 0e 	call 800115d0 <__adddf3>
8000f87e:	0b 89 10 48 	mov %e4,%d9,%d8
8000f882:	0b 23 10 68 	mov %e6,%d3,%d2
8000f886:	6d 00 7f 10 	call 80011984 <__gtdf2>
8000f88a:	ff 12 9b 00 	jge %d2,1,8000f9c0 <_dtoa_r+0x78c>
8000f88e:	b7 00 a9 4a 	imask %e4,0,21,9
8000f892:	0b ab 10 68 	mov %e6,%d11,%d10
8000f896:	6d 00 b9 0e 	call 80011608 <__subdf3>
8000f89a:	0b 89 10 48 	mov %e4,%d9,%d8
8000f89e:	0b 23 10 68 	mov %e6,%d3,%d2
8000f8a2:	6d 00 b1 10 	call 80011a04 <__ltdf2>
8000f8a6:	ff 02 18 00 	jge %d2,0,8000f8d6 <_dtoa_r+0x6a2>
8000f8aa:	60 e2       	mov.a %a2,%d14
8000f8ac:	60 ef       	mov.a %a15,%d14
8000f8ae:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000f8b2:	b0 ff       	add.a %a15,-1
8000f8b4:	8b 0f 03 f2 	eq %d15,%d15,48
8000f8b8:	df 0f 12 03 	jeq %d15,0,8000fedc <_dtoa_r+0xca8>
8000f8bc:	80 fe       	mov.d %d14,%a15
8000f8be:	3c f6       	j 8000f8aa <_dtoa_r+0x676>
8000f8c0:	0b 89 10 48 	mov %e4,%d9,%d8
8000f8c4:	82 06       	mov %d6,0
8000f8c6:	7b 40 02 74 	movh %d7,16420
8000f8ca:	6d 00 bf 0e 	call 80011648 <__muldf3>
8000f8ce:	40 fc       	mov.aa %a12,%a15
8000f8d0:	0b 23 10 c8 	mov %e12,%d3,%d2
8000f8d4:	3c b7       	j 8000f842 <_dtoa_r+0x60e>
8000f8d6:	09 ac 40 19 	ld.d %e12,[%sp]64
8000f8da:	19 a3 14 10 	ld.w %d3,[%sp]84
8000f8de:	19 a2 08 00 	ld.w %d2,[%sp]8
8000f8e2:	8b 03 80 52 	ge %d5,%d3,0
8000f8e6:	8b f2 40 54 	and.lt %d5,%d2,15
8000f8ea:	df 05 9e 00 	jeq %d5,0,8000fa26 <_dtoa_r+0x7f2>
8000f8ee:	91 00 00 f8 	movh.a %a15,32768
8000f8f2:	d9 ff c4 40 	lea %a15,[%a15]3332 <80000d04 <__mprec_tens>>
8000f8f6:	19 a3 10 00 	ld.w %d3,[%sp]16 <80000d04 <__mprec_tens>>
8000f8fa:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000f8fe:	19 a2 28 00 	ld.w %d2,[%sp]40
8000f902:	fa 13       	lt %d15,%d3,1
8000f904:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000f908:	09 f8 40 09 	ld.d %e8,[%a15]
8000f90c:	6e 16       	jz %d15,8000f938 <_dtoa_r+0x704>
8000f90e:	df 03 a4 81 	jne %d3,0,8000fc56 <_dtoa_r+0xa22>
8000f912:	0b 89 10 48 	mov %e4,%d9,%d8
8000f916:	82 06       	mov %d6,0
8000f918:	7b 40 01 74 	movh %d7,16404
8000f91c:	6d 00 96 0e 	call 80011648 <__muldf3>
8000f920:	0b cd 10 68 	mov %e6,%d13,%d12
8000f924:	0b 23 10 48 	mov %e4,%d3,%d2
8000f928:	a0 0c       	mov.a %a12,0
8000f92a:	6d 00 4d 10 	call 800119c4 <__gedf2>
8000f92e:	a0 0f       	mov.a %a15,0
8000f930:	ff 02 95 01 	jge %d2,0,8000fc5a <_dtoa_r+0xa26>
8000f934:	1d 00 9d 01 	j 8000fc6e <_dtoa_r+0xa3a>
8000f938:	d8 03       	ld.a %a15,[%sp]12
8000f93a:	0b cd 10 a8 	mov %e10,%d13,%d12
8000f93e:	0b 89 10 68 	mov %e6,%d9,%d8
8000f942:	0b ab 10 48 	mov %e4,%d11,%d10
8000f946:	80 fe       	mov.d %d14,%a15
8000f948:	6d 00 52 0f 	call 800117ec <__divdf3>
8000f94c:	0b 23 10 48 	mov %e4,%d3,%d2
8000f950:	c2 1e       	add %d14,1
8000f952:	6d 00 9d 10 	call 80011a8c <__fixdfsi>
8000f956:	02 24       	mov %d4,%d2
8000f958:	02 2f       	mov %d15,%d2
8000f95a:	6d 00 75 10 	call 80011a44 <__floatsidf>
8000f95e:	0b 89 10 68 	mov %e6,%d9,%d8
8000f962:	0b 23 10 48 	mov %e4,%d3,%d2
8000f966:	6d 00 71 0e 	call 80011648 <__muldf3>
8000f96a:	0b ab 10 48 	mov %e4,%d11,%d10
8000f96e:	0b 23 10 68 	mov %e6,%d3,%d2
8000f972:	6d 00 4b 0e 	call 80011608 <__subdf3>
8000f976:	0b 23 10 48 	mov %e4,%d3,%d2
8000f97a:	1b 0f 03 30 	addi %d3,%d15,48
8000f97e:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000f982:	28 03       	st.b [%a15]0,%d3
8000f984:	02 e3       	mov %d3,%d14
8000f986:	a2 23       	sub %d3,%d2
8000f988:	19 a2 10 00 	ld.w %d2,[%sp]16
8000f98c:	5f 23 3c 80 	jne %d3,%d2,8000fa04 <_dtoa_r+0x7d0>
8000f990:	0b 45 10 68 	mov %e6,%d5,%d4
8000f994:	6d 00 1e 0e 	call 800115d0 <__adddf3>
8000f998:	0b 89 10 68 	mov %e6,%d9,%d8
8000f99c:	0b 23 10 48 	mov %e4,%d3,%d2
8000f9a0:	0b 23 10 a8 	mov %e10,%d3,%d2
8000f9a4:	6d 00 f0 0f 	call 80011984 <__gtdf2>
8000f9a8:	4e 2e       	jgtz %d2,8000f9c4 <_dtoa_r+0x790>
8000f9aa:	0b ab 10 48 	mov %e4,%d11,%d10
8000f9ae:	0b 89 10 68 	mov %e6,%d9,%d8
8000f9b2:	6d 00 a9 0f 	call 80011904 <__eqdf2>
8000f9b6:	df 02 95 82 	jne %d2,0,8000fee0 <_dtoa_r+0xcac>
8000f9ba:	ae 05       	jnz.t %d15,0,8000f9c4 <_dtoa_r+0x790>
8000f9bc:	1d 00 92 02 	j 8000fee0 <_dtoa_r+0xcac>
8000f9c0:	58 0c       	ld.w %d15,[%sp]48
8000f9c2:	78 02       	st.w [%sp]8,%d15
8000f9c4:	58 03       	ld.w %d15,[%sp]12
8000f9c6:	a2 ef       	sub %d15,%d14
8000f9c8:	46 0f       	not %d15
8000f9ca:	60 e2       	mov.a %a2,%d14
8000f9cc:	60 ef       	mov.a %a15,%d14
8000f9ce:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000f9d2:	b0 ff       	add.a %a15,-1
8000f9d4:	8b 93 03 32 	eq %d3,%d3,57
8000f9d8:	df 03 11 00 	jeq %d3,0,8000f9fa <_dtoa_r+0x7c6>
8000f9dc:	9f 0f 0d 80 	jned %d15,0,8000f9f6 <_dtoa_r+0x7c2>
8000f9e0:	19 a3 08 00 	ld.w %d3,[%sp]8
8000f9e4:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000f9e8:	c2 13       	add %d3,1
8000f9ea:	da 30       	mov %d15,48
8000f9ec:	59 a3 08 00 	st.w [%sp]8,%d3
8000f9f0:	2c 30       	st.b [%a3]0,%d15
8000f9f2:	40 3f       	mov.aa %a15,%a3
8000f9f4:	3c 03       	j 8000f9fa <_dtoa_r+0x7c6>
8000f9f6:	80 fe       	mov.d %d14,%a15
8000f9f8:	3c e9       	j 8000f9ca <_dtoa_r+0x796>
8000f9fa:	0c f0       	ld.bu %d15,[%a15]0
8000f9fc:	c2 1f       	add %d15,1
8000f9fe:	28 0f       	st.b [%a15]0,%d15
8000fa00:	1d 00 70 02 	j 8000fee0 <_dtoa_r+0xcac>
8000fa04:	82 06       	mov %d6,0
8000fa06:	7b 40 02 74 	movh %d7,16420
8000fa0a:	6d 00 1f 0e 	call 80011648 <__muldf3>
8000fa0e:	d2 06       	mov %e6,0
8000fa10:	0b 23 10 48 	mov %e4,%d3,%d2
8000fa14:	0b 23 10 a8 	mov %e10,%d3,%d2
8000fa18:	60 ef       	mov.a %a15,%d14
8000fa1a:	6d 00 75 0f 	call 80011904 <__eqdf2>
8000fa1e:	df 02 90 ff 	jne %d2,0,8000f93e <_dtoa_r+0x70a>
8000fa22:	1d 00 5f 02 	j 8000fee0 <_dtoa_r+0xcac>
8000fa26:	19 a2 24 00 	ld.w %d2,[%sp]36
8000fa2a:	58 08       	ld.w %d15,[%sp]32
8000fa2c:	19 a8 14 00 	ld.w %d8,[%sp]20
8000fa30:	a0 0f       	mov.a %a15,0
8000fa32:	df 02 3b 00 	jeq %d2,0,8000faa8 <_dtoa_r+0x874>
8000fa36:	58 07       	ld.w %d15,[%sp]28
8000fa38:	ff 2f 10 00 	jge %d15,2,8000fa58 <_dtoa_r+0x824>
8000fa3c:	58 13       	ld.w %d15,[%sp]76
8000fa3e:	6e 05       	jz %d15,8000fa48 <_dtoa_r+0x814>
8000fa40:	1b 33 43 30 	addi %d3,%d3,1075
8000fa44:	58 08       	ld.w %d15,[%sp]32
8000fa46:	3c 22       	j 8000fa8a <_dtoa_r+0x856>
8000fa48:	19 a3 10 10 	ld.w %d3,[%sp]80
8000fa4c:	58 08       	ld.w %d15,[%sp]32
8000fa4e:	8b 63 03 31 	rsub %d3,%d3,54
8000fa52:	19 a8 14 00 	ld.w %d8,[%sp]20
8000fa56:	3c 1a       	j 8000fa8a <_dtoa_r+0x856>
8000fa58:	58 04       	ld.w %d15,[%sp]16
8000fa5a:	19 a2 20 00 	ld.w %d2,[%sp]32
8000fa5e:	c2 ff       	add %d15,-1
8000fa60:	3f f2 04 00 	jlt %d2,%d15,8000fa68 <_dtoa_r+0x834>
8000fa64:	5a f2       	sub %d15,%d2,%d15
8000fa66:	3c 0b       	j 8000fa7c <_dtoa_r+0x848>
8000fa68:	19 a3 20 00 	ld.w %d3,[%sp]32
8000fa6c:	78 08       	st.w [%sp]32,%d15
8000fa6e:	52 32       	sub %d2,%d15,%d3
8000fa70:	19 a3 34 00 	ld.w %d3,[%sp]52
8000fa74:	82 0f       	mov %d15,0
8000fa76:	42 23       	add %d3,%d2
8000fa78:	59 a3 34 00 	st.w [%sp]52,%d3
8000fa7c:	19 a3 10 00 	ld.w %d3,[%sp]16
8000fa80:	19 a8 14 00 	ld.w %d8,[%sp]20
8000fa84:	ce 33       	jgez %d3,8000fa8a <_dtoa_r+0x856>
8000fa86:	a2 38       	sub %d8,%d3
8000fa88:	82 03       	mov %d3,0
8000fa8a:	19 a2 14 00 	ld.w %d2,[%sp]20
8000fa8e:	40 d4       	mov.aa %a4,%a13
8000fa90:	42 32       	add %d2,%d3
8000fa92:	59 a2 14 00 	st.w [%sp]20,%d2
8000fa96:	19 a2 18 00 	ld.w %d2,[%sp]24
8000fa9a:	82 14       	mov %d4,1
8000fa9c:	42 32       	add %d2,%d3
8000fa9e:	59 a2 18 00 	st.w [%sp]24,%d2
8000faa2:	6d 00 6a 05 	call 80010576 <__i2b>
8000faa6:	40 2f       	mov.aa %a15,%a2
8000faa8:	19 a2 18 00 	ld.w %d2,[%sp]24
8000faac:	8b 18 80 32 	ge %d3,%d8,1
8000fab0:	8b 12 80 34 	and.ge %d3,%d2,1
8000fab4:	76 3e       	jz %d3,8000fad0 <_dtoa_r+0x89c>
8000fab6:	0b 82 80 31 	min %d3,%d2,%d8
8000faba:	19 a2 14 00 	ld.w %d2,[%sp]20
8000fabe:	a2 38       	sub %d8,%d3
8000fac0:	a2 32       	sub %d2,%d3
8000fac2:	59 a2 14 00 	st.w [%sp]20,%d2
8000fac6:	19 a2 18 00 	ld.w %d2,[%sp]24
8000faca:	a2 32       	sub %d2,%d3
8000facc:	59 a2 18 00 	st.w [%sp]24,%d2
8000fad0:	19 a3 20 00 	ld.w %d3,[%sp]32
8000fad4:	bf 13 27 00 	jlt %d3,1,8000fb22 <_dtoa_r+0x8ee>
8000fad8:	19 a2 24 00 	ld.w %d2,[%sp]36
8000fadc:	df 02 1c 00 	jeq %d2,0,8000fb14 <_dtoa_r+0x8e0>
8000fae0:	bf 1f 13 00 	jlt %d15,1,8000fb06 <_dtoa_r+0x8d2>
8000fae4:	40 f5       	mov.aa %a5,%a15
8000fae6:	02 f4       	mov %d4,%d15
8000fae8:	40 d4       	mov.aa %a4,%a13
8000faea:	6d 00 db 05 	call 800106a0 <__pow5mult>
8000faee:	40 e6       	mov.aa %a6,%a14
8000faf0:	40 d4       	mov.aa %a4,%a13
8000faf2:	40 25       	mov.aa %a5,%a2
8000faf4:	40 2f       	mov.aa %a15,%a2
8000faf6:	6d 00 48 05 	call 80010586 <__multiply>
8000fafa:	40 e5       	mov.aa %a5,%a14
8000fafc:	40 2c       	mov.aa %a12,%a2
8000fafe:	40 d4       	mov.aa %a4,%a13
8000fb00:	6d 00 9d 04 	call 8001043a <_Bfree>
8000fb04:	40 ce       	mov.aa %a14,%a12
8000fb06:	19 a4 20 00 	ld.w %d4,[%sp]32
8000fb0a:	40 d4       	mov.aa %a4,%a13
8000fb0c:	a2 f4       	sub %d4,%d15
8000fb0e:	40 e5       	mov.aa %a5,%a14
8000fb10:	76 49       	jz %d4,8000fb22 <_dtoa_r+0x8ee>
8000fb12:	3c 05       	j 8000fb1c <_dtoa_r+0x8e8>
8000fb14:	19 a4 20 00 	ld.w %d4,[%sp]32
8000fb18:	40 d4       	mov.aa %a4,%a13
8000fb1a:	40 e5       	mov.aa %a5,%a14
8000fb1c:	6d 00 c2 05 	call 800106a0 <__pow5mult>
8000fb20:	40 2e       	mov.aa %a14,%a2
8000fb22:	40 d4       	mov.aa %a4,%a13
8000fb24:	82 14       	mov %d4,1
8000fb26:	6d 00 28 05 	call 80010576 <__i2b>
8000fb2a:	19 a3 34 00 	ld.w %d3,[%sp]52
8000fb2e:	40 2c       	mov.aa %a12,%a2
8000fb30:	8e 3c       	jlez %d3,8000fb48 <_dtoa_r+0x914>
8000fb32:	40 d4       	mov.aa %a4,%a13
8000fb34:	40 25       	mov.aa %a5,%a2
8000fb36:	02 34       	mov %d4,%d3
8000fb38:	6d 00 b4 05 	call 800106a0 <__pow5mult>
8000fb3c:	58 07       	ld.w %d15,[%sp]28
8000fb3e:	40 2c       	mov.aa %a12,%a2
8000fb40:	82 09       	mov %d9,0
8000fb42:	ff 2f 1f 00 	jge %d15,2,8000fb80 <_dtoa_r+0x94c>
8000fb46:	3c 06       	j 8000fb52 <_dtoa_r+0x91e>
8000fb48:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000fb4c:	82 09       	mov %d9,0
8000fb4e:	ff 22 15 00 	jge %d2,2,8000fb78 <_dtoa_r+0x944>
8000fb52:	82 09       	mov %d9,0
8000fb54:	df 0c 12 80 	jne %d12,0,8000fb78 <_dtoa_r+0x944>
8000fb58:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000fb5c:	ee 0e       	jnz %d15,8000fb78 <_dtoa_r+0x944>
8000fb5e:	7b 00 ff f7 	movh %d15,32752
8000fb62:	26 df       	and %d15,%d13
8000fb64:	6e 0a       	jz %d15,8000fb78 <_dtoa_r+0x944>
8000fb66:	19 a3 14 00 	ld.w %d3,[%sp]20
8000fb6a:	58 06       	ld.w %d15,[%sp]24
8000fb6c:	c2 13       	add %d3,1
8000fb6e:	c2 1f       	add %d15,1
8000fb70:	59 a3 14 00 	st.w [%sp]20,%d3
8000fb74:	78 06       	st.w [%sp]24,%d15
8000fb76:	82 19       	mov %d9,1
8000fb78:	19 a3 34 00 	ld.w %d3,[%sp]52
8000fb7c:	82 12       	mov %d2,1
8000fb7e:	76 39       	jz %d3,8000fb90 <_dtoa_r+0x95c>
8000fb80:	4c c4       	ld.w %d15,[%a12]16
8000fb82:	90 c3       	addsc.a %a3,%a12,%d15,2
8000fb84:	19 34 10 00 	ld.w %d4,[%a3]16
8000fb88:	6d 00 a3 04 	call 800104ce <__hi0bits>
8000fb8c:	8b 02 02 21 	rsub %d2,%d2,32
8000fb90:	58 06       	ld.w %d15,[%sp]24
8000fb92:	42 2f       	add %d15,%d2
8000fb94:	16 1f       	and %d15,31
8000fb96:	6e 0a       	jz %d15,8000fbaa <_dtoa_r+0x976>
8000fb98:	8b 0f 02 31 	rsub %d3,%d15,32
8000fb9c:	8b cf 01 f1 	rsub %d15,%d15,28
8000fba0:	ff 53 07 00 	jge %d3,5,8000fbae <_dtoa_r+0x97a>
8000fba4:	df 43 10 00 	jeq %d3,4,8000fbc4 <_dtoa_r+0x990>
8000fba8:	02 3f       	mov %d15,%d3
8000fbaa:	1b cf 01 f0 	addi %d15,%d15,28
8000fbae:	19 a2 14 00 	ld.w %d2,[%sp]20
8000fbb2:	19 a3 18 00 	ld.w %d3,[%sp]24
8000fbb6:	42 f2       	add %d2,%d15
8000fbb8:	42 f3       	add %d3,%d15
8000fbba:	59 a2 14 00 	st.w [%sp]20,%d2
8000fbbe:	42 f8       	add %d8,%d15
8000fbc0:	59 a3 18 00 	st.w [%sp]24,%d3
8000fbc4:	58 05       	ld.w %d15,[%sp]20
8000fbc6:	8e f7       	jlez %d15,8000fbd4 <_dtoa_r+0x9a0>
8000fbc8:	40 e5       	mov.aa %a5,%a14
8000fbca:	40 d4       	mov.aa %a4,%a13
8000fbcc:	02 f4       	mov %d4,%d15
8000fbce:	6d 00 a7 05 	call 8001071c <__lshift>
8000fbd2:	40 2e       	mov.aa %a14,%a2
8000fbd4:	19 a2 18 00 	ld.w %d2,[%sp]24
8000fbd8:	8e 27       	jlez %d2,8000fbe6 <_dtoa_r+0x9b2>
8000fbda:	40 c5       	mov.aa %a5,%a12
8000fbdc:	40 d4       	mov.aa %a4,%a13
8000fbde:	02 24       	mov %d4,%d2
8000fbe0:	6d 00 9e 05 	call 8001071c <__lshift>
8000fbe4:	40 2c       	mov.aa %a12,%a2
8000fbe6:	19 a3 3c 00 	ld.w %d3,[%sp]60
8000fbea:	df 03 20 00 	jeq %d3,0,8000fc2a <_dtoa_r+0x9f6>
8000fbee:	40 e4       	mov.aa %a4,%a14
8000fbf0:	40 c5       	mov.aa %a5,%a12
8000fbf2:	6d 00 f2 05 	call 800107d6 <__mcmp>
8000fbf6:	ff 02 1a 00 	jge %d2,0,8000fc2a <_dtoa_r+0x9f6>
8000fbfa:	58 02       	ld.w %d15,[%sp]8
8000fbfc:	40 e5       	mov.aa %a5,%a14
8000fbfe:	c2 ff       	add %d15,-1
8000fc00:	40 d4       	mov.aa %a4,%a13
8000fc02:	fb a0 00 40 	mov %e4,10
8000fc06:	78 02       	st.w [%sp]8,%d15
8000fc08:	6d 00 22 04 	call 8001044c <__multadd>
8000fc0c:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000fc10:	19 a3 24 00 	ld.w %d3,[%sp]36
8000fc14:	59 a2 10 00 	st.w [%sp]16,%d2
8000fc18:	40 2e       	mov.aa %a14,%a2
8000fc1a:	76 38       	jz %d3,8000fc2a <_dtoa_r+0x9f6>
8000fc1c:	40 f5       	mov.aa %a5,%a15
8000fc1e:	40 d4       	mov.aa %a4,%a13
8000fc20:	fb a0 00 40 	mov %e4,10
8000fc24:	6d 00 14 04 	call 8001044c <__multadd>
8000fc28:	40 2f       	mov.aa %a15,%a2
8000fc2a:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000fc2e:	19 a3 10 00 	ld.w %d3,[%sp]16
8000fc32:	8b 32 80 f2 	ge %d15,%d2,3
8000fc36:	8b 13 40 f4 	and.lt %d15,%d3,1
8000fc3a:	6e 2a       	jz %d15,8000fc8e <_dtoa_r+0xa5a>
8000fc3c:	f6 3f       	jnz %d3,8000fc5a <_dtoa_r+0xa26>
8000fc3e:	40 c5       	mov.aa %a5,%a12
8000fc40:	40 d4       	mov.aa %a4,%a13
8000fc42:	d2 54       	mov %e4,5
8000fc44:	6d 00 04 04 	call 8001044c <__multadd>
8000fc48:	40 e4       	mov.aa %a4,%a14
8000fc4a:	40 25       	mov.aa %a5,%a2
8000fc4c:	40 2c       	mov.aa %a12,%a2
8000fc4e:	6d 00 c4 05 	call 800107d6 <__mcmp>
8000fc52:	4e 2e       	jgtz %d2,8000fc6e <_dtoa_r+0xa3a>
8000fc54:	3c 03       	j 8000fc5a <_dtoa_r+0xa26>
8000fc56:	a0 0c       	mov.a %a12,0
8000fc58:	a0 0f       	mov.a %a15,0
8000fc5a:	58 0a       	ld.w %d15,[%sp]40
8000fc5c:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000fc60:	46 0f       	not %d15
8000fc62:	78 02       	st.w [%sp]8,%d15
8000fc64:	3c 11       	j 8000fc86 <_dtoa_r+0xa52>
8000fc66:	58 0c       	ld.w %d15,[%sp]48
8000fc68:	a0 0c       	mov.a %a12,0
8000fc6a:	78 02       	st.w [%sp]8,%d15
8000fc6c:	a0 0f       	mov.a %a15,0
8000fc6e:	19 a2 08 00 	ld.w %d2,[%sp]8
8000fc72:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000fc76:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000fc7a:	da 31       	mov %d15,49
8000fc7c:	c2 12       	add %d2,1
8000fc7e:	c2 1e       	add %d14,1
8000fc80:	2c 30       	st.b [%a3]0,%d15
8000fc82:	59 a2 08 00 	st.w [%sp]8,%d2
8000fc86:	80 f8       	mov.d %d8,%a15
8000fc88:	a0 0f       	mov.a %a15,0
8000fc8a:	1d 00 14 01 	j 8000feb2 <_dtoa_r+0xc7e>
8000fc8e:	19 a3 24 00 	ld.w %d3,[%sp]36
8000fc92:	f6 35       	jnz %d3,8000fc9c <_dtoa_r+0xa68>
8000fc94:	19 a8 0c 00 	ld.w %d8,[%sp]12
8000fc98:	1d 00 c2 00 	j 8000fe1c <_dtoa_r+0xbe8>
8000fc9c:	8e 87       	jlez %d8,8000fcaa <_dtoa_r+0xa76>
8000fc9e:	40 f5       	mov.aa %a5,%a15
8000fca0:	40 d4       	mov.aa %a4,%a13
8000fca2:	02 84       	mov %d4,%d8
8000fca4:	6d 00 3c 05 	call 8001071c <__lshift>
8000fca8:	40 2f       	mov.aa %a15,%a2
8000fcaa:	80 f8       	mov.d %d8,%a15
8000fcac:	df 09 16 00 	jeq %d9,0,8000fcd8 <_dtoa_r+0xaa4>
8000fcb0:	40 d4       	mov.aa %a4,%a13
8000fcb2:	48 14       	ld.w %d4,[%a15]4
8000fcb4:	6d 00 98 03 	call 800103e4 <_Balloc>
8000fcb8:	48 44       	ld.w %d4,[%a15]16
8000fcba:	d9 24 0c 00 	lea %a4,[%a2]12
8000fcbe:	c2 24       	add %d4,2
8000fcc0:	d9 f5 0c 00 	lea %a5,[%a15]12
8000fcc4:	06 24       	sh %d4,2
8000fcc6:	80 2f       	mov.d %d15,%a2
8000fcc8:	6d 00 7e 03 	call 800103c4 <memcpy>
8000fccc:	60 f5       	mov.a %a5,%d15
8000fcce:	40 d4       	mov.aa %a4,%a13
8000fcd0:	82 14       	mov %d4,1
8000fcd2:	6d 00 25 05 	call 8001071c <__lshift>
8000fcd6:	80 28       	mov.d %d8,%a2
8000fcd8:	19 a9 0c 00 	ld.w %d9,[%sp]12
8000fcdc:	8f 1c 00 a1 	and %d10,%d12,1
8000fce0:	40 e4       	mov.aa %a4,%a14
8000fce2:	40 c5       	mov.aa %a5,%a12
8000fce4:	6d ff 1a fa 	call 8000f118 <quorem>
8000fce8:	40 e4       	mov.aa %a4,%a14
8000fcea:	40 f5       	mov.aa %a5,%a15
8000fcec:	02 2e       	mov %d14,%d2
8000fcee:	1b 02 03 f0 	addi %d15,%d2,48
8000fcf2:	6d 00 72 05 	call 800107d6 <__mcmp>
8000fcf6:	60 86       	mov.a %a6,%d8
8000fcf8:	40 d4       	mov.aa %a4,%a13
8000fcfa:	40 c5       	mov.aa %a5,%a12
8000fcfc:	02 2b       	mov %d11,%d2
8000fcfe:	6d 00 8d 05 	call 80010818 <__mdiff>
8000fd02:	19 22 0c 00 	ld.w %d2,[%a2]12
8000fd06:	80 2d       	mov.d %d13,%a2
8000fd08:	82 1c       	mov %d12,1
8000fd0a:	f6 26       	jnz %d2,8000fd16 <_dtoa_r+0xae2>
8000fd0c:	40 e4       	mov.aa %a4,%a14
8000fd0e:	40 25       	mov.aa %a5,%a2
8000fd10:	6d 00 63 05 	call 800107d6 <__mcmp>
8000fd14:	02 2c       	mov %d12,%d2
8000fd16:	60 d5       	mov.a %a5,%d13
8000fd18:	40 d4       	mov.aa %a4,%a13
8000fd1a:	6d 00 90 03 	call 8001043a <_Bfree>
8000fd1e:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000fd22:	1b 19 00 d0 	addi %d13,%d9,1
8000fd26:	a6 c3       	or %d3,%d12
8000fd28:	f6 3f       	jnz %d3,8000fd46 <_dtoa_r+0xb12>
8000fd2a:	f6 ae       	jnz %d10,8000fd46 <_dtoa_r+0xb12>
8000fd2c:	8b 9f 03 32 	eq %d3,%d15,57
8000fd30:	40 e2       	mov.aa %a2,%a14
8000fd32:	df 03 3a 80 	jne %d3,0,8000fda6 <_dtoa_r+0xb72>
8000fd36:	1b 1e 03 20 	addi %d2,%d14,49
8000fd3a:	8b 1b 80 b2 	ge %d11,%d11,1
8000fd3e:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
8000fd42:	02 de       	mov %d14,%d13
8000fd44:	3c 37       	j 8000fdb2 <_dtoa_r+0xb7e>
8000fd46:	ce b5       	jgez %d11,8000fd50 <_dtoa_r+0xb1c>
8000fd48:	02 fa       	mov %d10,%d15
8000fd4a:	40 e2       	mov.aa %a2,%a14
8000fd4c:	4e ca       	jgtz %d12,8000fd60 <_dtoa_r+0xb2c>
8000fd4e:	3c 1e       	j 8000fd8a <_dtoa_r+0xb56>
8000fd50:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000fd54:	a6 2b       	or %d11,%d2
8000fd56:	df 0b 20 80 	jne %d11,0,8000fd96 <_dtoa_r+0xb62>
8000fd5a:	df 0a 1e 80 	jne %d10,0,8000fd96 <_dtoa_r+0xb62>
8000fd5e:	3c f5       	j 8000fd48 <_dtoa_r+0xb14>
8000fd60:	40 d4       	mov.aa %a4,%a13
8000fd62:	40 e5       	mov.aa %a5,%a14
8000fd64:	82 14       	mov %d4,1
8000fd66:	6d 00 db 04 	call 8001071c <__lshift>
8000fd6a:	40 c5       	mov.aa %a5,%a12
8000fd6c:	40 24       	mov.aa %a4,%a2
8000fd6e:	b5 a2 04 00 	st.a [%sp]4,%a2
8000fd72:	6d 00 32 05 	call 800107d6 <__mcmp>
8000fd76:	99 a2 04 00 	ld.a %a2,[%sp]4
8000fd7a:	4e 23       	jgtz %d2,8000fd80 <_dtoa_r+0xb4c>
8000fd7c:	f6 27       	jnz %d2,8000fd8a <_dtoa_r+0xb56>
8000fd7e:	2e 06       	jz.t %d15,0,8000fd8a <_dtoa_r+0xb56>
8000fd80:	8b 9f 03 32 	eq %d3,%d15,57
8000fd84:	df 03 11 80 	jne %d3,0,8000fda6 <_dtoa_r+0xb72>
8000fd88:	92 1a       	add %d10,%d15,1
8000fd8a:	60 93       	mov.a %a3,%d9
8000fd8c:	02 de       	mov %d14,%d13
8000fd8e:	34 3a       	st.b [%a3],%d10
8000fd90:	40 2e       	mov.aa %a14,%a2
8000fd92:	1d 00 90 00 	j 8000feb2 <_dtoa_r+0xc7e>
8000fd96:	bf 1c 11 00 	jlt %d12,1,8000fdb8 <_dtoa_r+0xb84>
8000fd9a:	8b 9f 23 32 	ne %d3,%d15,57
8000fd9e:	40 e2       	mov.aa %a2,%a14
8000fda0:	02 de       	mov %d14,%d13
8000fda2:	c2 1f       	add %d15,1
8000fda4:	f6 37       	jnz %d3,8000fdb2 <_dtoa_r+0xb7e>
8000fda6:	60 93       	mov.a %a3,%d9
8000fda8:	da 39       	mov %d15,57
8000fdaa:	02 de       	mov %d14,%d13
8000fdac:	2c 30       	st.b [%a3]0,%d15
8000fdae:	40 2e       	mov.aa %a14,%a2
8000fdb0:	3c 5d       	j 8000fe6a <_dtoa_r+0xc36>
8000fdb2:	60 92       	mov.a %a2,%d9
8000fdb4:	2c 20       	st.b [%a2]0,%d15
8000fdb6:	3c 7e       	j 8000feb2 <_dtoa_r+0xc7e>
8000fdb8:	60 93       	mov.a %a3,%d9
8000fdba:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000fdbe:	02 d5       	mov %d5,%d13
8000fdc0:	19 a3 10 00 	ld.w %d3,[%sp]16
8000fdc4:	2c 30       	st.b [%a3]0,%d15
8000fdc6:	a2 25       	sub %d5,%d2
8000fdc8:	02 de       	mov %d14,%d13
8000fdca:	5f 35 41 00 	jeq %d5,%d3,8000fe4c <_dtoa_r+0xc18>
8000fdce:	40 e5       	mov.aa %a5,%a14
8000fdd0:	40 d4       	mov.aa %a4,%a13
8000fdd2:	fb a0 00 40 	mov %e4,10
8000fdd6:	6d 00 3b 03 	call 8001044c <__multadd>
8000fdda:	80 ff       	mov.d %d15,%a15
8000fddc:	40 2e       	mov.aa %a14,%a2
8000fdde:	40 d4       	mov.aa %a4,%a13
8000fde0:	40 f5       	mov.aa %a5,%a15
8000fde2:	fb a0 00 40 	mov %e4,10
8000fde6:	7e 86       	jne %d15,%d8,8000fdf2 <_dtoa_r+0xbbe>
8000fde8:	6d 00 32 03 	call 8001044c <__multadd>
8000fdec:	40 2f       	mov.aa %a15,%a2
8000fdee:	80 28       	mov.d %d8,%a2
8000fdf0:	3c 0b       	j 8000fe06 <_dtoa_r+0xbd2>
8000fdf2:	6d 00 2d 03 	call 8001044c <__multadd>
8000fdf6:	60 85       	mov.a %a5,%d8
8000fdf8:	40 d4       	mov.aa %a4,%a13
8000fdfa:	fb a0 00 40 	mov %e4,10
8000fdfe:	40 2f       	mov.aa %a15,%a2
8000fe00:	6d 00 26 03 	call 8001044c <__multadd>
8000fe04:	80 28       	mov.d %d8,%a2
8000fe06:	02 d9       	mov %d9,%d13
8000fe08:	1d ff 6c ff 	j 8000fce0 <_dtoa_r+0xaac>
8000fe0c:	40 e5       	mov.aa %a5,%a14
8000fe0e:	40 d4       	mov.aa %a4,%a13
8000fe10:	fb a0 00 40 	mov %e4,10
8000fe14:	6d 00 1c 03 	call 8001044c <__multadd>
8000fe18:	02 98       	mov %d8,%d9
8000fe1a:	40 2e       	mov.aa %a14,%a2
8000fe1c:	40 e4       	mov.aa %a4,%a14
8000fe1e:	40 c5       	mov.aa %a5,%a12
8000fe20:	6d ff 7c f9 	call 8000f118 <quorem>
8000fe24:	1b 18 00 90 	addi %d9,%d8,1
8000fe28:	1b 02 03 f0 	addi %d15,%d2,48
8000fe2c:	60 82       	mov.a %a2,%d8
8000fe2e:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000fe32:	02 95       	mov %d5,%d9
8000fe34:	19 a3 10 00 	ld.w %d3,[%sp]16
8000fe38:	2c 20       	st.b [%a2]0,%d15
8000fe3a:	a2 25       	sub %d5,%d2
8000fe3c:	3f 35 e8 7f 	jlt %d5,%d3,8000fe0c <_dtoa_r+0xbd8>
8000fe40:	8b 13 40 33 	max %d3,%d3,1
8000fe44:	02 2e       	mov %d14,%d2
8000fe46:	80 f8       	mov.d %d8,%a15
8000fe48:	42 3e       	add %d14,%d3
8000fe4a:	a0 0f       	mov.a %a15,0
8000fe4c:	40 e5       	mov.aa %a5,%a14
8000fe4e:	40 d4       	mov.aa %a4,%a13
8000fe50:	82 14       	mov %d4,1
8000fe52:	6d 00 65 04 	call 8001071c <__lshift>
8000fe56:	40 c5       	mov.aa %a5,%a12
8000fe58:	40 2e       	mov.aa %a14,%a2
8000fe5a:	40 24       	mov.aa %a4,%a2
8000fe5c:	6d 00 bd 04 	call 800107d6 <__mcmp>
8000fe60:	4e 25       	jgtz %d2,8000fe6a <_dtoa_r+0xc36>
8000fe62:	df 02 1e 80 	jne %d2,0,8000fe9e <_dtoa_r+0xc6a>
8000fe66:	6f 0f 1c 00 	jz.t %d15,0,8000fe9e <_dtoa_r+0xc6a>
8000fe6a:	58 03       	ld.w %d15,[%sp]12
8000fe6c:	a2 ef       	sub %d15,%d14
8000fe6e:	46 0f       	not %d15
8000fe70:	60 e2       	mov.a %a2,%d14
8000fe72:	60 e3       	mov.a %a3,%d14
8000fe74:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000fe78:	b0 f3       	add.a %a3,-1
8000fe7a:	8b 93 03 52 	eq %d5,%d3,57
8000fe7e:	76 5d       	jz %d5,8000fe98 <_dtoa_r+0xc64>
8000fe80:	9f 0f 0a 80 	jned %d15,0,8000fe94 <_dtoa_r+0xc60>
8000fe84:	58 02       	ld.w %d15,[%sp]8
8000fe86:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000fe8a:	c2 1f       	add %d15,1
8000fe8c:	78 02       	st.w [%sp]8,%d15
8000fe8e:	da 31       	mov %d15,49
8000fe90:	2c 30       	st.b [%a3]0,%d15
8000fe92:	3c 10       	j 8000feb2 <_dtoa_r+0xc7e>
8000fe94:	80 3e       	mov.d %d14,%a3
8000fe96:	3c ed       	j 8000fe70 <_dtoa_r+0xc3c>
8000fe98:	c2 13       	add %d3,1
8000fe9a:	34 33       	st.b [%a3],%d3
8000fe9c:	3c 0b       	j 8000feb2 <_dtoa_r+0xc7e>
8000fe9e:	60 e2       	mov.a %a2,%d14
8000fea0:	60 e3       	mov.a %a3,%d14
8000fea2:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000fea6:	b0 f3       	add.a %a3,-1
8000fea8:	8b 0f 03 f2 	eq %d15,%d15,48
8000feac:	6e 03       	jz %d15,8000feb2 <_dtoa_r+0xc7e>
8000feae:	80 3e       	mov.d %d14,%a3
8000feb0:	3c f7       	j 8000fe9e <_dtoa_r+0xc6a>
8000feb2:	40 d4       	mov.aa %a4,%a13
8000feb4:	40 c5       	mov.aa %a5,%a12
8000feb6:	6d 00 c2 02 	call 8001043a <_Bfree>
8000feba:	df 08 13 00 	jeq %d8,0,8000fee0 <_dtoa_r+0xcac>
8000febe:	80 f2       	mov.d %d2,%a15
8000fec0:	8b 02 20 f2 	ne %d15,%d2,0
8000fec4:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8000fec8:	6e 05       	jz %d15,8000fed2 <_dtoa_r+0xc9e>
8000feca:	40 d4       	mov.aa %a4,%a13
8000fecc:	40 f5       	mov.aa %a5,%a15
8000fece:	6d 00 b6 02 	call 8001043a <_Bfree>
8000fed2:	60 85       	mov.a %a5,%d8
8000fed4:	40 d4       	mov.aa %a4,%a13
8000fed6:	6d 00 b2 02 	call 8001043a <_Bfree>
8000feda:	3c 03       	j 8000fee0 <_dtoa_r+0xcac>
8000fedc:	58 0c       	ld.w %d15,[%sp]48
8000fede:	78 02       	st.w [%sp]8,%d15
8000fee0:	40 d4       	mov.aa %a4,%a13
8000fee2:	40 e5       	mov.aa %a5,%a14
8000fee4:	6d 00 ab 02 	call 8001043a <_Bfree>
8000fee8:	60 e2       	mov.a %a2,%d14
8000feea:	19 a2 08 00 	ld.w %d2,[%sp]8
8000feee:	99 a3 08 10 	ld.a %a3,[%sp]72
8000fef2:	82 0f       	mov %d15,0
8000fef4:	d8 0e       	ld.a %a15,[%sp]56
8000fef6:	2c 20       	st.b [%a2]0,%d15
8000fef8:	c2 12       	add %d2,1
8000fefa:	74 32       	st.w [%a3],%d2
8000fefc:	99 a2 0c 00 	ld.a %a2,[%sp]12
8000ff00:	bc f2       	jz.a %a15,8000ff04 <_dtoa_r+0xcd0>
8000ff02:	68 0e       	st.w [%a15]0,%d14
8000ff04:	00 90       	ret 
	...

8000ff08 <_localeconv_r>:
8000ff08:	91 00 00 28 	movh.a %a2,32768
8000ff0c:	d9 22 f0 10 	lea %a2,[%a2]3184 <80000c70 <lconv>>
8000ff10:	00 90       	ret 

8000ff12 <_malloc_r>:
8000ff12:	1b b4 00 f0 	addi %d15,%d4,11
8000ff16:	8b 7f 61 82 	lt.u %d8,%d15,23
8000ff1a:	8f 7f c0 f1 	andn %d15,%d15,7
8000ff1e:	ab 0f a1 88 	seln %d8,%d8,%d15,16
8000ff22:	0b 48 30 41 	lt.u %d4,%d8,%d4
8000ff26:	8b 08 20 45 	or.lt %d4,%d8,0
8000ff2a:	40 4d       	mov.aa %a13,%a4
8000ff2c:	76 45       	jz %d4,8000ff36 <_malloc_r+0x24>
8000ff2e:	da 0c       	mov %d15,12
8000ff30:	6c 40       	st.w [%a4]0,%d15
8000ff32:	1d 00 2a 02 	j 80010386 <_malloc_r+0x474>
8000ff36:	91 00 00 f7 	movh.a %a15,28672
8000ff3a:	8b 88 bf f2 	ge.u %d15,%d8,504
8000ff3e:	6d 00 51 02 	call 800103e0 <__malloc_lock>
8000ff42:	d9 ff 98 21 	lea %a15,[%a15]6296 <70001898 <__malloc_av_>>
8000ff46:	ee 19       	jnz %d15,8000ff78 <_malloc_r+0x66>
8000ff48:	8f d8 1f 20 	sh %d2,%d8,-3
8000ff4c:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000ff50:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000ff54:	7d 2c 09 80 	jne.a %a12,%a2,8000ff66 <_malloc_r+0x54>
8000ff58:	d9 c2 08 00 	lea %a2,[%a12]8
8000ff5c:	99 cc 14 00 	ld.a %a12,[%a12]20
8000ff60:	c2 22       	add %d2,2
8000ff62:	7d 2c 58 00 	jeq.a %a12,%a2,80010012 <_malloc_r+0x100>
8000ff66:	cc c3       	ld.a %a15,[%a12]12
8000ff68:	99 c2 08 00 	ld.a %a2,[%a12]8
8000ff6c:	4c c1       	ld.w %d15,[%a12]4
8000ff6e:	ec 23       	st.a [%a2]12,%a15
8000ff70:	8f 3f c0 f1 	andn %d15,%d15,3
8000ff74:	e8 22       	st.a [%a15]8,%a2
8000ff76:	3c 74       	j 8001005e <_malloc_r+0x14c>
8000ff78:	8f 78 1f f0 	sh %d15,%d8,-9
8000ff7c:	3b f0 03 20 	mov %d2,63
8000ff80:	6e 27       	jz %d15,8000ffce <_malloc_r+0xbc>
8000ff82:	8f a8 1f 20 	sh %d2,%d8,-6
8000ff86:	1b 82 03 20 	addi %d2,%d2,56
8000ff8a:	bf 5f 22 80 	jlt.u %d15,5,8000ffce <_malloc_r+0xbc>
8000ff8e:	8b 5f a1 22 	ge.u %d2,%d15,21
8000ff92:	f6 24       	jnz %d2,8000ff9a <_malloc_r+0x88>
8000ff94:	1b bf 05 20 	addi %d2,%d15,91
8000ff98:	3c 1b       	j 8000ffce <_malloc_r+0xbc>
8000ff9a:	8b 5f a5 22 	ge.u %d2,%d15,85
8000ff9e:	f6 26       	jnz %d2,8000ffaa <_malloc_r+0x98>
8000ffa0:	8f 48 1f 20 	sh %d2,%d8,-12
8000ffa4:	1b e2 06 20 	addi %d2,%d2,110
8000ffa8:	3c 13       	j 8000ffce <_malloc_r+0xbc>
8000ffaa:	8b 5f b5 22 	ge.u %d2,%d15,341
8000ffae:	f6 26       	jnz %d2,8000ffba <_malloc_r+0xa8>
8000ffb0:	8f 18 1f 20 	sh %d2,%d8,-15
8000ffb4:	1b 72 07 20 	addi %d2,%d2,119
8000ffb8:	3c 0b       	j 8000ffce <_malloc_r+0xbc>
8000ffba:	3b 50 55 30 	mov %d3,1365
8000ffbe:	3b e0 07 20 	mov %d2,126
8000ffc2:	7f 3f 06 80 	jge.u %d15,%d3,8000ffce <_malloc_r+0xbc>
8000ffc6:	8f e8 1e 20 	sh %d2,%d8,-18
8000ffca:	1b c2 07 20 	addi %d2,%d2,124
8000ffce:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000ffd2:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000ffd6:	7d 2c 1d 00 	jeq.a %a12,%a2,80010010 <_malloc_r+0xfe>
8000ffda:	19 c4 04 00 	ld.w %d4,[%a12]4
8000ffde:	8f 34 c0 41 	andn %d4,%d4,3
8000ffe2:	5a 84       	sub %d15,%d4,%d8
8000ffe4:	8b 0f 41 32 	lt %d3,%d15,16
8000ffe8:	f6 33       	jnz %d3,8000ffee <_malloc_r+0xdc>
8000ffea:	c2 f2       	add %d2,-1
8000ffec:	3c 12       	j 80010010 <_malloc_r+0xfe>
8000ffee:	0e fe       	jltz %d15,8001000a <_malloc_r+0xf8>
8000fff0:	cc c3       	ld.a %a15,[%a12]12
8000fff2:	99 c2 08 00 	ld.a %a2,[%a12]8
8000fff6:	ec 23       	st.a [%a2]12,%a15
8000fff8:	e8 22       	st.a [%a15]8,%a2
8000fffa:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
8000fffe:	b7 10 21 20 	imask %e2,1,0,1
80010002:	49 f2 44 08 	ldmst [%a15]4,%e2
80010006:	1d 00 cc 01 	j 8001039e <_malloc_r+0x48c>
8001000a:	99 cc 0c 00 	ld.a %a12,[%a12]12
8001000e:	3c e4       	j 8000ffd6 <_malloc_r+0xc4>
80010010:	c2 12       	add %d2,1
80010012:	c8 4c       	ld.a %a12,[%a15]16
80010014:	91 00 00 37 	movh.a %a3,28672
80010018:	d9 33 a0 21 	lea %a3,[%a3]6304 <700018a0 <__malloc_av_+0x8>>
8001001c:	7d 3c 83 00 	jeq.a %a12,%a3,80010122 <_malloc_r+0x210>
80010020:	4c c1       	ld.w %d15,[%a12]4
80010022:	8f 3f c0 f1 	andn %d15,%d15,3
80010026:	52 83       	sub %d3,%d15,%d8
80010028:	8b 03 41 42 	lt %d4,%d3,16
8001002c:	df 04 16 80 	jne %d4,0,80010058 <_malloc_r+0x146>
80010030:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80010034:	8f 18 40 81 	or %d8,%d8,1
80010038:	59 c8 04 00 	st.w [%a12]4,%d8
8001003c:	e8 52       	st.a [%a15]20,%a2
8001003e:	e8 42       	st.a [%a15]16,%a2
80010040:	8f 13 40 f1 	or %d15,%d3,1
80010044:	b5 23 0c 00 	st.a [%a2]12,%a3
80010048:	b5 23 08 00 	st.a [%a2]8,%a3
8001004c:	6c 21       	st.w [%a2]4,%d15
8001004e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80010052:	74 23       	st.w [%a2],%d3
80010054:	1d 00 a5 01 	j 8001039e <_malloc_r+0x48c>
80010058:	e8 53       	st.a [%a15]20,%a3
8001005a:	e8 43       	st.a [%a15]16,%a3
8001005c:	0e 33       	jltz %d3,80010062 <_malloc_r+0x150>
8001005e:	10 cf       	addsc.a %a15,%a12,%d15,0
80010060:	3c cf       	j 8000fffe <_malloc_r+0xec>
80010062:	3b 00 20 30 	mov %d3,512
80010066:	7f 3f 15 80 	jge.u %d15,%d3,80010090 <_malloc_r+0x17e>
8001006a:	06 df       	sh %d15,-3
8001006c:	d0 f2       	addsc.a %a2,%a15,%d15,3
8001006e:	48 14       	ld.w %d4,[%a15]4
80010070:	99 24 08 00 	ld.a %a4,[%a2]8
80010074:	8f ef 3f 30 	sha %d3,%d15,-2
80010078:	b5 c2 0c 00 	st.a [%a12]12,%a2
8001007c:	b5 c4 08 00 	st.a [%a12]8,%a4
80010080:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
80010084:	b5 2c 08 00 	st.a [%a2]8,%a12
80010088:	68 13       	st.w [%a15]4,%d3
8001008a:	b5 4c 0c 00 	st.a [%a4]12,%a12
8001008e:	3c 4a       	j 80010122 <_malloc_r+0x210>
80010090:	8f af 1f 40 	sh %d4,%d15,-6
80010094:	8f 7f 1f 30 	sh %d3,%d15,-9
80010098:	1b 84 03 40 	addi %d4,%d4,56
8001009c:	bf 53 22 80 	jlt.u %d3,5,800100e0 <_malloc_r+0x1ce>
800100a0:	8b 53 a1 42 	ge.u %d4,%d3,21
800100a4:	f6 44       	jnz %d4,800100ac <_malloc_r+0x19a>
800100a6:	1b b3 05 40 	addi %d4,%d3,91
800100aa:	3c 1b       	j 800100e0 <_malloc_r+0x1ce>
800100ac:	8b 53 a5 42 	ge.u %d4,%d3,85
800100b0:	f6 46       	jnz %d4,800100bc <_malloc_r+0x1aa>
800100b2:	8f 4f 1f 40 	sh %d4,%d15,-12
800100b6:	1b e4 06 40 	addi %d4,%d4,110
800100ba:	3c 13       	j 800100e0 <_malloc_r+0x1ce>
800100bc:	8b 53 b5 42 	ge.u %d4,%d3,341
800100c0:	f6 46       	jnz %d4,800100cc <_malloc_r+0x1ba>
800100c2:	8f 1f 1f 40 	sh %d4,%d15,-15
800100c6:	1b 74 07 40 	addi %d4,%d4,119
800100ca:	3c 0b       	j 800100e0 <_malloc_r+0x1ce>
800100cc:	3b 50 55 50 	mov %d5,1365
800100d0:	3b e0 07 40 	mov %d4,126
800100d4:	7f 53 06 80 	jge.u %d3,%d5,800100e0 <_malloc_r+0x1ce>
800100d8:	8f ef 1e 40 	sh %d4,%d15,-18
800100dc:	1b c4 07 40 	addi %d4,%d4,124
800100e0:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
800100e4:	99 42 08 00 	ld.a %a2,[%a4]8
800100e8:	7d 42 0d 80 	jne.a %a2,%a4,80010102 <_malloc_r+0x1f0>
800100ec:	4c f1       	ld.w %d15,[%a15]4
800100ee:	86 e4       	sha %d4,-2
800100f0:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
800100f4:	40 24       	mov.aa %a4,%a2
800100f6:	68 14       	st.w [%a15]4,%d4
800100f8:	3c 0d       	j 80010112 <_malloc_r+0x200>
800100fa:	99 22 08 00 	ld.a %a2,[%a2]8
800100fe:	7d 42 08 00 	jeq.a %a2,%a4,8001010e <_malloc_r+0x1fc>
80010102:	19 23 04 00 	ld.w %d3,[%a2]4
80010106:	8f 33 c0 31 	andn %d3,%d3,3
8001010a:	3f 3f f8 ff 	jlt.u %d15,%d3,800100fa <_malloc_r+0x1e8>
8001010e:	99 24 0c 00 	ld.a %a4,[%a2]12
80010112:	b5 c4 0c 00 	st.a [%a12]12,%a4
80010116:	b5 c2 08 00 	st.a [%a12]8,%a2
8001011a:	b5 4c 08 00 	st.a [%a4]8,%a12
8001011e:	b5 2c 0c 00 	st.a [%a2]12,%a12
80010122:	8f e2 3f 30 	sha %d3,%d2,-2
80010126:	82 1f       	mov %d15,1
80010128:	0f 3f 00 f0 	sh %d15,%d15,%d3
8001012c:	48 13       	ld.w %d3,[%a15]4
8001012e:	3f f3 73 80 	jlt.u %d3,%d15,80010214 <_malloc_r+0x302>
80010132:	0f 3f 80 40 	and %d4,%d15,%d3
80010136:	f6 49       	jnz %d4,80010148 <_malloc_r+0x236>
80010138:	8f 32 c0 21 	andn %d2,%d2,3
8001013c:	06 1f       	sh %d15,1
8001013e:	0f 3f 80 40 	and %d4,%d15,%d3
80010142:	c2 42       	add %d2,4
80010144:	df 04 fc 7f 	jeq %d4,0,8001013c <_malloc_r+0x22a>
80010148:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8001014c:	02 24       	mov %d4,%d2
8001014e:	40 24       	mov.aa %a4,%a2
80010150:	99 4c 0c 00 	ld.a %a12,[%a4]12
80010154:	7d 4c 3c 00 	jeq.a %a12,%a4,800101cc <_malloc_r+0x2ba>
80010158:	19 c6 04 00 	ld.w %d6,[%a12]4
8001015c:	8f 36 c0 61 	andn %d6,%d6,3
80010160:	0b 86 80 30 	sub %d3,%d6,%d8
80010164:	8b 03 41 52 	lt %d5,%d3,16
80010168:	df 05 1d 80 	jne %d5,0,800101a2 <_malloc_r+0x290>
8001016c:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80010170:	8f 18 40 81 	or %d8,%d8,1
80010174:	59 c8 04 00 	st.w [%a12]4,%d8
80010178:	99 c4 0c 00 	ld.a %a4,[%a12]12
8001017c:	09 c5 88 05 	ld.a %a5,[+%a12]8
80010180:	8f 13 40 f1 	or %d15,%d3,1
80010184:	b5 54 0c 00 	st.a [%a5]12,%a4
80010188:	b5 45 08 00 	st.a [%a4]8,%a5
8001018c:	e8 52       	st.a [%a15]20,%a2
8001018e:	e8 42       	st.a [%a15]16,%a2
80010190:	b5 23 0c 00 	st.a [%a2]12,%a3
80010194:	b5 23 08 00 	st.a [%a2]8,%a3
80010198:	6c 21       	st.w [%a2]4,%d15
8001019a:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8001019e:	74 23       	st.w [%a2],%d3
800101a0:	3c 0e       	j 800101bc <_malloc_r+0x2aa>
800101a2:	bf 03 12 00 	jlt %d3,0,800101c6 <_malloc_r+0x2b4>
800101a6:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
800101aa:	b7 10 21 20 	imask %e2,1,0,1
800101ae:	49 f2 44 08 	ldmst [%a15]4,%e2
800101b2:	cc c3       	ld.a %a15,[%a12]12
800101b4:	09 c2 88 05 	ld.a %a2,[+%a12]8
800101b8:	ec 23       	st.a [%a2]12,%a15
800101ba:	e8 22       	st.a [%a15]8,%a2
800101bc:	40 d4       	mov.aa %a4,%a13
800101be:	6d 00 12 01 	call 800103e2 <__malloc_unlock>
800101c2:	1d 00 f3 00 	j 800103a8 <_malloc_r+0x496>
800101c6:	99 cc 0c 00 	ld.a %a12,[%a12]12
800101ca:	3c c5       	j 80010154 <_malloc_r+0x242>
800101cc:	c2 14       	add %d4,1
800101ce:	8f 34 00 31 	and %d3,%d4,3
800101d2:	d9 44 08 00 	lea %a4,[%a4]8
800101d6:	df 03 bd ff 	jne %d3,0,80010150 <_malloc_r+0x23e>
800101da:	8f 32 00 31 	and %d3,%d2,3
800101de:	f6 36       	jnz %d3,800101ea <_malloc_r+0x2d8>
800101e0:	48 12       	ld.w %d2,[%a15]4
800101e2:	0f f2 e0 20 	andn %d2,%d2,%d15
800101e6:	68 12       	st.w [%a15]4,%d2
800101e8:	3c 07       	j 800101f6 <_malloc_r+0x2e4>
800101ea:	d9 24 f8 ff 	lea %a4,[%a2]-8
800101ee:	d4 22       	ld.a %a2,[%a2]
800101f0:	c2 f2       	add %d2,-1
800101f2:	7d 42 f4 7f 	jeq.a %a2,%a4,800101da <_malloc_r+0x2c8>
800101f6:	06 1f       	sh %d15,1
800101f8:	48 12       	ld.w %d2,[%a15]4
800101fa:	8b 0f 20 32 	ne %d3,%d15,0
800101fe:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
80010202:	76 39       	jz %d3,80010214 <_malloc_r+0x302>
80010204:	0f 2f 80 30 	and %d3,%d15,%d2
80010208:	f6 34       	jnz %d3,80010210 <_malloc_r+0x2fe>
8001020a:	c2 44       	add %d4,4
8001020c:	06 1f       	sh %d15,1
8001020e:	3c fb       	j 80010204 <_malloc_r+0x2f2>
80010210:	02 42       	mov %d2,%d4
80010212:	3c 9b       	j 80010148 <_malloc_r+0x236>
80010214:	c8 2c       	ld.a %a12,[%a15]8
80010216:	19 ca 04 00 	ld.w %d10,[%a12]4
8001021a:	8f 3a c0 a1 	andn %d10,%d10,3
8001021e:	5a 8a       	sub %d15,%d10,%d8
80010220:	8b 0f 41 22 	lt %d2,%d15,16
80010224:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
80010228:	df 02 b1 00 	jeq %d2,0,8001038a <_malloc_r+0x478>
8001022c:	91 00 00 27 	movh.a %a2,28672
80010230:	19 2b 98 24 	ld.w %d11,[%a2]18584 <70004898 <__malloc_top_pad>>
80010234:	91 00 00 27 	movh.a %a2,28672
80010238:	42 8b       	add %d11,%d8
8001023a:	19 23 90 21 	ld.w %d3,[%a2]6288 <70001890 <__malloc_sbrk_base>>
8001023e:	1b fb 00 f1 	addi %d15,%d11,4111
80010242:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
80010246:	1b 0b 01 20 	addi %d2,%d11,16
8001024a:	8b f3 3f b2 	ne %d11,%d3,-1
8001024e:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
80010252:	40 d4       	mov.aa %a4,%a13
80010254:	02 b4       	mov %d4,%d11
80010256:	80 2c       	mov.d %d12,%a2
80010258:	6d 00 ba 03 	call 800109cc <_sbrk_r>
8001025c:	80 29       	mov.d %d9,%a2
8001025e:	df f9 86 00 	jeq %d9,-1,8001036a <_malloc_r+0x458>
80010262:	80 c2       	mov.d %d2,%a12
80010264:	80 c3       	mov.d %d3,%a12
80010266:	42 a2       	add %d2,%d10
80010268:	80 f4       	mov.d %d4,%a15
8001026a:	0b 29 30 f1 	lt.u %d15,%d9,%d2
8001026e:	0b 43 10 f2 	and.ne %d15,%d3,%d4
80010272:	01 fc 10 d4 	ne.a %d13,%a12,%a15
80010276:	ee 7a       	jnz %d15,8001036a <_malloc_r+0x458>
80010278:	91 00 00 e7 	movh.a %a14,28672
8001027c:	19 e3 a8 14 	ld.w %d3,[%a14]18536 <70004868 <__malloc_current_mallinfo>>
80010280:	42 b3       	add %d3,%d11
80010282:	59 e3 a8 14 	st.w [%a14]18536 <70004868 <__malloc_current_mallinfo>>,%d3
80010286:	5f 29 0c 80 	jne %d9,%d2,8001029e <_malloc_r+0x38c>
8001028a:	b7 09 14 f6 	insert %d15,%d9,0,12,20
8001028e:	ee 08       	jnz %d15,8001029e <_malloc_r+0x38c>
80010290:	c8 22       	ld.a %a2,[%a15]8
80010292:	42 ba       	add %d10,%d11
80010294:	8f 1a 40 a1 	or %d10,%d10,1
80010298:	59 2a 04 00 	st.w [%a2]4,%d10
8001029c:	3c 55       	j 80010346 <_malloc_r+0x434>
8001029e:	60 c2       	mov.a %a2,%d12
800102a0:	19 2f 90 21 	ld.w %d15,[%a2]6288
800102a4:	5e f6       	jne %d15,-1,800102b0 <_malloc_r+0x39e>
800102a6:	91 00 00 27 	movh.a %a2,28672
800102aa:	59 29 90 21 	st.w [%a2]6288 <70001890 <__malloc_sbrk_base>>,%d9
800102ae:	3c 06       	j 800102ba <_malloc_r+0x3a8>
800102b0:	0b 29 80 20 	sub %d2,%d9,%d2
800102b4:	42 23       	add %d3,%d2
800102b6:	59 e3 a8 14 	st.w [%a14]18536 <70004868 <__malloc_current_mallinfo>>,%d3
800102ba:	8f 79 00 21 	and %d2,%d9,7
800102be:	82 0f       	mov %d15,0
800102c0:	76 24       	jz %d2,800102c8 <_malloc_r+0x3b6>
800102c2:	8b 82 00 f1 	rsub %d15,%d2,8
800102c6:	42 f9       	add %d9,%d15
800102c8:	42 9b       	add %d11,%d9
800102ca:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
800102ce:	1b 0f 00 21 	addi %d2,%d15,4096
800102d2:	5a b2       	sub %d15,%d2,%d11
800102d4:	40 d4       	mov.aa %a4,%a13
800102d6:	02 f4       	mov %d4,%d15
800102d8:	6d 00 7a 03 	call 800109cc <_sbrk_r>
800102dc:	80 22       	mov.d %d2,%a2
800102de:	df f2 04 80 	jne %d2,-1,800102e6 <_malloc_r+0x3d4>
800102e2:	60 92       	mov.a %a2,%d9
800102e4:	82 0f       	mov %d15,0
800102e6:	80 2b       	mov.d %d11,%a2
800102e8:	19 e2 a8 14 	ld.w %d2,[%a14]18536 <70004868 <__malloc_current_mallinfo>>
800102ec:	a2 9b       	sub %d11,%d9
800102ee:	42 f2       	add %d2,%d15
800102f0:	60 92       	mov.a %a2,%d9
800102f2:	42 bf       	add %d15,%d11
800102f4:	68 29       	st.w [%a15]8,%d9
800102f6:	8f 1f 40 31 	or %d3,%d15,1
800102fa:	59 e2 a8 14 	st.w [%a14]18536 <70004868 <__malloc_current_mallinfo>>,%d2
800102fe:	59 23 04 00 	st.w [%a2]4 <70004868 <__malloc_current_mallinfo>>,%d3
80010302:	df 0d 22 00 	jeq %d13,0,80010346 <_malloc_r+0x434>
80010306:	8b 0a a1 f2 	ge.u %d15,%d10,16
8001030a:	ee 05       	jnz %d15,80010314 <_malloc_r+0x402>
8001030c:	82 12       	mov %d2,1
8001030e:	59 22 04 00 	st.w [%a2]4,%d2
80010312:	3c 2c       	j 8001036a <_malloc_r+0x458>
80010314:	1b 4a ff af 	addi %d10,%d10,-12
80010318:	8f 7a c0 f1 	andn %d15,%d10,7
8001031c:	10 c2       	addsc.a %a2,%a12,%d15,0
8001031e:	82 52       	mov %d2,5
80010320:	59 22 04 00 	st.w [%a2]4,%d2
80010324:	59 22 08 00 	st.w [%a2]8,%d2
80010328:	19 c2 04 00 	ld.w %d2,[%a12]4
8001032c:	8f 12 00 21 	and %d2,%d2,1
80010330:	a6 f2       	or %d2,%d15
80010332:	59 c2 04 00 	st.w [%a12]4,%d2
80010336:	8b 0f 61 f2 	lt.u %d15,%d15,16
8001033a:	ee 06       	jnz %d15,80010346 <_malloc_r+0x434>
8001033c:	40 d4       	mov.aa %a4,%a13
8001033e:	d9 c5 08 00 	lea %a5,[%a12]8
80010342:	6d 00 5a 04 	call 80010bf6 <_free_r>
80010346:	91 00 00 27 	movh.a %a2,28672
8001034a:	19 ef a8 14 	ld.w %d15,[%a14]18536 <70004868 <__malloc_current_mallinfo>>
8001034e:	19 22 94 24 	ld.w %d2,[%a2]18580 <70004894 <__malloc_max_sbrked_mem>>
80010352:	7f f2 04 80 	jge.u %d2,%d15,8001035a <_malloc_r+0x448>
80010356:	59 2f 94 24 	st.w [%a2]18580 <70004894 <__malloc_max_sbrked_mem>>,%d15
8001035a:	91 00 00 27 	movh.a %a2,28672
8001035e:	19 22 90 24 	ld.w %d2,[%a2]18576 <70004890 <__malloc_max_total_mem>>
80010362:	7f f2 04 80 	jge.u %d2,%d15,8001036a <_malloc_r+0x458>
80010366:	59 2f 90 24 	st.w [%a2]18576 <70004890 <__malloc_max_total_mem>>,%d15
8001036a:	c8 22       	ld.a %a2,[%a15]8
8001036c:	19 22 04 00 	ld.w %d2,[%a2]4 <70004890 <__malloc_max_total_mem>>
80010370:	8f 32 c0 21 	andn %d2,%d2,3
80010374:	5a 82       	sub %d15,%d2,%d8
80010376:	8b 0f 41 32 	lt %d3,%d15,16
8001037a:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
8001037e:	76 36       	jz %d3,8001038a <_malloc_r+0x478>
80010380:	40 d4       	mov.aa %a4,%a13
80010382:	6d 00 30 00 	call 800103e2 <__malloc_unlock>
80010386:	a0 0c       	mov.a %a12,0
80010388:	3c 10       	j 800103a8 <_malloc_r+0x496>
8001038a:	c8 2c       	ld.a %a12,[%a15]8
8001038c:	8f 18 40 21 	or %d2,%d8,1
80010390:	96 01       	or %d15,1
80010392:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80010396:	59 c2 04 00 	st.w [%a12]4,%d2
8001039a:	e8 22       	st.a [%a15]8,%a2
8001039c:	6c 21       	st.w [%a2]4,%d15
8001039e:	40 d4       	mov.aa %a4,%a13
800103a0:	6d 00 21 00 	call 800103e2 <__malloc_unlock>
800103a4:	d9 cc 08 00 	lea %a12,[%a12]8
800103a8:	40 c2       	mov.aa %a2,%a12
800103aa:	00 90       	ret 

800103ac <memchr>:
800103ac:	8f f4 0f 41 	and %d4,%d4,255
800103b0:	9f 05 04 80 	jned %d5,0,800103b8 <memchr+0xc>
800103b4:	a0 02       	mov.a %a2,0
800103b6:	00 90       	ret 
800103b8:	0c 40       	ld.bu %d15,[%a4]0
800103ba:	3e 43       	jeq %d15,%d4,800103c0 <memchr+0x14>
800103bc:	b0 14       	add.a %a4,1
800103be:	3c f9       	j 800103b0 <memchr+0x4>
800103c0:	40 42       	mov.aa %a2,%a4
800103c2:	00 90       	ret 

800103c4 <memcpy>:
800103c4:	40 42       	mov.aa %a2,%a4
800103c6:	a0 0f       	mov.a %a15,0
800103c8:	01 f2 10 40 	add.a %a4,%a2,%a15
800103cc:	01 f5 10 30 	add.a %a3,%a5,%a15
800103d0:	9f 04 03 80 	jned %d4,0,800103d6 <memcpy+0x12>
800103d4:	00 90       	ret 
800103d6:	79 3f 00 00 	ld.b %d15,[%a3]0
800103da:	b0 1f       	add.a %a15,1
800103dc:	2c 40       	st.b [%a4]0,%d15
800103de:	3c f5       	j 800103c8 <memcpy+0x4>

800103e0 <__malloc_lock>:
800103e0:	00 90       	ret 

800103e2 <__malloc_unlock>:
800103e2:	00 90       	ret 

800103e4 <_Balloc>:
800103e4:	19 42 0c 10 	ld.w %d2,[%a4]76
800103e8:	40 4f       	mov.aa %a15,%a4
800103ea:	02 4f       	mov %d15,%d4
800103ec:	76 29       	jz %d2,800103fe <_Balloc+0x1a>
800103ee:	99 f3 0c 10 	ld.a %a3,[%a15]76
800103f2:	90 33       	addsc.a %a3,%a3,%d15,2
800103f4:	d4 32       	ld.a %a2,[%a3]
800103f6:	bc 2f       	jz.a %a2,80010414 <_Balloc+0x30>
800103f8:	4c 20       	ld.w %d15,[%a2]0
800103fa:	6c 30       	st.w [%a3]0,%d15
800103fc:	3c 1b       	j 80010432 <_Balloc+0x4e>
800103fe:	82 44       	mov %d4,4
80010400:	3b 10 02 50 	mov %d5,33
80010404:	6d 00 6b 03 	call 80010ada <_calloc_r>
80010408:	b5 f2 0c 10 	st.a [%a15]76,%a2
8001040c:	bd 02 f1 ff 	jnz.a %a2,800103ee <_Balloc+0xa>
80010410:	a0 02       	mov.a %a2,0
80010412:	00 90       	ret 
80010414:	82 18       	mov %d8,1
80010416:	0f f8 00 80 	sh %d8,%d8,%d15
8001041a:	1b 58 00 50 	addi %d5,%d8,5
8001041e:	40 f4       	mov.aa %a4,%a15
80010420:	82 14       	mov %d4,1
80010422:	06 25       	sh %d5,2
80010424:	6d 00 5b 03 	call 80010ada <_calloc_r>
80010428:	bd 02 f4 7f 	jz.a %a2,80010410 <_Balloc+0x2c>
8001042c:	6c 21       	st.w [%a2]4,%d15
8001042e:	59 28 08 00 	st.w [%a2]8,%d8
80010432:	82 0f       	mov %d15,0
80010434:	6c 24       	st.w [%a2]16,%d15
80010436:	6c 23       	st.w [%a2]12,%d15
80010438:	00 90       	ret 

8001043a <_Bfree>:
8001043a:	bc 58       	jz.a %a5,8001044a <_Bfree+0x10>
8001043c:	99 4f 0c 10 	ld.a %a15,[%a4]76
80010440:	4c 51       	ld.w %d15,[%a5]4
80010442:	90 ff       	addsc.a %a15,%a15,%d15,2
80010444:	4c f0       	ld.w %d15,[%a15]0
80010446:	6c 50       	st.w [%a5]0,%d15
80010448:	e8 05       	st.a [%a15]0,%a5
8001044a:	00 90       	ret 

8001044c <__multadd>:
8001044c:	19 59 10 00 	ld.w %d9,[%a5]16
80010450:	40 4c       	mov.aa %a12,%a4
80010452:	9a f9       	add %d15,%d9,-1
80010454:	8b 19 80 22 	ge %d2,%d9,1
80010458:	40 5f       	mov.aa %a15,%a5
8001045a:	02 58       	mov %d8,%d5
8001045c:	d9 53 14 00 	lea %a3,[%a5]20
80010460:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80010464:	40 32       	mov.aa %a2,%a3
80010466:	44 25       	ld.w %d5,[%a2+]
80010468:	b7 05 10 38 	insert %d3,%d5,0,16,16
8001046c:	8f 05 1f f0 	sh %d15,%d5,-16
80010470:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
80010474:	8f 03 1f 60 	sh %d6,%d3,-16
80010478:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
8001047c:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
80010480:	8f 0f 1f 80 	sh %d8,%d15,-16
80010484:	74 33       	st.w [%a3],%d3
80010486:	40 23       	mov.aa %a3,%a2
80010488:	9f 02 ee ff 	jned %d2,0,80010464 <__multadd+0x18>
8001048c:	df 08 1f 00 	jeq %d8,0,800104ca <__multadd+0x7e>
80010490:	4c f2       	ld.w %d15,[%a15]8
80010492:	3f f9 16 00 	jlt %d9,%d15,800104be <__multadd+0x72>
80010496:	48 14       	ld.w %d4,[%a15]4
80010498:	40 c4       	mov.aa %a4,%a12
8001049a:	c2 14       	add %d4,1
8001049c:	6d ff a4 ff 	call 800103e4 <_Balloc>
800104a0:	48 44       	ld.w %d4,[%a15]16
800104a2:	d9 f5 0c 00 	lea %a5,[%a15]12
800104a6:	c2 24       	add %d4,2
800104a8:	d9 24 0c 00 	lea %a4,[%a2]12
800104ac:	06 24       	sh %d4,2
800104ae:	40 2d       	mov.aa %a13,%a2
800104b0:	6d ff 8a ff 	call 800103c4 <memcpy>
800104b4:	40 f5       	mov.aa %a5,%a15
800104b6:	40 c4       	mov.aa %a4,%a12
800104b8:	6d ff c1 ff 	call 8001043a <_Bfree>
800104bc:	40 df       	mov.aa %a15,%a13
800104be:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
800104c2:	c2 19       	add %d9,1
800104c4:	59 28 14 00 	st.w [%a2]20,%d8
800104c8:	68 49       	st.w [%a15]16,%d9
800104ca:	40 f2       	mov.aa %a2,%a15
800104cc:	00 90       	ret 

800104ce <__hi0bits>:
800104ce:	b7 04 10 f0 	insert %d15,%d4,0,0,16
800104d2:	82 02       	mov %d2,0
800104d4:	ee 05       	jnz %d15,800104de <__hi0bits+0x10>
800104d6:	8f 04 01 40 	sh %d4,%d4,16
800104da:	3b 00 01 20 	mov %d2,16
800104de:	b7 04 18 f0 	insert %d15,%d4,0,0,24
800104e2:	ee 05       	jnz %d15,800104ec <__hi0bits+0x1e>
800104e4:	1b 82 00 20 	addi %d2,%d2,8
800104e8:	8f 84 00 40 	sh %d4,%d4,8
800104ec:	b7 04 1c f0 	insert %d15,%d4,0,0,28
800104f0:	ee 03       	jnz %d15,800104f6 <__hi0bits+0x28>
800104f2:	c2 42       	add %d2,4
800104f4:	06 44       	sh %d4,4
800104f6:	b7 04 1e f0 	insert %d15,%d4,0,0,30
800104fa:	ee 03       	jnz %d15,80010500 <__hi0bits+0x32>
800104fc:	c2 22       	add %d2,2
800104fe:	06 24       	sh %d4,2
80010500:	0e 47       	jltz %d4,8001050e <__hi0bits+0x40>
80010502:	7b 00 00 f4 	movh %d15,16384
80010506:	26 f4       	and %d4,%d15
80010508:	c2 12       	add %d2,1
8001050a:	ab 02 82 24 	sel %d2,%d4,%d2,32
8001050e:	00 90       	ret 

80010510 <__lo0bits>:
80010510:	54 43       	ld.w %d3,[%a4]
80010512:	8f 73 00 f1 	and %d15,%d3,7
80010516:	6e 0e       	jz %d15,80010532 <__lo0bits+0x22>
80010518:	82 02       	mov %d2,0
8001051a:	6f 03 2d 80 	jnz.t %d3,0,80010574 <__lo0bits+0x64>
8001051e:	6f 13 06 00 	jz.t %d3,1,8001052a <__lo0bits+0x1a>
80010522:	06 f3       	sh %d3,-1
80010524:	74 43       	st.w [%a4],%d3
80010526:	82 12       	mov %d2,1
80010528:	00 90       	ret 
8001052a:	06 e3       	sh %d3,-2
8001052c:	74 43       	st.w [%a4],%d3
8001052e:	82 22       	mov %d2,2
80010530:	00 90       	ret 
80010532:	b7 03 10 f8 	insert %d15,%d3,0,16,16
80010536:	82 04       	mov %d4,0
80010538:	ee 05       	jnz %d15,80010542 <__lo0bits+0x32>
8001053a:	8f 03 1f 30 	sh %d3,%d3,-16
8001053e:	3b 00 01 40 	mov %d4,16
80010542:	02 3f       	mov %d15,%d3
80010544:	16 ff       	and %d15,255
80010546:	ee 04       	jnz %d15,8001054e <__lo0bits+0x3e>
80010548:	1b 84 00 40 	addi %d4,%d4,8
8001054c:	06 83       	sh %d3,-8
8001054e:	8f f3 00 f1 	and %d15,%d3,15
80010552:	ee 03       	jnz %d15,80010558 <__lo0bits+0x48>
80010554:	c2 44       	add %d4,4
80010556:	06 c3       	sh %d3,-4
80010558:	8f 33 00 f1 	and %d15,%d3,3
8001055c:	ee 03       	jnz %d15,80010562 <__lo0bits+0x52>
8001055e:	c2 24       	add %d4,2
80010560:	06 e3       	sh %d3,-2
80010562:	6f 03 07 80 	jnz.t %d3,0,80010570 <__lo0bits+0x60>
80010566:	06 f3       	sh %d3,-1
80010568:	3b 00 02 20 	mov %d2,32
8001056c:	76 34       	jz %d3,80010574 <__lo0bits+0x64>
8001056e:	c2 14       	add %d4,1
80010570:	74 43       	st.w [%a4],%d3
80010572:	02 42       	mov %d2,%d4
80010574:	00 90       	ret 

80010576 <__i2b>:
80010576:	02 4f       	mov %d15,%d4
80010578:	82 14       	mov %d4,1
8001057a:	6d ff 35 ff 	call 800103e4 <_Balloc>
8001057e:	6c 25       	st.w [%a2]20,%d15
80010580:	82 1f       	mov %d15,1
80010582:	6c 24       	st.w [%a2]16,%d15
80010584:	00 90       	ret 

80010586 <__multiply>:
80010586:	19 52 10 00 	ld.w %d2,[%a5]16
8001058a:	4c 64       	ld.w %d15,[%a6]16
8001058c:	40 5f       	mov.aa %a15,%a5
8001058e:	40 6c       	mov.aa %a12,%a6
80010590:	7f f2 04 00 	jge %d2,%d15,80010598 <__multiply+0x12>
80010594:	40 6f       	mov.aa %a15,%a6
80010596:	40 5c       	mov.aa %a12,%a5
80010598:	48 4a       	ld.w %d10,[%a15]16
8001059a:	19 c9 10 00 	ld.w %d9,[%a12]16
8001059e:	4c f2       	ld.w %d15,[%a15]8
800105a0:	0b 9a 00 80 	add %d8,%d10,%d9
800105a4:	48 12       	ld.w %d2,[%a15]4
800105a6:	0b 8f 20 41 	lt %d4,%d15,%d8
800105aa:	42 24       	add %d4,%d2
800105ac:	6d ff 1c ff 	call 800103e4 <_Balloc>
800105b0:	d9 23 14 00 	lea %a3,[%a2]20
800105b4:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
800105b8:	40 34       	mov.aa %a4,%a3
800105ba:	82 0f       	mov %d15,0
800105bc:	80 43       	mov.d %d3,%a4
800105be:	80 d2       	mov.d %d2,%a13
800105c0:	7f 23 04 80 	jge.u %d3,%d2,800105c8 <__multiply+0x42>
800105c4:	64 4f       	st.w [%a4+],%d15
800105c6:	3c fb       	j 800105bc <__multiply+0x36>
800105c8:	d9 ff 14 00 	lea %a15,[%a15]20
800105cc:	d9 cc 14 00 	lea %a12,[%a12]20
800105d0:	80 f3       	mov.d %d3,%a15
800105d2:	80 cf       	mov.d %d15,%a12
800105d4:	13 4a 20 43 	madd %d4,%d3,%d10,4
800105d8:	13 49 20 0f 	madd %d0,%d15,%d9,4
800105dc:	80 c2       	mov.d %d2,%a12
800105de:	7f 02 54 80 	jge.u %d2,%d0,80010686 <__multiply+0x100>
800105e2:	b9 c2 00 00 	ld.hu %d2,[%a12]0
800105e6:	40 34       	mov.aa %a4,%a3
800105e8:	40 f6       	mov.aa %a6,%a15
800105ea:	82 03       	mov %d3,0
800105ec:	df 02 21 00 	jeq %d2,0,8001062e <__multiply+0xa8>
800105f0:	40 45       	mov.aa %a5,%a4
800105f2:	44 67       	ld.w %d7,[%a6+]
800105f4:	44 56       	ld.w %d6,[%a5+]
800105f6:	b7 07 10 18 	insert %d1,%d7,0,16,16
800105fa:	b7 06 10 58 	insert %d5,%d6,0,16,16
800105fe:	8f 07 1f 70 	sh %d7,%d7,-16
80010602:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
80010606:	8f 06 1f 60 	sh %d6,%d6,-16
8001060a:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
8001060e:	42 35       	add %d5,%d3
80010610:	8f 05 1f 30 	sh %d3,%d5,-16
80010614:	1a 36       	add %d15,%d6,%d3
80010616:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
8001061a:	8f 0f 1f 30 	sh %d3,%d15,-16
8001061e:	80 6f       	mov.d %d15,%a6
80010620:	74 45       	st.w [%a4],%d5
80010622:	7f 4f 04 80 	jge.u %d15,%d4,8001062a <__multiply+0xa4>
80010626:	40 54       	mov.aa %a4,%a5
80010628:	3c e4       	j 800105f0 <__multiply+0x6a>
8001062a:	59 43 04 00 	st.w [%a4]4,%d3
8001062e:	b9 c2 02 00 	ld.hu %d2,[%a12]2
80010632:	df 02 27 00 	jeq %d2,0,80010680 <__multiply+0xfa>
80010636:	54 33       	ld.w %d3,[%a3]
80010638:	40 34       	mov.aa %a4,%a3
8001063a:	40 f5       	mov.aa %a5,%a15
8001063c:	82 07       	mov %d7,0
8001063e:	40 56       	mov.aa %a6,%a5
80010640:	44 66       	ld.w %d6,[%a6+]
80010642:	40 47       	mov.aa %a7,%a4
80010644:	44 75       	ld.w %d5,[%a7+]
80010646:	b7 06 10 68 	insert %d6,%d6,0,16,16
8001064a:	8f 05 1f 50 	sh %d5,%d5,-16
8001064e:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
80010652:	42 7f       	add %d15,%d7
80010654:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
80010658:	8f 0f 1f f0 	sh %d15,%d15,-16
8001065c:	74 43       	st.w [%a4],%d3
8001065e:	b9 55 02 00 	ld.hu %d5,[%a5]2
80010662:	b9 43 04 00 	ld.hu %d3,[%a4]4
80010666:	40 65       	mov.aa %a5,%a6
80010668:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
8001066c:	42 f3       	add %d3,%d15
8001066e:	80 6f       	mov.d %d15,%a6
80010670:	8f 03 1f 70 	sh %d7,%d3,-16
80010674:	7f 4f 04 80 	jge.u %d15,%d4,8001067c <__multiply+0xf6>
80010678:	40 74       	mov.aa %a4,%a7
8001067a:	3c e2       	j 8001063e <__multiply+0xb8>
8001067c:	59 43 04 00 	st.w [%a4]4,%d3
80010680:	b0 4c       	add.a %a12,4
80010682:	b0 43       	add.a %a3,4
80010684:	3c ac       	j 800105dc <__multiply+0x56>
80010686:	8b 08 40 f3 	max %d15,%d8,0
8001068a:	9f 0f 05 80 	jned %d15,0,80010694 <__multiply+0x10e>
8001068e:	59 28 10 00 	st.w [%a2]16,%d8
80010692:	00 90       	ret 
80010694:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
80010698:	df 02 fb ff 	jne %d2,0,8001068e <__multiply+0x108>
8001069c:	c2 f8       	add %d8,-1
8001069e:	3c f6       	j 8001068a <__multiply+0x104>

800106a0 <__pow5mult>:
800106a0:	8f 34 00 21 	and %d2,%d4,3
800106a4:	40 4c       	mov.aa %a12,%a4
800106a6:	40 5d       	mov.aa %a13,%a5
800106a8:	02 4f       	mov %d15,%d4
800106aa:	76 2d       	jz %d2,800106c4 <__pow5mult+0x24>
800106ac:	91 00 00 f8 	movh.a %a15,32768
800106b0:	d9 ff e8 20 	lea %a15,[%a15]3240 <80000ca8 <p05.2553>>
800106b4:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
800106b8:	82 05       	mov %d5,0
800106ba:	19 f4 fc ff 	ld.w %d4,[%a15]-4
800106be:	6d ff c7 fe 	call 8001044c <__multadd>
800106c2:	40 2d       	mov.aa %a13,%a2
800106c4:	86 ef       	sha %d15,-2
800106c6:	6e 29       	jz %d15,80010718 <__pow5mult+0x78>
800106c8:	99 cf 08 10 	ld.a %a15,[%a12]72
800106cc:	7c fb       	jnz.a %a15,800106e2 <__pow5mult+0x42>
800106ce:	40 c4       	mov.aa %a4,%a12
800106d0:	3b 10 27 40 	mov %d4,625
800106d4:	6d ff 51 ff 	call 80010576 <__i2b>
800106d8:	82 02       	mov %d2,0
800106da:	b5 c2 08 10 	st.a [%a12]72,%a2
800106de:	40 2f       	mov.aa %a15,%a2
800106e0:	74 22       	st.w [%a2],%d2
800106e2:	82 08       	mov %d8,0
800106e4:	2e 0c       	jz.t %d15,0,800106fc <__pow5mult+0x5c>
800106e6:	40 d5       	mov.aa %a5,%a13
800106e8:	40 c4       	mov.aa %a4,%a12
800106ea:	40 f6       	mov.aa %a6,%a15
800106ec:	6d ff 4d ff 	call 80010586 <__multiply>
800106f0:	40 d5       	mov.aa %a5,%a13
800106f2:	40 2e       	mov.aa %a14,%a2
800106f4:	40 c4       	mov.aa %a4,%a12
800106f6:	6d ff a2 fe 	call 8001043a <_Bfree>
800106fa:	40 ed       	mov.aa %a13,%a14
800106fc:	86 ff       	sha %d15,-1
800106fe:	6e 0d       	jz %d15,80010718 <__pow5mult+0x78>
80010700:	c8 02       	ld.a %a2,[%a15]0
80010702:	bc 23       	jz.a %a2,80010708 <__pow5mult+0x68>
80010704:	40 2f       	mov.aa %a15,%a2
80010706:	3c ef       	j 800106e4 <__pow5mult+0x44>
80010708:	40 c4       	mov.aa %a4,%a12
8001070a:	40 f5       	mov.aa %a5,%a15
8001070c:	40 f6       	mov.aa %a6,%a15
8001070e:	6d ff 3c ff 	call 80010586 <__multiply>
80010712:	e8 02       	st.a [%a15]0,%a2
80010714:	74 28       	st.w [%a2],%d8
80010716:	3c f7       	j 80010704 <__pow5mult+0x64>
80010718:	40 d2       	mov.aa %a2,%a13
8001071a:	00 90       	ret 

8001071c <__lshift>:
8001071c:	19 5b 10 00 	ld.w %d11,[%a5]16
80010720:	8f b4 3f 80 	sha %d8,%d4,-5
80010724:	02 4a       	mov %d10,%d4
80010726:	42 8b       	add %d11,%d8
80010728:	19 54 04 00 	ld.w %d4,[%a5]4
8001072c:	4c 52       	ld.w %d15,[%a5]8
8001072e:	40 4e       	mov.aa %a14,%a4
80010730:	40 5c       	mov.aa %a12,%a5
80010732:	1b 1b 00 90 	addi %d9,%d11,1
80010736:	7f 9f 05 00 	jge %d15,%d9,80010740 <__lshift+0x24>
8001073a:	c2 14       	add %d4,1
8001073c:	06 1f       	sh %d15,1
8001073e:	3c fc       	j 80010736 <__lshift+0x1a>
80010740:	40 e4       	mov.aa %a4,%a14
80010742:	6d ff 51 fe 	call 800103e4 <_Balloc>
80010746:	8b 08 40 f3 	max %d15,%d8,0
8001074a:	40 2d       	mov.aa %a13,%a2
8001074c:	d9 2f 14 00 	lea %a15,[%a2]20
80010750:	d2 02       	mov %e2,0
80010752:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
80010756:	9f 0f 03 80 	jned %d15,0,8001075c <__lshift+0x40>
8001075a:	3c 04       	j 80010762 <__lshift+0x46>
8001075c:	74 23       	st.w [%a2],%d3
8001075e:	c2 12       	add %d2,1
80010760:	3c f9       	j 80010752 <__lshift+0x36>
80010762:	8b 08 40 83 	max %d8,%d8,0
80010766:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
8001076a:	d9 cf 14 00 	lea %a15,[%a12]20
8001076e:	19 c2 10 00 	ld.w %d2,[%a12]16
80010772:	80 f3       	mov.d %d3,%a15
80010774:	8f fa 01 41 	and %d4,%d10,31
80010778:	13 42 20 23 	madd %d2,%d3,%d2,4
8001077c:	8b 04 02 51 	rsub %d5,%d4,32
80010780:	82 0f       	mov %d15,0
80010782:	df 04 1a 00 	jeq %d4,0,800107b6 <__lshift+0x9a>
80010786:	40 f5       	mov.aa %a5,%a15
80010788:	44 53       	ld.w %d3,[%a5+]
8001078a:	d9 32 04 00 	lea %a2,[%a3]4
8001078e:	0f 43 00 30 	sh %d3,%d3,%d4
80010792:	a6 3f       	or %d15,%d3
80010794:	6c 30       	st.w [%a3]0,%d15
80010796:	4c f0       	ld.w %d15,[%a15]0
80010798:	8b 05 00 31 	rsub %d3,%d5,0
8001079c:	0f 3f 00 30 	sh %d3,%d15,%d3
800107a0:	02 3f       	mov %d15,%d3
800107a2:	80 53       	mov.d %d3,%a5
800107a4:	40 5f       	mov.aa %a15,%a5
800107a6:	7f 23 04 80 	jge.u %d3,%d2,800107ae <__lshift+0x92>
800107aa:	40 23       	mov.aa %a3,%a2
800107ac:	3c ed       	j 80010786 <__lshift+0x6a>
800107ae:	c2 2b       	add %d11,2
800107b0:	6c 31       	st.w [%a3]4,%d15
800107b2:	2a b9       	cmov %d9,%d15,%d11
800107b4:	3c 08       	j 800107c4 <__lshift+0xa8>
800107b6:	4c f0       	ld.w %d15,[%a15]0
800107b8:	b0 4f       	add.a %a15,4
800107ba:	80 f3       	mov.d %d3,%a15
800107bc:	6c 30       	st.w [%a3]0,%d15
800107be:	b0 43       	add.a %a3,4
800107c0:	3f 23 fb ff 	jlt.u %d3,%d2,800107b6 <__lshift+0x9a>
800107c4:	c2 f9       	add %d9,-1
800107c6:	59 d9 10 00 	st.w [%a13]16,%d9
800107ca:	40 e4       	mov.aa %a4,%a14
800107cc:	40 c5       	mov.aa %a5,%a12
800107ce:	6d ff 36 fe 	call 8001043a <_Bfree>
800107d2:	40 d2       	mov.aa %a2,%a13
800107d4:	00 90       	ret 

800107d6 <__mcmp>:
800107d6:	4c 54       	ld.w %d15,[%a5]16
800107d8:	19 42 10 00 	ld.w %d2,[%a4]16
800107dc:	a2 f2       	sub %d2,%d15
800107de:	df 02 1c 80 	jne %d2,0,80010816 <__mcmp+0x40>
800107e2:	80 42       	mov.d %d2,%a4
800107e4:	06 2f       	sh %d15,2
800107e6:	60 f2       	mov.a %a2,%d15
800107e8:	1b 42 01 30 	addi %d3,%d2,20
800107ec:	d9 55 14 00 	lea %a5,[%a5]20
800107f0:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
800107f4:	30 25       	add.a %a5,%a2
800107f6:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
800107fa:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
800107fe:	5f f2 08 00 	jeq %d2,%d15,8001080e <__mcmp+0x38>
80010802:	0b f2 30 21 	lt.u %d2,%d2,%d15
80010806:	82 f3       	mov %d3,-1
80010808:	ab 13 80 22 	sel %d2,%d2,%d3,1
8001080c:	00 90       	ret 
8001080e:	80 ff       	mov.d %d15,%a15
80010810:	3f f3 f3 ff 	jlt.u %d3,%d15,800107f6 <__mcmp+0x20>
80010814:	82 02       	mov %d2,0
80010816:	00 90       	ret 

80010818 <__mdiff>:
80010818:	40 4d       	mov.aa %a13,%a4
8001081a:	40 5f       	mov.aa %a15,%a5
8001081c:	40 54       	mov.aa %a4,%a5
8001081e:	40 65       	mov.aa %a5,%a6
80010820:	40 6c       	mov.aa %a12,%a6
80010822:	6d ff da ff 	call 800107d6 <__mcmp>
80010826:	02 2f       	mov %d15,%d2
80010828:	f6 2a       	jnz %d2,8001083c <__mdiff+0x24>
8001082a:	40 d4       	mov.aa %a4,%a13
8001082c:	82 04       	mov %d4,0
8001082e:	6d ff db fd 	call 800103e4 <_Balloc>
80010832:	82 12       	mov %d2,1
80010834:	59 22 10 00 	st.w [%a2]16,%d2
80010838:	6c 25       	st.w [%a2]20,%d15
8001083a:	00 90       	ret 
8001083c:	82 08       	mov %d8,0
8001083e:	ce 25       	jgez %d2,80010848 <__mdiff+0x30>
80010840:	40 f2       	mov.aa %a2,%a15
80010842:	82 18       	mov %d8,1
80010844:	40 cf       	mov.aa %a15,%a12
80010846:	40 2c       	mov.aa %a12,%a2
80010848:	40 d4       	mov.aa %a4,%a13
8001084a:	48 14       	ld.w %d4,[%a15]4
8001084c:	6d ff cc fd 	call 800103e4 <_Balloc>
80010850:	48 42       	ld.w %d2,[%a15]16
80010852:	d9 ff 14 00 	lea %a15,[%a15]20
80010856:	80 ff       	mov.d %d15,%a15
80010858:	d9 c4 14 00 	lea %a4,[%a12]20
8001085c:	13 42 20 7f 	madd %d7,%d15,%d2,4
80010860:	19 c0 10 00 	ld.w %d0,[%a12]16
80010864:	80 4f       	mov.d %d15,%a4
80010866:	59 28 0c 00 	st.w [%a2]12,%d8
8001086a:	13 40 20 0f 	madd %d0,%d15,%d0,4
8001086e:	d9 25 14 00 	lea %a5,[%a2]20
80010872:	82 03       	mov %d3,0
80010874:	44 f6       	ld.w %d6,[%a15+]
80010876:	44 45       	ld.w %d5,[%a4+]
80010878:	b7 06 10 48 	insert %d4,%d6,0,16,16
8001087c:	b7 05 10 18 	insert %d1,%d5,0,16,16
80010880:	42 34       	add %d4,%d3
80010882:	a2 14       	sub %d4,%d1
80010884:	8f 06 1f 60 	sh %d6,%d6,-16
80010888:	8f 05 1f 50 	sh %d5,%d5,-16
8001088c:	8f 04 3f 30 	sha %d3,%d4,-16
80010890:	0b 56 80 50 	sub %d5,%d6,%d5
80010894:	1a 35       	add %d15,%d5,%d3
80010896:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8001089a:	8f 0f 3f 30 	sha %d3,%d15,-16
8001089e:	80 4f       	mov.d %d15,%a4
800108a0:	d9 53 04 00 	lea %a3,[%a5]4
800108a4:	74 54       	st.w [%a5],%d4
800108a6:	40 35       	mov.aa %a5,%a3
800108a8:	3f 0f e6 ff 	jlt.u %d15,%d0,80010874 <__mdiff+0x5c>
800108ac:	80 ff       	mov.d %d15,%a15
800108ae:	7f 7f 12 80 	jge.u %d15,%d7,800108d2 <__mdiff+0xba>
800108b2:	44 f5       	ld.w %d5,[%a15+]
800108b4:	b7 05 10 48 	insert %d4,%d5,0,16,16
800108b8:	8f 05 1f 50 	sh %d5,%d5,-16
800108bc:	42 34       	add %d4,%d3
800108be:	8f 04 3f f0 	sha %d15,%d4,-16
800108c2:	42 5f       	add %d15,%d5
800108c4:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
800108c8:	8f 0f 3f 30 	sha %d3,%d15,-16
800108cc:	74 34       	st.w [%a3],%d4
800108ce:	b0 43       	add.a %a3,4
800108d0:	3c ee       	j 800108ac <__mdiff+0x94>
800108d2:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
800108d6:	ee 03       	jnz %d15,800108dc <__mdiff+0xc4>
800108d8:	c2 f2       	add %d2,-1
800108da:	3c fc       	j 800108d2 <__mdiff+0xba>
800108dc:	59 22 10 00 	st.w [%a2]16,%d2
800108e0:	00 90       	ret 

800108e2 <__d2b>:
800108e2:	20 08       	sub.a %sp,8
800108e4:	02 48       	mov %d8,%d4
800108e6:	82 14       	mov %d4,1
800108e8:	02 59       	mov %d9,%d5
800108ea:	40 5d       	mov.aa %a13,%a5
800108ec:	40 6c       	mov.aa %a12,%a6
800108ee:	6d ff 7b fd 	call 800103e4 <_Balloc>
800108f2:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
800108f6:	37 09 6b 9a 	extr.u %d9,%d9,20,11
800108fa:	40 2f       	mov.aa %a15,%a2
800108fc:	76 93       	jz %d9,80010902 <__d2b+0x20>
800108fe:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
80010902:	59 a2 04 00 	st.w [%sp]4,%d2
80010906:	df 08 20 00 	jeq %d8,0,80010946 <__d2b+0x64>
8001090a:	d9 a4 08 00 	lea %a4,[%sp]8
8001090e:	89 48 38 f5 	st.w [+%a4]-8,%d8
80010912:	40 a4       	mov.aa %a4,%sp
80010914:	6d ff fe fd 	call 80010510 <__lo0bits>
80010918:	58 00       	ld.w %d15,[%sp]0
8001091a:	76 2f       	jz %d2,80010938 <__d2b+0x56>
8001091c:	19 a4 04 00 	ld.w %d4,[%sp]4
80010920:	8b 02 02 31 	rsub %d3,%d2,32
80010924:	0f 34 00 30 	sh %d3,%d4,%d3
80010928:	a6 3f       	or %d15,%d3
8001092a:	68 5f       	st.w [%a15]20,%d15
8001092c:	8b 02 00 f1 	rsub %d15,%d2,0
80010930:	0f f4 00 f0 	sh %d15,%d4,%d15
80010934:	78 01       	st.w [%sp]4,%d15
80010936:	3c 02       	j 8001093a <__d2b+0x58>
80010938:	68 5f       	st.w [%a15]20,%d15
8001093a:	58 01       	ld.w %d15,[%sp]4
8001093c:	82 28       	mov %d8,2
8001093e:	ea 18       	cmovn %d8,%d15,1
80010940:	68 6f       	st.w [%a15]24,%d15
80010942:	68 48       	st.w [%a15]16,%d8
80010944:	3c 0c       	j 8001095c <__d2b+0x7a>
80010946:	d9 a4 04 00 	lea %a4,[%sp]4
8001094a:	6d ff e3 fd 	call 80010510 <__lo0bits>
8001094e:	58 01       	ld.w %d15,[%sp]4
80010950:	1b 02 02 20 	addi %d2,%d2,32
80010954:	68 5f       	st.w [%a15]20,%d15
80010956:	82 1f       	mov %d15,1
80010958:	68 4f       	st.w [%a15]16,%d15
8001095a:	82 18       	mov %d8,1
8001095c:	76 98       	jz %d9,8001096c <__d2b+0x8a>
8001095e:	1b d9 bc 9f 	addi %d9,%d9,-1075
80010962:	42 29       	add %d9,%d2
80010964:	74 d9       	st.w [%a13],%d9
80010966:	8b 52 03 21 	rsub %d2,%d2,53
8001096a:	3c 0d       	j 80010984 <__d2b+0xa2>
8001096c:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
80010970:	1b e2 bc 2f 	addi %d2,%d2,-1074
80010974:	74 d2       	st.w [%a13],%d2
80010976:	19 24 10 00 	ld.w %d4,[%a2]16
8001097a:	6d ff aa fd 	call 800104ce <__hi0bits>
8001097e:	06 58       	sh %d8,5
80010980:	0b 28 80 20 	sub %d2,%d8,%d2
80010984:	74 c2       	st.w [%a12],%d2
80010986:	40 f2       	mov.aa %a2,%a15
80010988:	00 90       	ret 

8001098a <__fpclassifyd>:
8001098a:	0f 45 a0 f0 	or %d15,%d5,%d4
8001098e:	82 22       	mov %d2,2
80010990:	6e 1d       	jz %d15,800109ca <__fpclassifyd+0x40>
80010992:	7b 00 00 38 	movh %d3,32768
80010996:	3a 53       	eq %d15,%d3,%d5
80010998:	8b 04 00 f4 	and.eq %d15,%d4,0
8001099c:	8b 04 00 62 	eq %d6,%d4,0
800109a0:	ee 15       	jnz %d15,800109ca <__fpclassifyd+0x40>
800109a2:	b7 05 81 5f 	insert %d5,%d5,0,31,1
800109a6:	7b 00 fe f7 	movh %d15,32736
800109aa:	9b 05 ff 3f 	addih %d3,%d5,65520
800109ae:	82 42       	mov %d2,4
800109b0:	3f f3 0d 80 	jlt.u %d3,%d15,800109ca <__fpclassifyd+0x40>
800109b4:	7b 00 01 f0 	movh %d15,16
800109b8:	82 32       	mov %d2,3
800109ba:	3f f5 08 80 	jlt.u %d5,%d15,800109ca <__fpclassifyd+0x40>
800109be:	7b 00 ff 27 	movh %d2,32752
800109c2:	0b 25 00 51 	eq %d5,%d5,%d2
800109c6:	0f 56 80 20 	and %d2,%d6,%d5
800109ca:	00 90       	ret 

800109cc <_sbrk_r>:
800109cc:	82 0f       	mov %d15,0
800109ce:	91 00 00 c7 	movh.a %a12,28672
800109d2:	59 cf a0 24 	st.w [%a12]18592 <700048a0 <errno>>,%d15
800109d6:	40 4f       	mov.aa %a15,%a4
800109d8:	6d 00 02 05 	call 800113dc <sbrk>
800109dc:	80 2f       	mov.d %d15,%a2
800109de:	5e f5       	jne %d15,-1,800109e8 <_sbrk_r+0x1c>
800109e0:	19 cf a0 24 	ld.w %d15,[%a12]18592 <700048a0 <errno>>
800109e4:	6e 02       	jz %d15,800109e8 <_sbrk_r+0x1c>
800109e6:	68 0f       	st.w [%a15]0,%d15
800109e8:	00 90       	ret 

800109ea <__ssprint_r>:
800109ea:	4c 62       	ld.w %d15,[%a6]8
800109ec:	20 08       	sub.a %sp,8
800109ee:	40 4e       	mov.aa %a14,%a4
800109f0:	40 5f       	mov.aa %a15,%a5
800109f2:	40 6c       	mov.aa %a12,%a6
800109f4:	54 6c       	ld.w %d12,[%a6]
800109f6:	6e 30       	jz %d15,80010a56 <__ssprint_r+0x6c>
800109f8:	a0 02       	mov.a %a2,0
800109fa:	b5 a2 04 00 	st.a [%sp]4,%a2
800109fe:	82 09       	mov %d9,0
80010a00:	3b 00 48 e0 	mov %d14,1152
80010a04:	3b f0 b7 df 	mov %d13,-1153
80010a08:	3c 0a       	j 80010a1c <__ssprint_r+0x32>
80010a0a:	60 c2       	mov.a %a2,%d12
80010a0c:	d4 22       	ld.a %a2,[%a2]
80010a0e:	b5 a2 04 00 	st.a [%sp]4,%a2
80010a12:	60 c2       	mov.a %a2,%d12
80010a14:	1b 8c 00 c0 	addi %d12,%d12,8
80010a18:	19 29 04 00 	ld.w %d9,[%a2]4
80010a1c:	df 09 f7 7f 	jeq %d9,0,80010a0a <__ssprint_r+0x20>
80010a20:	48 28       	ld.w %d8,[%a15]8
80010a22:	3f 89 5a 80 	jlt.u %d9,%d8,80010ad6 <__ssprint_r+0xec>
80010a26:	88 62       	ld.h %d2,[%a15]12
80010a28:	0f e2 80 f0 	and %d15,%d2,%d14
80010a2c:	ee 19       	jnz %d15,80010a5e <__ssprint_r+0x74>
80010a2e:	3f 89 54 80 	jlt.u %d9,%d8,80010ad6 <__ssprint_r+0xec>
80010a32:	c8 04       	ld.a %a4,[%a15]0
80010a34:	99 a5 04 00 	ld.a %a5,[%sp]4 <0 <NULL>>
80010a38:	02 84       	mov %d4,%d8
80010a3a:	6d 00 b4 01 	call 80010da2 <memmove>
80010a3e:	4c f2       	ld.w %d15,[%a15]8
80010a40:	a2 8f       	sub %d15,%d8
80010a42:	68 2f       	st.w [%a15]8,%d15
80010a44:	4c f0       	ld.w %d15,[%a15]0
80010a46:	42 f8       	add %d8,%d15
80010a48:	4c c2       	ld.w %d15,[%a12]8
80010a4a:	68 08       	st.w [%a15]0,%d8
80010a4c:	52 99       	sub %d9,%d15,%d9
80010a4e:	59 c9 08 00 	st.w [%a12]8,%d9
80010a52:	df 09 dc ff 	jne %d9,0,80010a0a <__ssprint_r+0x20>
80010a56:	82 0f       	mov %d15,0
80010a58:	6c c1       	st.w [%a12]4,%d15
80010a5a:	82 02       	mov %d2,0
80010a5c:	00 90       	ret 
80010a5e:	c8 45       	ld.a %a5,[%a15]16
80010a60:	48 5a       	ld.w %d10,[%a15]20
80010a62:	4c f0       	ld.w %d15,[%a15]0
80010a64:	80 53       	mov.d %d3,%a5
80010a66:	53 3a 20 a0 	mul %d10,%d10,3
80010a6a:	a2 3f       	sub %d15,%d3
80010a6c:	82 23       	mov %d3,2
80010a6e:	4b 3a 01 a2 	div %e10,%d10,%d3
80010a72:	92 13       	add %d3,%d15,1
80010a74:	42 93       	add %d3,%d9
80010a76:	0b 3a b0 a1 	max.u %d10,%d10,%d3
80010a7a:	40 e4       	mov.aa %a4,%a14
80010a7c:	02 a4       	mov %d4,%d10
80010a7e:	6f a2 12 00 	jz.t %d2,10,80010aa2 <__ssprint_r+0xb8>
80010a82:	6d ff 48 fa 	call 8000ff12 <_malloc_r>
80010a86:	40 2d       	mov.aa %a13,%a2
80010a88:	bd 02 15 00 	jz.a %a2,80010ab2 <__ssprint_r+0xc8>
80010a8c:	c8 45       	ld.a %a5,[%a15]16
80010a8e:	40 24       	mov.aa %a4,%a2
80010a90:	02 f4       	mov %d4,%d15
80010a92:	6d ff 99 fc 	call 800103c4 <memcpy>
80010a96:	88 62       	ld.h %d2,[%a15]12
80010a98:	26 d2       	and %d2,%d13
80010a9a:	8f 02 48 21 	or %d2,%d2,128
80010a9e:	a8 62       	st.h [%a15]12,%d2
80010aa0:	3c 13       	j 80010ac6 <__ssprint_r+0xdc>
80010aa2:	6d 00 b0 01 	call 80010e02 <_realloc_r>
80010aa6:	40 2d       	mov.aa %a13,%a2
80010aa8:	7c 2f       	jnz.a %a2,80010ac6 <__ssprint_r+0xdc>
80010aaa:	c8 45       	ld.a %a5,[%a15]16
80010aac:	40 e4       	mov.aa %a4,%a14
80010aae:	6d 00 a4 00 	call 80010bf6 <_free_r>
80010ab2:	da 0c       	mov %d15,12
80010ab4:	6c e0       	st.w [%a14]0,%d15
80010ab6:	8c f6       	ld.h %d15,[%a15]12
80010ab8:	82 f2       	mov %d2,-1
80010aba:	96 40       	or %d15,64
80010abc:	a8 6f       	st.h [%a15]12,%d15
80010abe:	82 0f       	mov %d15,0
80010ac0:	6c c2       	st.w [%a12]8,%d15
80010ac2:	6c c1       	st.w [%a12]4,%d15
80010ac4:	00 90       	ret 
80010ac6:	e8 4d       	st.a [%a15]16,%a13
80010ac8:	10 dd       	addsc.a %a13,%a13,%d15,0
80010aca:	68 5a       	st.w [%a15]20,%d10
80010acc:	a2 fa       	sub %d10,%d15
80010ace:	e8 0d       	st.a [%a15]0,%a13
80010ad0:	02 98       	mov %d8,%d9
80010ad2:	68 2a       	st.w [%a15]8,%d10
80010ad4:	3c ad       	j 80010a2e <__ssprint_r+0x44>
80010ad6:	02 98       	mov %d8,%d9
80010ad8:	3c ad       	j 80010a32 <__ssprint_r+0x48>

80010ada <_calloc_r>:
80010ada:	e2 54       	mul %d4,%d5
80010adc:	6d ff 1b fa 	call 8000ff12 <_malloc_r>
80010ae0:	40 2f       	mov.aa %a15,%a2
80010ae2:	a0 02       	mov.a %a2,0
80010ae4:	bd 0f 2b 00 	jz.a %a15,80010b3a <_calloc_r+0x60>
80010ae8:	19 f5 fc ff 	ld.w %d5,[%a15]-4
80010aec:	8f 35 c0 51 	andn %d5,%d5,3
80010af0:	c2 c5       	add %d5,-4
80010af2:	8b 55 a2 f2 	ge.u %d15,%d5,37
80010af6:	ee 1d       	jnz %d15,80010b30 <_calloc_r+0x56>
80010af8:	8b 45 61 f2 	lt.u %d15,%d5,20
80010afc:	40 f2       	mov.aa %a2,%a15
80010afe:	ee 14       	jnz %d15,80010b26 <_calloc_r+0x4c>
80010b00:	82 0f       	mov %d15,0
80010b02:	68 0f       	st.w [%a15]0,%d15
80010b04:	68 1f       	st.w [%a15]4,%d15
80010b06:	8b c5 a1 22 	ge.u %d2,%d5,28
80010b0a:	d9 f2 08 00 	lea %a2,[%a15]8
80010b0e:	76 2c       	jz %d2,80010b26 <_calloc_r+0x4c>
80010b10:	68 2f       	st.w [%a15]8,%d15
80010b12:	68 3f       	st.w [%a15]12,%d15
80010b14:	8b 45 02 52 	eq %d5,%d5,36
80010b18:	d9 f2 10 00 	lea %a2,[%a15]16
80010b1c:	76 55       	jz %d5,80010b26 <_calloc_r+0x4c>
80010b1e:	68 4f       	st.w [%a15]16,%d15
80010b20:	d9 f2 18 00 	lea %a2,[%a15]24
80010b24:	68 5f       	st.w [%a15]20,%d15
80010b26:	82 0f       	mov %d15,0
80010b28:	6c 20       	st.w [%a2]0,%d15
80010b2a:	6c 21       	st.w [%a2]4,%d15
80010b2c:	6c 22       	st.w [%a2]8,%d15
80010b2e:	3c 05       	j 80010b38 <_calloc_r+0x5e>
80010b30:	40 f4       	mov.aa %a4,%a15
80010b32:	82 04       	mov %d4,0
80010b34:	6d 00 5f 01 	call 80010df2 <memset>
80010b38:	40 f2       	mov.aa %a2,%a15
80010b3a:	00 90       	ret 

80010b3c <_malloc_trim_r>:
80010b3c:	02 4f       	mov %d15,%d4
80010b3e:	40 4f       	mov.aa %a15,%a4
80010b40:	6d ff 50 fc 	call 800103e0 <__malloc_lock>
80010b44:	91 00 00 c7 	movh.a %a12,28672
80010b48:	d9 cc 98 21 	lea %a12,[%a12]6296 <70001898 <__malloc_av_>>
80010b4c:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <__DSPR0_START+0x8>>
80010b50:	3b 00 00 21 	mov %d2,4096
80010b54:	19 28 04 00 	ld.w %d8,[%a2]4
80010b58:	8f 38 c0 81 	andn %d8,%d8,3
80010b5c:	5a f8       	sub %d15,%d8,%d15
80010b5e:	1b ff fe f0 	addi %d15,%d15,4079
80010b62:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
80010b66:	1b 0f 00 ff 	addi %d15,%d15,-4096
80010b6a:	7f 2f 07 00 	jge %d15,%d2,80010b78 <_malloc_trim_r+0x3c>
80010b6e:	40 f4       	mov.aa %a4,%a15
80010b70:	6d ff 39 fc 	call 800103e2 <__malloc_unlock>
80010b74:	82 02       	mov %d2,0
80010b76:	00 90       	ret 
80010b78:	40 f4       	mov.aa %a4,%a15
80010b7a:	82 04       	mov %d4,0
80010b7c:	6d ff 28 ff 	call 800109cc <_sbrk_r>
80010b80:	99 c3 08 00 	ld.a %a3,[%a12]8
80010b84:	60 84       	mov.a %a4,%d8
80010b86:	30 43       	add.a %a3,%a4
80010b88:	7d 32 f3 ff 	jne.a %a2,%a3,80010b6e <_malloc_trim_r+0x32>
80010b8c:	40 f4       	mov.aa %a4,%a15
80010b8e:	8b 0f 00 41 	rsub %d4,%d15,0
80010b92:	6d ff 1d ff 	call 800109cc <_sbrk_r>
80010b96:	80 22       	mov.d %d2,%a2
80010b98:	df f2 1c 80 	jne %d2,-1,80010bd0 <_malloc_trim_r+0x94>
80010b9c:	40 f4       	mov.aa %a4,%a15
80010b9e:	82 04       	mov %d4,0
80010ba0:	6d ff 16 ff 	call 800109cc <_sbrk_r>
80010ba4:	99 c3 08 00 	ld.a %a3,[%a12]8
80010ba8:	01 32 20 40 	sub.a %a4,%a2,%a3
80010bac:	80 4f       	mov.d %d15,%a4
80010bae:	8b 0f 41 22 	lt %d2,%d15,16
80010bb2:	df 02 de ff 	jne %d2,0,80010b6e <_malloc_trim_r+0x32>
80010bb6:	91 00 00 47 	movh.a %a4,28672
80010bba:	99 44 90 21 	ld.a %a4,[%a4]6288 <70001890 <__malloc_sbrk_base>>
80010bbe:	96 01       	or %d15,1
80010bc0:	6c 31       	st.w [%a3]4,%d15
80010bc2:	01 42 20 20 	sub.a %a2,%a2,%a4
80010bc6:	91 00 00 47 	movh.a %a4,28672
80010bca:	b5 42 a8 14 	st.a [%a4]18536 <70004868 <__malloc_current_mallinfo>>,%a2
80010bce:	3c d0       	j 80010b6e <_malloc_trim_r+0x32>
80010bd0:	99 c2 08 00 	ld.a %a2,[%a12]8
80010bd4:	a2 f8       	sub %d8,%d15
80010bd6:	8f 18 40 81 	or %d8,%d8,1
80010bda:	59 28 04 00 	st.w [%a2]4,%d8
80010bde:	91 00 00 27 	movh.a %a2,28672
80010be2:	19 22 a8 14 	ld.w %d2,[%a2]18536 <70004868 <__malloc_current_mallinfo>>
80010be6:	40 f4       	mov.aa %a4,%a15
80010be8:	5a f2       	sub %d15,%d2,%d15
80010bea:	59 2f a8 14 	st.w [%a2]18536 <70004868 <__malloc_current_mallinfo>>,%d15
80010bee:	6d ff fa fb 	call 800103e2 <__malloc_unlock>
80010bf2:	82 12       	mov %d2,1
80010bf4:	00 90       	ret 

80010bf6 <_free_r>:
80010bf6:	40 4d       	mov.aa %a13,%a4
80010bf8:	bd 05 d4 00 	jz.a %a5,80010da0 <_free_r+0x1aa>
80010bfc:	40 5c       	mov.aa %a12,%a5
80010bfe:	6d ff f1 fb 	call 800103e0 <__malloc_lock>
80010c02:	19 c4 fc ff 	ld.w %d4,[%a12]-4
80010c06:	d9 cf f8 ff 	lea %a15,[%a12]-8
80010c0a:	8f 14 c0 f1 	andn %d15,%d4,1
80010c0e:	91 00 00 27 	movh.a %a2,28672
80010c12:	10 f3       	addsc.a %a3,%a15,%d15,0
80010c14:	d9 22 98 21 	lea %a2,[%a2]6296 <70001898 <__malloc_av_>>
80010c18:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <__DSPR0_START+0x8>>
80010c1c:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <__DSPR0_START+0x8>>
80010c20:	8f 14 00 41 	and %d4,%d4,1
80010c24:	8f 33 c0 31 	andn %d3,%d3,3
80010c28:	7d 43 24 80 	jne.a %a3,%a4,80010c70 <_free_r+0x7a>
80010c2c:	42 3f       	add %d15,%d3
80010c2e:	f6 4d       	jnz %d4,80010c48 <_free_r+0x52>
80010c30:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
80010c34:	60 23       	mov.a %a3,%d2
80010c36:	42 2f       	add %d15,%d2
80010c38:	01 3f 20 f0 	sub.a %a15,%a15,%a3
80010c3c:	c8 33       	ld.a %a3,[%a15]12
80010c3e:	c8 24       	ld.a %a4,[%a15]8
80010c40:	b5 43 0c 00 	st.a [%a4]12,%a3
80010c44:	b5 34 08 00 	st.a [%a3]8,%a4
80010c48:	8f 1f 40 21 	or %d2,%d15,1
80010c4c:	68 12       	st.w [%a15]4,%d2
80010c4e:	ec 22       	st.a [%a2]8,%a15
80010c50:	91 00 00 f7 	movh.a %a15,28672
80010c54:	19 f2 94 21 	ld.w %d2,[%a15]6292 <70001894 <__malloc_trim_threshold>>
80010c58:	3f 2f 09 80 	jlt.u %d15,%d2,80010c6a <_free_r+0x74>
80010c5c:	91 00 00 f7 	movh.a %a15,28672
80010c60:	40 d4       	mov.aa %a4,%a13
80010c62:	19 f4 98 24 	ld.w %d4,[%a15]18584 <70004898 <__malloc_top_pad>>
80010c66:	6d ff 6b ff 	call 80010b3c <_malloc_trim_r>
80010c6a:	40 d4       	mov.aa %a4,%a13
80010c6c:	1d ff bb fb 	j 800103e2 <__malloc_unlock>
80010c70:	59 33 04 00 	st.w [%a3]4,%d3
80010c74:	82 02       	mov %d2,0
80010c76:	df 04 16 80 	jne %d4,0,80010ca2 <_free_r+0xac>
80010c7a:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
80010c7e:	60 24       	mov.a %a4,%d2
80010c80:	42 2f       	add %d15,%d2
80010c82:	01 4f 20 f0 	sub.a %a15,%a15,%a4
80010c86:	c8 25       	ld.a %a5,[%a15]8
80010c88:	91 00 00 47 	movh.a %a4,28672
80010c8c:	d9 44 a0 21 	lea %a4,[%a4]6304 <700018a0 <__malloc_av_+0x8>>
80010c90:	82 12       	mov %d2,1
80010c92:	7d 45 08 00 	jeq.a %a5,%a4,80010ca2 <_free_r+0xac>
80010c96:	c8 34       	ld.a %a4,[%a15]12
80010c98:	82 02       	mov %d2,0
80010c9a:	b5 54 0c 00 	st.a [%a5]12,%a4
80010c9e:	b5 45 08 00 	st.a [%a4]8,%a5
80010ca2:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
80010ca6:	19 44 04 00 	ld.w %d4,[%a4]4
80010caa:	6f 04 18 80 	jnz.t %d4,0,80010cda <_free_r+0xe4>
80010cae:	42 3f       	add %d15,%d3
80010cb0:	99 35 08 00 	ld.a %a5,[%a3]8
80010cb4:	f6 2d       	jnz %d2,80010cce <_free_r+0xd8>
80010cb6:	91 00 00 47 	movh.a %a4,28672
80010cba:	d9 44 a0 21 	lea %a4,[%a4]6304 <700018a0 <__malloc_av_+0x8>>
80010cbe:	7d 45 08 80 	jne.a %a5,%a4,80010cce <_free_r+0xd8>
80010cc2:	ec 25       	st.a [%a2]20,%a15
80010cc4:	ec 24       	st.a [%a2]16,%a15
80010cc6:	e8 35       	st.a [%a15]12,%a5
80010cc8:	e8 25       	st.a [%a15]8,%a5
80010cca:	82 12       	mov %d2,1
80010ccc:	3c 07       	j 80010cda <_free_r+0xe4>
80010cce:	99 33 0c 00 	ld.a %a3,[%a3]12
80010cd2:	b5 53 0c 00 	st.a [%a5]12,%a3
80010cd6:	b5 35 08 00 	st.a [%a3]8,%a5
80010cda:	8f 1f 40 31 	or %d3,%d15,1
80010cde:	10 f3       	addsc.a %a3,%a15,%d15,0
80010ce0:	68 13       	st.w [%a15]4,%d3
80010ce2:	6c 30       	st.w [%a3]0,%d15
80010ce4:	df 02 c3 ff 	jne %d2,0,80010c6a <_free_r+0x74>
80010ce8:	3b 00 20 20 	mov %d2,512
80010cec:	7f 2f 12 80 	jge.u %d15,%d2,80010d10 <_free_r+0x11a>
80010cf0:	19 23 04 00 	ld.w %d3,[%a2]4
80010cf4:	06 df       	sh %d15,-3
80010cf6:	8f ef 3f 20 	sha %d2,%d15,-2
80010cfa:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80010cfe:	59 22 04 00 	st.w [%a2]4,%d2
80010d02:	d0 22       	addsc.a %a2,%a2,%d15,3
80010d04:	99 23 08 00 	ld.a %a3,[%a2]8
80010d08:	e8 32       	st.a [%a15]12,%a2
80010d0a:	e8 23       	st.a [%a15]8,%a3
80010d0c:	ec 22       	st.a [%a2]8,%a15
80010d0e:	3c 46       	j 80010d9a <_free_r+0x1a4>
80010d10:	8f af 1f 30 	sh %d3,%d15,-6
80010d14:	8f 7f 1f 20 	sh %d2,%d15,-9
80010d18:	1b 83 03 30 	addi %d3,%d3,56
80010d1c:	bf 52 22 80 	jlt.u %d2,5,80010d60 <_free_r+0x16a>
80010d20:	8b 52 a1 32 	ge.u %d3,%d2,21
80010d24:	f6 34       	jnz %d3,80010d2c <_free_r+0x136>
80010d26:	1b b2 05 30 	addi %d3,%d2,91
80010d2a:	3c 1b       	j 80010d60 <_free_r+0x16a>
80010d2c:	8b 52 a5 32 	ge.u %d3,%d2,85
80010d30:	f6 36       	jnz %d3,80010d3c <_free_r+0x146>
80010d32:	8f 4f 1f 30 	sh %d3,%d15,-12
80010d36:	1b e3 06 30 	addi %d3,%d3,110
80010d3a:	3c 13       	j 80010d60 <_free_r+0x16a>
80010d3c:	8b 52 b5 32 	ge.u %d3,%d2,341
80010d40:	f6 36       	jnz %d3,80010d4c <_free_r+0x156>
80010d42:	8f 1f 1f 30 	sh %d3,%d15,-15
80010d46:	1b 73 07 30 	addi %d3,%d3,119
80010d4a:	3c 0b       	j 80010d60 <_free_r+0x16a>
80010d4c:	3b 50 55 40 	mov %d4,1365
80010d50:	3b e0 07 30 	mov %d3,126
80010d54:	7f 42 06 80 	jge.u %d2,%d4,80010d60 <_free_r+0x16a>
80010d58:	8f ef 1e 30 	sh %d3,%d15,-18
80010d5c:	1b c3 07 30 	addi %d3,%d3,124
80010d60:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
80010d64:	99 65 08 00 	ld.a %a5,[%a6]8
80010d68:	40 53       	mov.aa %a3,%a5
80010d6a:	7d 65 0d 80 	jne.a %a5,%a6,80010d84 <_free_r+0x18e>
80010d6e:	4c 21       	ld.w %d15,[%a2]4
80010d70:	86 e3       	sha %d3,-2
80010d72:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
80010d76:	59 23 04 00 	st.w [%a2]4,%d3
80010d7a:	3c 0d       	j 80010d94 <_free_r+0x19e>
80010d7c:	99 33 08 00 	ld.a %a3,[%a3]8
80010d80:	7d 63 08 00 	jeq.a %a3,%a6,80010d90 <_free_r+0x19a>
80010d84:	19 32 04 00 	ld.w %d2,[%a3]4
80010d88:	8f 32 c0 21 	andn %d2,%d2,3
80010d8c:	3f 2f f8 ff 	jlt.u %d15,%d2,80010d7c <_free_r+0x186>
80010d90:	99 35 0c 00 	ld.a %a5,[%a3]12
80010d94:	e8 35       	st.a [%a15]12,%a5
80010d96:	e8 23       	st.a [%a15]8,%a3
80010d98:	ec 52       	st.a [%a5]8,%a15
80010d9a:	ec 33       	st.a [%a3]12,%a15
80010d9c:	1d ff 67 ff 	j 80010c6a <_free_r+0x74>
80010da0:	00 90       	ret 

80010da2 <memmove>:
80010da2:	80 46       	mov.d %d6,%a4
80010da4:	80 52       	mov.d %d2,%a5
80010da6:	7f 62 16 80 	jge.u %d2,%d6,80010dd2 <memmove+0x30>
80010daa:	0b 42 00 50 	add %d5,%d2,%d4
80010dae:	7f 56 12 80 	jge.u %d6,%d5,80010dd2 <memmove+0x30>
80010db2:	60 4f       	mov.a %a15,%d4
80010db4:	02 42       	mov %d2,%d4
80010db6:	c2 f2       	add %d2,-1
80010db8:	fd f0 03 00 	loop %a15,80010dbe <memmove+0x1c>
80010dbc:	3c 19       	j 80010dee <memmove+0x4c>
80010dbe:	5a 42       	sub %d15,%d2,%d4
80010dc0:	60 f2       	mov.a %a2,%d15
80010dc2:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
80010dc6:	1a 62       	add %d15,%d2,%d6
80010dc8:	79 23 00 00 	ld.b %d3,[%a2]0
80010dcc:	60 f2       	mov.a %a2,%d15
80010dce:	34 23       	st.b [%a2],%d3
80010dd0:	3c f3       	j 80010db6 <memmove+0x14>
80010dd2:	60 4f       	mov.a %a15,%d4
80010dd4:	a0 02       	mov.a %a2,0
80010dd6:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
80010dda:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
80010dde:	fd f0 03 00 	loop %a15,80010de4 <memmove+0x42>
80010de2:	3c 06       	j 80010dee <memmove+0x4c>
80010de4:	79 33 00 00 	ld.b %d3,[%a3]0
80010de8:	b0 12       	add.a %a2,1
80010dea:	34 43       	st.b [%a4],%d3
80010dec:	3c f5       	j 80010dd6 <memmove+0x34>
80010dee:	60 62       	mov.a %a2,%d6
80010df0:	00 90       	ret 

80010df2 <memset>:
80010df2:	40 42       	mov.aa %a2,%a4
80010df4:	40 4f       	mov.aa %a15,%a4
80010df6:	9f 05 03 80 	jned %d5,0,80010dfc <memset+0xa>
80010dfa:	00 90       	ret 
80010dfc:	28 04       	st.b [%a15]0,%d4
80010dfe:	b0 1f       	add.a %a15,1
80010e00:	3c fb       	j 80010df6 <memset+0x4>

80010e02 <_realloc_r>:
80010e02:	40 4d       	mov.aa %a13,%a4
80010e04:	40 5f       	mov.aa %a15,%a5
80010e06:	02 49       	mov %d9,%d4
80010e08:	7c 53       	jnz.a %a5,80010e0e <_realloc_r+0xc>
80010e0a:	1d ff 84 f8 	j 8000ff12 <_malloc_r>
80010e0e:	6d ff e9 fa 	call 800103e0 <__malloc_lock>
80010e12:	1b b9 00 20 	addi %d2,%d9,11
80010e16:	8b 72 61 f2 	lt.u %d15,%d2,23
80010e1a:	8f 72 c0 21 	andn %d2,%d2,7
80010e1e:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
80010e22:	19 f3 fc ff 	ld.w %d3,[%a15]-4
80010e26:	0b 9f 30 21 	lt.u %d2,%d15,%d9
80010e2a:	8b 0f 20 25 	or.lt %d2,%d15,0
80010e2e:	d9 fe f8 ff 	lea %a14,[%a15]-8
80010e32:	8f 33 c0 81 	andn %d8,%d3,3
80010e36:	76 25       	jz %d2,80010e40 <_realloc_r+0x3e>
80010e38:	da 0c       	mov %d15,12
80010e3a:	6c d0       	st.w [%a13]0,%d15
80010e3c:	1d 00 56 01 	j 800110e8 <_realloc_r+0x2e6>
80010e40:	7f f8 ac 01 	jge %d8,%d15,80011198 <_realloc_r+0x396>
80010e44:	7b 00 00 c7 	movh %d12,28672
80010e48:	60 c3       	mov.a %a3,%d12
80010e4a:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
80010e4e:	d9 34 98 21 	lea %a4,[%a3]6296
80010e52:	99 43 08 00 	ld.a %a3,[%a4]8
80010e56:	80 4c       	mov.d %d12,%a4
80010e58:	19 2b 04 00 	ld.w %d11,[%a2]4
80010e5c:	7d 32 0a 00 	jeq.a %a2,%a3,80010e70 <_realloc_r+0x6e>
80010e60:	8f 1b c0 21 	andn %d2,%d11,1
80010e64:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80010e68:	19 42 04 00 	ld.w %d2,[%a4]4
80010e6c:	6f 02 2b 80 	jnz.t %d2,0,80010ec2 <_realloc_r+0xc0>
80010e70:	8f 3b c0 b1 	andn %d11,%d11,3
80010e74:	0b 8b 00 20 	add %d2,%d11,%d8
80010e78:	7d 32 1b 80 	jne.a %a2,%a3,80010eae <_realloc_r+0xac>
80010e7c:	1b 0f 01 40 	addi %d4,%d15,16
80010e80:	3f 42 23 00 	jlt %d2,%d4,80010ec6 <_realloc_r+0xc4>
80010e84:	10 ee       	addsc.a %a14,%a14,%d15,0
80010e86:	60 c2       	mov.a %a2,%d12
80010e88:	a2 f2       	sub %d2,%d15
80010e8a:	b5 2e 08 00 	st.a [%a2]8,%a14
80010e8e:	8f 12 40 21 	or %d2,%d2,1
80010e92:	59 e2 04 00 	st.w [%a14]4,%d2
80010e96:	19 f2 fc ff 	ld.w %d2,[%a15]-4
80010e9a:	40 d4       	mov.aa %a4,%a13
80010e9c:	8f 12 00 21 	and %d2,%d2,1
80010ea0:	a6 2f       	or %d15,%d2
80010ea2:	59 ff fc ff 	st.w [%a15]-4,%d15
80010ea6:	6d ff 9e fa 	call 800103e2 <__malloc_unlock>
80010eaa:	40 f2       	mov.aa %a2,%a15
80010eac:	00 90       	ret 
80010eae:	3f f2 0c 00 	jlt %d2,%d15,80010ec6 <_realloc_r+0xc4>
80010eb2:	cc 23       	ld.a %a15,[%a2]12
80010eb4:	99 22 08 00 	ld.a %a2,[%a2]8
80010eb8:	02 28       	mov %d8,%d2
80010eba:	ec 23       	st.a [%a2]12,%a15
80010ebc:	e8 22       	st.a [%a15]8,%a2
80010ebe:	1d 00 6d 01 	j 80011198 <_realloc_r+0x396>
80010ec2:	82 0b       	mov %d11,0
80010ec4:	a0 02       	mov.a %a2,0
80010ec6:	6f 03 08 81 	jnz.t %d3,0,800110d6 <_realloc_r+0x2d4>
80010eca:	99 fc f8 ff 	ld.a %a12,[%a15]-8
80010ece:	01 ce 20 c0 	sub.a %a12,%a14,%a12
80010ed2:	19 ca 04 00 	ld.w %d10,[%a12]4
80010ed6:	8f 3a c0 a1 	andn %d10,%d10,3
80010eda:	42 8a       	add %d10,%d8
80010edc:	bd 02 b3 00 	jz.a %a2,80011042 <_realloc_r+0x240>
80010ee0:	42 ab       	add %d11,%d10
80010ee2:	7d 32 5f 80 	jne.a %a2,%a3,80010fa0 <_realloc_r+0x19e>
80010ee6:	1b 0f 01 20 	addi %d2,%d15,16
80010eea:	3f 2b ac 00 	jlt %d11,%d2,80011042 <_realloc_r+0x240>
80010eee:	40 ce       	mov.aa %a14,%a12
80010ef0:	99 c2 0c 00 	ld.a %a2,[%a12]12
80010ef4:	09 e3 88 05 	ld.a %a3,[+%a14]8
80010ef8:	1b c8 ff 4f 	addi %d4,%d8,-4
80010efc:	8b 54 a2 22 	ge.u %d2,%d4,37
80010f00:	b5 32 0c 00 	st.a [%a3]12,%a2
80010f04:	b5 23 08 00 	st.a [%a2]8,%a3
80010f08:	df 02 36 80 	jne %d2,0,80010f74 <_realloc_r+0x172>
80010f0c:	8b 44 61 22 	lt.u %d2,%d4,20
80010f10:	40 e3       	mov.aa %a3,%a14
80010f12:	df 02 28 80 	jne %d2,0,80010f62 <_realloc_r+0x160>
80010f16:	48 02       	ld.w %d2,[%a15]0
80010f18:	59 c2 08 00 	st.w [%a12]8,%d2
80010f1c:	48 13       	ld.w %d3,[%a15]4
80010f1e:	8b c4 a1 22 	ge.u %d2,%d4,28
80010f22:	59 c3 0c 00 	st.w [%a12]12,%d3
80010f26:	f6 26       	jnz %d2,80010f32 <_realloc_r+0x130>
80010f28:	d9 c3 10 00 	lea %a3,[%a12]16
80010f2c:	d9 ff 08 00 	lea %a15,[%a15]8
80010f30:	3c 19       	j 80010f62 <_realloc_r+0x160>
80010f32:	48 22       	ld.w %d2,[%a15]8
80010f34:	8b 44 02 82 	eq %d8,%d4,36
80010f38:	59 c2 10 00 	st.w [%a12]16,%d2
80010f3c:	48 33       	ld.w %d3,[%a15]12
80010f3e:	59 c3 14 00 	st.w [%a12]20,%d3
80010f42:	f6 86       	jnz %d8,80010f4e <_realloc_r+0x14c>
80010f44:	d9 c3 18 00 	lea %a3,[%a12]24
80010f48:	d9 ff 10 00 	lea %a15,[%a15]16
80010f4c:	3c 0b       	j 80010f62 <_realloc_r+0x160>
80010f4e:	48 42       	ld.w %d2,[%a15]16
80010f50:	d9 c3 20 00 	lea %a3,[%a12]32
80010f54:	59 c2 18 00 	st.w [%a12]24,%d2
80010f58:	48 53       	ld.w %d3,[%a15]20
80010f5a:	d9 ff 18 00 	lea %a15,[%a15]24
80010f5e:	59 c3 1c 00 	st.w [%a12]28,%d3
80010f62:	48 02       	ld.w %d2,[%a15]0
80010f64:	74 32       	st.w [%a3],%d2
80010f66:	48 13       	ld.w %d3,[%a15]4
80010f68:	59 33 04 00 	st.w [%a3]4,%d3
80010f6c:	48 22       	ld.w %d2,[%a15]8
80010f6e:	59 32 08 00 	st.w [%a3]8,%d2
80010f72:	3c 05       	j 80010f7c <_realloc_r+0x17a>
80010f74:	40 e4       	mov.aa %a4,%a14
80010f76:	40 f5       	mov.aa %a5,%a15
80010f78:	6d ff 15 ff 	call 80010da2 <memmove>
80010f7c:	10 cf       	addsc.a %a15,%a12,%d15,0
80010f7e:	60 c2       	mov.a %a2,%d12
80010f80:	a2 fb       	sub %d11,%d15
80010f82:	ec 22       	st.a [%a2]8,%a15
80010f84:	8f 1b 40 b1 	or %d11,%d11,1
80010f88:	68 1b       	st.w [%a15]4,%d11
80010f8a:	19 c2 04 00 	ld.w %d2,[%a12]4
80010f8e:	40 d4       	mov.aa %a4,%a13
80010f90:	8f 12 00 21 	and %d2,%d2,1
80010f94:	a6 2f       	or %d15,%d2
80010f96:	6c c1       	st.w [%a12]4,%d15
80010f98:	6d ff 25 fa 	call 800103e2 <__malloc_unlock>
80010f9c:	40 e2       	mov.aa %a2,%a14
80010f9e:	00 90       	ret 
80010fa0:	3f fb 51 00 	jlt %d11,%d15,80011042 <_realloc_r+0x240>
80010fa4:	99 23 0c 00 	ld.a %a3,[%a2]12
80010fa8:	99 22 08 00 	ld.a %a2,[%a2]8
80010fac:	40 c4       	mov.aa %a4,%a12
80010fae:	1b c8 ff 4f 	addi %d4,%d8,-4
80010fb2:	b5 23 0c 00 	st.a [%a2]12,%a3
80010fb6:	b5 32 08 00 	st.a [%a3]8,%a2
80010fba:	09 43 88 05 	ld.a %a3,[+%a4]8
80010fbe:	99 c2 0c 00 	ld.a %a2,[%a12]12
80010fc2:	8b 54 a2 22 	ge.u %d2,%d4,37
80010fc6:	b5 32 0c 00 	st.a [%a3]12,%a2
80010fca:	b5 23 08 00 	st.a [%a2]8,%a3
80010fce:	df 02 35 80 	jne %d2,0,80011038 <_realloc_r+0x236>
80010fd2:	8b 44 61 22 	lt.u %d2,%d4,20
80010fd6:	df 02 28 80 	jne %d2,0,80011026 <_realloc_r+0x224>
80010fda:	48 02       	ld.w %d2,[%a15]0
80010fdc:	59 c2 08 00 	st.w [%a12]8,%d2
80010fe0:	48 13       	ld.w %d3,[%a15]4
80010fe2:	8b c4 a1 22 	ge.u %d2,%d4,28
80010fe6:	59 c3 0c 00 	st.w [%a12]12,%d3
80010fea:	f6 26       	jnz %d2,80010ff6 <_realloc_r+0x1f4>
80010fec:	d9 c4 10 00 	lea %a4,[%a12]16
80010ff0:	d9 ff 08 00 	lea %a15,[%a15]8
80010ff4:	3c 19       	j 80011026 <_realloc_r+0x224>
80010ff6:	48 22       	ld.w %d2,[%a15]8
80010ff8:	8b 44 02 82 	eq %d8,%d4,36
80010ffc:	59 c2 10 00 	st.w [%a12]16,%d2
80011000:	48 33       	ld.w %d3,[%a15]12
80011002:	59 c3 14 00 	st.w [%a12]20,%d3
80011006:	f6 86       	jnz %d8,80011012 <_realloc_r+0x210>
80011008:	d9 c4 18 00 	lea %a4,[%a12]24
8001100c:	d9 ff 10 00 	lea %a15,[%a15]16
80011010:	3c 0b       	j 80011026 <_realloc_r+0x224>
80011012:	48 42       	ld.w %d2,[%a15]16
80011014:	d9 c4 20 00 	lea %a4,[%a12]32
80011018:	59 c2 18 00 	st.w [%a12]24,%d2
8001101c:	48 53       	ld.w %d3,[%a15]20
8001101e:	d9 ff 18 00 	lea %a15,[%a15]24
80011022:	59 c3 1c 00 	st.w [%a12]28,%d3
80011026:	48 02       	ld.w %d2,[%a15]0
80011028:	74 42       	st.w [%a4],%d2
8001102a:	48 13       	ld.w %d3,[%a15]4
8001102c:	59 43 04 00 	st.w [%a4]4,%d3
80011030:	48 22       	ld.w %d2,[%a15]8
80011032:	59 42 08 00 	st.w [%a4]8,%d2
80011036:	3c 04       	j 8001103e <_realloc_r+0x23c>
80011038:	40 f5       	mov.aa %a5,%a15
8001103a:	6d ff b4 fe 	call 80010da2 <memmove>
8001103e:	02 b8       	mov %d8,%d11
80011040:	3c 45       	j 800110ca <_realloc_r+0x2c8>
80011042:	3f fa 4a 00 	jlt %d10,%d15,800110d6 <_realloc_r+0x2d4>
80011046:	40 c4       	mov.aa %a4,%a12
80011048:	99 c2 0c 00 	ld.a %a2,[%a12]12
8001104c:	09 43 88 05 	ld.a %a3,[+%a4]8
80011050:	1b c8 ff 4f 	addi %d4,%d8,-4
80011054:	8b 54 a2 22 	ge.u %d2,%d4,37
80011058:	b5 32 0c 00 	st.a [%a3]12,%a2
8001105c:	b5 23 08 00 	st.a [%a2]8,%a3
80011060:	df 02 37 80 	jne %d2,0,800110ce <_realloc_r+0x2cc>
80011064:	8b 44 61 22 	lt.u %d2,%d4,20
80011068:	df 02 28 80 	jne %d2,0,800110b8 <_realloc_r+0x2b6>
8001106c:	48 03       	ld.w %d3,[%a15]0
8001106e:	59 c3 08 00 	st.w [%a12]8,%d3
80011072:	48 12       	ld.w %d2,[%a15]4
80011074:	59 c2 0c 00 	st.w [%a12]12,%d2
80011078:	8b c4 a1 22 	ge.u %d2,%d4,28
8001107c:	f6 26       	jnz %d2,80011088 <_realloc_r+0x286>
8001107e:	d9 c4 10 00 	lea %a4,[%a12]16
80011082:	d9 ff 08 00 	lea %a15,[%a15]8
80011086:	3c 19       	j 800110b8 <_realloc_r+0x2b6>
80011088:	48 23       	ld.w %d3,[%a15]8
8001108a:	8b 44 02 82 	eq %d8,%d4,36
8001108e:	59 c3 10 00 	st.w [%a12]16,%d3
80011092:	48 32       	ld.w %d2,[%a15]12
80011094:	59 c2 14 00 	st.w [%a12]20,%d2
80011098:	f6 86       	jnz %d8,800110a4 <_realloc_r+0x2a2>
8001109a:	d9 c4 18 00 	lea %a4,[%a12]24
8001109e:	d9 ff 10 00 	lea %a15,[%a15]16
800110a2:	3c 0b       	j 800110b8 <_realloc_r+0x2b6>
800110a4:	48 43       	ld.w %d3,[%a15]16
800110a6:	d9 c4 20 00 	lea %a4,[%a12]32
800110aa:	59 c3 18 00 	st.w [%a12]24,%d3
800110ae:	48 52       	ld.w %d2,[%a15]20
800110b0:	d9 ff 18 00 	lea %a15,[%a15]24
800110b4:	59 c2 1c 00 	st.w [%a12]28,%d2
800110b8:	48 03       	ld.w %d3,[%a15]0
800110ba:	74 43       	st.w [%a4],%d3
800110bc:	48 12       	ld.w %d2,[%a15]4
800110be:	59 42 04 00 	st.w [%a4]4,%d2
800110c2:	48 23       	ld.w %d3,[%a15]8
800110c4:	59 43 08 00 	st.w [%a4]8,%d3
800110c8:	02 a8       	mov %d8,%d10
800110ca:	40 ce       	mov.aa %a14,%a12
800110cc:	3c 66       	j 80011198 <_realloc_r+0x396>
800110ce:	40 f5       	mov.aa %a5,%a15
800110d0:	6d ff 69 fe 	call 80010da2 <memmove>
800110d4:	3c fa       	j 800110c8 <_realloc_r+0x2c6>
800110d6:	40 d4       	mov.aa %a4,%a13
800110d8:	02 94       	mov %d4,%d9
800110da:	6d ff 1c f7 	call 8000ff12 <_malloc_r>
800110de:	40 2c       	mov.aa %a12,%a2
800110e0:	7c 26       	jnz.a %a2,800110ec <_realloc_r+0x2ea>
800110e2:	40 d4       	mov.aa %a4,%a13
800110e4:	6d ff 7f f9 	call 800103e2 <__malloc_unlock>
800110e8:	a0 02       	mov.a %a2,0
800110ea:	00 90       	ret 
800110ec:	19 f2 fc ff 	ld.w %d2,[%a15]-4
800110f0:	d9 23 f8 ff 	lea %a3,[%a2]-8
800110f4:	8f 12 c0 21 	andn %d2,%d2,1
800110f8:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
800110fc:	80 32       	mov.d %d2,%a3
800110fe:	80 23       	mov.d %d3,%a2
80011100:	5f 32 08 80 	jne %d2,%d3,80011110 <_realloc_r+0x30e>
80011104:	19 c2 fc ff 	ld.w %d2,[%a12]-4
80011108:	8f 32 c0 21 	andn %d2,%d2,3
8001110c:	42 28       	add %d8,%d2
8001110e:	3c 45       	j 80011198 <_realloc_r+0x396>
80011110:	1b c8 ff 4f 	addi %d4,%d8,-4
80011114:	8b 54 a2 f2 	ge.u %d15,%d4,37
80011118:	ee 33       	jnz %d15,8001117e <_realloc_r+0x37c>
8001111a:	8b 44 61 f2 	lt.u %d15,%d4,20
8001111e:	40 c3       	mov.aa %a3,%a12
80011120:	40 f2       	mov.aa %a2,%a15
80011122:	ee 23       	jnz %d15,80011168 <_realloc_r+0x366>
80011124:	4c f0       	ld.w %d15,[%a15]0
80011126:	d9 c3 08 00 	lea %a3,[%a12]8
8001112a:	6c c0       	st.w [%a12]0,%d15
8001112c:	48 12       	ld.w %d2,[%a15]4
8001112e:	8b c4 a1 f2 	ge.u %d15,%d4,28
80011132:	59 c2 04 00 	st.w [%a12]4,%d2
80011136:	d9 f2 08 00 	lea %a2,[%a15]8
8001113a:	6e 17       	jz %d15,80011168 <_realloc_r+0x366>
8001113c:	48 23       	ld.w %d3,[%a15]8
8001113e:	8b 44 02 82 	eq %d8,%d4,36
80011142:	59 c3 08 00 	st.w [%a12]8,%d3
80011146:	4c f3       	ld.w %d15,[%a15]12
80011148:	d9 c3 10 00 	lea %a3,[%a12]16
8001114c:	6c c3       	st.w [%a12]12,%d15
8001114e:	d9 f2 10 00 	lea %a2,[%a15]16
80011152:	76 8b       	jz %d8,80011168 <_realloc_r+0x366>
80011154:	48 42       	ld.w %d2,[%a15]16
80011156:	d9 c3 18 00 	lea %a3,[%a12]24
8001115a:	59 c2 10 00 	st.w [%a12]16,%d2
8001115e:	48 53       	ld.w %d3,[%a15]20
80011160:	d9 f2 18 00 	lea %a2,[%a15]24
80011164:	59 c3 14 00 	st.w [%a12]20,%d3
80011168:	4c 20       	ld.w %d15,[%a2]0
8001116a:	6c 30       	st.w [%a3]0,%d15
8001116c:	19 22 04 00 	ld.w %d2,[%a2]4
80011170:	59 32 04 00 	st.w [%a3]4,%d2
80011174:	19 23 08 00 	ld.w %d3,[%a2]8
80011178:	59 33 08 00 	st.w [%a3]8,%d3
8001117c:	3c 05       	j 80011186 <_realloc_r+0x384>
8001117e:	40 c4       	mov.aa %a4,%a12
80011180:	40 f5       	mov.aa %a5,%a15
80011182:	6d ff 10 fe 	call 80010da2 <memmove>
80011186:	40 d4       	mov.aa %a4,%a13
80011188:	40 f5       	mov.aa %a5,%a15
8001118a:	6d ff 36 fd 	call 80010bf6 <_free_r>
8001118e:	40 d4       	mov.aa %a4,%a13
80011190:	6d ff 29 f9 	call 800103e2 <__malloc_unlock>
80011194:	40 c2       	mov.aa %a2,%a12
80011196:	00 90       	ret 
80011198:	0b f8 80 20 	sub %d2,%d8,%d15
8001119c:	8b 02 61 42 	lt.u %d4,%d2,16
800111a0:	19 e3 04 00 	ld.w %d3,[%a14]4
800111a4:	df 04 16 80 	jne %d4,0,800111d0 <_realloc_r+0x3ce>
800111a8:	8f 13 00 31 	and %d3,%d3,1
800111ac:	10 e5       	addsc.a %a5,%a14,%d15,0
800111ae:	a6 3f       	or %d15,%d3
800111b0:	6c e1       	st.w [%a14]4,%d15
800111b2:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
800111b6:	8f 12 40 f1 	or %d15,%d2,1
800111ba:	b7 10 21 20 	imask %e2,1,0,1
800111be:	6c 51       	st.w [%a5]4,%d15
800111c0:	49 f2 44 08 	ldmst [%a15]4,%e2
800111c4:	40 d4       	mov.aa %a4,%a13
800111c6:	d9 55 08 00 	lea %a5,[%a5]8
800111ca:	6d ff 16 fd 	call 80010bf6 <_free_r>
800111ce:	3c 0c       	j 800111e6 <_realloc_r+0x3e4>
800111d0:	8f 13 00 31 	and %d3,%d3,1
800111d4:	a6 83       	or %d3,%d8
800111d6:	59 e3 04 00 	st.w [%a14]4,%d3
800111da:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
800111de:	b7 10 21 20 	imask %e2,1,0,1
800111e2:	49 f2 44 08 	ldmst [%a15]4,%e2
800111e6:	40 d4       	mov.aa %a4,%a13
800111e8:	6d ff fd f8 	call 800103e2 <__malloc_unlock>
800111ec:	d9 e2 08 00 	lea %a2,[%a14]8
800111f0:	00 90       	ret 

800111f2 <__int_handler>:
800111f2:	00 90       	ret 

800111f4 <__class_0_trap_handler>:
800111f4:	00 a0       	debug 
800111f6:	7b d0 ea fd 	movh %d15,57005
800111fa:	60 fe       	mov.a %a14,%d15
800111fc:	1d 00 e8 00 	j 800113cc <_exit>
80011200:	00 90       	ret 

80011202 <tsim_abort>:
80011202:	8f 84 00 40 	sh %d4,%d4,8
80011206:	8f f5 0f 51 	and %d5,%d5,255
8001120a:	b7 04 10 48 	insert %d4,%d4,0,16,16
8001120e:	9b d5 ea 5d 	addih %d5,%d5,57005
80011212:	42 54       	add %d4,%d5
80011214:	60 4e       	mov.a %a14,%d4
80011216:	1d 00 db 00 	j 800113cc <_exit>
8001121a:	00 90       	ret 

8001121c <__class_7_trap_handler>:
8001121c:	02 45       	mov %d5,%d4
8001121e:	00 a0       	debug 
80011220:	82 74       	mov %d4,7
80011222:	1d ff f0 ff 	j 80011202 <tsim_abort>

80011226 <__class_6_trap_handler>:
80011226:	02 45       	mov %d5,%d4
80011228:	00 a0       	debug 
8001122a:	82 64       	mov %d4,6
8001122c:	1d ff eb ff 	j 80011202 <tsim_abort>

80011230 <__class_5_trap_handler>:
80011230:	02 45       	mov %d5,%d4
80011232:	00 a0       	debug 
80011234:	82 54       	mov %d4,5
80011236:	1d ff e6 ff 	j 80011202 <tsim_abort>

8001123a <__class_4_trap_handler>:
8001123a:	02 45       	mov %d5,%d4
8001123c:	00 a0       	debug 
8001123e:	82 44       	mov %d4,4
80011240:	1d ff e1 ff 	j 80011202 <tsim_abort>

80011244 <__class_3_trap_handler>:
80011244:	02 45       	mov %d5,%d4
80011246:	00 a0       	debug 
80011248:	82 34       	mov %d4,3
8001124a:	1d ff dc ff 	j 80011202 <tsim_abort>

8001124e <__class_2_trap_handler>:
8001124e:	02 45       	mov %d5,%d4
80011250:	00 a0       	debug 
80011252:	82 24       	mov %d4,2
80011254:	1d ff d7 ff 	j 80011202 <tsim_abort>

80011258 <__class_1_trap_handler>:
80011258:	02 45       	mov %d5,%d4
8001125a:	00 a0       	debug 
8001125c:	82 14       	mov %d4,1
8001125e:	1d ff d2 ff 	j 80011202 <tsim_abort>

80011262 <_install_int_handler>:
80011262:	8b 04 b0 f2 	ge.u %d15,%d4,256
80011266:	82 02       	mov %d2,0
80011268:	ee 0f       	jnz %d15,80011286 <_install_int_handler+0x24>
8001126a:	91 00 00 f7 	movh.a %a15,28672
8001126e:	19 f2 08 35 	ld.w %d2,[%a15]20680 <700050c8 <_init_vectab_initialized>>
80011272:	76 2a       	jz %d2,80011286 <_install_int_handler+0x24>
80011274:	91 00 00 f7 	movh.a %a15,28672
80011278:	d9 ff a8 24 	lea %a15,[%a15]18600 <700048a8 <Cdisptab>>
8001127c:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80011280:	82 12       	mov %d2,1
80011282:	e8 04       	st.a [%a15]0,%a4
80011284:	68 15       	st.w [%a15]4,%d5
80011286:	00 90       	ret 

80011288 <_init_vectab>:
80011288:	91 00 00 c7 	movh.a %a12,28672
8001128c:	19 cf 08 35 	ld.w %d15,[%a12]20680 <700050c8 <_init_vectab_initialized>>
80011290:	ee 51       	jnz %d15,80011332 <_init_vectab+0xaa>
80011292:	7b 00 00 f8 	movh %d15,32768
80011296:	6d 00 4f 00 	call 80011334 <unlock_wdtcon>
8001129a:	1b 0f 00 f1 	addi %d15,%d15,4096
8001129e:	cd 4f e2 0f 	mtcr $btv,%d15
800112a2:	7b 00 01 f5 	movh %d15,20496
800112a6:	1b 0f 00 f0 	addi %d15,%d15,0
800112aa:	cd 0f e2 0f 	mtcr $biv,%d15
800112ae:	6d 00 59 00 	call 80011360 <lock_wdtcon>
800112b2:	7b 10 00 f8 	movh %d15,32769
800112b6:	91 00 00 27 	movh.a %a2,28672
800112ba:	1b 4f 1f f1 	addi %d15,%d15,4596
800112be:	59 2f 28 25 	st.w [%a2]20648 <700050a8 <Tdisptab>>,%d15
800112c2:	7b 10 00 f8 	movh %d15,32769
800112c6:	d9 2f 28 25 	lea %a15,[%a2]20648 <700050a8 <Tdisptab>>
800112ca:	1b 8f 25 f1 	addi %d15,%d15,4696
800112ce:	68 1f       	st.w [%a15]4,%d15
800112d0:	7b 10 00 f8 	movh %d15,32769
800112d4:	1b ef 24 f1 	addi %d15,%d15,4686
800112d8:	68 2f       	st.w [%a15]8,%d15
800112da:	7b 10 00 f8 	movh %d15,32769
800112de:	1b 4f 24 f1 	addi %d15,%d15,4676
800112e2:	68 3f       	st.w [%a15]12,%d15
800112e4:	7b 10 00 f8 	movh %d15,32769
800112e8:	1b af 23 f1 	addi %d15,%d15,4666
800112ec:	68 4f       	st.w [%a15]16,%d15
800112ee:	7b 10 00 f8 	movh %d15,32769
800112f2:	1b 0f 23 f1 	addi %d15,%d15,4656
800112f6:	68 5f       	st.w [%a15]20,%d15
800112f8:	7b 10 00 f8 	movh %d15,32769
800112fc:	1b 6f 22 f1 	addi %d15,%d15,4646
80011300:	68 6f       	st.w [%a15]24,%d15
80011302:	7b 10 00 f8 	movh %d15,32769
80011306:	1b cf 21 f1 	addi %d15,%d15,4636
8001130a:	91 00 00 37 	movh.a %a3,28672
8001130e:	7b 10 00 28 	movh %d2,32769
80011312:	68 7f       	st.w [%a15]28,%d15
80011314:	d9 33 a8 24 	lea %a3,[%a3]18600 <700048a8 <Cdisptab>>
80011318:	82 0f       	mov %d15,0
8001131a:	1b 22 1f 21 	addi %d2,%d2,4594
8001131e:	c5 0f 3f 30 	lea %a15,ff <_.+0xfe>
80011322:	d0 32       	addsc.a %a2,%a3,%d15,3
80011324:	6c 21       	st.w [%a2]4,%d15
80011326:	74 22       	st.w [%a2],%d2
80011328:	c2 1f       	add %d15,1
8001132a:	fc fc       	loop %a15,80011322 <_init_vectab+0x9a>
8001132c:	82 1f       	mov %d15,1
8001132e:	59 cf 08 35 	st.w [%a12]20680 <700050c8 <_init_vectab_initialized>>,%d15
80011332:	00 90       	ret 

80011334 <unlock_wdtcon>:
80011334:	4d c0 e1 ff 	mfcr %d15,$core_id
80011338:	16 07       	and %d15,7
8001133a:	53 cf 20 f0 	mul %d15,%d15,12
8001133e:	60 f2       	mov.a %a2,%d15
80011340:	d9 2f 00 46 	lea %a15,[%a2]24832
80011344:	11 3f 00 ff 	addih.a %a15,%a15,61443
80011348:	4c f0       	ld.w %d15,[%a15]0
8001134a:	8f ff cf f1 	andn %d15,%d15,255
8001134e:	8f 1f 4f 21 	or %d2,%d15,241
80011352:	68 02       	st.w [%a15]0,%d2
80011354:	0d 00 80 04 	dsync 
80011358:	96 f2       	or %d15,242
8001135a:	68 0f       	st.w [%a15]0,%d15
8001135c:	4c f0       	ld.w %d15,[%a15]0
8001135e:	00 90       	ret 

80011360 <lock_wdtcon>:
80011360:	4d c0 e1 ff 	mfcr %d15,$core_id
80011364:	16 07       	and %d15,7
80011366:	53 cf 20 f0 	mul %d15,%d15,12
8001136a:	60 f2       	mov.a %a2,%d15
8001136c:	d9 2f 00 46 	lea %a15,[%a2]24832
80011370:	11 3f 00 ff 	addih.a %a15,%a15,61443
80011374:	4c f0       	ld.w %d15,[%a15]0
80011376:	8f ff cf f1 	andn %d15,%d15,255
8001137a:	8f 1f 4f 21 	or %d2,%d15,241
8001137e:	68 02       	st.w [%a15]0,%d2
80011380:	0d 00 80 04 	dsync 
80011384:	96 f3       	or %d15,243
80011386:	68 0f       	st.w [%a15]0,%d15
80011388:	4c f0       	ld.w %d15,[%a15]0
8001138a:	00 90       	ret 

8001138c <unlock_safety_wdtcon>:
8001138c:	91 30 00 ff 	movh.a %a15,61443
80011390:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80011394:	4c f0       	ld.w %d15,[%a15]0
80011396:	8f ff cf f1 	andn %d15,%d15,255
8001139a:	8f 1f 4f 21 	or %d2,%d15,241
8001139e:	68 02       	st.w [%a15]0,%d2
800113a0:	0d 00 80 04 	dsync 
800113a4:	96 f2       	or %d15,242
800113a6:	68 0f       	st.w [%a15]0,%d15
800113a8:	4c f0       	ld.w %d15,[%a15]0
800113aa:	00 90       	ret 

800113ac <lock_safety_wdtcon>:
800113ac:	91 30 00 ff 	movh.a %a15,61443
800113b0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800113b4:	4c f0       	ld.w %d15,[%a15]0
800113b6:	8f ff cf f1 	andn %d15,%d15,255
800113ba:	8f 1f 4f 21 	or %d2,%d15,241
800113be:	68 02       	st.w [%a15]0,%d2
800113c0:	0d 00 80 04 	dsync 
800113c4:	96 f3       	or %d15,243
800113c6:	68 0f       	st.w [%a15]0,%d15
800113c8:	4c f0       	ld.w %d15,[%a15]0
800113ca:	00 90       	ret 

800113cc <_exit>:
800113cc:	76 43       	jz %d4,800113d2 <_exit+0x6>
800113ce:	60 4e       	mov.a %a14,%d4
800113d0:	3c 04       	j 800113d8 <_exit+0xc>
800113d2:	bb d0 00 f9 	mov.u %d15,36877
800113d6:	60 fe       	mov.a %a14,%d15
800113d8:	00 a0       	debug 
800113da:	3c 00       	j 800113da <_exit+0xe>

800113dc <sbrk>:
800113dc:	91 00 00 f7 	movh.a %a15,28672
800113e0:	19 ff e0 21 	ld.w %d15,[%a15]7328 <70001ca0 <heap_top.2289>>
800113e4:	7b 00 00 27 	movh %d2,28672
800113e8:	42 f4       	add %d4,%d15
800113ea:	1b 82 0d 25 	addi %d2,%d2,20696
800113ee:	7f 42 09 80 	jge.u %d2,%d4,80011400 <sbrk+0x24>
800113f2:	6d 00 13 00 	call 80011418 <__errno>
800113f6:	da 0c       	mov %d15,12
800113f8:	6c 20       	st.w [%a2]0,%d15
800113fa:	a0 02       	mov.a %a2,0
800113fc:	b0 f2       	add.a %a2,-1
800113fe:	00 90       	ret 
80011400:	7b 00 00 27 	movh %d2,28672
80011404:	1b 82 0d 25 	addi %d2,%d2,20696
80011408:	7f 24 04 80 	jge.u %d4,%d2,80011410 <sbrk+0x34>
8001140c:	6d 00 0b 00 	call 80011422 <abort>
80011410:	59 f4 e0 21 	st.w [%a15]7328,%d4
80011414:	60 f2       	mov.a %a2,%d15
80011416:	00 90       	ret 

80011418 <__errno>:
80011418:	91 00 00 27 	movh.a %a2,28672
8001141c:	d9 22 10 35 	lea %a2,[%a2]20688 <700050d0 <_my_errno>>
80011420:	00 90       	ret 

80011422 <abort>:
80011422:	00 a0       	debug 
80011424:	7b e0 ea fd 	movh %d15,57006
80011428:	1b ff ee fb 	addi %d15,%d15,-16657
8001142c:	60 fe       	mov.a %a14,%d15
8001142e:	1d ff cf ff 	j 800113cc <_exit>
80011432:	3c 00       	j 80011432 <abort+0x10>

80011434 <_fpadd_parts>:
80011434:	0c 40       	ld.bu %d15,[%a4]0
80011436:	40 42       	mov.aa %a2,%a4
80011438:	bf 2f cb 80 	jlt.u %d15,2,800115ce <_fpadd_parts+0x19a>
8001143c:	14 52       	ld.bu %d2,[%a5]
8001143e:	40 52       	mov.aa %a2,%a5
80011440:	bf 22 c7 80 	jlt.u %d2,2,800115ce <_fpadd_parts+0x19a>
80011444:	5e 4e       	jne %d15,4,80011460 <_fpadd_parts+0x2c>
80011446:	40 42       	mov.aa %a2,%a4
80011448:	df 42 c3 80 	jne %d2,4,800115ce <_fpadd_parts+0x19a>
8001144c:	19 42 04 00 	ld.w %d2,[%a4]4
80011450:	4c 51       	ld.w %d15,[%a5]4
80011452:	5f f2 be 00 	jeq %d2,%d15,800115ce <_fpadd_parts+0x19a>
80011456:	91 00 00 f8 	movh.a %a15,32768
8001145a:	d9 f2 cc 70 	lea %a2,[%a15]3532 <80000dcc <__thenan_df>>
8001145e:	00 90       	ret 
80011460:	40 52       	mov.aa %a2,%a5
80011462:	df 42 b6 00 	jeq %d2,4,800115ce <_fpadd_parts+0x19a>
80011466:	df 22 11 80 	jne %d2,2,80011488 <_fpadd_parts+0x54>
8001146a:	40 42       	mov.aa %a2,%a4
8001146c:	df 2f b1 80 	jne %d15,2,800115ce <_fpadd_parts+0x19a>
80011470:	40 63       	mov.aa %a3,%a6
80011472:	a0 4f       	mov.a %a15,4
80011474:	44 4f       	ld.w %d15,[%a4+]
80011476:	64 3f       	st.w [%a3+],%d15
80011478:	fc fe       	loop %a15,80011474 <_fpadd_parts+0x40>
8001147a:	4c 21       	ld.w %d15,[%a2]4
8001147c:	19 52 04 00 	ld.w %d2,[%a5]4
80011480:	40 62       	mov.aa %a2,%a6
80011482:	26 2f       	and %d15,%d2
80011484:	6c 61       	st.w [%a6]4,%d15
80011486:	00 90       	ret 
80011488:	40 52       	mov.aa %a2,%a5
8001148a:	df 2f a2 00 	jeq %d15,2,800115ce <_fpadd_parts+0x19a>
8001148e:	4c 42       	ld.w %d15,[%a4]8
80011490:	19 52 08 00 	ld.w %d2,[%a5]8
80011494:	40 6f       	mov.aa %a15,%a6
80011496:	52 23       	sub %d3,%d15,%d2
80011498:	0b 30 c0 c1 	abs %d12,%d3
8001149c:	8b 0c 84 42 	ge %d4,%d12,64
800114a0:	40 5c       	mov.aa %a12,%a5
800114a2:	40 4d       	mov.aa %a13,%a4
800114a4:	09 4a 4c 09 	ld.d %e10,[%a4]12
800114a8:	09 58 4c 09 	ld.d %e8,[%a5]12
800114ac:	df 04 35 80 	jne %d4,0,80011516 <_fpadd_parts+0xe2>
800114b0:	bf 13 19 00 	jlt %d3,1,800114e2 <_fpadd_parts+0xae>
800114b4:	0b 89 10 48 	mov %e4,%d9,%d8
800114b8:	02 c6       	mov %d6,%d12
800114ba:	6d 00 99 03 	call 80011bec <__lshrdi3>
800114be:	d2 14       	mov %e4,1
800114c0:	02 c6       	mov %d6,%d12
800114c2:	02 2e       	mov %d14,%d2
800114c4:	02 3d       	mov %d13,%d3
800114c6:	6d 00 86 03 	call 80011bd2 <__ashldi3>
800114ca:	8b f2 9f 20 	addx %d2,%d2,-1
800114ce:	8b f3 bf 30 	addc %d3,%d3,-1
800114d2:	26 82       	and %d2,%d8
800114d4:	26 93       	and %d3,%d9
800114d6:	a6 23       	or %d3,%d2
800114d8:	02 e8       	mov %d8,%d14
800114da:	8b 03 00 85 	or.ne %d8,%d3,0
800114de:	02 d9       	mov %d9,%d13
800114e0:	3c 21       	j 80011522 <_fpadd_parts+0xee>
800114e2:	df 03 20 00 	jeq %d3,0,80011522 <_fpadd_parts+0xee>
800114e6:	0b ab 10 48 	mov %e4,%d11,%d10
800114ea:	02 c6       	mov %d6,%d12
800114ec:	6d 00 80 03 	call 80011bec <__lshrdi3>
800114f0:	d2 14       	mov %e4,1
800114f2:	02 c6       	mov %d6,%d12
800114f4:	02 2e       	mov %d14,%d2
800114f6:	02 3d       	mov %d13,%d3
800114f8:	6d 00 6d 03 	call 80011bd2 <__ashldi3>
800114fc:	8b f2 9f 20 	addx %d2,%d2,-1
80011500:	8b f3 bf 30 	addc %d3,%d3,-1
80011504:	26 a2       	and %d2,%d10
80011506:	26 b3       	and %d3,%d11
80011508:	a6 23       	or %d3,%d2
8001150a:	02 ea       	mov %d10,%d14
8001150c:	42 cf       	add %d15,%d12
8001150e:	8b 03 00 a5 	or.ne %d10,%d3,0
80011512:	02 db       	mov %d11,%d13
80011514:	3c 07       	j 80011522 <_fpadd_parts+0xee>
80011516:	3f f2 05 00 	jlt %d2,%d15,80011520 <_fpadd_parts+0xec>
8001151a:	02 2f       	mov %d15,%d2
8001151c:	d2 0a       	mov %e10,0
8001151e:	3c 02       	j 80011522 <_fpadd_parts+0xee>
80011520:	d2 08       	mov %e8,0
80011522:	19 d4 04 00 	ld.w %d4,[%a13]4
80011526:	19 c2 04 00 	ld.w %d2,[%a12]4
8001152a:	5f 24 34 00 	jeq %d4,%d2,80011592 <_fpadd_parts+0x15e>
8001152e:	0b 8a c0 20 	subx %d2,%d10,%d8
80011532:	0b 9b d0 30 	subc %d3,%d11,%d9
80011536:	76 45       	jz %d4,80011540 <_fpadd_parts+0x10c>
80011538:	0b a8 c0 20 	subx %d2,%d8,%d10
8001153c:	0b b9 d0 30 	subc %d3,%d9,%d11
80011540:	0e 37       	jltz %d3,8001154e <_fpadd_parts+0x11a>
80011542:	82 04       	mov %d4,0
80011544:	68 14       	st.w [%a15]4,%d4
80011546:	68 2f       	st.w [%a15]8,%d15
80011548:	89 f2 4c 09 	st.d [%a15]12,%e2
8001154c:	3c 0c       	j 80011564 <_fpadd_parts+0x130>
8001154e:	68 2f       	st.w [%a15]8,%d15
80011550:	8b 03 00 f1 	rsub %d15,%d3,0
80011554:	82 14       	mov %d4,1
80011556:	8b 02 00 31 	rsub %d3,%d2,0
8001155a:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
8001155e:	68 14       	st.w [%a15]4,%d4
80011560:	68 33       	st.w [%a15]12,%d3
80011562:	68 4f       	st.w [%a15]16,%d15
80011564:	82 f5       	mov %d5,-1
80011566:	06 c5       	sh %d5,-4
80011568:	48 32       	ld.w %d2,[%a15]12
8001156a:	48 43       	ld.w %d3,[%a15]16
8001156c:	8b f2 9f 60 	addx %d6,%d2,-1
80011570:	8b f3 bf 40 	addc %d4,%d3,-1
80011574:	3a 54       	eq %d15,%d4,%d5
80011576:	8b f6 3f f4 	and.ne %d15,%d6,-1
8001157a:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
8001157e:	6e 12       	jz %d15,800115a2 <_fpadd_parts+0x16e>
80011580:	4c f2       	ld.w %d15,[%a15]8
80011582:	77 23 80 30 	dextr %d3,%d3,%d2,1
80011586:	c2 ff       	add %d15,-1
80011588:	06 12       	sh %d2,1
8001158a:	68 32       	st.w [%a15]12,%d2
8001158c:	68 43       	st.w [%a15]16,%d3
8001158e:	68 2f       	st.w [%a15]8,%d15
80011590:	3c ec       	j 80011568 <_fpadd_parts+0x134>
80011592:	0b a8 40 20 	addx %d2,%d8,%d10
80011596:	68 2f       	st.w [%a15]8,%d15
80011598:	0b b9 50 f0 	addc %d15,%d9,%d11
8001159c:	68 14       	st.w [%a15]4,%d4
8001159e:	68 32       	st.w [%a15]12,%d2
800115a0:	68 4f       	st.w [%a15]16,%d15
800115a2:	82 3f       	mov %d15,3
800115a4:	28 0f       	st.b [%a15]0,%d15
800115a6:	4c f4       	ld.w %d15,[%a15]16
800115a8:	7b 00 00 42 	movh %d4,8192
800115ac:	0b 4f 30 31 	lt.u %d3,%d15,%d4
800115b0:	48 32       	ld.w %d2,[%a15]12
800115b2:	40 f2       	mov.aa %a2,%a15
800115b4:	f6 3d       	jnz %d3,800115ce <_fpadd_parts+0x19a>
800115b6:	8f 12 00 31 	and %d3,%d2,1
800115ba:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
800115be:	06 ff       	sh %d15,-1
800115c0:	96 00       	or %d15,0
800115c2:	68 4f       	st.w [%a15]16,%d15
800115c4:	4c f2       	ld.w %d15,[%a15]8
800115c6:	a6 32       	or %d2,%d3
800115c8:	c2 1f       	add %d15,1
800115ca:	68 32       	st.w [%a15]12,%d2
800115cc:	68 2f       	st.w [%a15]8,%d15
800115ce:	00 90       	ret 

800115d0 <__adddf3>:
800115d0:	20 50       	sub.a %sp,80
800115d2:	d9 a4 04 00 	lea %a4,[%sp]4
800115d6:	d9 a5 14 00 	lea %a5,[%sp]20
800115da:	89 a4 44 09 	st.d [%sp]4,%e4
800115de:	89 a6 4c 09 	st.d [%sp]12,%e6
800115e2:	6d 00 a1 03 	call 80011d24 <__unpack_d>
800115e6:	d9 a4 0c 00 	lea %a4,[%sp]12
800115ea:	d9 a5 28 00 	lea %a5,[%sp]40
800115ee:	6d 00 9b 03 	call 80011d24 <__unpack_d>
800115f2:	d9 a4 14 00 	lea %a4,[%sp]20
800115f6:	d9 a5 28 00 	lea %a5,[%sp]40
800115fa:	d9 a6 3c 00 	lea %a6,[%sp]60
800115fe:	6d ff 1b ff 	call 80011434 <_fpadd_parts>
80011602:	40 24       	mov.aa %a4,%a2
80011604:	1d 00 07 03 	j 80011c12 <__pack_d>

80011608 <__subdf3>:
80011608:	20 50       	sub.a %sp,80
8001160a:	d9 a4 04 00 	lea %a4,[%sp]4
8001160e:	d9 a5 14 00 	lea %a5,[%sp]20
80011612:	89 a4 44 09 	st.d [%sp]4,%e4
80011616:	89 a6 4c 09 	st.d [%sp]12,%e6
8001161a:	6d 00 85 03 	call 80011d24 <__unpack_d>
8001161e:	d9 a4 0c 00 	lea %a4,[%sp]12
80011622:	d9 a5 28 00 	lea %a5,[%sp]40
80011626:	6d 00 7f 03 	call 80011d24 <__unpack_d>
8001162a:	58 0b       	ld.w %d15,[%sp]44
8001162c:	d9 a4 14 00 	lea %a4,[%sp]20
80011630:	8f 1f 80 f1 	xor %d15,%d15,1
80011634:	d9 a5 28 00 	lea %a5,[%sp]40
80011638:	d9 a6 3c 00 	lea %a6,[%sp]60
8001163c:	78 0b       	st.w [%sp]44,%d15
8001163e:	6d ff fb fe 	call 80011434 <_fpadd_parts>
80011642:	40 24       	mov.aa %a4,%a2
80011644:	1d 00 e7 02 	j 80011c12 <__pack_d>

80011648 <__muldf3>:
80011648:	20 50       	sub.a %sp,80
8001164a:	d9 a4 04 00 	lea %a4,[%sp]4
8001164e:	d9 a5 14 00 	lea %a5,[%sp]20
80011652:	89 a4 44 09 	st.d [%sp]4,%e4
80011656:	89 a6 4c 09 	st.d [%sp]12,%e6
8001165a:	6d 00 65 03 	call 80011d24 <__unpack_d>
8001165e:	d9 a4 0c 00 	lea %a4,[%sp]12
80011662:	d9 a5 28 00 	lea %a5,[%sp]40
80011666:	6d 00 5f 03 	call 80011d24 <__unpack_d>
8001166a:	39 a3 14 00 	ld.bu %d3,[%sp]20
8001166e:	ff 23 0c 80 	jge.u %d3,2,80011686 <__muldf3+0x3e>
80011672:	19 a2 18 00 	ld.w %d2,[%sp]24
80011676:	58 0b       	ld.w %d15,[%sp]44
80011678:	d9 a4 14 00 	lea %a4,[%sp]20
8001167c:	0b f2 10 f1 	ne %d15,%d2,%d15
80011680:	78 06       	st.w [%sp]24,%d15
80011682:	1d 00 b3 00 	j 800117e8 <__muldf3+0x1a0>
80011686:	39 af 28 00 	ld.bu %d15,[%sp]40
8001168a:	ff 2f 0c 80 	jge.u %d15,2,800116a2 <__muldf3+0x5a>
8001168e:	58 0b       	ld.w %d15,[%sp]44
80011690:	19 a2 18 00 	ld.w %d2,[%sp]24
80011694:	d9 a4 28 00 	lea %a4,[%sp]40
80011698:	0b f2 10 f1 	ne %d15,%d2,%d15
8001169c:	78 0b       	st.w [%sp]44,%d15
8001169e:	1d 00 a5 00 	j 800117e8 <__muldf3+0x1a0>
800116a2:	df 43 09 80 	jne %d3,4,800116b4 <__muldf3+0x6c>
800116a6:	91 00 00 48 	movh.a %a4,32768
800116aa:	d9 44 cc 70 	lea %a4,[%a4]3532 <80000dcc <__thenan_df>>
800116ae:	df 2f 9d 00 	jeq %d15,2,800117e8 <__muldf3+0x1a0>
800116b2:	3c e0       	j 80011672 <__muldf3+0x2a>
800116b4:	5e 48       	jne %d15,4,800116c4 <__muldf3+0x7c>
800116b6:	91 00 00 48 	movh.a %a4,32768
800116ba:	d9 44 cc 70 	lea %a4,[%a4]3532 <80000dcc <__thenan_df>>
800116be:	df 23 95 00 	jeq %d3,2,800117e8 <__muldf3+0x1a0>
800116c2:	3c e6       	j 8001168e <__muldf3+0x46>
800116c4:	df 23 d7 7f 	jeq %d3,2,80011672 <__muldf3+0x2a>
800116c8:	df 2f e3 7f 	jeq %d15,2,8001168e <__muldf3+0x46>
800116cc:	58 08       	ld.w %d15,[%sp]32
800116ce:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
800116d2:	d2 00       	mov %e0,0
800116d4:	19 a0 34 00 	ld.w %d0,[%sp]52
800116d8:	73 bf 68 60 	mul.u %e6,%d15,%d11
800116dc:	82 0c       	mov %d12,0
800116de:	73 0f 68 40 	mul.u %e4,%d15,%d0
800116e2:	19 aa 24 00 	ld.w %d10,[%sp]36
800116e6:	82 02       	mov %d2,0
800116e8:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
800116ec:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
800116f0:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
800116f4:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
800116f8:	82 0d       	mov %d13,0
800116fa:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
800116fe:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
80011702:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
80011706:	0b 54 10 08 	mov %e0,%d4,%d5
8001170a:	42 20       	add %d0,%d2
8001170c:	3a 73       	eq %d15,%d3,%d7
8001170e:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
80011712:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
80011716:	8b 0f 00 62 	eq %d6,%d15,0
8001171a:	3a 50       	eq %d15,%d0,%d5
8001171c:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
80011720:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
80011724:	ba 0f       	eq %d15,%d15,0
80011726:	53 1f 40 40 	mul.u %e4,%d15,1
8001172a:	02 38       	mov %d8,%d3
8001172c:	82 09       	mov %d9,0
8001172e:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
80011732:	02 5f       	mov %d15,%d5
80011734:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
80011738:	42 6f       	add %d15,%d6
8001173a:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
8001173e:	0b 4f 10 68 	mov %e6,%d15,%d4
80011742:	0b 62 40 40 	addx %d4,%d2,%d6
80011746:	0b 73 50 20 	addc %d2,%d3,%d7
8001174a:	58 07       	ld.w %d15,[%sp]28
8001174c:	19 a3 30 00 	ld.w %d3,[%sp]48
80011750:	19 a5 18 00 	ld.w %d5,[%sp]24
80011754:	42 3f       	add %d15,%d3
80011756:	19 a3 2c 00 	ld.w %d3,[%sp]44
8001175a:	c2 4f       	add %d15,4
8001175c:	0b 35 10 31 	ne %d3,%d5,%d3
80011760:	59 a3 00 10 	st.w [%sp]64,%d3
80011764:	7b 00 00 52 	movh %d5,8192
80011768:	0b 52 50 31 	ge.u %d3,%d2,%d5
8001176c:	df 03 1b 00 	jeq %d3,0,800117a2 <__muldf3+0x15a>
80011770:	8f 14 00 31 	and %d3,%d4,1
80011774:	76 37       	jz %d3,80011782 <__muldf3+0x13a>
80011776:	8f f0 1f 30 	sh %d3,%d0,-1
8001177a:	77 10 80 1f 	dextr %d1,%d0,%d1,31
8001177e:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
80011782:	77 42 80 4f 	dextr %d4,%d2,%d4,31
80011786:	c2 1f       	add %d15,1
80011788:	06 f2       	sh %d2,-1
8001178a:	3c ed       	j 80011764 <__muldf3+0x11c>
8001178c:	77 42 80 20 	dextr %d2,%d2,%d4,1
80011790:	06 14       	sh %d4,1
80011792:	ce 04       	jgez %d0,8001179a <__muldf3+0x152>
80011794:	8f 14 40 51 	or %d5,%d4,1
80011798:	02 54       	mov %d4,%d5
8001179a:	77 10 80 00 	dextr %d0,%d0,%d1,1
8001179e:	c2 ff       	add %d15,-1
800117a0:	06 11       	sh %d1,1
800117a2:	7b 00 00 51 	movh %d5,4096
800117a6:	0b 52 30 31 	lt.u %d3,%d2,%d5
800117aa:	df 03 f1 ff 	jne %d3,0,8001178c <__muldf3+0x144>
800117ae:	78 11       	st.w [%sp]68,%d15
800117b0:	02 4f       	mov %d15,%d4
800117b2:	16 ff       	and %d15,255
800117b4:	8b 0f 28 f2 	ne %d15,%d15,128
800117b8:	ee 0f       	jnz %d15,800117d6 <__muldf3+0x18e>
800117ba:	a6 10       	or %d0,%d1
800117bc:	77 42 00 fc 	dextr %d15,%d2,%d4,24
800117c0:	8b 00 20 02 	ne %d0,%d0,0
800117c4:	0f f0 e0 00 	andn %d0,%d0,%d15
800117c8:	76 07       	jz %d0,800117d6 <__muldf3+0x18e>
800117ca:	8b 04 88 40 	addx %d4,%d4,128
800117ce:	8b 02 a0 20 	addc %d2,%d2,0
800117d2:	8f f4 cf 41 	andn %d4,%d4,255
800117d6:	d9 a4 10 10 	lea %a4,[%sp]80
800117da:	82 3f       	mov %d15,3
800117dc:	59 a4 08 10 	st.w [%sp]72,%d4
800117e0:	59 a2 0c 10 	st.w [%sp]76,%d2
800117e4:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <IfxMultican_RXD2D_P14_8_IN+0x8>>,%d15
800117e8:	1d 00 15 02 	j 80011c12 <__pack_d>

800117ec <__divdf3>:
800117ec:	20 38       	sub.a %sp,56
800117ee:	40 a4       	mov.aa %a4,%sp
800117f0:	d9 a5 10 00 	lea %a5,[%sp]16
800117f4:	89 a4 40 09 	st.d [%sp],%e4
800117f8:	89 a6 48 09 	st.d [%sp]8,%e6
800117fc:	6d 00 94 02 	call 80011d24 <__unpack_d>
80011800:	d9 a4 08 00 	lea %a4,[%sp]8
80011804:	d9 a5 24 00 	lea %a5,[%sp]36
80011808:	6d 00 8e 02 	call 80011d24 <__unpack_d>
8001180c:	39 a2 10 00 	ld.bu %d2,[%sp]16
80011810:	bf 22 76 80 	jlt.u %d2,2,800118fc <__divdf3+0x110>
80011814:	39 af 24 00 	ld.bu %d15,[%sp]36
80011818:	d9 a4 24 00 	lea %a4,[%sp]36
8001181c:	bf 2f 72 80 	jlt.u %d15,2,80011900 <__divdf3+0x114>
80011820:	19 a4 14 00 	ld.w %d4,[%sp]20
80011824:	19 a3 28 00 	ld.w %d3,[%sp]40
80011828:	c6 43       	xor %d3,%d4
8001182a:	59 a3 14 00 	st.w [%sp]20,%d3
8001182e:	1b e2 ff 3f 	addi %d3,%d2,-2
80011832:	8f d3 0f 31 	and %d3,%d3,253
80011836:	f6 38       	jnz %d3,80011846 <__divdf3+0x5a>
80011838:	91 00 00 48 	movh.a %a4,32768
8001183c:	d9 44 cc 70 	lea %a4,[%a4]3532 <80000dcc <__thenan_df>>
80011840:	5f f2 5e 80 	jne %d2,%d15,800118fc <__divdf3+0x110>
80011844:	3c 5e       	j 80011900 <__divdf3+0x114>
80011846:	5e 47       	jne %d15,4,80011854 <__divdf3+0x68>
80011848:	d2 02       	mov %e2,0
8001184a:	82 0f       	mov %d15,0
8001184c:	89 a2 5c 09 	st.d [%sp]28,%e2
80011850:	78 06       	st.w [%sp]24,%d15
80011852:	3c 55       	j 800118fc <__divdf3+0x110>
80011854:	5e 25       	jne %d15,2,8001185e <__divdf3+0x72>
80011856:	82 4f       	mov %d15,4
80011858:	e9 af 10 00 	st.b [%sp]16,%d15
8001185c:	3c 50       	j 800118fc <__divdf3+0x110>
8001185e:	58 06       	ld.w %d15,[%sp]24
80011860:	09 a2 5c 09 	ld.d %e2,[%sp]28
80011864:	09 a4 70 09 	ld.d %e4,[%sp]48
80011868:	19 a6 2c 00 	ld.w %d6,[%sp]44
8001186c:	52 66       	sub %d6,%d15,%d6
8001186e:	3a 53       	eq %d15,%d3,%d5
80011870:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
80011874:	59 a6 18 00 	st.w [%sp]24,%d6
80011878:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
8001187c:	ee 07       	jnz %d15,8001188a <__divdf3+0x9e>
8001187e:	c2 f6       	add %d6,-1
80011880:	77 23 80 30 	dextr %d3,%d3,%d2,1
80011884:	59 a6 18 00 	st.w [%sp]24,%d6
80011888:	06 12       	sh %d2,1
8001188a:	82 01       	mov %d1,0
8001188c:	7b 00 00 f1 	movh %d15,4096
80011890:	82 00       	mov %d0,0
80011892:	82 07       	mov %d7,0
80011894:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
80011898:	0b 53 00 61 	eq %d6,%d3,%d5
8001189c:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
800118a0:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
800118a4:	f6 6b       	jnz %d6,800118ba <__divdf3+0xce>
800118a6:	0f 10 a0 80 	or %d8,%d0,%d1
800118aa:	0f f7 a0 60 	or %d6,%d7,%d15
800118ae:	0b 42 c0 20 	subx %d2,%d2,%d4
800118b2:	02 80       	mov %d0,%d8
800118b4:	02 67       	mov %d7,%d6
800118b6:	0b 53 d0 30 	subc %d3,%d3,%d5
800118ba:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
800118be:	77 23 80 30 	dextr %d3,%d3,%d2,1
800118c2:	06 ff       	sh %d15,-1
800118c4:	06 12       	sh %d2,1
800118c6:	fd f0 e9 7f 	loop %a15,80011898 <__divdf3+0xac>
800118ca:	02 0f       	mov %d15,%d0
800118cc:	16 ff       	and %d15,255
800118ce:	8b 0f 28 f2 	ne %d15,%d15,128
800118d2:	0b 70 10 48 	mov %e4,%d0,%d7
800118d6:	ee 0f       	jnz %d15,800118f4 <__divdf3+0x108>
800118d8:	a6 32       	or %d2,%d3
800118da:	77 07 00 fc 	dextr %d15,%d7,%d0,24
800118de:	8b 02 20 22 	ne %d2,%d2,0
800118e2:	0f f2 e0 20 	andn %d2,%d2,%d15
800118e6:	76 27       	jz %d2,800118f4 <__divdf3+0x108>
800118e8:	8b 00 88 00 	addx %d0,%d0,128
800118ec:	8b 07 a0 40 	addc %d4,%d7,0
800118f0:	8f f0 cf 51 	andn %d5,%d0,255
800118f4:	59 a5 1c 00 	st.w [%sp]28,%d5
800118f8:	59 a4 20 00 	st.w [%sp]32,%d4
800118fc:	d9 a4 10 00 	lea %a4,[%sp]16
80011900:	1d 00 89 01 	j 80011c12 <__pack_d>

80011904 <__eqdf2>:
80011904:	20 38       	sub.a %sp,56
80011906:	40 a4       	mov.aa %a4,%sp
80011908:	d9 a5 10 00 	lea %a5,[%sp]16
8001190c:	89 a4 40 09 	st.d [%sp],%e4
80011910:	89 a6 48 09 	st.d [%sp]8,%e6
80011914:	6d 00 08 02 	call 80011d24 <__unpack_d>
80011918:	d9 a4 08 00 	lea %a4,[%sp]8
8001191c:	d9 a5 24 00 	lea %a5,[%sp]36
80011920:	6d 00 02 02 	call 80011d24 <__unpack_d>
80011924:	39 af 10 00 	ld.bu %d15,[%sp]16
80011928:	82 12       	mov %d2,1
8001192a:	bf 2f 0c 80 	jlt.u %d15,2,80011942 <__eqdf2+0x3e>
8001192e:	39 af 24 00 	ld.bu %d15,[%sp]36
80011932:	bf 2f 08 80 	jlt.u %d15,2,80011942 <__eqdf2+0x3e>
80011936:	d9 a4 10 00 	lea %a4,[%sp]16
8001193a:	d9 a5 24 00 	lea %a5,[%sp]36
8001193e:	6d 00 49 02 	call 80011dd0 <__fpcmp_parts_d>
80011942:	00 90       	ret 

80011944 <__nedf2>:
80011944:	20 38       	sub.a %sp,56
80011946:	40 a4       	mov.aa %a4,%sp
80011948:	d9 a5 10 00 	lea %a5,[%sp]16
8001194c:	89 a4 40 09 	st.d [%sp],%e4
80011950:	89 a6 48 09 	st.d [%sp]8,%e6
80011954:	6d 00 e8 01 	call 80011d24 <__unpack_d>
80011958:	d9 a4 08 00 	lea %a4,[%sp]8
8001195c:	d9 a5 24 00 	lea %a5,[%sp]36
80011960:	6d 00 e2 01 	call 80011d24 <__unpack_d>
80011964:	39 af 10 00 	ld.bu %d15,[%sp]16
80011968:	82 12       	mov %d2,1
8001196a:	bf 2f 0c 80 	jlt.u %d15,2,80011982 <__nedf2+0x3e>
8001196e:	39 af 24 00 	ld.bu %d15,[%sp]36
80011972:	bf 2f 08 80 	jlt.u %d15,2,80011982 <__nedf2+0x3e>
80011976:	d9 a4 10 00 	lea %a4,[%sp]16
8001197a:	d9 a5 24 00 	lea %a5,[%sp]36
8001197e:	6d 00 29 02 	call 80011dd0 <__fpcmp_parts_d>
80011982:	00 90       	ret 

80011984 <__gtdf2>:
80011984:	20 38       	sub.a %sp,56
80011986:	40 a4       	mov.aa %a4,%sp
80011988:	d9 a5 10 00 	lea %a5,[%sp]16
8001198c:	89 a4 40 09 	st.d [%sp],%e4
80011990:	89 a6 48 09 	st.d [%sp]8,%e6
80011994:	6d 00 c8 01 	call 80011d24 <__unpack_d>
80011998:	d9 a4 08 00 	lea %a4,[%sp]8
8001199c:	d9 a5 24 00 	lea %a5,[%sp]36
800119a0:	6d 00 c2 01 	call 80011d24 <__unpack_d>
800119a4:	39 af 10 00 	ld.bu %d15,[%sp]16
800119a8:	82 f2       	mov %d2,-1
800119aa:	bf 2f 0c 80 	jlt.u %d15,2,800119c2 <__gtdf2+0x3e>
800119ae:	39 af 24 00 	ld.bu %d15,[%sp]36
800119b2:	bf 2f 08 80 	jlt.u %d15,2,800119c2 <__gtdf2+0x3e>
800119b6:	d9 a4 10 00 	lea %a4,[%sp]16
800119ba:	d9 a5 24 00 	lea %a5,[%sp]36
800119be:	6d 00 09 02 	call 80011dd0 <__fpcmp_parts_d>
800119c2:	00 90       	ret 

800119c4 <__gedf2>:
800119c4:	20 38       	sub.a %sp,56
800119c6:	40 a4       	mov.aa %a4,%sp
800119c8:	d9 a5 10 00 	lea %a5,[%sp]16
800119cc:	89 a4 40 09 	st.d [%sp],%e4
800119d0:	89 a6 48 09 	st.d [%sp]8,%e6
800119d4:	6d 00 a8 01 	call 80011d24 <__unpack_d>
800119d8:	d9 a4 08 00 	lea %a4,[%sp]8
800119dc:	d9 a5 24 00 	lea %a5,[%sp]36
800119e0:	6d 00 a2 01 	call 80011d24 <__unpack_d>
800119e4:	39 af 10 00 	ld.bu %d15,[%sp]16
800119e8:	82 f2       	mov %d2,-1
800119ea:	bf 2f 0c 80 	jlt.u %d15,2,80011a02 <__gedf2+0x3e>
800119ee:	39 af 24 00 	ld.bu %d15,[%sp]36
800119f2:	bf 2f 08 80 	jlt.u %d15,2,80011a02 <__gedf2+0x3e>
800119f6:	d9 a4 10 00 	lea %a4,[%sp]16
800119fa:	d9 a5 24 00 	lea %a5,[%sp]36
800119fe:	6d 00 e9 01 	call 80011dd0 <__fpcmp_parts_d>
80011a02:	00 90       	ret 

80011a04 <__ltdf2>:
80011a04:	20 38       	sub.a %sp,56
80011a06:	40 a4       	mov.aa %a4,%sp
80011a08:	d9 a5 10 00 	lea %a5,[%sp]16
80011a0c:	89 a4 40 09 	st.d [%sp],%e4
80011a10:	89 a6 48 09 	st.d [%sp]8,%e6
80011a14:	6d 00 88 01 	call 80011d24 <__unpack_d>
80011a18:	d9 a4 08 00 	lea %a4,[%sp]8
80011a1c:	d9 a5 24 00 	lea %a5,[%sp]36
80011a20:	6d 00 82 01 	call 80011d24 <__unpack_d>
80011a24:	39 af 10 00 	ld.bu %d15,[%sp]16
80011a28:	82 12       	mov %d2,1
80011a2a:	bf 2f 0c 80 	jlt.u %d15,2,80011a42 <__ltdf2+0x3e>
80011a2e:	39 af 24 00 	ld.bu %d15,[%sp]36
80011a32:	bf 2f 08 80 	jlt.u %d15,2,80011a42 <__ltdf2+0x3e>
80011a36:	d9 a4 10 00 	lea %a4,[%sp]16
80011a3a:	d9 a5 24 00 	lea %a5,[%sp]36
80011a3e:	6d 00 c9 01 	call 80011dd0 <__fpcmp_parts_d>
80011a42:	00 90       	ret 

80011a44 <__floatsidf>:
80011a44:	20 18       	sub.a %sp,24
80011a46:	82 3f       	mov %d15,3
80011a48:	2c a4       	st.b [%sp]4,%d15
80011a4a:	8f 14 1e f0 	sh %d15,%d4,-31
80011a4e:	78 02       	st.w [%sp]8,%d15
80011a50:	f6 44       	jnz %d4,80011a58 <__floatsidf+0x14>
80011a52:	82 2f       	mov %d15,2
80011a54:	2c a4       	st.b [%sp]4,%d15
80011a56:	3c 16       	j 80011a82 <__floatsidf+0x3e>
80011a58:	6e 09       	jz %d15,80011a6a <__floatsidf+0x26>
80011a5a:	7b 00 00 f8 	movh %d15,32768
80011a5e:	82 02       	mov %d2,0
80011a60:	7b 00 1e 3c 	movh %d3,49632
80011a64:	5f f4 13 00 	jeq %d4,%d15,80011a8a <__floatsidf+0x46>
80011a68:	32 54       	rsub %d4
80011a6a:	0f 04 b0 f1 	clz %d15,%d4
80011a6e:	1b df 01 60 	addi %d6,%d15,29
80011a72:	82 05       	mov %d5,0
80011a74:	6d 00 af 00 	call 80011bd2 <__ashldi3>
80011a78:	8b ff 01 f1 	rsub %d15,%d15,31
80011a7c:	89 a2 50 09 	st.d [%sp]16,%e2
80011a80:	78 03       	st.w [%sp]12,%d15
80011a82:	d9 a4 04 00 	lea %a4,[%sp]4
80011a86:	6d 00 c6 00 	call 80011c12 <__pack_d>
80011a8a:	00 90       	ret 

80011a8c <__fixdfsi>:
80011a8c:	20 20       	sub.a %sp,32
80011a8e:	d9 a4 20 00 	lea %a4,[%sp]32
80011a92:	89 44 64 f5 	st.d [+%a4]-28,%e4
80011a96:	d9 a5 0c 00 	lea %a5,[%sp]12
80011a9a:	6d 00 45 01 	call 80011d24 <__unpack_d>
80011a9e:	0c ac       	ld.bu %d15,[%sp]12
80011aa0:	82 02       	mov %d2,0
80011aa2:	bf 3f 1b 80 	jlt.u %d15,3,80011ad8 <__fixdfsi+0x4c>
80011aa6:	5e 48       	jne %d15,4,80011ab6 <__fixdfsi+0x2a>
80011aa8:	7b 00 00 28 	movh %d2,32768
80011aac:	58 04       	ld.w %d15,[%sp]16
80011aae:	1b f2 ff 3f 	addi %d3,%d2,-1
80011ab2:	6a 32       	cmovn %d2,%d15,%d3
80011ab4:	00 90       	ret 
80011ab6:	19 a6 14 00 	ld.w %d6,[%sp]20
80011aba:	82 02       	mov %d2,0
80011abc:	0e 6e       	jltz %d6,80011ad8 <__fixdfsi+0x4c>
80011abe:	8b f6 81 f2 	ge %d15,%d6,31
80011ac2:	ee f3       	jnz %d15,80011aa8 <__fixdfsi+0x1c>
80011ac4:	09 a4 58 09 	ld.d %e4,[%sp]24
80011ac8:	8b c6 03 61 	rsub %d6,%d6,60
80011acc:	6d 00 90 00 	call 80011bec <__lshrdi3>
80011ad0:	58 04       	ld.w %d15,[%sp]16
80011ad2:	8b 02 00 41 	rsub %d4,%d2,0
80011ad6:	2a 42       	cmov %d2,%d15,%d4
80011ad8:	00 90       	ret 

80011ada <__floatunsidf>:
80011ada:	20 18       	sub.a %sp,24
80011adc:	82 0f       	mov %d15,0
80011ade:	78 02       	st.w [%sp]8,%d15
80011ae0:	f6 44       	jnz %d4,80011ae8 <__floatunsidf+0xe>
80011ae2:	82 2f       	mov %d15,2
80011ae4:	2c a4       	st.b [%sp]4,%d15
80011ae6:	3c 0f       	j 80011b04 <__floatunsidf+0x2a>
80011ae8:	82 3f       	mov %d15,3
80011aea:	2c a4       	st.b [%sp]4,%d15
80011aec:	0f 04 b0 f1 	clz %d15,%d4
80011af0:	1b df 01 60 	addi %d6,%d15,29
80011af4:	82 05       	mov %d5,0
80011af6:	6d 00 6e 00 	call 80011bd2 <__ashldi3>
80011afa:	8b ff 01 f1 	rsub %d15,%d15,31
80011afe:	89 a2 50 09 	st.d [%sp]16,%e2
80011b02:	78 03       	st.w [%sp]12,%d15
80011b04:	d9 a4 04 00 	lea %a4,[%sp]4
80011b08:	1d 00 85 00 	j 80011c12 <__pack_d>

80011b0c <__udivdi3>:
80011b0c:	0f 67 a0 20 	or %d2,%d7,%d6
80011b10:	0b 45 10 a8 	mov %e10,%d5,%d4
80011b14:	02 6f       	mov %d15,%d6
80011b16:	02 7c       	mov %d12,%d7
80011b18:	d2 f8       	mov %e8,-1
80011b1a:	df 02 46 00 	jeq %d2,0,80011ba6 <__udivdi3+0x9a>
80011b1e:	8f 07 40 21 	or %d2,%d7,0
80011b22:	f6 2d       	jnz %d2,80011b3c <__udivdi3+0x30>
80011b24:	4b 6b 11 82 	div.u %e8,%d11,%d6
80011b28:	d2 04       	mov %e4,0
80011b2a:	02 a4       	mov %d4,%d10
80011b2c:	42 95       	add %d5,%d9
80011b2e:	6d 00 a4 01 	call 80011e76 <__udiv6432>
80011b32:	82 04       	mov %d4,0
80011b34:	02 85       	mov %d5,%d8
80011b36:	13 12 40 84 	madd.u %e8,%e4,%d2,1
80011b3a:	3c 36       	j 80011ba6 <__udivdi3+0x9a>
80011b3c:	0b 7b 00 21 	eq %d2,%d11,%d7
80011b40:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
80011b44:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
80011b48:	d2 08       	mov %e8,0
80011b4a:	df 02 2e 80 	jne %d2,0,80011ba6 <__udivdi3+0x9a>
80011b4e:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
80011b52:	0f 07 b0 d1 	clz %d13,%d7
80011b56:	60 5f       	mov.a %a15,%d5
80011b58:	0b 67 10 48 	mov %e4,%d7,%d6
80011b5c:	02 d6       	mov %d6,%d13
80011b5e:	6d 00 3a 00 	call 80011bd2 <__ashldi3>
80011b62:	8f fb 1f e0 	sh %d14,%d11,-1
80011b66:	80 f4       	mov.d %d4,%a15
80011b68:	02 36       	mov %d6,%d3
80011b6a:	02 e5       	mov %d5,%d14
80011b6c:	6d 00 85 01 	call 80011e76 <__udiv6432>
80011b70:	8b fd 01 d1 	rsub %d13,%d13,31
80011b74:	8b 0d 00 31 	rsub %d3,%d13,0
80011b78:	0f 32 00 30 	sh %d3,%d2,%d3
80011b7c:	02 32       	mov %d2,%d3
80011b7e:	8b f2 9f 80 	addx %d8,%d2,-1
80011b82:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
80011b86:	82 03       	mov %d3,0
80011b88:	8b f3 bf 90 	addc %d9,%d3,-1
80011b8c:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
80011b90:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
80011b94:	0b cb 00 41 	eq %d4,%d11,%d12
80011b98:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
80011b9c:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
80011ba0:	f6 43       	jnz %d4,80011ba6 <__udivdi3+0x9a>
80011ba2:	0b 23 10 88 	mov %e8,%d3,%d2
80011ba6:	0b 89 10 28 	mov %e2,%d9,%d8
80011baa:	00 90       	ret 

80011bac <__umoddi3>:
80011bac:	0f 67 a0 90 	or %d9,%d7,%d6
80011bb0:	02 6f       	mov %d15,%d6
80011bb2:	d2 00       	mov %e0,0
80011bb4:	76 9c       	jz %d9,80011bcc <__umoddi3+0x20>
80011bb6:	02 7a       	mov %d10,%d7
80011bb8:	0b 45 10 88 	mov %e8,%d5,%d4
80011bbc:	6d ff a8 ff 	call 80011b0c <__udivdi3>
80011bc0:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
80011bc4:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
80011bc8:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
80011bcc:	0b 01 10 28 	mov %e2,%d1,%d0
80011bd0:	00 90       	ret 

80011bd2 <__ashldi3>:
80011bd2:	6f 56 07 80 	jnz.t %d6,5,80011be0 <__ashldi3+0xe>
80011bd6:	0f 64 00 20 	sh %d2,%d4,%d6
80011bda:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
80011bde:	00 90       	ret 
80011be0:	8b 06 1e 60 	add %d6,%d6,-32
80011be4:	82 02       	mov %d2,0
80011be6:	0f 64 00 30 	sh %d3,%d4,%d6
80011bea:	00 90       	ret 

80011bec <__lshrdi3>:
80011bec:	6f 56 0c 80 	jnz.t %d6,5,80011c04 <__lshrdi3+0x18>
80011bf0:	8b 06 02 71 	rsub %d7,%d6,32
80011bf4:	32 56       	rsub %d6
80011bf6:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
80011bfa:	0f 65 00 30 	sh %d3,%d5,%d6
80011bfe:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
80011c02:	00 90       	ret 
80011c04:	8b 06 02 60 	add %d6,%d6,32
80011c08:	32 56       	rsub %d6
80011c0a:	0f 65 00 20 	sh %d2,%d5,%d6
80011c0e:	82 03       	mov %d3,0
80011c10:	00 90       	ret 

80011c12 <__pack_d>:
80011c12:	14 42       	ld.bu %d2,[%a4]
80011c14:	19 49 0c 00 	ld.w %d9,[%a4]12
80011c18:	19 48 10 00 	ld.w %d8,[%a4]16
80011c1c:	19 4c 04 00 	ld.w %d12,[%a4]4
80011c20:	ff 22 0b 80 	jge.u %d2,2,80011c36 <__pack_d+0x24>
80011c24:	77 98 00 9c 	dextr %d9,%d8,%d9,24
80011c28:	06 88       	sh %d8,-8
80011c2a:	02 95       	mov %d5,%d9
80011c2c:	b7 18 8d 49 	insert %d4,%d8,1,19,13
80011c30:	3b f0 7f f0 	mov %d15,2047
80011c34:	3c 6f       	j 80011d12 <__pack_d+0x100>
80011c36:	3b f0 7f f0 	mov %d15,2047
80011c3a:	d2 04       	mov %e4,0
80011c3c:	df 42 6b 00 	jeq %d2,4,80011d12 <__pack_d+0x100>
80011c40:	0f 89 a0 f0 	or %d15,%d9,%d8
80011c44:	8b 22 00 32 	eq %d3,%d2,2
80011c48:	8b 0f e0 34 	or.eq %d3,%d15,0
80011c4c:	82 0f       	mov %d15,0
80011c4e:	df 03 62 80 	jne %d3,0,80011d12 <__pack_d+0x100>
80011c52:	19 42 08 00 	ld.w %d2,[%a4]8
80011c56:	3b 20 c0 ff 	mov %d15,-1022
80011c5a:	7f f2 36 00 	jge %d2,%d15,80011cc6 <__pack_d+0xb4>
80011c5e:	a2 2f       	sub %d15,%d2
80011c60:	8b 9f 83 42 	ge %d4,%d15,57
80011c64:	82 02       	mov %d2,0
80011c66:	df 04 18 80 	jne %d4,0,80011c96 <__pack_d+0x84>
80011c6a:	0b 98 10 48 	mov %e4,%d8,%d9
80011c6e:	02 f6       	mov %d6,%d15
80011c70:	6d ff be ff 	call 80011bec <__lshrdi3>
80011c74:	d2 14       	mov %e4,1
80011c76:	02 f6       	mov %d6,%d15
80011c78:	0b 32 10 a8 	mov %e10,%d2,%d3
80011c7c:	6d ff ab ff 	call 80011bd2 <__ashldi3>
80011c80:	8b f2 9f 20 	addx %d2,%d2,-1
80011c84:	8b f3 bf 30 	addc %d3,%d3,-1
80011c88:	26 29       	and %d9,%d2
80011c8a:	26 38       	and %d8,%d3
80011c8c:	a6 98       	or %d8,%d9
80011c8e:	02 b2       	mov %d2,%d11
80011c90:	8b 08 00 25 	or.ne %d2,%d8,0
80011c94:	02 a3       	mov %d3,%d10
80011c96:	02 2f       	mov %d15,%d2
80011c98:	16 ff       	and %d15,255
80011c9a:	8b 0f 28 f2 	ne %d15,%d15,128
80011c9e:	ee 07       	jnz %d15,80011cac <__pack_d+0x9a>
80011ca0:	8f 02 10 f1 	and %d15,%d2,256
80011ca4:	6e 08       	jz %d15,80011cb4 <__pack_d+0xa2>
80011ca6:	8b 02 88 20 	addx %d2,%d2,128
80011caa:	3c 03       	j 80011cb0 <__pack_d+0x9e>
80011cac:	8b f2 87 20 	addx %d2,%d2,127
80011cb0:	8b 03 a0 30 	addc %d3,%d3,0
80011cb4:	7b 00 00 41 	movh %d4,4096
80011cb8:	0b 43 50 f1 	ge.u %d15,%d3,%d4
80011cbc:	77 23 00 5c 	dextr %d5,%d3,%d2,24
80011cc0:	8f 83 1f 40 	sh %d4,%d3,-8
80011cc4:	3c 27       	j 80011d12 <__pack_d+0x100>
80011cc6:	3b 00 40 30 	mov %d3,1024
80011cca:	3b f0 7f f0 	mov %d15,2047
80011cce:	7f 32 22 00 	jge %d2,%d3,80011d12 <__pack_d+0x100>
80011cd2:	02 9f       	mov %d15,%d9
80011cd4:	16 ff       	and %d15,255
80011cd6:	8b 0f 28 f2 	ne %d15,%d15,128
80011cda:	ee 07       	jnz %d15,80011ce8 <__pack_d+0xd6>
80011cdc:	8f 09 10 f1 	and %d15,%d9,256
80011ce0:	6e 08       	jz %d15,80011cf0 <__pack_d+0xde>
80011ce2:	8b 09 88 90 	addx %d9,%d9,128
80011ce6:	3c 03       	j 80011cec <__pack_d+0xda>
80011ce8:	8b f9 87 90 	addx %d9,%d9,127
80011cec:	8b 08 a0 80 	addc %d8,%d8,0
80011cf0:	7b 00 00 32 	movh %d3,8192
80011cf4:	0b 38 50 f1 	ge.u %d15,%d8,%d3
80011cf8:	ee 04       	jnz %d15,80011d00 <__pack_d+0xee>
80011cfa:	1b f2 3f f0 	addi %d15,%d2,1023
80011cfe:	3c 06       	j 80011d0a <__pack_d+0xf8>
80011d00:	77 98 80 9f 	dextr %d9,%d8,%d9,31
80011d04:	1b 02 40 f0 	addi %d15,%d2,1024
80011d08:	06 f8       	sh %d8,-1
80011d0a:	77 98 00 5c 	dextr %d5,%d8,%d9,24
80011d0e:	8f 88 1f 40 	sh %d4,%d8,-8
80011d12:	d2 02       	mov %e2,0
80011d14:	37 43 14 40 	insert %d4,%d3,%d4,0,20
80011d18:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
80011d1c:	02 52       	mov %d2,%d5
80011d1e:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
80011d22:	00 90       	ret 

80011d24 <__unpack_d>:
80011d24:	19 44 04 00 	ld.w %d4,[%a4]4
80011d28:	54 42       	ld.w %d2,[%a4]
80011d2a:	37 04 74 50 	extr.u %d5,%d4,0,20
80011d2e:	37 04 6b fa 	extr.u %d15,%d4,20,11
80011d32:	8f 14 1e 40 	sh %d4,%d4,-31
80011d36:	59 54 04 00 	st.w [%a5]4,%d4
80011d3a:	02 53       	mov %d3,%d5
80011d3c:	ee 21       	jnz %d15,80011d7e <__unpack_d+0x5a>
80011d3e:	0f 25 a0 f0 	or %d15,%d5,%d2
80011d42:	ee 03       	jnz %d15,80011d48 <__unpack_d+0x24>
80011d44:	82 2f       	mov %d15,2
80011d46:	3c 23       	j 80011d8c <__unpack_d+0x68>
80011d48:	3b 20 c0 ff 	mov %d15,-1022
80011d4c:	6c 52       	st.w [%a5]8,%d15
80011d4e:	82 3f       	mov %d15,3
80011d50:	77 25 00 34 	dextr %d3,%d5,%d2,8
80011d54:	2c 50       	st.b [%a5]0,%d15
80011d56:	8f 82 00 20 	sh %d2,%d2,8
80011d5a:	3b 10 c0 ff 	mov %d15,-1023
80011d5e:	77 23 80 30 	dextr %d3,%d3,%d2,1
80011d62:	7b 00 00 61 	movh %d6,4096
80011d66:	0b 63 30 51 	lt.u %d5,%d3,%d6
80011d6a:	02 f4       	mov %d4,%d15
80011d6c:	06 12       	sh %d2,1
80011d6e:	c2 ff       	add %d15,-1
80011d70:	df 05 f7 ff 	jne %d5,0,80011d5e <__unpack_d+0x3a>
80011d74:	59 54 08 00 	st.w [%a5]8,%d4
80011d78:	59 52 0c 00 	st.w [%a5]12,%d2
80011d7c:	3c 27       	j 80011dca <__unpack_d+0xa6>
80011d7e:	3b f0 7f 40 	mov %d4,2047
80011d82:	fe 47       	jne %d15,%d4,80011db0 <__unpack_d+0x8c>
80011d84:	0f 25 a0 f0 	or %d15,%d5,%d2
80011d88:	ee 04       	jnz %d15,80011d90 <__unpack_d+0x6c>
80011d8a:	82 4f       	mov %d15,4
80011d8c:	2c 50       	st.b [%a5]0,%d15
80011d8e:	00 90       	ret 
80011d90:	7b 80 00 f0 	movh %d15,8
80011d94:	26 5f       	and %d15,%d5
80011d96:	6e 02       	jz %d15,80011d9a <__unpack_d+0x76>
80011d98:	82 1f       	mov %d15,1
80011d9a:	2c 50       	st.b [%a5]0,%d15
80011d9c:	b7 03 81 f9 	insert %d15,%d3,0,19,1
80011da0:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
80011da4:	8f 82 00 40 	sh %d4,%d2,8
80011da8:	59 54 0c 00 	st.w [%a5]12,%d4
80011dac:	6c 54       	st.w [%a5]16,%d15
80011dae:	00 90       	ret 
80011db0:	1b 1f c0 ff 	addi %d15,%d15,-1023
80011db4:	77 25 00 34 	dextr %d3,%d5,%d2,8
80011db8:	6c 52       	st.w [%a5]8,%d15
80011dba:	8f 82 00 20 	sh %d2,%d2,8
80011dbe:	82 3f       	mov %d15,3
80011dc0:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
80011dc4:	2c 50       	st.b [%a5]0,%d15
80011dc6:	59 52 0c 00 	st.w [%a5]12,%d2
80011dca:	59 53 10 00 	st.w [%a5]16,%d3
80011dce:	00 90       	ret 

80011dd0 <__fpcmp_parts_d>:
80011dd0:	14 43       	ld.bu %d3,[%a4]
80011dd2:	82 12       	mov %d2,1
80011dd4:	bf 23 50 80 	jlt.u %d3,2,80011e74 <__fpcmp_parts_d+0xa4>
80011dd8:	0c 50       	ld.bu %d15,[%a5]0
80011dda:	bf 2f 4d 80 	jlt.u %d15,2,80011e74 <__fpcmp_parts_d+0xa4>
80011dde:	8b 43 00 42 	eq %d4,%d3,4
80011de2:	8b 4f 00 22 	eq %d2,%d15,4
80011de6:	0f 24 80 50 	and %d5,%d4,%d2
80011dea:	76 56       	jz %d5,80011df6 <__fpcmp_parts_d+0x26>
80011dec:	19 52 04 00 	ld.w %d2,[%a5]4
80011df0:	4c 41       	ld.w %d15,[%a4]4
80011df2:	a2 f2       	sub %d2,%d15
80011df4:	00 90       	ret 
80011df6:	76 47       	jz %d4,80011e04 <__fpcmp_parts_d+0x34>
80011df8:	19 42 04 00 	ld.w %d2,[%a4]4
80011dfc:	82 1f       	mov %d15,1
80011dfe:	ab ff bf 22 	seln %d2,%d2,%d15,-1
80011e02:	00 90       	ret 
80011e04:	76 27       	jz %d2,80011e12 <__fpcmp_parts_d+0x42>
80011e06:	19 52 04 00 	ld.w %d2,[%a5]4
80011e0a:	82 ff       	mov %d15,-1
80011e0c:	ab 1f a0 22 	seln %d2,%d2,%d15,1
80011e10:	00 90       	ret 
80011e12:	df 23 06 80 	jne %d3,2,80011e1e <__fpcmp_parts_d+0x4e>
80011e16:	82 02       	mov %d2,0
80011e18:	df 2f f7 ff 	jne %d15,2,80011e06 <__fpcmp_parts_d+0x36>
80011e1c:	00 90       	ret 
80011e1e:	df 2f ed 7f 	jeq %d15,2,80011df8 <__fpcmp_parts_d+0x28>
80011e22:	19 45 04 00 	ld.w %d5,[%a4]4
80011e26:	4c 51       	ld.w %d15,[%a5]4
80011e28:	5f f5 19 80 	jne %d5,%d15,80011e5a <__fpcmp_parts_d+0x8a>
80011e2c:	19 42 08 00 	ld.w %d2,[%a4]8
80011e30:	4c 52       	ld.w %d15,[%a5]8
80011e32:	3f 2f 14 00 	jlt %d15,%d2,80011e5a <__fpcmp_parts_d+0x8a>
80011e36:	3f f2 1c 00 	jlt %d2,%d15,80011e6e <__fpcmp_parts_d+0x9e>
80011e3a:	19 43 10 00 	ld.w %d3,[%a4]16
80011e3e:	19 54 10 00 	ld.w %d4,[%a5]16
80011e42:	19 47 0c 00 	ld.w %d7,[%a4]12
80011e46:	19 56 0c 00 	ld.w %d6,[%a5]12
80011e4a:	0b 43 00 21 	eq %d2,%d3,%d4
80011e4e:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
80011e52:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
80011e56:	3a 43       	eq %d15,%d3,%d4
80011e58:	f6 25       	jnz %d2,80011e62 <__fpcmp_parts_d+0x92>
80011e5a:	82 12       	mov %d2,1
80011e5c:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
80011e60:	00 90       	ret 
80011e62:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
80011e66:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
80011e6a:	82 02       	mov %d2,0
80011e6c:	ee 04       	jnz %d15,80011e74 <__fpcmp_parts_d+0xa4>
80011e6e:	82 f2       	mov %d2,-1
80011e70:	ab 12 a0 25 	seln %d2,%d5,%d2,1
80011e74:	00 90       	ret 

80011e76 <__udiv6432>:
80011e76:	02 53       	mov %d3,%d5
80011e78:	82 f2       	mov %d2,-1
80011e7a:	7f 65 4b 80 	jge.u %d5,%d6,80011f10 <__udiv6432+0x9a>
80011e7e:	0f 06 b0 21 	clz %d2,%d6
80011e82:	0f 26 00 60 	sh %d6,%d6,%d2
80011e86:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
80011e8a:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
80011e8e:	8f 06 1f 70 	sh %d7,%d6,-16
80011e92:	4b 73 11 02 	div.u %e0,%d3,%d7
80011e96:	b7 06 10 88 	insert %d8,%d6,0,16,16
80011e9a:	0f 24 00 20 	sh %d2,%d4,%d2
80011e9e:	02 05       	mov %d5,%d0
80011ea0:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
80011ea4:	e2 80       	mul %d0,%d8
80011ea6:	8f 02 1f b0 	sh %d11,%d2,-16
80011eaa:	b7 02 10 28 	insert %d2,%d2,0,16,16
80011eae:	82 0c       	mov %d12,0
80011eb0:	7b 10 00 90 	movh %d9,1
80011eb4:	7f 95 09 80 	jge.u %d5,%d9,80011ec6 <__udiv6432+0x50>
80011eb8:	8f 01 01 f0 	sh %d15,%d1,16
80011ebc:	0b 0c 00 a0 	add %d10,%d12,%d0
80011ec0:	42 bf       	add %d15,%d11
80011ec2:	7f af 07 80 	jge.u %d15,%d10,80011ed0 <__udiv6432+0x5a>
80011ec6:	42 71       	add %d1,%d7
80011ec8:	c2 f5       	add %d5,-1
80011eca:	a2 8c       	sub %d12,%d8
80011ecc:	3f 91 f4 ff 	jlt.u %d1,%d9,80011eb4 <__udiv6432+0x3e>
80011ed0:	8f 03 01 30 	sh %d3,%d3,16
80011ed4:	42 3b       	add %d11,%d3
80011ed6:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
80011eda:	82 0a       	mov %d10,0
80011edc:	4b 76 11 02 	div.u %e0,%d6,%d7
80011ee0:	7b 10 00 10 	movh %d1,1
80011ee4:	02 03       	mov %d3,%d0
80011ee6:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
80011eea:	e2 80       	mul %d0,%d8
80011eec:	7f 13 09 80 	jge.u %d3,%d1,80011efe <__udiv6432+0x88>
80011ef0:	8f 06 01 f0 	sh %d15,%d6,16
80011ef4:	0b 0a 00 90 	add %d9,%d10,%d0
80011ef8:	42 2f       	add %d15,%d2
80011efa:	7f 9f 07 80 	jge.u %d15,%d9,80011f08 <__udiv6432+0x92>
80011efe:	42 76       	add %d6,%d7
80011f00:	c2 f3       	add %d3,-1
80011f02:	a2 8a       	sub %d10,%d8
80011f04:	3f 16 f4 ff 	jlt.u %d6,%d1,80011eec <__udiv6432+0x76>
80011f08:	8f 05 01 50 	sh %d5,%d5,16
80011f0c:	0b 53 00 20 	add %d2,%d3,%d5
80011f10:	00 90       	ret 
80011f12:	00 00       	nop 
80011f14:	00 00       	nop 
	...

Disassembly of section .inttab:

50100000 <TriCore_int_table>:
50100000:	00 a0       	debug 
	...

50100020 <___interrupt_1>:
50100020:	9d 80 ce 6e 	ja 8000dd9c <__interrupt_1>
	...

50100040 <__interrupt_2>:
50100040:	e0 02       	bisr 2
50100042:	91 00 00 f7 	movh.a %a15,28672
50100046:	d9 ff b8 24 	lea %a15,[%a15]18616 <700048b8 <Cdisptab+0x10>>
5010004a:	c4 fe       	ld.a %a14,[%a15+]
5010004c:	54 f4       	ld.w %d4,[%a15]
5010004e:	2d 0e 00 00 	calli %a14
50100052:	0d 00 40 02 	rslcx 
50100056:	00 80       	rfe 
	...

50100060 <__interrupt_3>:
50100060:	e0 03       	bisr 3
50100062:	91 00 00 f7 	movh.a %a15,28672
50100066:	d9 ff 80 34 	lea %a15,[%a15]18624 <700048c0 <Cdisptab+0x18>>
5010006a:	c4 fe       	ld.a %a14,[%a15+]
5010006c:	54 f4       	ld.w %d4,[%a15]
5010006e:	2d 0e 00 00 	calli %a14
50100072:	0d 00 40 02 	rslcx 
50100076:	00 80       	rfe 
	...

50100080 <__interrupt_4>:
50100080:	e0 04       	bisr 4
50100082:	91 00 00 f7 	movh.a %a15,28672
50100086:	d9 ff 88 34 	lea %a15,[%a15]18632 <700048c8 <Cdisptab+0x20>>
5010008a:	c4 fe       	ld.a %a14,[%a15+]
5010008c:	54 f4       	ld.w %d4,[%a15]
5010008e:	2d 0e 00 00 	calli %a14
50100092:	0d 00 40 02 	rslcx 
50100096:	00 80       	rfe 
	...

501000a0 <__interrupt_5>:
501000a0:	e0 05       	bisr 5
501000a2:	91 00 00 f7 	movh.a %a15,28672
501000a6:	d9 ff 90 34 	lea %a15,[%a15]18640 <700048d0 <Cdisptab+0x28>>
501000aa:	c4 fe       	ld.a %a14,[%a15+]
501000ac:	54 f4       	ld.w %d4,[%a15]
501000ae:	2d 0e 00 00 	calli %a14
501000b2:	0d 00 40 02 	rslcx 
501000b6:	00 80       	rfe 
	...

501000c0 <__interrupt_6>:
501000c0:	e0 06       	bisr 6
501000c2:	91 00 00 f7 	movh.a %a15,28672
501000c6:	d9 ff 98 34 	lea %a15,[%a15]18648 <700048d8 <Cdisptab+0x30>>
501000ca:	c4 fe       	ld.a %a14,[%a15+]
501000cc:	54 f4       	ld.w %d4,[%a15]
501000ce:	2d 0e 00 00 	calli %a14
501000d2:	0d 00 40 02 	rslcx 
501000d6:	00 80       	rfe 
	...

501000e0 <__interrupt_7>:
501000e0:	e0 07       	bisr 7
501000e2:	91 00 00 f7 	movh.a %a15,28672
501000e6:	d9 ff a0 34 	lea %a15,[%a15]18656 <700048e0 <Cdisptab+0x38>>
501000ea:	c4 fe       	ld.a %a14,[%a15+]
501000ec:	54 f4       	ld.w %d4,[%a15]
501000ee:	2d 0e 00 00 	calli %a14
501000f2:	0d 00 40 02 	rslcx 
501000f6:	00 80       	rfe 
	...

50100100 <__interrupt_8>:
50100100:	e0 08       	bisr 8
50100102:	91 00 00 f7 	movh.a %a15,28672
50100106:	d9 ff a8 34 	lea %a15,[%a15]18664 <700048e8 <Cdisptab+0x40>>
5010010a:	c4 fe       	ld.a %a14,[%a15+]
5010010c:	54 f4       	ld.w %d4,[%a15]
5010010e:	2d 0e 00 00 	calli %a14
50100112:	0d 00 40 02 	rslcx 
50100116:	00 80       	rfe 
	...

50100120 <__interrupt_9>:
50100120:	e0 09       	bisr 9
50100122:	91 00 00 f7 	movh.a %a15,28672
50100126:	d9 ff b0 34 	lea %a15,[%a15]18672 <700048f0 <Cdisptab+0x48>>
5010012a:	c4 fe       	ld.a %a14,[%a15+]
5010012c:	54 f4       	ld.w %d4,[%a15]
5010012e:	2d 0e 00 00 	calli %a14
50100132:	0d 00 40 02 	rslcx 
50100136:	00 80       	rfe 
	...

50100140 <__interrupt_10>:
50100140:	e0 0a       	bisr 10
50100142:	91 00 00 f7 	movh.a %a15,28672
50100146:	d9 ff b8 34 	lea %a15,[%a15]18680 <700048f8 <Cdisptab+0x50>>
5010014a:	c4 fe       	ld.a %a14,[%a15+]
5010014c:	54 f4       	ld.w %d4,[%a15]
5010014e:	2d 0e 00 00 	calli %a14
50100152:	0d 00 40 02 	rslcx 
50100156:	00 80       	rfe 
	...

50100160 <__interrupt_11>:
50100160:	e0 0b       	bisr 11
50100162:	91 00 00 f7 	movh.a %a15,28672
50100166:	d9 ff 80 44 	lea %a15,[%a15]18688 <70004900 <Cdisptab+0x58>>
5010016a:	c4 fe       	ld.a %a14,[%a15+]
5010016c:	54 f4       	ld.w %d4,[%a15]
5010016e:	2d 0e 00 00 	calli %a14
50100172:	0d 00 40 02 	rslcx 
50100176:	00 80       	rfe 
	...

50100180 <__interrupt_12>:
50100180:	e0 0c       	bisr 12
50100182:	91 00 00 f7 	movh.a %a15,28672
50100186:	d9 ff 88 44 	lea %a15,[%a15]18696 <70004908 <Cdisptab+0x60>>
5010018a:	c4 fe       	ld.a %a14,[%a15+]
5010018c:	54 f4       	ld.w %d4,[%a15]
5010018e:	2d 0e 00 00 	calli %a14
50100192:	0d 00 40 02 	rslcx 
50100196:	00 80       	rfe 
	...

501001a0 <__interrupt_13>:
501001a0:	e0 0d       	bisr 13
501001a2:	91 00 00 f7 	movh.a %a15,28672
501001a6:	d9 ff 90 44 	lea %a15,[%a15]18704 <70004910 <Cdisptab+0x68>>
501001aa:	c4 fe       	ld.a %a14,[%a15+]
501001ac:	54 f4       	ld.w %d4,[%a15]
501001ae:	2d 0e 00 00 	calli %a14
501001b2:	0d 00 40 02 	rslcx 
501001b6:	00 80       	rfe 
	...

501001c0 <__interrupt_14>:
501001c0:	e0 0e       	bisr 14
501001c2:	91 00 00 f7 	movh.a %a15,28672
501001c6:	d9 ff 98 44 	lea %a15,[%a15]18712 <70004918 <Cdisptab+0x70>>
501001ca:	c4 fe       	ld.a %a14,[%a15+]
501001cc:	54 f4       	ld.w %d4,[%a15]
501001ce:	2d 0e 00 00 	calli %a14
501001d2:	0d 00 40 02 	rslcx 
501001d6:	00 80       	rfe 
	...

501001e0 <__interrupt_15>:
501001e0:	e0 0f       	bisr 15
501001e2:	91 00 00 f7 	movh.a %a15,28672
501001e6:	d9 ff a0 44 	lea %a15,[%a15]18720 <70004920 <Cdisptab+0x78>>
501001ea:	c4 fe       	ld.a %a14,[%a15+]
501001ec:	54 f4       	ld.w %d4,[%a15]
501001ee:	2d 0e 00 00 	calli %a14
501001f2:	0d 00 40 02 	rslcx 
501001f6:	00 80       	rfe 
	...

50100200 <__interrupt_16>:
50100200:	e0 10       	bisr 16
50100202:	91 00 00 f7 	movh.a %a15,28672
50100206:	d9 ff a8 44 	lea %a15,[%a15]18728 <70004928 <Cdisptab+0x80>>
5010020a:	c4 fe       	ld.a %a14,[%a15+]
5010020c:	54 f4       	ld.w %d4,[%a15]
5010020e:	2d 0e 00 00 	calli %a14
50100212:	0d 00 40 02 	rslcx 
50100216:	00 80       	rfe 
	...

50100220 <__interrupt_17>:
50100220:	e0 11       	bisr 17
50100222:	91 00 00 f7 	movh.a %a15,28672
50100226:	d9 ff b0 44 	lea %a15,[%a15]18736 <70004930 <Cdisptab+0x88>>
5010022a:	c4 fe       	ld.a %a14,[%a15+]
5010022c:	54 f4       	ld.w %d4,[%a15]
5010022e:	2d 0e 00 00 	calli %a14
50100232:	0d 00 40 02 	rslcx 
50100236:	00 80       	rfe 
	...

50100240 <__interrupt_18>:
50100240:	e0 12       	bisr 18
50100242:	91 00 00 f7 	movh.a %a15,28672
50100246:	d9 ff b8 44 	lea %a15,[%a15]18744 <70004938 <Cdisptab+0x90>>
5010024a:	c4 fe       	ld.a %a14,[%a15+]
5010024c:	54 f4       	ld.w %d4,[%a15]
5010024e:	2d 0e 00 00 	calli %a14
50100252:	0d 00 40 02 	rslcx 
50100256:	00 80       	rfe 
	...

50100260 <__interrupt_19>:
50100260:	e0 13       	bisr 19
50100262:	91 00 00 f7 	movh.a %a15,28672
50100266:	d9 ff 80 54 	lea %a15,[%a15]18752 <70004940 <Cdisptab+0x98>>
5010026a:	c4 fe       	ld.a %a14,[%a15+]
5010026c:	54 f4       	ld.w %d4,[%a15]
5010026e:	2d 0e 00 00 	calli %a14
50100272:	0d 00 40 02 	rslcx 
50100276:	00 80       	rfe 
	...

50100280 <__interrupt_20>:
50100280:	e0 14       	bisr 20
50100282:	91 00 00 f7 	movh.a %a15,28672
50100286:	d9 ff 88 54 	lea %a15,[%a15]18760 <70004948 <Cdisptab+0xa0>>
5010028a:	c4 fe       	ld.a %a14,[%a15+]
5010028c:	54 f4       	ld.w %d4,[%a15]
5010028e:	2d 0e 00 00 	calli %a14
50100292:	0d 00 40 02 	rslcx 
50100296:	00 80       	rfe 
	...

501002a0 <__interrupt_21>:
501002a0:	e0 15       	bisr 21
501002a2:	91 00 00 f7 	movh.a %a15,28672
501002a6:	d9 ff 90 54 	lea %a15,[%a15]18768 <70004950 <Cdisptab+0xa8>>
501002aa:	c4 fe       	ld.a %a14,[%a15+]
501002ac:	54 f4       	ld.w %d4,[%a15]
501002ae:	2d 0e 00 00 	calli %a14
501002b2:	0d 00 40 02 	rslcx 
501002b6:	00 80       	rfe 
	...

501002c0 <__interrupt_22>:
501002c0:	e0 16       	bisr 22
501002c2:	91 00 00 f7 	movh.a %a15,28672
501002c6:	d9 ff 98 54 	lea %a15,[%a15]18776 <70004958 <Cdisptab+0xb0>>
501002ca:	c4 fe       	ld.a %a14,[%a15+]
501002cc:	54 f4       	ld.w %d4,[%a15]
501002ce:	2d 0e 00 00 	calli %a14
501002d2:	0d 00 40 02 	rslcx 
501002d6:	00 80       	rfe 
	...

501002e0 <__interrupt_23>:
501002e0:	e0 17       	bisr 23
501002e2:	91 00 00 f7 	movh.a %a15,28672
501002e6:	d9 ff a0 54 	lea %a15,[%a15]18784 <70004960 <Cdisptab+0xb8>>
501002ea:	c4 fe       	ld.a %a14,[%a15+]
501002ec:	54 f4       	ld.w %d4,[%a15]
501002ee:	2d 0e 00 00 	calli %a14
501002f2:	0d 00 40 02 	rslcx 
501002f6:	00 80       	rfe 
	...

50100300 <__interrupt_24>:
50100300:	e0 18       	bisr 24
50100302:	91 00 00 f7 	movh.a %a15,28672
50100306:	d9 ff a8 54 	lea %a15,[%a15]18792 <70004968 <Cdisptab+0xc0>>
5010030a:	c4 fe       	ld.a %a14,[%a15+]
5010030c:	54 f4       	ld.w %d4,[%a15]
5010030e:	2d 0e 00 00 	calli %a14
50100312:	0d 00 40 02 	rslcx 
50100316:	00 80       	rfe 
	...

50100320 <__interrupt_25>:
50100320:	e0 19       	bisr 25
50100322:	91 00 00 f7 	movh.a %a15,28672
50100326:	d9 ff b0 54 	lea %a15,[%a15]18800 <70004970 <Cdisptab+0xc8>>
5010032a:	c4 fe       	ld.a %a14,[%a15+]
5010032c:	54 f4       	ld.w %d4,[%a15]
5010032e:	2d 0e 00 00 	calli %a14
50100332:	0d 00 40 02 	rslcx 
50100336:	00 80       	rfe 
	...

50100340 <__interrupt_26>:
50100340:	e0 1a       	bisr 26
50100342:	91 00 00 f7 	movh.a %a15,28672
50100346:	d9 ff b8 54 	lea %a15,[%a15]18808 <70004978 <Cdisptab+0xd0>>
5010034a:	c4 fe       	ld.a %a14,[%a15+]
5010034c:	54 f4       	ld.w %d4,[%a15]
5010034e:	2d 0e 00 00 	calli %a14
50100352:	0d 00 40 02 	rslcx 
50100356:	00 80       	rfe 
	...

50100360 <__interrupt_27>:
50100360:	e0 1b       	bisr 27
50100362:	91 00 00 f7 	movh.a %a15,28672
50100366:	d9 ff 80 64 	lea %a15,[%a15]18816 <70004980 <Cdisptab+0xd8>>
5010036a:	c4 fe       	ld.a %a14,[%a15+]
5010036c:	54 f4       	ld.w %d4,[%a15]
5010036e:	2d 0e 00 00 	calli %a14
50100372:	0d 00 40 02 	rslcx 
50100376:	00 80       	rfe 
	...

50100380 <__interrupt_28>:
50100380:	e0 1c       	bisr 28
50100382:	91 00 00 f7 	movh.a %a15,28672
50100386:	d9 ff 88 64 	lea %a15,[%a15]18824 <70004988 <Cdisptab+0xe0>>
5010038a:	c4 fe       	ld.a %a14,[%a15+]
5010038c:	54 f4       	ld.w %d4,[%a15]
5010038e:	2d 0e 00 00 	calli %a14
50100392:	0d 00 40 02 	rslcx 
50100396:	00 80       	rfe 
	...

501003a0 <__interrupt_29>:
501003a0:	e0 1d       	bisr 29
501003a2:	91 00 00 f7 	movh.a %a15,28672
501003a6:	d9 ff 90 64 	lea %a15,[%a15]18832 <70004990 <Cdisptab+0xe8>>
501003aa:	c4 fe       	ld.a %a14,[%a15+]
501003ac:	54 f4       	ld.w %d4,[%a15]
501003ae:	2d 0e 00 00 	calli %a14
501003b2:	0d 00 40 02 	rslcx 
501003b6:	00 80       	rfe 
	...

501003c0 <__interrupt_30>:
501003c0:	e0 1e       	bisr 30
501003c2:	91 00 00 f7 	movh.a %a15,28672
501003c6:	d9 ff 98 64 	lea %a15,[%a15]18840 <70004998 <Cdisptab+0xf0>>
501003ca:	c4 fe       	ld.a %a14,[%a15+]
501003cc:	54 f4       	ld.w %d4,[%a15]
501003ce:	2d 0e 00 00 	calli %a14
501003d2:	0d 00 40 02 	rslcx 
501003d6:	00 80       	rfe 
	...

501003e0 <__interrupt_31>:
501003e0:	e0 1f       	bisr 31
501003e2:	91 00 00 f7 	movh.a %a15,28672
501003e6:	d9 ff a0 64 	lea %a15,[%a15]18848 <700049a0 <Cdisptab+0xf8>>
501003ea:	c4 fe       	ld.a %a14,[%a15+]
501003ec:	54 f4       	ld.w %d4,[%a15]
501003ee:	2d 0e 00 00 	calli %a14
501003f2:	0d 00 40 02 	rslcx 
501003f6:	00 80       	rfe 
	...

50100400 <__interrupt_32>:
50100400:	e0 20       	bisr 32
50100402:	91 00 00 f7 	movh.a %a15,28672
50100406:	d9 ff a8 64 	lea %a15,[%a15]18856 <700049a8 <Cdisptab+0x100>>
5010040a:	c4 fe       	ld.a %a14,[%a15+]
5010040c:	54 f4       	ld.w %d4,[%a15]
5010040e:	2d 0e 00 00 	calli %a14
50100412:	0d 00 40 02 	rslcx 
50100416:	00 80       	rfe 
	...

50100420 <__interrupt_33>:
50100420:	e0 21       	bisr 33
50100422:	91 00 00 f7 	movh.a %a15,28672
50100426:	d9 ff b0 64 	lea %a15,[%a15]18864 <700049b0 <Cdisptab+0x108>>
5010042a:	c4 fe       	ld.a %a14,[%a15+]
5010042c:	54 f4       	ld.w %d4,[%a15]
5010042e:	2d 0e 00 00 	calli %a14
50100432:	0d 00 40 02 	rslcx 
50100436:	00 80       	rfe 
	...

50100440 <__interrupt_34>:
50100440:	e0 22       	bisr 34
50100442:	91 00 00 f7 	movh.a %a15,28672
50100446:	d9 ff b8 64 	lea %a15,[%a15]18872 <700049b8 <Cdisptab+0x110>>
5010044a:	c4 fe       	ld.a %a14,[%a15+]
5010044c:	54 f4       	ld.w %d4,[%a15]
5010044e:	2d 0e 00 00 	calli %a14
50100452:	0d 00 40 02 	rslcx 
50100456:	00 80       	rfe 
	...

50100460 <__interrupt_35>:
50100460:	e0 23       	bisr 35
50100462:	91 00 00 f7 	movh.a %a15,28672
50100466:	d9 ff 80 74 	lea %a15,[%a15]18880 <700049c0 <Cdisptab+0x118>>
5010046a:	c4 fe       	ld.a %a14,[%a15+]
5010046c:	54 f4       	ld.w %d4,[%a15]
5010046e:	2d 0e 00 00 	calli %a14
50100472:	0d 00 40 02 	rslcx 
50100476:	00 80       	rfe 
	...

50100480 <__interrupt_36>:
50100480:	e0 24       	bisr 36
50100482:	91 00 00 f7 	movh.a %a15,28672
50100486:	d9 ff 88 74 	lea %a15,[%a15]18888 <700049c8 <Cdisptab+0x120>>
5010048a:	c4 fe       	ld.a %a14,[%a15+]
5010048c:	54 f4       	ld.w %d4,[%a15]
5010048e:	2d 0e 00 00 	calli %a14
50100492:	0d 00 40 02 	rslcx 
50100496:	00 80       	rfe 
	...

501004a0 <__interrupt_37>:
501004a0:	e0 25       	bisr 37
501004a2:	91 00 00 f7 	movh.a %a15,28672
501004a6:	d9 ff 90 74 	lea %a15,[%a15]18896 <700049d0 <Cdisptab+0x128>>
501004aa:	c4 fe       	ld.a %a14,[%a15+]
501004ac:	54 f4       	ld.w %d4,[%a15]
501004ae:	2d 0e 00 00 	calli %a14
501004b2:	0d 00 40 02 	rslcx 
501004b6:	00 80       	rfe 
	...

501004c0 <__interrupt_38>:
501004c0:	e0 26       	bisr 38
501004c2:	91 00 00 f7 	movh.a %a15,28672
501004c6:	d9 ff 98 74 	lea %a15,[%a15]18904 <700049d8 <Cdisptab+0x130>>
501004ca:	c4 fe       	ld.a %a14,[%a15+]
501004cc:	54 f4       	ld.w %d4,[%a15]
501004ce:	2d 0e 00 00 	calli %a14
501004d2:	0d 00 40 02 	rslcx 
501004d6:	00 80       	rfe 
	...

501004e0 <__interrupt_39>:
501004e0:	e0 27       	bisr 39
501004e2:	91 00 00 f7 	movh.a %a15,28672
501004e6:	d9 ff a0 74 	lea %a15,[%a15]18912 <700049e0 <Cdisptab+0x138>>
501004ea:	c4 fe       	ld.a %a14,[%a15+]
501004ec:	54 f4       	ld.w %d4,[%a15]
501004ee:	2d 0e 00 00 	calli %a14
501004f2:	0d 00 40 02 	rslcx 
501004f6:	00 80       	rfe 
	...

50100500 <__interrupt_40>:
50100500:	e0 28       	bisr 40
50100502:	91 00 00 f7 	movh.a %a15,28672
50100506:	d9 ff a8 74 	lea %a15,[%a15]18920 <700049e8 <Cdisptab+0x140>>
5010050a:	c4 fe       	ld.a %a14,[%a15+]
5010050c:	54 f4       	ld.w %d4,[%a15]
5010050e:	2d 0e 00 00 	calli %a14
50100512:	0d 00 40 02 	rslcx 
50100516:	00 80       	rfe 
	...

50100520 <__interrupt_41>:
50100520:	e0 29       	bisr 41
50100522:	91 00 00 f7 	movh.a %a15,28672
50100526:	d9 ff b0 74 	lea %a15,[%a15]18928 <700049f0 <Cdisptab+0x148>>
5010052a:	c4 fe       	ld.a %a14,[%a15+]
5010052c:	54 f4       	ld.w %d4,[%a15]
5010052e:	2d 0e 00 00 	calli %a14
50100532:	0d 00 40 02 	rslcx 
50100536:	00 80       	rfe 
	...

50100540 <__interrupt_42>:
50100540:	e0 2a       	bisr 42
50100542:	91 00 00 f7 	movh.a %a15,28672
50100546:	d9 ff b8 74 	lea %a15,[%a15]18936 <700049f8 <Cdisptab+0x150>>
5010054a:	c4 fe       	ld.a %a14,[%a15+]
5010054c:	54 f4       	ld.w %d4,[%a15]
5010054e:	2d 0e 00 00 	calli %a14
50100552:	0d 00 40 02 	rslcx 
50100556:	00 80       	rfe 
	...

50100560 <__interrupt_43>:
50100560:	e0 2b       	bisr 43
50100562:	91 00 00 f7 	movh.a %a15,28672
50100566:	d9 ff 80 84 	lea %a15,[%a15]18944 <70004a00 <Cdisptab+0x158>>
5010056a:	c4 fe       	ld.a %a14,[%a15+]
5010056c:	54 f4       	ld.w %d4,[%a15]
5010056e:	2d 0e 00 00 	calli %a14
50100572:	0d 00 40 02 	rslcx 
50100576:	00 80       	rfe 
	...

50100580 <__interrupt_44>:
50100580:	e0 2c       	bisr 44
50100582:	91 00 00 f7 	movh.a %a15,28672
50100586:	d9 ff 88 84 	lea %a15,[%a15]18952 <70004a08 <Cdisptab+0x160>>
5010058a:	c4 fe       	ld.a %a14,[%a15+]
5010058c:	54 f4       	ld.w %d4,[%a15]
5010058e:	2d 0e 00 00 	calli %a14
50100592:	0d 00 40 02 	rslcx 
50100596:	00 80       	rfe 
	...

501005a0 <__interrupt_45>:
501005a0:	e0 2d       	bisr 45
501005a2:	91 00 00 f7 	movh.a %a15,28672
501005a6:	d9 ff 90 84 	lea %a15,[%a15]18960 <70004a10 <Cdisptab+0x168>>
501005aa:	c4 fe       	ld.a %a14,[%a15+]
501005ac:	54 f4       	ld.w %d4,[%a15]
501005ae:	2d 0e 00 00 	calli %a14
501005b2:	0d 00 40 02 	rslcx 
501005b6:	00 80       	rfe 
	...

501005c0 <__interrupt_46>:
501005c0:	e0 2e       	bisr 46
501005c2:	91 00 00 f7 	movh.a %a15,28672
501005c6:	d9 ff 98 84 	lea %a15,[%a15]18968 <70004a18 <Cdisptab+0x170>>
501005ca:	c4 fe       	ld.a %a14,[%a15+]
501005cc:	54 f4       	ld.w %d4,[%a15]
501005ce:	2d 0e 00 00 	calli %a14
501005d2:	0d 00 40 02 	rslcx 
501005d6:	00 80       	rfe 
	...

501005e0 <__interrupt_47>:
501005e0:	e0 2f       	bisr 47
501005e2:	91 00 00 f7 	movh.a %a15,28672
501005e6:	d9 ff a0 84 	lea %a15,[%a15]18976 <70004a20 <Cdisptab+0x178>>
501005ea:	c4 fe       	ld.a %a14,[%a15+]
501005ec:	54 f4       	ld.w %d4,[%a15]
501005ee:	2d 0e 00 00 	calli %a14
501005f2:	0d 00 40 02 	rslcx 
501005f6:	00 80       	rfe 
	...

50100600 <__interrupt_48>:
50100600:	e0 30       	bisr 48
50100602:	91 00 00 f7 	movh.a %a15,28672
50100606:	d9 ff a8 84 	lea %a15,[%a15]18984 <70004a28 <Cdisptab+0x180>>
5010060a:	c4 fe       	ld.a %a14,[%a15+]
5010060c:	54 f4       	ld.w %d4,[%a15]
5010060e:	2d 0e 00 00 	calli %a14
50100612:	0d 00 40 02 	rslcx 
50100616:	00 80       	rfe 
	...

50100620 <__interrupt_49>:
50100620:	e0 31       	bisr 49
50100622:	91 00 00 f7 	movh.a %a15,28672
50100626:	d9 ff b0 84 	lea %a15,[%a15]18992 <70004a30 <Cdisptab+0x188>>
5010062a:	c4 fe       	ld.a %a14,[%a15+]
5010062c:	54 f4       	ld.w %d4,[%a15]
5010062e:	2d 0e 00 00 	calli %a14
50100632:	0d 00 40 02 	rslcx 
50100636:	00 80       	rfe 
	...

50100640 <__interrupt_50>:
50100640:	e0 32       	bisr 50
50100642:	91 00 00 f7 	movh.a %a15,28672
50100646:	d9 ff b8 84 	lea %a15,[%a15]19000 <70004a38 <Cdisptab+0x190>>
5010064a:	c4 fe       	ld.a %a14,[%a15+]
5010064c:	54 f4       	ld.w %d4,[%a15]
5010064e:	2d 0e 00 00 	calli %a14
50100652:	0d 00 40 02 	rslcx 
50100656:	00 80       	rfe 
	...

50100660 <__interrupt_51>:
50100660:	e0 33       	bisr 51
50100662:	91 00 00 f7 	movh.a %a15,28672
50100666:	d9 ff 80 94 	lea %a15,[%a15]19008 <70004a40 <Cdisptab+0x198>>
5010066a:	c4 fe       	ld.a %a14,[%a15+]
5010066c:	54 f4       	ld.w %d4,[%a15]
5010066e:	2d 0e 00 00 	calli %a14
50100672:	0d 00 40 02 	rslcx 
50100676:	00 80       	rfe 
	...

50100680 <__interrupt_52>:
50100680:	e0 34       	bisr 52
50100682:	91 00 00 f7 	movh.a %a15,28672
50100686:	d9 ff 88 94 	lea %a15,[%a15]19016 <70004a48 <Cdisptab+0x1a0>>
5010068a:	c4 fe       	ld.a %a14,[%a15+]
5010068c:	54 f4       	ld.w %d4,[%a15]
5010068e:	2d 0e 00 00 	calli %a14
50100692:	0d 00 40 02 	rslcx 
50100696:	00 80       	rfe 
	...

501006a0 <__interrupt_53>:
501006a0:	e0 35       	bisr 53
501006a2:	91 00 00 f7 	movh.a %a15,28672
501006a6:	d9 ff 90 94 	lea %a15,[%a15]19024 <70004a50 <Cdisptab+0x1a8>>
501006aa:	c4 fe       	ld.a %a14,[%a15+]
501006ac:	54 f4       	ld.w %d4,[%a15]
501006ae:	2d 0e 00 00 	calli %a14
501006b2:	0d 00 40 02 	rslcx 
501006b6:	00 80       	rfe 
	...

501006c0 <__interrupt_54>:
501006c0:	e0 36       	bisr 54
501006c2:	91 00 00 f7 	movh.a %a15,28672
501006c6:	d9 ff 98 94 	lea %a15,[%a15]19032 <70004a58 <Cdisptab+0x1b0>>
501006ca:	c4 fe       	ld.a %a14,[%a15+]
501006cc:	54 f4       	ld.w %d4,[%a15]
501006ce:	2d 0e 00 00 	calli %a14
501006d2:	0d 00 40 02 	rslcx 
501006d6:	00 80       	rfe 
	...

501006e0 <__interrupt_55>:
501006e0:	e0 37       	bisr 55
501006e2:	91 00 00 f7 	movh.a %a15,28672
501006e6:	d9 ff a0 94 	lea %a15,[%a15]19040 <70004a60 <Cdisptab+0x1b8>>
501006ea:	c4 fe       	ld.a %a14,[%a15+]
501006ec:	54 f4       	ld.w %d4,[%a15]
501006ee:	2d 0e 00 00 	calli %a14
501006f2:	0d 00 40 02 	rslcx 
501006f6:	00 80       	rfe 
	...

50100700 <__interrupt_56>:
50100700:	e0 38       	bisr 56
50100702:	91 00 00 f7 	movh.a %a15,28672
50100706:	d9 ff a8 94 	lea %a15,[%a15]19048 <70004a68 <Cdisptab+0x1c0>>
5010070a:	c4 fe       	ld.a %a14,[%a15+]
5010070c:	54 f4       	ld.w %d4,[%a15]
5010070e:	2d 0e 00 00 	calli %a14
50100712:	0d 00 40 02 	rslcx 
50100716:	00 80       	rfe 
	...

50100720 <__interrupt_57>:
50100720:	e0 39       	bisr 57
50100722:	91 00 00 f7 	movh.a %a15,28672
50100726:	d9 ff b0 94 	lea %a15,[%a15]19056 <70004a70 <Cdisptab+0x1c8>>
5010072a:	c4 fe       	ld.a %a14,[%a15+]
5010072c:	54 f4       	ld.w %d4,[%a15]
5010072e:	2d 0e 00 00 	calli %a14
50100732:	0d 00 40 02 	rslcx 
50100736:	00 80       	rfe 
	...

50100740 <__interrupt_58>:
50100740:	e0 3a       	bisr 58
50100742:	91 00 00 f7 	movh.a %a15,28672
50100746:	d9 ff b8 94 	lea %a15,[%a15]19064 <70004a78 <Cdisptab+0x1d0>>
5010074a:	c4 fe       	ld.a %a14,[%a15+]
5010074c:	54 f4       	ld.w %d4,[%a15]
5010074e:	2d 0e 00 00 	calli %a14
50100752:	0d 00 40 02 	rslcx 
50100756:	00 80       	rfe 
	...

50100760 <__interrupt_59>:
50100760:	e0 3b       	bisr 59
50100762:	91 00 00 f7 	movh.a %a15,28672
50100766:	d9 ff 80 a4 	lea %a15,[%a15]19072 <70004a80 <Cdisptab+0x1d8>>
5010076a:	c4 fe       	ld.a %a14,[%a15+]
5010076c:	54 f4       	ld.w %d4,[%a15]
5010076e:	2d 0e 00 00 	calli %a14
50100772:	0d 00 40 02 	rslcx 
50100776:	00 80       	rfe 
	...

50100780 <__interrupt_60>:
50100780:	e0 3c       	bisr 60
50100782:	91 00 00 f7 	movh.a %a15,28672
50100786:	d9 ff 88 a4 	lea %a15,[%a15]19080 <70004a88 <Cdisptab+0x1e0>>
5010078a:	c4 fe       	ld.a %a14,[%a15+]
5010078c:	54 f4       	ld.w %d4,[%a15]
5010078e:	2d 0e 00 00 	calli %a14
50100792:	0d 00 40 02 	rslcx 
50100796:	00 80       	rfe 
	...

501007a0 <__interrupt_61>:
501007a0:	e0 3d       	bisr 61
501007a2:	91 00 00 f7 	movh.a %a15,28672
501007a6:	d9 ff 90 a4 	lea %a15,[%a15]19088 <70004a90 <Cdisptab+0x1e8>>
501007aa:	c4 fe       	ld.a %a14,[%a15+]
501007ac:	54 f4       	ld.w %d4,[%a15]
501007ae:	2d 0e 00 00 	calli %a14
501007b2:	0d 00 40 02 	rslcx 
501007b6:	00 80       	rfe 
	...

501007c0 <__interrupt_62>:
501007c0:	e0 3e       	bisr 62
501007c2:	91 00 00 f7 	movh.a %a15,28672
501007c6:	d9 ff 98 a4 	lea %a15,[%a15]19096 <70004a98 <Cdisptab+0x1f0>>
501007ca:	c4 fe       	ld.a %a14,[%a15+]
501007cc:	54 f4       	ld.w %d4,[%a15]
501007ce:	2d 0e 00 00 	calli %a14
501007d2:	0d 00 40 02 	rslcx 
501007d6:	00 80       	rfe 
	...

501007e0 <__interrupt_63>:
501007e0:	e0 3f       	bisr 63
501007e2:	91 00 00 f7 	movh.a %a15,28672
501007e6:	d9 ff a0 a4 	lea %a15,[%a15]19104 <70004aa0 <Cdisptab+0x1f8>>
501007ea:	c4 fe       	ld.a %a14,[%a15+]
501007ec:	54 f4       	ld.w %d4,[%a15]
501007ee:	2d 0e 00 00 	calli %a14
501007f2:	0d 00 40 02 	rslcx 
501007f6:	00 80       	rfe 
	...

50100800 <__interrupt_64>:
50100800:	e0 40       	bisr 64
50100802:	91 00 00 f7 	movh.a %a15,28672
50100806:	d9 ff a8 a4 	lea %a15,[%a15]19112 <70004aa8 <Cdisptab+0x200>>
5010080a:	c4 fe       	ld.a %a14,[%a15+]
5010080c:	54 f4       	ld.w %d4,[%a15]
5010080e:	2d 0e 00 00 	calli %a14
50100812:	0d 00 40 02 	rslcx 
50100816:	00 80       	rfe 
	...

50100820 <__interrupt_65>:
50100820:	e0 41       	bisr 65
50100822:	91 00 00 f7 	movh.a %a15,28672
50100826:	d9 ff b0 a4 	lea %a15,[%a15]19120 <70004ab0 <Cdisptab+0x208>>
5010082a:	c4 fe       	ld.a %a14,[%a15+]
5010082c:	54 f4       	ld.w %d4,[%a15]
5010082e:	2d 0e 00 00 	calli %a14
50100832:	0d 00 40 02 	rslcx 
50100836:	00 80       	rfe 
	...

50100840 <__interrupt_66>:
50100840:	e0 42       	bisr 66
50100842:	91 00 00 f7 	movh.a %a15,28672
50100846:	d9 ff b8 a4 	lea %a15,[%a15]19128 <70004ab8 <Cdisptab+0x210>>
5010084a:	c4 fe       	ld.a %a14,[%a15+]
5010084c:	54 f4       	ld.w %d4,[%a15]
5010084e:	2d 0e 00 00 	calli %a14
50100852:	0d 00 40 02 	rslcx 
50100856:	00 80       	rfe 
	...

50100860 <__interrupt_67>:
50100860:	e0 43       	bisr 67
50100862:	91 00 00 f7 	movh.a %a15,28672
50100866:	d9 ff 80 b4 	lea %a15,[%a15]19136 <70004ac0 <Cdisptab+0x218>>
5010086a:	c4 fe       	ld.a %a14,[%a15+]
5010086c:	54 f4       	ld.w %d4,[%a15]
5010086e:	2d 0e 00 00 	calli %a14
50100872:	0d 00 40 02 	rslcx 
50100876:	00 80       	rfe 
	...

50100880 <__interrupt_68>:
50100880:	e0 44       	bisr 68
50100882:	91 00 00 f7 	movh.a %a15,28672
50100886:	d9 ff 88 b4 	lea %a15,[%a15]19144 <70004ac8 <Cdisptab+0x220>>
5010088a:	c4 fe       	ld.a %a14,[%a15+]
5010088c:	54 f4       	ld.w %d4,[%a15]
5010088e:	2d 0e 00 00 	calli %a14
50100892:	0d 00 40 02 	rslcx 
50100896:	00 80       	rfe 
	...

501008a0 <__interrupt_69>:
501008a0:	e0 45       	bisr 69
501008a2:	91 00 00 f7 	movh.a %a15,28672
501008a6:	d9 ff 90 b4 	lea %a15,[%a15]19152 <70004ad0 <Cdisptab+0x228>>
501008aa:	c4 fe       	ld.a %a14,[%a15+]
501008ac:	54 f4       	ld.w %d4,[%a15]
501008ae:	2d 0e 00 00 	calli %a14
501008b2:	0d 00 40 02 	rslcx 
501008b6:	00 80       	rfe 
	...

501008c0 <__interrupt_70>:
501008c0:	e0 46       	bisr 70
501008c2:	91 00 00 f7 	movh.a %a15,28672
501008c6:	d9 ff 98 b4 	lea %a15,[%a15]19160 <70004ad8 <Cdisptab+0x230>>
501008ca:	c4 fe       	ld.a %a14,[%a15+]
501008cc:	54 f4       	ld.w %d4,[%a15]
501008ce:	2d 0e 00 00 	calli %a14
501008d2:	0d 00 40 02 	rslcx 
501008d6:	00 80       	rfe 
	...

501008e0 <__interrupt_71>:
501008e0:	e0 47       	bisr 71
501008e2:	91 00 00 f7 	movh.a %a15,28672
501008e6:	d9 ff a0 b4 	lea %a15,[%a15]19168 <70004ae0 <Cdisptab+0x238>>
501008ea:	c4 fe       	ld.a %a14,[%a15+]
501008ec:	54 f4       	ld.w %d4,[%a15]
501008ee:	2d 0e 00 00 	calli %a14
501008f2:	0d 00 40 02 	rslcx 
501008f6:	00 80       	rfe 
	...

50100900 <__interrupt_72>:
50100900:	e0 48       	bisr 72
50100902:	91 00 00 f7 	movh.a %a15,28672
50100906:	d9 ff a8 b4 	lea %a15,[%a15]19176 <70004ae8 <Cdisptab+0x240>>
5010090a:	c4 fe       	ld.a %a14,[%a15+]
5010090c:	54 f4       	ld.w %d4,[%a15]
5010090e:	2d 0e 00 00 	calli %a14
50100912:	0d 00 40 02 	rslcx 
50100916:	00 80       	rfe 
	...

50100920 <__interrupt_73>:
50100920:	e0 49       	bisr 73
50100922:	91 00 00 f7 	movh.a %a15,28672
50100926:	d9 ff b0 b4 	lea %a15,[%a15]19184 <70004af0 <Cdisptab+0x248>>
5010092a:	c4 fe       	ld.a %a14,[%a15+]
5010092c:	54 f4       	ld.w %d4,[%a15]
5010092e:	2d 0e 00 00 	calli %a14
50100932:	0d 00 40 02 	rslcx 
50100936:	00 80       	rfe 
	...

50100940 <__interrupt_74>:
50100940:	e0 4a       	bisr 74
50100942:	91 00 00 f7 	movh.a %a15,28672
50100946:	d9 ff b8 b4 	lea %a15,[%a15]19192 <70004af8 <Cdisptab+0x250>>
5010094a:	c4 fe       	ld.a %a14,[%a15+]
5010094c:	54 f4       	ld.w %d4,[%a15]
5010094e:	2d 0e 00 00 	calli %a14
50100952:	0d 00 40 02 	rslcx 
50100956:	00 80       	rfe 
	...

50100960 <__interrupt_75>:
50100960:	e0 4b       	bisr 75
50100962:	91 00 00 f7 	movh.a %a15,28672
50100966:	d9 ff 80 c4 	lea %a15,[%a15]19200 <70004b00 <Cdisptab+0x258>>
5010096a:	c4 fe       	ld.a %a14,[%a15+]
5010096c:	54 f4       	ld.w %d4,[%a15]
5010096e:	2d 0e 00 00 	calli %a14
50100972:	0d 00 40 02 	rslcx 
50100976:	00 80       	rfe 
	...

50100980 <__interrupt_76>:
50100980:	e0 4c       	bisr 76
50100982:	91 00 00 f7 	movh.a %a15,28672
50100986:	d9 ff 88 c4 	lea %a15,[%a15]19208 <70004b08 <Cdisptab+0x260>>
5010098a:	c4 fe       	ld.a %a14,[%a15+]
5010098c:	54 f4       	ld.w %d4,[%a15]
5010098e:	2d 0e 00 00 	calli %a14
50100992:	0d 00 40 02 	rslcx 
50100996:	00 80       	rfe 
	...

501009a0 <__interrupt_77>:
501009a0:	e0 4d       	bisr 77
501009a2:	91 00 00 f7 	movh.a %a15,28672
501009a6:	d9 ff 90 c4 	lea %a15,[%a15]19216 <70004b10 <Cdisptab+0x268>>
501009aa:	c4 fe       	ld.a %a14,[%a15+]
501009ac:	54 f4       	ld.w %d4,[%a15]
501009ae:	2d 0e 00 00 	calli %a14
501009b2:	0d 00 40 02 	rslcx 
501009b6:	00 80       	rfe 
	...

501009c0 <__interrupt_78>:
501009c0:	e0 4e       	bisr 78
501009c2:	91 00 00 f7 	movh.a %a15,28672
501009c6:	d9 ff 98 c4 	lea %a15,[%a15]19224 <70004b18 <Cdisptab+0x270>>
501009ca:	c4 fe       	ld.a %a14,[%a15+]
501009cc:	54 f4       	ld.w %d4,[%a15]
501009ce:	2d 0e 00 00 	calli %a14
501009d2:	0d 00 40 02 	rslcx 
501009d6:	00 80       	rfe 
	...

501009e0 <__interrupt_79>:
501009e0:	e0 4f       	bisr 79
501009e2:	91 00 00 f7 	movh.a %a15,28672
501009e6:	d9 ff a0 c4 	lea %a15,[%a15]19232 <70004b20 <Cdisptab+0x278>>
501009ea:	c4 fe       	ld.a %a14,[%a15+]
501009ec:	54 f4       	ld.w %d4,[%a15]
501009ee:	2d 0e 00 00 	calli %a14
501009f2:	0d 00 40 02 	rslcx 
501009f6:	00 80       	rfe 
	...

50100a00 <__interrupt_80>:
50100a00:	e0 50       	bisr 80
50100a02:	91 00 00 f7 	movh.a %a15,28672
50100a06:	d9 ff a8 c4 	lea %a15,[%a15]19240 <70004b28 <Cdisptab+0x280>>
50100a0a:	c4 fe       	ld.a %a14,[%a15+]
50100a0c:	54 f4       	ld.w %d4,[%a15]
50100a0e:	2d 0e 00 00 	calli %a14
50100a12:	0d 00 40 02 	rslcx 
50100a16:	00 80       	rfe 
	...

50100a20 <__interrupt_81>:
50100a20:	e0 51       	bisr 81
50100a22:	91 00 00 f7 	movh.a %a15,28672
50100a26:	d9 ff b0 c4 	lea %a15,[%a15]19248 <70004b30 <Cdisptab+0x288>>
50100a2a:	c4 fe       	ld.a %a14,[%a15+]
50100a2c:	54 f4       	ld.w %d4,[%a15]
50100a2e:	2d 0e 00 00 	calli %a14
50100a32:	0d 00 40 02 	rslcx 
50100a36:	00 80       	rfe 
	...

50100a40 <__interrupt_82>:
50100a40:	e0 52       	bisr 82
50100a42:	91 00 00 f7 	movh.a %a15,28672
50100a46:	d9 ff b8 c4 	lea %a15,[%a15]19256 <70004b38 <Cdisptab+0x290>>
50100a4a:	c4 fe       	ld.a %a14,[%a15+]
50100a4c:	54 f4       	ld.w %d4,[%a15]
50100a4e:	2d 0e 00 00 	calli %a14
50100a52:	0d 00 40 02 	rslcx 
50100a56:	00 80       	rfe 
	...

50100a60 <__interrupt_83>:
50100a60:	e0 53       	bisr 83
50100a62:	91 00 00 f7 	movh.a %a15,28672
50100a66:	d9 ff 80 d4 	lea %a15,[%a15]19264 <70004b40 <Cdisptab+0x298>>
50100a6a:	c4 fe       	ld.a %a14,[%a15+]
50100a6c:	54 f4       	ld.w %d4,[%a15]
50100a6e:	2d 0e 00 00 	calli %a14
50100a72:	0d 00 40 02 	rslcx 
50100a76:	00 80       	rfe 
	...

50100a80 <__interrupt_84>:
50100a80:	e0 54       	bisr 84
50100a82:	91 00 00 f7 	movh.a %a15,28672
50100a86:	d9 ff 88 d4 	lea %a15,[%a15]19272 <70004b48 <Cdisptab+0x2a0>>
50100a8a:	c4 fe       	ld.a %a14,[%a15+]
50100a8c:	54 f4       	ld.w %d4,[%a15]
50100a8e:	2d 0e 00 00 	calli %a14
50100a92:	0d 00 40 02 	rslcx 
50100a96:	00 80       	rfe 
	...

50100aa0 <__interrupt_85>:
50100aa0:	e0 55       	bisr 85
50100aa2:	91 00 00 f7 	movh.a %a15,28672
50100aa6:	d9 ff 90 d4 	lea %a15,[%a15]19280 <70004b50 <Cdisptab+0x2a8>>
50100aaa:	c4 fe       	ld.a %a14,[%a15+]
50100aac:	54 f4       	ld.w %d4,[%a15]
50100aae:	2d 0e 00 00 	calli %a14
50100ab2:	0d 00 40 02 	rslcx 
50100ab6:	00 80       	rfe 
	...

50100ac0 <__interrupt_86>:
50100ac0:	e0 56       	bisr 86
50100ac2:	91 00 00 f7 	movh.a %a15,28672
50100ac6:	d9 ff 98 d4 	lea %a15,[%a15]19288 <70004b58 <Cdisptab+0x2b0>>
50100aca:	c4 fe       	ld.a %a14,[%a15+]
50100acc:	54 f4       	ld.w %d4,[%a15]
50100ace:	2d 0e 00 00 	calli %a14
50100ad2:	0d 00 40 02 	rslcx 
50100ad6:	00 80       	rfe 
	...

50100ae0 <__interrupt_87>:
50100ae0:	e0 57       	bisr 87
50100ae2:	91 00 00 f7 	movh.a %a15,28672
50100ae6:	d9 ff a0 d4 	lea %a15,[%a15]19296 <70004b60 <Cdisptab+0x2b8>>
50100aea:	c4 fe       	ld.a %a14,[%a15+]
50100aec:	54 f4       	ld.w %d4,[%a15]
50100aee:	2d 0e 00 00 	calli %a14
50100af2:	0d 00 40 02 	rslcx 
50100af6:	00 80       	rfe 
	...

50100b00 <__interrupt_88>:
50100b00:	e0 58       	bisr 88
50100b02:	91 00 00 f7 	movh.a %a15,28672
50100b06:	d9 ff a8 d4 	lea %a15,[%a15]19304 <70004b68 <Cdisptab+0x2c0>>
50100b0a:	c4 fe       	ld.a %a14,[%a15+]
50100b0c:	54 f4       	ld.w %d4,[%a15]
50100b0e:	2d 0e 00 00 	calli %a14
50100b12:	0d 00 40 02 	rslcx 
50100b16:	00 80       	rfe 
	...

50100b20 <__interrupt_89>:
50100b20:	e0 59       	bisr 89
50100b22:	91 00 00 f7 	movh.a %a15,28672
50100b26:	d9 ff b0 d4 	lea %a15,[%a15]19312 <70004b70 <Cdisptab+0x2c8>>
50100b2a:	c4 fe       	ld.a %a14,[%a15+]
50100b2c:	54 f4       	ld.w %d4,[%a15]
50100b2e:	2d 0e 00 00 	calli %a14
50100b32:	0d 00 40 02 	rslcx 
50100b36:	00 80       	rfe 
	...

50100b40 <__interrupt_90>:
50100b40:	e0 5a       	bisr 90
50100b42:	91 00 00 f7 	movh.a %a15,28672
50100b46:	d9 ff b8 d4 	lea %a15,[%a15]19320 <70004b78 <Cdisptab+0x2d0>>
50100b4a:	c4 fe       	ld.a %a14,[%a15+]
50100b4c:	54 f4       	ld.w %d4,[%a15]
50100b4e:	2d 0e 00 00 	calli %a14
50100b52:	0d 00 40 02 	rslcx 
50100b56:	00 80       	rfe 
	...

50100b60 <__interrupt_91>:
50100b60:	e0 5b       	bisr 91
50100b62:	91 00 00 f7 	movh.a %a15,28672
50100b66:	d9 ff 80 e4 	lea %a15,[%a15]19328 <70004b80 <Cdisptab+0x2d8>>
50100b6a:	c4 fe       	ld.a %a14,[%a15+]
50100b6c:	54 f4       	ld.w %d4,[%a15]
50100b6e:	2d 0e 00 00 	calli %a14
50100b72:	0d 00 40 02 	rslcx 
50100b76:	00 80       	rfe 
	...

50100b80 <__interrupt_92>:
50100b80:	e0 5c       	bisr 92
50100b82:	91 00 00 f7 	movh.a %a15,28672
50100b86:	d9 ff 88 e4 	lea %a15,[%a15]19336 <70004b88 <Cdisptab+0x2e0>>
50100b8a:	c4 fe       	ld.a %a14,[%a15+]
50100b8c:	54 f4       	ld.w %d4,[%a15]
50100b8e:	2d 0e 00 00 	calli %a14
50100b92:	0d 00 40 02 	rslcx 
50100b96:	00 80       	rfe 
	...

50100ba0 <__interrupt_93>:
50100ba0:	e0 5d       	bisr 93
50100ba2:	91 00 00 f7 	movh.a %a15,28672
50100ba6:	d9 ff 90 e4 	lea %a15,[%a15]19344 <70004b90 <Cdisptab+0x2e8>>
50100baa:	c4 fe       	ld.a %a14,[%a15+]
50100bac:	54 f4       	ld.w %d4,[%a15]
50100bae:	2d 0e 00 00 	calli %a14
50100bb2:	0d 00 40 02 	rslcx 
50100bb6:	00 80       	rfe 
	...

50100bc0 <__interrupt_94>:
50100bc0:	e0 5e       	bisr 94
50100bc2:	91 00 00 f7 	movh.a %a15,28672
50100bc6:	d9 ff 98 e4 	lea %a15,[%a15]19352 <70004b98 <Cdisptab+0x2f0>>
50100bca:	c4 fe       	ld.a %a14,[%a15+]
50100bcc:	54 f4       	ld.w %d4,[%a15]
50100bce:	2d 0e 00 00 	calli %a14
50100bd2:	0d 00 40 02 	rslcx 
50100bd6:	00 80       	rfe 
	...

50100be0 <__interrupt_95>:
50100be0:	e0 5f       	bisr 95
50100be2:	91 00 00 f7 	movh.a %a15,28672
50100be6:	d9 ff a0 e4 	lea %a15,[%a15]19360 <70004ba0 <Cdisptab+0x2f8>>
50100bea:	c4 fe       	ld.a %a14,[%a15+]
50100bec:	54 f4       	ld.w %d4,[%a15]
50100bee:	2d 0e 00 00 	calli %a14
50100bf2:	0d 00 40 02 	rslcx 
50100bf6:	00 80       	rfe 
	...

50100c00 <__interrupt_96>:
50100c00:	e0 60       	bisr 96
50100c02:	91 00 00 f7 	movh.a %a15,28672
50100c06:	d9 ff a8 e4 	lea %a15,[%a15]19368 <70004ba8 <Cdisptab+0x300>>
50100c0a:	c4 fe       	ld.a %a14,[%a15+]
50100c0c:	54 f4       	ld.w %d4,[%a15]
50100c0e:	2d 0e 00 00 	calli %a14
50100c12:	0d 00 40 02 	rslcx 
50100c16:	00 80       	rfe 
	...

50100c20 <__interrupt_97>:
50100c20:	e0 61       	bisr 97
50100c22:	91 00 00 f7 	movh.a %a15,28672
50100c26:	d9 ff b0 e4 	lea %a15,[%a15]19376 <70004bb0 <Cdisptab+0x308>>
50100c2a:	c4 fe       	ld.a %a14,[%a15+]
50100c2c:	54 f4       	ld.w %d4,[%a15]
50100c2e:	2d 0e 00 00 	calli %a14
50100c32:	0d 00 40 02 	rslcx 
50100c36:	00 80       	rfe 
	...

50100c40 <__interrupt_98>:
50100c40:	e0 62       	bisr 98
50100c42:	91 00 00 f7 	movh.a %a15,28672
50100c46:	d9 ff b8 e4 	lea %a15,[%a15]19384 <70004bb8 <Cdisptab+0x310>>
50100c4a:	c4 fe       	ld.a %a14,[%a15+]
50100c4c:	54 f4       	ld.w %d4,[%a15]
50100c4e:	2d 0e 00 00 	calli %a14
50100c52:	0d 00 40 02 	rslcx 
50100c56:	00 80       	rfe 
	...

50100c60 <__interrupt_99>:
50100c60:	e0 63       	bisr 99
50100c62:	91 00 00 f7 	movh.a %a15,28672
50100c66:	d9 ff 80 f4 	lea %a15,[%a15]19392 <70004bc0 <Cdisptab+0x318>>
50100c6a:	c4 fe       	ld.a %a14,[%a15+]
50100c6c:	54 f4       	ld.w %d4,[%a15]
50100c6e:	2d 0e 00 00 	calli %a14
50100c72:	0d 00 40 02 	rslcx 
50100c76:	00 80       	rfe 
	...

50100c80 <__interrupt_100>:
50100c80:	e0 64       	bisr 100
50100c82:	91 00 00 f7 	movh.a %a15,28672
50100c86:	d9 ff 88 f4 	lea %a15,[%a15]19400 <70004bc8 <Cdisptab+0x320>>
50100c8a:	c4 fe       	ld.a %a14,[%a15+]
50100c8c:	54 f4       	ld.w %d4,[%a15]
50100c8e:	2d 0e 00 00 	calli %a14
50100c92:	0d 00 40 02 	rslcx 
50100c96:	00 80       	rfe 
	...

50100ca0 <__interrupt_101>:
50100ca0:	e0 65       	bisr 101
50100ca2:	91 00 00 f7 	movh.a %a15,28672
50100ca6:	d9 ff 90 f4 	lea %a15,[%a15]19408 <70004bd0 <Cdisptab+0x328>>
50100caa:	c4 fe       	ld.a %a14,[%a15+]
50100cac:	54 f4       	ld.w %d4,[%a15]
50100cae:	2d 0e 00 00 	calli %a14
50100cb2:	0d 00 40 02 	rslcx 
50100cb6:	00 80       	rfe 
	...

50100cc0 <__interrupt_102>:
50100cc0:	e0 66       	bisr 102
50100cc2:	91 00 00 f7 	movh.a %a15,28672
50100cc6:	d9 ff 98 f4 	lea %a15,[%a15]19416 <70004bd8 <Cdisptab+0x330>>
50100cca:	c4 fe       	ld.a %a14,[%a15+]
50100ccc:	54 f4       	ld.w %d4,[%a15]
50100cce:	2d 0e 00 00 	calli %a14
50100cd2:	0d 00 40 02 	rslcx 
50100cd6:	00 80       	rfe 
	...

50100ce0 <__interrupt_103>:
50100ce0:	e0 67       	bisr 103
50100ce2:	91 00 00 f7 	movh.a %a15,28672
50100ce6:	d9 ff a0 f4 	lea %a15,[%a15]19424 <70004be0 <Cdisptab+0x338>>
50100cea:	c4 fe       	ld.a %a14,[%a15+]
50100cec:	54 f4       	ld.w %d4,[%a15]
50100cee:	2d 0e 00 00 	calli %a14
50100cf2:	0d 00 40 02 	rslcx 
50100cf6:	00 80       	rfe 
	...

50100d00 <__interrupt_104>:
50100d00:	e0 68       	bisr 104
50100d02:	91 00 00 f7 	movh.a %a15,28672
50100d06:	d9 ff a8 f4 	lea %a15,[%a15]19432 <70004be8 <Cdisptab+0x340>>
50100d0a:	c4 fe       	ld.a %a14,[%a15+]
50100d0c:	54 f4       	ld.w %d4,[%a15]
50100d0e:	2d 0e 00 00 	calli %a14
50100d12:	0d 00 40 02 	rslcx 
50100d16:	00 80       	rfe 
	...

50100d20 <__interrupt_105>:
50100d20:	e0 69       	bisr 105
50100d22:	91 00 00 f7 	movh.a %a15,28672
50100d26:	d9 ff b0 f4 	lea %a15,[%a15]19440 <70004bf0 <Cdisptab+0x348>>
50100d2a:	c4 fe       	ld.a %a14,[%a15+]
50100d2c:	54 f4       	ld.w %d4,[%a15]
50100d2e:	2d 0e 00 00 	calli %a14
50100d32:	0d 00 40 02 	rslcx 
50100d36:	00 80       	rfe 
	...

50100d40 <__interrupt_106>:
50100d40:	e0 6a       	bisr 106
50100d42:	91 00 00 f7 	movh.a %a15,28672
50100d46:	d9 ff b8 f4 	lea %a15,[%a15]19448 <70004bf8 <Cdisptab+0x350>>
50100d4a:	c4 fe       	ld.a %a14,[%a15+]
50100d4c:	54 f4       	ld.w %d4,[%a15]
50100d4e:	2d 0e 00 00 	calli %a14
50100d52:	0d 00 40 02 	rslcx 
50100d56:	00 80       	rfe 
	...

50100d60 <__interrupt_107>:
50100d60:	e0 6b       	bisr 107
50100d62:	91 00 00 f7 	movh.a %a15,28672
50100d66:	d9 ff c0 04 	lea %a15,[%a15]19456 <70004c00 <Cdisptab+0x358>>
50100d6a:	c4 fe       	ld.a %a14,[%a15+]
50100d6c:	54 f4       	ld.w %d4,[%a15]
50100d6e:	2d 0e 00 00 	calli %a14
50100d72:	0d 00 40 02 	rslcx 
50100d76:	00 80       	rfe 
	...

50100d80 <__interrupt_108>:
50100d80:	e0 6c       	bisr 108
50100d82:	91 00 00 f7 	movh.a %a15,28672
50100d86:	d9 ff c8 04 	lea %a15,[%a15]19464 <70004c08 <Cdisptab+0x360>>
50100d8a:	c4 fe       	ld.a %a14,[%a15+]
50100d8c:	54 f4       	ld.w %d4,[%a15]
50100d8e:	2d 0e 00 00 	calli %a14
50100d92:	0d 00 40 02 	rslcx 
50100d96:	00 80       	rfe 
	...

50100da0 <__interrupt_109>:
50100da0:	e0 6d       	bisr 109
50100da2:	91 00 00 f7 	movh.a %a15,28672
50100da6:	d9 ff d0 04 	lea %a15,[%a15]19472 <70004c10 <Cdisptab+0x368>>
50100daa:	c4 fe       	ld.a %a14,[%a15+]
50100dac:	54 f4       	ld.w %d4,[%a15]
50100dae:	2d 0e 00 00 	calli %a14
50100db2:	0d 00 40 02 	rslcx 
50100db6:	00 80       	rfe 
	...

50100dc0 <__interrupt_110>:
50100dc0:	e0 6e       	bisr 110
50100dc2:	91 00 00 f7 	movh.a %a15,28672
50100dc6:	d9 ff d8 04 	lea %a15,[%a15]19480 <70004c18 <Cdisptab+0x370>>
50100dca:	c4 fe       	ld.a %a14,[%a15+]
50100dcc:	54 f4       	ld.w %d4,[%a15]
50100dce:	2d 0e 00 00 	calli %a14
50100dd2:	0d 00 40 02 	rslcx 
50100dd6:	00 80       	rfe 
	...

50100de0 <__interrupt_111>:
50100de0:	e0 6f       	bisr 111
50100de2:	91 00 00 f7 	movh.a %a15,28672
50100de6:	d9 ff e0 04 	lea %a15,[%a15]19488 <70004c20 <Cdisptab+0x378>>
50100dea:	c4 fe       	ld.a %a14,[%a15+]
50100dec:	54 f4       	ld.w %d4,[%a15]
50100dee:	2d 0e 00 00 	calli %a14
50100df2:	0d 00 40 02 	rslcx 
50100df6:	00 80       	rfe 
	...

50100e00 <__interrupt_112>:
50100e00:	e0 70       	bisr 112
50100e02:	91 00 00 f7 	movh.a %a15,28672
50100e06:	d9 ff e8 04 	lea %a15,[%a15]19496 <70004c28 <Cdisptab+0x380>>
50100e0a:	c4 fe       	ld.a %a14,[%a15+]
50100e0c:	54 f4       	ld.w %d4,[%a15]
50100e0e:	2d 0e 00 00 	calli %a14
50100e12:	0d 00 40 02 	rslcx 
50100e16:	00 80       	rfe 
	...

50100e20 <__interrupt_113>:
50100e20:	e0 71       	bisr 113
50100e22:	91 00 00 f7 	movh.a %a15,28672
50100e26:	d9 ff f0 04 	lea %a15,[%a15]19504 <70004c30 <Cdisptab+0x388>>
50100e2a:	c4 fe       	ld.a %a14,[%a15+]
50100e2c:	54 f4       	ld.w %d4,[%a15]
50100e2e:	2d 0e 00 00 	calli %a14
50100e32:	0d 00 40 02 	rslcx 
50100e36:	00 80       	rfe 
	...

50100e40 <__interrupt_114>:
50100e40:	e0 72       	bisr 114
50100e42:	91 00 00 f7 	movh.a %a15,28672
50100e46:	d9 ff f8 04 	lea %a15,[%a15]19512 <70004c38 <Cdisptab+0x390>>
50100e4a:	c4 fe       	ld.a %a14,[%a15+]
50100e4c:	54 f4       	ld.w %d4,[%a15]
50100e4e:	2d 0e 00 00 	calli %a14
50100e52:	0d 00 40 02 	rslcx 
50100e56:	00 80       	rfe 
	...

50100e60 <__interrupt_115>:
50100e60:	e0 73       	bisr 115
50100e62:	91 00 00 f7 	movh.a %a15,28672
50100e66:	d9 ff c0 14 	lea %a15,[%a15]19520 <70004c40 <Cdisptab+0x398>>
50100e6a:	c4 fe       	ld.a %a14,[%a15+]
50100e6c:	54 f4       	ld.w %d4,[%a15]
50100e6e:	2d 0e 00 00 	calli %a14
50100e72:	0d 00 40 02 	rslcx 
50100e76:	00 80       	rfe 
	...

50100e80 <__interrupt_116>:
50100e80:	e0 74       	bisr 116
50100e82:	91 00 00 f7 	movh.a %a15,28672
50100e86:	d9 ff c8 14 	lea %a15,[%a15]19528 <70004c48 <Cdisptab+0x3a0>>
50100e8a:	c4 fe       	ld.a %a14,[%a15+]
50100e8c:	54 f4       	ld.w %d4,[%a15]
50100e8e:	2d 0e 00 00 	calli %a14
50100e92:	0d 00 40 02 	rslcx 
50100e96:	00 80       	rfe 
	...

50100ea0 <__interrupt_117>:
50100ea0:	e0 75       	bisr 117
50100ea2:	91 00 00 f7 	movh.a %a15,28672
50100ea6:	d9 ff d0 14 	lea %a15,[%a15]19536 <70004c50 <Cdisptab+0x3a8>>
50100eaa:	c4 fe       	ld.a %a14,[%a15+]
50100eac:	54 f4       	ld.w %d4,[%a15]
50100eae:	2d 0e 00 00 	calli %a14
50100eb2:	0d 00 40 02 	rslcx 
50100eb6:	00 80       	rfe 
	...

50100ec0 <__interrupt_118>:
50100ec0:	e0 76       	bisr 118
50100ec2:	91 00 00 f7 	movh.a %a15,28672
50100ec6:	d9 ff d8 14 	lea %a15,[%a15]19544 <70004c58 <Cdisptab+0x3b0>>
50100eca:	c4 fe       	ld.a %a14,[%a15+]
50100ecc:	54 f4       	ld.w %d4,[%a15]
50100ece:	2d 0e 00 00 	calli %a14
50100ed2:	0d 00 40 02 	rslcx 
50100ed6:	00 80       	rfe 
	...

50100ee0 <__interrupt_119>:
50100ee0:	e0 77       	bisr 119
50100ee2:	91 00 00 f7 	movh.a %a15,28672
50100ee6:	d9 ff e0 14 	lea %a15,[%a15]19552 <70004c60 <Cdisptab+0x3b8>>
50100eea:	c4 fe       	ld.a %a14,[%a15+]
50100eec:	54 f4       	ld.w %d4,[%a15]
50100eee:	2d 0e 00 00 	calli %a14
50100ef2:	0d 00 40 02 	rslcx 
50100ef6:	00 80       	rfe 
	...

50100f00 <__interrupt_120>:
50100f00:	e0 78       	bisr 120
50100f02:	91 00 00 f7 	movh.a %a15,28672
50100f06:	d9 ff e8 14 	lea %a15,[%a15]19560 <70004c68 <Cdisptab+0x3c0>>
50100f0a:	c4 fe       	ld.a %a14,[%a15+]
50100f0c:	54 f4       	ld.w %d4,[%a15]
50100f0e:	2d 0e 00 00 	calli %a14
50100f12:	0d 00 40 02 	rslcx 
50100f16:	00 80       	rfe 
	...

50100f20 <__interrupt_121>:
50100f20:	e0 79       	bisr 121
50100f22:	91 00 00 f7 	movh.a %a15,28672
50100f26:	d9 ff f0 14 	lea %a15,[%a15]19568 <70004c70 <Cdisptab+0x3c8>>
50100f2a:	c4 fe       	ld.a %a14,[%a15+]
50100f2c:	54 f4       	ld.w %d4,[%a15]
50100f2e:	2d 0e 00 00 	calli %a14
50100f32:	0d 00 40 02 	rslcx 
50100f36:	00 80       	rfe 
	...

50100f40 <__interrupt_122>:
50100f40:	e0 7a       	bisr 122
50100f42:	91 00 00 f7 	movh.a %a15,28672
50100f46:	d9 ff f8 14 	lea %a15,[%a15]19576 <70004c78 <Cdisptab+0x3d0>>
50100f4a:	c4 fe       	ld.a %a14,[%a15+]
50100f4c:	54 f4       	ld.w %d4,[%a15]
50100f4e:	2d 0e 00 00 	calli %a14
50100f52:	0d 00 40 02 	rslcx 
50100f56:	00 80       	rfe 
	...

50100f60 <__interrupt_123>:
50100f60:	e0 7b       	bisr 123
50100f62:	91 00 00 f7 	movh.a %a15,28672
50100f66:	d9 ff c0 24 	lea %a15,[%a15]19584 <70004c80 <Cdisptab+0x3d8>>
50100f6a:	c4 fe       	ld.a %a14,[%a15+]
50100f6c:	54 f4       	ld.w %d4,[%a15]
50100f6e:	2d 0e 00 00 	calli %a14
50100f72:	0d 00 40 02 	rslcx 
50100f76:	00 80       	rfe 
	...

50100f80 <__interrupt_124>:
50100f80:	e0 7c       	bisr 124
50100f82:	91 00 00 f7 	movh.a %a15,28672
50100f86:	d9 ff c8 24 	lea %a15,[%a15]19592 <70004c88 <Cdisptab+0x3e0>>
50100f8a:	c4 fe       	ld.a %a14,[%a15+]
50100f8c:	54 f4       	ld.w %d4,[%a15]
50100f8e:	2d 0e 00 00 	calli %a14
50100f92:	0d 00 40 02 	rslcx 
50100f96:	00 80       	rfe 
	...

50100fa0 <__interrupt_125>:
50100fa0:	e0 7d       	bisr 125
50100fa2:	91 00 00 f7 	movh.a %a15,28672
50100fa6:	d9 ff d0 24 	lea %a15,[%a15]19600 <70004c90 <Cdisptab+0x3e8>>
50100faa:	c4 fe       	ld.a %a14,[%a15+]
50100fac:	54 f4       	ld.w %d4,[%a15]
50100fae:	2d 0e 00 00 	calli %a14
50100fb2:	0d 00 40 02 	rslcx 
50100fb6:	00 80       	rfe 
	...

50100fc0 <__interrupt_126>:
50100fc0:	e0 7e       	bisr 126
50100fc2:	91 00 00 f7 	movh.a %a15,28672
50100fc6:	d9 ff d8 24 	lea %a15,[%a15]19608 <70004c98 <Cdisptab+0x3f0>>
50100fca:	c4 fe       	ld.a %a14,[%a15+]
50100fcc:	54 f4       	ld.w %d4,[%a15]
50100fce:	2d 0e 00 00 	calli %a14
50100fd2:	0d 00 40 02 	rslcx 
50100fd6:	00 80       	rfe 
	...

50100fe0 <__interrupt_127>:
50100fe0:	e0 7f       	bisr 127
50100fe2:	91 00 00 f7 	movh.a %a15,28672
50100fe6:	d9 ff e0 24 	lea %a15,[%a15]19616 <70004ca0 <Cdisptab+0x3f8>>
50100fea:	c4 fe       	ld.a %a14,[%a15+]
50100fec:	54 f4       	ld.w %d4,[%a15]
50100fee:	2d 0e 00 00 	calli %a14
50100ff2:	0d 00 40 02 	rslcx 
50100ff6:	00 80       	rfe 
	...

50101000 <__interrupt_128>:
50101000:	e0 80       	bisr 128
50101002:	91 00 00 f7 	movh.a %a15,28672
50101006:	d9 ff e8 24 	lea %a15,[%a15]19624 <70004ca8 <Cdisptab+0x400>>
5010100a:	c4 fe       	ld.a %a14,[%a15+]
5010100c:	54 f4       	ld.w %d4,[%a15]
5010100e:	2d 0e 00 00 	calli %a14
50101012:	0d 00 40 02 	rslcx 
50101016:	00 80       	rfe 
	...

50101020 <__interrupt_129>:
50101020:	e0 81       	bisr 129
50101022:	91 00 00 f7 	movh.a %a15,28672
50101026:	d9 ff f0 24 	lea %a15,[%a15]19632 <70004cb0 <Cdisptab+0x408>>
5010102a:	c4 fe       	ld.a %a14,[%a15+]
5010102c:	54 f4       	ld.w %d4,[%a15]
5010102e:	2d 0e 00 00 	calli %a14
50101032:	0d 00 40 02 	rslcx 
50101036:	00 80       	rfe 
	...

50101040 <__interrupt_130>:
50101040:	e0 82       	bisr 130
50101042:	91 00 00 f7 	movh.a %a15,28672
50101046:	d9 ff f8 24 	lea %a15,[%a15]19640 <70004cb8 <Cdisptab+0x410>>
5010104a:	c4 fe       	ld.a %a14,[%a15+]
5010104c:	54 f4       	ld.w %d4,[%a15]
5010104e:	2d 0e 00 00 	calli %a14
50101052:	0d 00 40 02 	rslcx 
50101056:	00 80       	rfe 
	...

50101060 <__interrupt_131>:
50101060:	e0 83       	bisr 131
50101062:	91 00 00 f7 	movh.a %a15,28672
50101066:	d9 ff c0 34 	lea %a15,[%a15]19648 <70004cc0 <Cdisptab+0x418>>
5010106a:	c4 fe       	ld.a %a14,[%a15+]
5010106c:	54 f4       	ld.w %d4,[%a15]
5010106e:	2d 0e 00 00 	calli %a14
50101072:	0d 00 40 02 	rslcx 
50101076:	00 80       	rfe 
	...

50101080 <__interrupt_132>:
50101080:	e0 84       	bisr 132
50101082:	91 00 00 f7 	movh.a %a15,28672
50101086:	d9 ff c8 34 	lea %a15,[%a15]19656 <70004cc8 <Cdisptab+0x420>>
5010108a:	c4 fe       	ld.a %a14,[%a15+]
5010108c:	54 f4       	ld.w %d4,[%a15]
5010108e:	2d 0e 00 00 	calli %a14
50101092:	0d 00 40 02 	rslcx 
50101096:	00 80       	rfe 
	...

501010a0 <__interrupt_133>:
501010a0:	e0 85       	bisr 133
501010a2:	91 00 00 f7 	movh.a %a15,28672
501010a6:	d9 ff d0 34 	lea %a15,[%a15]19664 <70004cd0 <Cdisptab+0x428>>
501010aa:	c4 fe       	ld.a %a14,[%a15+]
501010ac:	54 f4       	ld.w %d4,[%a15]
501010ae:	2d 0e 00 00 	calli %a14
501010b2:	0d 00 40 02 	rslcx 
501010b6:	00 80       	rfe 
	...

501010c0 <__interrupt_134>:
501010c0:	e0 86       	bisr 134
501010c2:	91 00 00 f7 	movh.a %a15,28672
501010c6:	d9 ff d8 34 	lea %a15,[%a15]19672 <70004cd8 <Cdisptab+0x430>>
501010ca:	c4 fe       	ld.a %a14,[%a15+]
501010cc:	54 f4       	ld.w %d4,[%a15]
501010ce:	2d 0e 00 00 	calli %a14
501010d2:	0d 00 40 02 	rslcx 
501010d6:	00 80       	rfe 
	...

501010e0 <__interrupt_135>:
501010e0:	e0 87       	bisr 135
501010e2:	91 00 00 f7 	movh.a %a15,28672
501010e6:	d9 ff e0 34 	lea %a15,[%a15]19680 <70004ce0 <Cdisptab+0x438>>
501010ea:	c4 fe       	ld.a %a14,[%a15+]
501010ec:	54 f4       	ld.w %d4,[%a15]
501010ee:	2d 0e 00 00 	calli %a14
501010f2:	0d 00 40 02 	rslcx 
501010f6:	00 80       	rfe 
	...

50101100 <__interrupt_136>:
50101100:	e0 88       	bisr 136
50101102:	91 00 00 f7 	movh.a %a15,28672
50101106:	d9 ff e8 34 	lea %a15,[%a15]19688 <70004ce8 <Cdisptab+0x440>>
5010110a:	c4 fe       	ld.a %a14,[%a15+]
5010110c:	54 f4       	ld.w %d4,[%a15]
5010110e:	2d 0e 00 00 	calli %a14
50101112:	0d 00 40 02 	rslcx 
50101116:	00 80       	rfe 
	...

50101120 <__interrupt_137>:
50101120:	e0 89       	bisr 137
50101122:	91 00 00 f7 	movh.a %a15,28672
50101126:	d9 ff f0 34 	lea %a15,[%a15]19696 <70004cf0 <Cdisptab+0x448>>
5010112a:	c4 fe       	ld.a %a14,[%a15+]
5010112c:	54 f4       	ld.w %d4,[%a15]
5010112e:	2d 0e 00 00 	calli %a14
50101132:	0d 00 40 02 	rslcx 
50101136:	00 80       	rfe 
	...

50101140 <__interrupt_138>:
50101140:	e0 8a       	bisr 138
50101142:	91 00 00 f7 	movh.a %a15,28672
50101146:	d9 ff f8 34 	lea %a15,[%a15]19704 <70004cf8 <Cdisptab+0x450>>
5010114a:	c4 fe       	ld.a %a14,[%a15+]
5010114c:	54 f4       	ld.w %d4,[%a15]
5010114e:	2d 0e 00 00 	calli %a14
50101152:	0d 00 40 02 	rslcx 
50101156:	00 80       	rfe 
	...

50101160 <__interrupt_139>:
50101160:	e0 8b       	bisr 139
50101162:	91 00 00 f7 	movh.a %a15,28672
50101166:	d9 ff c0 44 	lea %a15,[%a15]19712 <70004d00 <Cdisptab+0x458>>
5010116a:	c4 fe       	ld.a %a14,[%a15+]
5010116c:	54 f4       	ld.w %d4,[%a15]
5010116e:	2d 0e 00 00 	calli %a14
50101172:	0d 00 40 02 	rslcx 
50101176:	00 80       	rfe 
	...

50101180 <__interrupt_140>:
50101180:	e0 8c       	bisr 140
50101182:	91 00 00 f7 	movh.a %a15,28672
50101186:	d9 ff c8 44 	lea %a15,[%a15]19720 <70004d08 <Cdisptab+0x460>>
5010118a:	c4 fe       	ld.a %a14,[%a15+]
5010118c:	54 f4       	ld.w %d4,[%a15]
5010118e:	2d 0e 00 00 	calli %a14
50101192:	0d 00 40 02 	rslcx 
50101196:	00 80       	rfe 
	...

501011a0 <__interrupt_141>:
501011a0:	e0 8d       	bisr 141
501011a2:	91 00 00 f7 	movh.a %a15,28672
501011a6:	d9 ff d0 44 	lea %a15,[%a15]19728 <70004d10 <Cdisptab+0x468>>
501011aa:	c4 fe       	ld.a %a14,[%a15+]
501011ac:	54 f4       	ld.w %d4,[%a15]
501011ae:	2d 0e 00 00 	calli %a14
501011b2:	0d 00 40 02 	rslcx 
501011b6:	00 80       	rfe 
	...

501011c0 <__interrupt_142>:
501011c0:	e0 8e       	bisr 142
501011c2:	91 00 00 f7 	movh.a %a15,28672
501011c6:	d9 ff d8 44 	lea %a15,[%a15]19736 <70004d18 <Cdisptab+0x470>>
501011ca:	c4 fe       	ld.a %a14,[%a15+]
501011cc:	54 f4       	ld.w %d4,[%a15]
501011ce:	2d 0e 00 00 	calli %a14
501011d2:	0d 00 40 02 	rslcx 
501011d6:	00 80       	rfe 
	...

501011e0 <__interrupt_143>:
501011e0:	e0 8f       	bisr 143
501011e2:	91 00 00 f7 	movh.a %a15,28672
501011e6:	d9 ff e0 44 	lea %a15,[%a15]19744 <70004d20 <Cdisptab+0x478>>
501011ea:	c4 fe       	ld.a %a14,[%a15+]
501011ec:	54 f4       	ld.w %d4,[%a15]
501011ee:	2d 0e 00 00 	calli %a14
501011f2:	0d 00 40 02 	rslcx 
501011f6:	00 80       	rfe 
	...

50101200 <__interrupt_144>:
50101200:	e0 90       	bisr 144
50101202:	91 00 00 f7 	movh.a %a15,28672
50101206:	d9 ff e8 44 	lea %a15,[%a15]19752 <70004d28 <Cdisptab+0x480>>
5010120a:	c4 fe       	ld.a %a14,[%a15+]
5010120c:	54 f4       	ld.w %d4,[%a15]
5010120e:	2d 0e 00 00 	calli %a14
50101212:	0d 00 40 02 	rslcx 
50101216:	00 80       	rfe 
	...

50101220 <__interrupt_145>:
50101220:	e0 91       	bisr 145
50101222:	91 00 00 f7 	movh.a %a15,28672
50101226:	d9 ff f0 44 	lea %a15,[%a15]19760 <70004d30 <Cdisptab+0x488>>
5010122a:	c4 fe       	ld.a %a14,[%a15+]
5010122c:	54 f4       	ld.w %d4,[%a15]
5010122e:	2d 0e 00 00 	calli %a14
50101232:	0d 00 40 02 	rslcx 
50101236:	00 80       	rfe 
	...

50101240 <__interrupt_146>:
50101240:	e0 92       	bisr 146
50101242:	91 00 00 f7 	movh.a %a15,28672
50101246:	d9 ff f8 44 	lea %a15,[%a15]19768 <70004d38 <Cdisptab+0x490>>
5010124a:	c4 fe       	ld.a %a14,[%a15+]
5010124c:	54 f4       	ld.w %d4,[%a15]
5010124e:	2d 0e 00 00 	calli %a14
50101252:	0d 00 40 02 	rslcx 
50101256:	00 80       	rfe 
	...

50101260 <__interrupt_147>:
50101260:	e0 93       	bisr 147
50101262:	91 00 00 f7 	movh.a %a15,28672
50101266:	d9 ff c0 54 	lea %a15,[%a15]19776 <70004d40 <Cdisptab+0x498>>
5010126a:	c4 fe       	ld.a %a14,[%a15+]
5010126c:	54 f4       	ld.w %d4,[%a15]
5010126e:	2d 0e 00 00 	calli %a14
50101272:	0d 00 40 02 	rslcx 
50101276:	00 80       	rfe 
	...

50101280 <__interrupt_148>:
50101280:	e0 94       	bisr 148
50101282:	91 00 00 f7 	movh.a %a15,28672
50101286:	d9 ff c8 54 	lea %a15,[%a15]19784 <70004d48 <Cdisptab+0x4a0>>
5010128a:	c4 fe       	ld.a %a14,[%a15+]
5010128c:	54 f4       	ld.w %d4,[%a15]
5010128e:	2d 0e 00 00 	calli %a14
50101292:	0d 00 40 02 	rslcx 
50101296:	00 80       	rfe 
	...

501012a0 <__interrupt_149>:
501012a0:	e0 95       	bisr 149
501012a2:	91 00 00 f7 	movh.a %a15,28672
501012a6:	d9 ff d0 54 	lea %a15,[%a15]19792 <70004d50 <Cdisptab+0x4a8>>
501012aa:	c4 fe       	ld.a %a14,[%a15+]
501012ac:	54 f4       	ld.w %d4,[%a15]
501012ae:	2d 0e 00 00 	calli %a14
501012b2:	0d 00 40 02 	rslcx 
501012b6:	00 80       	rfe 
	...

501012c0 <__interrupt_150>:
501012c0:	e0 96       	bisr 150
501012c2:	91 00 00 f7 	movh.a %a15,28672
501012c6:	d9 ff d8 54 	lea %a15,[%a15]19800 <70004d58 <Cdisptab+0x4b0>>
501012ca:	c4 fe       	ld.a %a14,[%a15+]
501012cc:	54 f4       	ld.w %d4,[%a15]
501012ce:	2d 0e 00 00 	calli %a14
501012d2:	0d 00 40 02 	rslcx 
501012d6:	00 80       	rfe 
	...

501012e0 <__interrupt_151>:
501012e0:	e0 97       	bisr 151
501012e2:	91 00 00 f7 	movh.a %a15,28672
501012e6:	d9 ff e0 54 	lea %a15,[%a15]19808 <70004d60 <Cdisptab+0x4b8>>
501012ea:	c4 fe       	ld.a %a14,[%a15+]
501012ec:	54 f4       	ld.w %d4,[%a15]
501012ee:	2d 0e 00 00 	calli %a14
501012f2:	0d 00 40 02 	rslcx 
501012f6:	00 80       	rfe 
	...

50101300 <__interrupt_152>:
50101300:	e0 98       	bisr 152
50101302:	91 00 00 f7 	movh.a %a15,28672
50101306:	d9 ff e8 54 	lea %a15,[%a15]19816 <70004d68 <Cdisptab+0x4c0>>
5010130a:	c4 fe       	ld.a %a14,[%a15+]
5010130c:	54 f4       	ld.w %d4,[%a15]
5010130e:	2d 0e 00 00 	calli %a14
50101312:	0d 00 40 02 	rslcx 
50101316:	00 80       	rfe 
	...

50101320 <__interrupt_153>:
50101320:	e0 99       	bisr 153
50101322:	91 00 00 f7 	movh.a %a15,28672
50101326:	d9 ff f0 54 	lea %a15,[%a15]19824 <70004d70 <Cdisptab+0x4c8>>
5010132a:	c4 fe       	ld.a %a14,[%a15+]
5010132c:	54 f4       	ld.w %d4,[%a15]
5010132e:	2d 0e 00 00 	calli %a14
50101332:	0d 00 40 02 	rslcx 
50101336:	00 80       	rfe 
	...

50101340 <__interrupt_154>:
50101340:	e0 9a       	bisr 154
50101342:	91 00 00 f7 	movh.a %a15,28672
50101346:	d9 ff f8 54 	lea %a15,[%a15]19832 <70004d78 <Cdisptab+0x4d0>>
5010134a:	c4 fe       	ld.a %a14,[%a15+]
5010134c:	54 f4       	ld.w %d4,[%a15]
5010134e:	2d 0e 00 00 	calli %a14
50101352:	0d 00 40 02 	rslcx 
50101356:	00 80       	rfe 
	...

50101360 <__interrupt_155>:
50101360:	e0 9b       	bisr 155
50101362:	91 00 00 f7 	movh.a %a15,28672
50101366:	d9 ff c0 64 	lea %a15,[%a15]19840 <70004d80 <Cdisptab+0x4d8>>
5010136a:	c4 fe       	ld.a %a14,[%a15+]
5010136c:	54 f4       	ld.w %d4,[%a15]
5010136e:	2d 0e 00 00 	calli %a14
50101372:	0d 00 40 02 	rslcx 
50101376:	00 80       	rfe 
	...

50101380 <__interrupt_156>:
50101380:	e0 9c       	bisr 156
50101382:	91 00 00 f7 	movh.a %a15,28672
50101386:	d9 ff c8 64 	lea %a15,[%a15]19848 <70004d88 <Cdisptab+0x4e0>>
5010138a:	c4 fe       	ld.a %a14,[%a15+]
5010138c:	54 f4       	ld.w %d4,[%a15]
5010138e:	2d 0e 00 00 	calli %a14
50101392:	0d 00 40 02 	rslcx 
50101396:	00 80       	rfe 
	...

501013a0 <__interrupt_157>:
501013a0:	e0 9d       	bisr 157
501013a2:	91 00 00 f7 	movh.a %a15,28672
501013a6:	d9 ff d0 64 	lea %a15,[%a15]19856 <70004d90 <Cdisptab+0x4e8>>
501013aa:	c4 fe       	ld.a %a14,[%a15+]
501013ac:	54 f4       	ld.w %d4,[%a15]
501013ae:	2d 0e 00 00 	calli %a14
501013b2:	0d 00 40 02 	rslcx 
501013b6:	00 80       	rfe 
	...

501013c0 <__interrupt_158>:
501013c0:	e0 9e       	bisr 158
501013c2:	91 00 00 f7 	movh.a %a15,28672
501013c6:	d9 ff d8 64 	lea %a15,[%a15]19864 <70004d98 <Cdisptab+0x4f0>>
501013ca:	c4 fe       	ld.a %a14,[%a15+]
501013cc:	54 f4       	ld.w %d4,[%a15]
501013ce:	2d 0e 00 00 	calli %a14
501013d2:	0d 00 40 02 	rslcx 
501013d6:	00 80       	rfe 
	...

501013e0 <__interrupt_159>:
501013e0:	e0 9f       	bisr 159
501013e2:	91 00 00 f7 	movh.a %a15,28672
501013e6:	d9 ff e0 64 	lea %a15,[%a15]19872 <70004da0 <Cdisptab+0x4f8>>
501013ea:	c4 fe       	ld.a %a14,[%a15+]
501013ec:	54 f4       	ld.w %d4,[%a15]
501013ee:	2d 0e 00 00 	calli %a14
501013f2:	0d 00 40 02 	rslcx 
501013f6:	00 80       	rfe 
	...

50101400 <__interrupt_160>:
50101400:	e0 a0       	bisr 160
50101402:	91 00 00 f7 	movh.a %a15,28672
50101406:	d9 ff e8 64 	lea %a15,[%a15]19880 <70004da8 <Cdisptab+0x500>>
5010140a:	c4 fe       	ld.a %a14,[%a15+]
5010140c:	54 f4       	ld.w %d4,[%a15]
5010140e:	2d 0e 00 00 	calli %a14
50101412:	0d 00 40 02 	rslcx 
50101416:	00 80       	rfe 
	...

50101420 <__interrupt_161>:
50101420:	e0 a1       	bisr 161
50101422:	91 00 00 f7 	movh.a %a15,28672
50101426:	d9 ff f0 64 	lea %a15,[%a15]19888 <70004db0 <Cdisptab+0x508>>
5010142a:	c4 fe       	ld.a %a14,[%a15+]
5010142c:	54 f4       	ld.w %d4,[%a15]
5010142e:	2d 0e 00 00 	calli %a14
50101432:	0d 00 40 02 	rslcx 
50101436:	00 80       	rfe 
	...

50101440 <__interrupt_162>:
50101440:	e0 a2       	bisr 162
50101442:	91 00 00 f7 	movh.a %a15,28672
50101446:	d9 ff f8 64 	lea %a15,[%a15]19896 <70004db8 <Cdisptab+0x510>>
5010144a:	c4 fe       	ld.a %a14,[%a15+]
5010144c:	54 f4       	ld.w %d4,[%a15]
5010144e:	2d 0e 00 00 	calli %a14
50101452:	0d 00 40 02 	rslcx 
50101456:	00 80       	rfe 
	...

50101460 <__interrupt_163>:
50101460:	e0 a3       	bisr 163
50101462:	91 00 00 f7 	movh.a %a15,28672
50101466:	d9 ff c0 74 	lea %a15,[%a15]19904 <70004dc0 <Cdisptab+0x518>>
5010146a:	c4 fe       	ld.a %a14,[%a15+]
5010146c:	54 f4       	ld.w %d4,[%a15]
5010146e:	2d 0e 00 00 	calli %a14
50101472:	0d 00 40 02 	rslcx 
50101476:	00 80       	rfe 
	...

50101480 <__interrupt_164>:
50101480:	e0 a4       	bisr 164
50101482:	91 00 00 f7 	movh.a %a15,28672
50101486:	d9 ff c8 74 	lea %a15,[%a15]19912 <70004dc8 <Cdisptab+0x520>>
5010148a:	c4 fe       	ld.a %a14,[%a15+]
5010148c:	54 f4       	ld.w %d4,[%a15]
5010148e:	2d 0e 00 00 	calli %a14
50101492:	0d 00 40 02 	rslcx 
50101496:	00 80       	rfe 
	...

501014a0 <__interrupt_165>:
501014a0:	e0 a5       	bisr 165
501014a2:	91 00 00 f7 	movh.a %a15,28672
501014a6:	d9 ff d0 74 	lea %a15,[%a15]19920 <70004dd0 <Cdisptab+0x528>>
501014aa:	c4 fe       	ld.a %a14,[%a15+]
501014ac:	54 f4       	ld.w %d4,[%a15]
501014ae:	2d 0e 00 00 	calli %a14
501014b2:	0d 00 40 02 	rslcx 
501014b6:	00 80       	rfe 
	...

501014c0 <__interrupt_166>:
501014c0:	e0 a6       	bisr 166
501014c2:	91 00 00 f7 	movh.a %a15,28672
501014c6:	d9 ff d8 74 	lea %a15,[%a15]19928 <70004dd8 <Cdisptab+0x530>>
501014ca:	c4 fe       	ld.a %a14,[%a15+]
501014cc:	54 f4       	ld.w %d4,[%a15]
501014ce:	2d 0e 00 00 	calli %a14
501014d2:	0d 00 40 02 	rslcx 
501014d6:	00 80       	rfe 
	...

501014e0 <__interrupt_167>:
501014e0:	e0 a7       	bisr 167
501014e2:	91 00 00 f7 	movh.a %a15,28672
501014e6:	d9 ff e0 74 	lea %a15,[%a15]19936 <70004de0 <Cdisptab+0x538>>
501014ea:	c4 fe       	ld.a %a14,[%a15+]
501014ec:	54 f4       	ld.w %d4,[%a15]
501014ee:	2d 0e 00 00 	calli %a14
501014f2:	0d 00 40 02 	rslcx 
501014f6:	00 80       	rfe 
	...

50101500 <__interrupt_168>:
50101500:	e0 a8       	bisr 168
50101502:	91 00 00 f7 	movh.a %a15,28672
50101506:	d9 ff e8 74 	lea %a15,[%a15]19944 <70004de8 <Cdisptab+0x540>>
5010150a:	c4 fe       	ld.a %a14,[%a15+]
5010150c:	54 f4       	ld.w %d4,[%a15]
5010150e:	2d 0e 00 00 	calli %a14
50101512:	0d 00 40 02 	rslcx 
50101516:	00 80       	rfe 
	...

50101520 <__interrupt_169>:
50101520:	e0 a9       	bisr 169
50101522:	91 00 00 f7 	movh.a %a15,28672
50101526:	d9 ff f0 74 	lea %a15,[%a15]19952 <70004df0 <Cdisptab+0x548>>
5010152a:	c4 fe       	ld.a %a14,[%a15+]
5010152c:	54 f4       	ld.w %d4,[%a15]
5010152e:	2d 0e 00 00 	calli %a14
50101532:	0d 00 40 02 	rslcx 
50101536:	00 80       	rfe 
	...

50101540 <__interrupt_170>:
50101540:	e0 aa       	bisr 170
50101542:	91 00 00 f7 	movh.a %a15,28672
50101546:	d9 ff f8 74 	lea %a15,[%a15]19960 <70004df8 <Cdisptab+0x550>>
5010154a:	c4 fe       	ld.a %a14,[%a15+]
5010154c:	54 f4       	ld.w %d4,[%a15]
5010154e:	2d 0e 00 00 	calli %a14
50101552:	0d 00 40 02 	rslcx 
50101556:	00 80       	rfe 
	...

50101560 <__interrupt_171>:
50101560:	e0 ab       	bisr 171
50101562:	91 00 00 f7 	movh.a %a15,28672
50101566:	d9 ff c0 84 	lea %a15,[%a15]19968 <70004e00 <Cdisptab+0x558>>
5010156a:	c4 fe       	ld.a %a14,[%a15+]
5010156c:	54 f4       	ld.w %d4,[%a15]
5010156e:	2d 0e 00 00 	calli %a14
50101572:	0d 00 40 02 	rslcx 
50101576:	00 80       	rfe 
	...

50101580 <__interrupt_172>:
50101580:	e0 ac       	bisr 172
50101582:	91 00 00 f7 	movh.a %a15,28672
50101586:	d9 ff c8 84 	lea %a15,[%a15]19976 <70004e08 <Cdisptab+0x560>>
5010158a:	c4 fe       	ld.a %a14,[%a15+]
5010158c:	54 f4       	ld.w %d4,[%a15]
5010158e:	2d 0e 00 00 	calli %a14
50101592:	0d 00 40 02 	rslcx 
50101596:	00 80       	rfe 
	...

501015a0 <__interrupt_173>:
501015a0:	e0 ad       	bisr 173
501015a2:	91 00 00 f7 	movh.a %a15,28672
501015a6:	d9 ff d0 84 	lea %a15,[%a15]19984 <70004e10 <Cdisptab+0x568>>
501015aa:	c4 fe       	ld.a %a14,[%a15+]
501015ac:	54 f4       	ld.w %d4,[%a15]
501015ae:	2d 0e 00 00 	calli %a14
501015b2:	0d 00 40 02 	rslcx 
501015b6:	00 80       	rfe 
	...

501015c0 <__interrupt_174>:
501015c0:	e0 ae       	bisr 174
501015c2:	91 00 00 f7 	movh.a %a15,28672
501015c6:	d9 ff d8 84 	lea %a15,[%a15]19992 <70004e18 <Cdisptab+0x570>>
501015ca:	c4 fe       	ld.a %a14,[%a15+]
501015cc:	54 f4       	ld.w %d4,[%a15]
501015ce:	2d 0e 00 00 	calli %a14
501015d2:	0d 00 40 02 	rslcx 
501015d6:	00 80       	rfe 
	...

501015e0 <__interrupt_175>:
501015e0:	e0 af       	bisr 175
501015e2:	91 00 00 f7 	movh.a %a15,28672
501015e6:	d9 ff e0 84 	lea %a15,[%a15]20000 <70004e20 <Cdisptab+0x578>>
501015ea:	c4 fe       	ld.a %a14,[%a15+]
501015ec:	54 f4       	ld.w %d4,[%a15]
501015ee:	2d 0e 00 00 	calli %a14
501015f2:	0d 00 40 02 	rslcx 
501015f6:	00 80       	rfe 
	...

50101600 <__interrupt_176>:
50101600:	e0 b0       	bisr 176
50101602:	91 00 00 f7 	movh.a %a15,28672
50101606:	d9 ff e8 84 	lea %a15,[%a15]20008 <70004e28 <Cdisptab+0x580>>
5010160a:	c4 fe       	ld.a %a14,[%a15+]
5010160c:	54 f4       	ld.w %d4,[%a15]
5010160e:	2d 0e 00 00 	calli %a14
50101612:	0d 00 40 02 	rslcx 
50101616:	00 80       	rfe 
	...

50101620 <__interrupt_177>:
50101620:	e0 b1       	bisr 177
50101622:	91 00 00 f7 	movh.a %a15,28672
50101626:	d9 ff f0 84 	lea %a15,[%a15]20016 <70004e30 <Cdisptab+0x588>>
5010162a:	c4 fe       	ld.a %a14,[%a15+]
5010162c:	54 f4       	ld.w %d4,[%a15]
5010162e:	2d 0e 00 00 	calli %a14
50101632:	0d 00 40 02 	rslcx 
50101636:	00 80       	rfe 
	...

50101640 <__interrupt_178>:
50101640:	e0 b2       	bisr 178
50101642:	91 00 00 f7 	movh.a %a15,28672
50101646:	d9 ff f8 84 	lea %a15,[%a15]20024 <70004e38 <Cdisptab+0x590>>
5010164a:	c4 fe       	ld.a %a14,[%a15+]
5010164c:	54 f4       	ld.w %d4,[%a15]
5010164e:	2d 0e 00 00 	calli %a14
50101652:	0d 00 40 02 	rslcx 
50101656:	00 80       	rfe 
	...

50101660 <__interrupt_179>:
50101660:	e0 b3       	bisr 179
50101662:	91 00 00 f7 	movh.a %a15,28672
50101666:	d9 ff c0 94 	lea %a15,[%a15]20032 <70004e40 <Cdisptab+0x598>>
5010166a:	c4 fe       	ld.a %a14,[%a15+]
5010166c:	54 f4       	ld.w %d4,[%a15]
5010166e:	2d 0e 00 00 	calli %a14
50101672:	0d 00 40 02 	rslcx 
50101676:	00 80       	rfe 
	...

50101680 <__interrupt_180>:
50101680:	e0 b4       	bisr 180
50101682:	91 00 00 f7 	movh.a %a15,28672
50101686:	d9 ff c8 94 	lea %a15,[%a15]20040 <70004e48 <Cdisptab+0x5a0>>
5010168a:	c4 fe       	ld.a %a14,[%a15+]
5010168c:	54 f4       	ld.w %d4,[%a15]
5010168e:	2d 0e 00 00 	calli %a14
50101692:	0d 00 40 02 	rslcx 
50101696:	00 80       	rfe 
	...

501016a0 <__interrupt_181>:
501016a0:	e0 b5       	bisr 181
501016a2:	91 00 00 f7 	movh.a %a15,28672
501016a6:	d9 ff d0 94 	lea %a15,[%a15]20048 <70004e50 <Cdisptab+0x5a8>>
501016aa:	c4 fe       	ld.a %a14,[%a15+]
501016ac:	54 f4       	ld.w %d4,[%a15]
501016ae:	2d 0e 00 00 	calli %a14
501016b2:	0d 00 40 02 	rslcx 
501016b6:	00 80       	rfe 
	...

501016c0 <__interrupt_182>:
501016c0:	e0 b6       	bisr 182
501016c2:	91 00 00 f7 	movh.a %a15,28672
501016c6:	d9 ff d8 94 	lea %a15,[%a15]20056 <70004e58 <Cdisptab+0x5b0>>
501016ca:	c4 fe       	ld.a %a14,[%a15+]
501016cc:	54 f4       	ld.w %d4,[%a15]
501016ce:	2d 0e 00 00 	calli %a14
501016d2:	0d 00 40 02 	rslcx 
501016d6:	00 80       	rfe 
	...

501016e0 <__interrupt_183>:
501016e0:	e0 b7       	bisr 183
501016e2:	91 00 00 f7 	movh.a %a15,28672
501016e6:	d9 ff e0 94 	lea %a15,[%a15]20064 <70004e60 <Cdisptab+0x5b8>>
501016ea:	c4 fe       	ld.a %a14,[%a15+]
501016ec:	54 f4       	ld.w %d4,[%a15]
501016ee:	2d 0e 00 00 	calli %a14
501016f2:	0d 00 40 02 	rslcx 
501016f6:	00 80       	rfe 
	...

50101700 <__interrupt_184>:
50101700:	e0 b8       	bisr 184
50101702:	91 00 00 f7 	movh.a %a15,28672
50101706:	d9 ff e8 94 	lea %a15,[%a15]20072 <70004e68 <Cdisptab+0x5c0>>
5010170a:	c4 fe       	ld.a %a14,[%a15+]
5010170c:	54 f4       	ld.w %d4,[%a15]
5010170e:	2d 0e 00 00 	calli %a14
50101712:	0d 00 40 02 	rslcx 
50101716:	00 80       	rfe 
	...

50101720 <__interrupt_185>:
50101720:	e0 b9       	bisr 185
50101722:	91 00 00 f7 	movh.a %a15,28672
50101726:	d9 ff f0 94 	lea %a15,[%a15]20080 <70004e70 <Cdisptab+0x5c8>>
5010172a:	c4 fe       	ld.a %a14,[%a15+]
5010172c:	54 f4       	ld.w %d4,[%a15]
5010172e:	2d 0e 00 00 	calli %a14
50101732:	0d 00 40 02 	rslcx 
50101736:	00 80       	rfe 
	...

50101740 <__interrupt_186>:
50101740:	e0 ba       	bisr 186
50101742:	91 00 00 f7 	movh.a %a15,28672
50101746:	d9 ff f8 94 	lea %a15,[%a15]20088 <70004e78 <Cdisptab+0x5d0>>
5010174a:	c4 fe       	ld.a %a14,[%a15+]
5010174c:	54 f4       	ld.w %d4,[%a15]
5010174e:	2d 0e 00 00 	calli %a14
50101752:	0d 00 40 02 	rslcx 
50101756:	00 80       	rfe 
	...

50101760 <__interrupt_187>:
50101760:	e0 bb       	bisr 187
50101762:	91 00 00 f7 	movh.a %a15,28672
50101766:	d9 ff c0 a4 	lea %a15,[%a15]20096 <70004e80 <Cdisptab+0x5d8>>
5010176a:	c4 fe       	ld.a %a14,[%a15+]
5010176c:	54 f4       	ld.w %d4,[%a15]
5010176e:	2d 0e 00 00 	calli %a14
50101772:	0d 00 40 02 	rslcx 
50101776:	00 80       	rfe 
	...

50101780 <__interrupt_188>:
50101780:	e0 bc       	bisr 188
50101782:	91 00 00 f7 	movh.a %a15,28672
50101786:	d9 ff c8 a4 	lea %a15,[%a15]20104 <70004e88 <Cdisptab+0x5e0>>
5010178a:	c4 fe       	ld.a %a14,[%a15+]
5010178c:	54 f4       	ld.w %d4,[%a15]
5010178e:	2d 0e 00 00 	calli %a14
50101792:	0d 00 40 02 	rslcx 
50101796:	00 80       	rfe 
	...

501017a0 <__interrupt_189>:
501017a0:	e0 bd       	bisr 189
501017a2:	91 00 00 f7 	movh.a %a15,28672
501017a6:	d9 ff d0 a4 	lea %a15,[%a15]20112 <70004e90 <Cdisptab+0x5e8>>
501017aa:	c4 fe       	ld.a %a14,[%a15+]
501017ac:	54 f4       	ld.w %d4,[%a15]
501017ae:	2d 0e 00 00 	calli %a14
501017b2:	0d 00 40 02 	rslcx 
501017b6:	00 80       	rfe 
	...

501017c0 <__interrupt_190>:
501017c0:	e0 be       	bisr 190
501017c2:	91 00 00 f7 	movh.a %a15,28672
501017c6:	d9 ff d8 a4 	lea %a15,[%a15]20120 <70004e98 <Cdisptab+0x5f0>>
501017ca:	c4 fe       	ld.a %a14,[%a15+]
501017cc:	54 f4       	ld.w %d4,[%a15]
501017ce:	2d 0e 00 00 	calli %a14
501017d2:	0d 00 40 02 	rslcx 
501017d6:	00 80       	rfe 
	...

501017e0 <__interrupt_191>:
501017e0:	e0 bf       	bisr 191
501017e2:	91 00 00 f7 	movh.a %a15,28672
501017e6:	d9 ff e0 a4 	lea %a15,[%a15]20128 <70004ea0 <Cdisptab+0x5f8>>
501017ea:	c4 fe       	ld.a %a14,[%a15+]
501017ec:	54 f4       	ld.w %d4,[%a15]
501017ee:	2d 0e 00 00 	calli %a14
501017f2:	0d 00 40 02 	rslcx 
501017f6:	00 80       	rfe 
	...

50101800 <__interrupt_192>:
50101800:	e0 c0       	bisr 192
50101802:	91 00 00 f7 	movh.a %a15,28672
50101806:	d9 ff e8 a4 	lea %a15,[%a15]20136 <70004ea8 <Cdisptab+0x600>>
5010180a:	c4 fe       	ld.a %a14,[%a15+]
5010180c:	54 f4       	ld.w %d4,[%a15]
5010180e:	2d 0e 00 00 	calli %a14
50101812:	0d 00 40 02 	rslcx 
50101816:	00 80       	rfe 
	...

50101820 <__interrupt_193>:
50101820:	e0 c1       	bisr 193
50101822:	91 00 00 f7 	movh.a %a15,28672
50101826:	d9 ff f0 a4 	lea %a15,[%a15]20144 <70004eb0 <Cdisptab+0x608>>
5010182a:	c4 fe       	ld.a %a14,[%a15+]
5010182c:	54 f4       	ld.w %d4,[%a15]
5010182e:	2d 0e 00 00 	calli %a14
50101832:	0d 00 40 02 	rslcx 
50101836:	00 80       	rfe 
	...

50101840 <__interrupt_194>:
50101840:	e0 c2       	bisr 194
50101842:	91 00 00 f7 	movh.a %a15,28672
50101846:	d9 ff f8 a4 	lea %a15,[%a15]20152 <70004eb8 <Cdisptab+0x610>>
5010184a:	c4 fe       	ld.a %a14,[%a15+]
5010184c:	54 f4       	ld.w %d4,[%a15]
5010184e:	2d 0e 00 00 	calli %a14
50101852:	0d 00 40 02 	rslcx 
50101856:	00 80       	rfe 
	...

50101860 <__interrupt_195>:
50101860:	e0 c3       	bisr 195
50101862:	91 00 00 f7 	movh.a %a15,28672
50101866:	d9 ff c0 b4 	lea %a15,[%a15]20160 <70004ec0 <Cdisptab+0x618>>
5010186a:	c4 fe       	ld.a %a14,[%a15+]
5010186c:	54 f4       	ld.w %d4,[%a15]
5010186e:	2d 0e 00 00 	calli %a14
50101872:	0d 00 40 02 	rslcx 
50101876:	00 80       	rfe 
	...

50101880 <__interrupt_196>:
50101880:	e0 c4       	bisr 196
50101882:	91 00 00 f7 	movh.a %a15,28672
50101886:	d9 ff c8 b4 	lea %a15,[%a15]20168 <70004ec8 <Cdisptab+0x620>>
5010188a:	c4 fe       	ld.a %a14,[%a15+]
5010188c:	54 f4       	ld.w %d4,[%a15]
5010188e:	2d 0e 00 00 	calli %a14
50101892:	0d 00 40 02 	rslcx 
50101896:	00 80       	rfe 
	...

501018a0 <__interrupt_197>:
501018a0:	e0 c5       	bisr 197
501018a2:	91 00 00 f7 	movh.a %a15,28672
501018a6:	d9 ff d0 b4 	lea %a15,[%a15]20176 <70004ed0 <Cdisptab+0x628>>
501018aa:	c4 fe       	ld.a %a14,[%a15+]
501018ac:	54 f4       	ld.w %d4,[%a15]
501018ae:	2d 0e 00 00 	calli %a14
501018b2:	0d 00 40 02 	rslcx 
501018b6:	00 80       	rfe 
	...

501018c0 <__interrupt_198>:
501018c0:	e0 c6       	bisr 198
501018c2:	91 00 00 f7 	movh.a %a15,28672
501018c6:	d9 ff d8 b4 	lea %a15,[%a15]20184 <70004ed8 <Cdisptab+0x630>>
501018ca:	c4 fe       	ld.a %a14,[%a15+]
501018cc:	54 f4       	ld.w %d4,[%a15]
501018ce:	2d 0e 00 00 	calli %a14
501018d2:	0d 00 40 02 	rslcx 
501018d6:	00 80       	rfe 
	...

501018e0 <__interrupt_199>:
501018e0:	e0 c7       	bisr 199
501018e2:	91 00 00 f7 	movh.a %a15,28672
501018e6:	d9 ff e0 b4 	lea %a15,[%a15]20192 <70004ee0 <Cdisptab+0x638>>
501018ea:	c4 fe       	ld.a %a14,[%a15+]
501018ec:	54 f4       	ld.w %d4,[%a15]
501018ee:	2d 0e 00 00 	calli %a14
501018f2:	0d 00 40 02 	rslcx 
501018f6:	00 80       	rfe 
	...

50101900 <__interrupt_200>:
50101900:	e0 c8       	bisr 200
50101902:	91 00 00 f7 	movh.a %a15,28672
50101906:	d9 ff e8 b4 	lea %a15,[%a15]20200 <70004ee8 <Cdisptab+0x640>>
5010190a:	c4 fe       	ld.a %a14,[%a15+]
5010190c:	54 f4       	ld.w %d4,[%a15]
5010190e:	2d 0e 00 00 	calli %a14
50101912:	0d 00 40 02 	rslcx 
50101916:	00 80       	rfe 
	...

50101920 <__interrupt_201>:
50101920:	e0 c9       	bisr 201
50101922:	91 00 00 f7 	movh.a %a15,28672
50101926:	d9 ff f0 b4 	lea %a15,[%a15]20208 <70004ef0 <Cdisptab+0x648>>
5010192a:	c4 fe       	ld.a %a14,[%a15+]
5010192c:	54 f4       	ld.w %d4,[%a15]
5010192e:	2d 0e 00 00 	calli %a14
50101932:	0d 00 40 02 	rslcx 
50101936:	00 80       	rfe 
	...

50101940 <__interrupt_202>:
50101940:	e0 ca       	bisr 202
50101942:	91 00 00 f7 	movh.a %a15,28672
50101946:	d9 ff f8 b4 	lea %a15,[%a15]20216 <70004ef8 <Cdisptab+0x650>>
5010194a:	c4 fe       	ld.a %a14,[%a15+]
5010194c:	54 f4       	ld.w %d4,[%a15]
5010194e:	2d 0e 00 00 	calli %a14
50101952:	0d 00 40 02 	rslcx 
50101956:	00 80       	rfe 
	...

50101960 <__interrupt_203>:
50101960:	e0 cb       	bisr 203
50101962:	91 00 00 f7 	movh.a %a15,28672
50101966:	d9 ff c0 c4 	lea %a15,[%a15]20224 <70004f00 <Cdisptab+0x658>>
5010196a:	c4 fe       	ld.a %a14,[%a15+]
5010196c:	54 f4       	ld.w %d4,[%a15]
5010196e:	2d 0e 00 00 	calli %a14
50101972:	0d 00 40 02 	rslcx 
50101976:	00 80       	rfe 
	...

50101980 <__interrupt_204>:
50101980:	e0 cc       	bisr 204
50101982:	91 00 00 f7 	movh.a %a15,28672
50101986:	d9 ff c8 c4 	lea %a15,[%a15]20232 <70004f08 <Cdisptab+0x660>>
5010198a:	c4 fe       	ld.a %a14,[%a15+]
5010198c:	54 f4       	ld.w %d4,[%a15]
5010198e:	2d 0e 00 00 	calli %a14
50101992:	0d 00 40 02 	rslcx 
50101996:	00 80       	rfe 
	...

501019a0 <__interrupt_205>:
501019a0:	e0 cd       	bisr 205
501019a2:	91 00 00 f7 	movh.a %a15,28672
501019a6:	d9 ff d0 c4 	lea %a15,[%a15]20240 <70004f10 <Cdisptab+0x668>>
501019aa:	c4 fe       	ld.a %a14,[%a15+]
501019ac:	54 f4       	ld.w %d4,[%a15]
501019ae:	2d 0e 00 00 	calli %a14
501019b2:	0d 00 40 02 	rslcx 
501019b6:	00 80       	rfe 
	...

501019c0 <__interrupt_206>:
501019c0:	e0 ce       	bisr 206
501019c2:	91 00 00 f7 	movh.a %a15,28672
501019c6:	d9 ff d8 c4 	lea %a15,[%a15]20248 <70004f18 <Cdisptab+0x670>>
501019ca:	c4 fe       	ld.a %a14,[%a15+]
501019cc:	54 f4       	ld.w %d4,[%a15]
501019ce:	2d 0e 00 00 	calli %a14
501019d2:	0d 00 40 02 	rslcx 
501019d6:	00 80       	rfe 
	...

501019e0 <__interrupt_207>:
501019e0:	e0 cf       	bisr 207
501019e2:	91 00 00 f7 	movh.a %a15,28672
501019e6:	d9 ff e0 c4 	lea %a15,[%a15]20256 <70004f20 <Cdisptab+0x678>>
501019ea:	c4 fe       	ld.a %a14,[%a15+]
501019ec:	54 f4       	ld.w %d4,[%a15]
501019ee:	2d 0e 00 00 	calli %a14
501019f2:	0d 00 40 02 	rslcx 
501019f6:	00 80       	rfe 
	...

50101a00 <__interrupt_208>:
50101a00:	e0 d0       	bisr 208
50101a02:	91 00 00 f7 	movh.a %a15,28672
50101a06:	d9 ff e8 c4 	lea %a15,[%a15]20264 <70004f28 <Cdisptab+0x680>>
50101a0a:	c4 fe       	ld.a %a14,[%a15+]
50101a0c:	54 f4       	ld.w %d4,[%a15]
50101a0e:	2d 0e 00 00 	calli %a14
50101a12:	0d 00 40 02 	rslcx 
50101a16:	00 80       	rfe 
	...

50101a20 <__interrupt_209>:
50101a20:	e0 d1       	bisr 209
50101a22:	91 00 00 f7 	movh.a %a15,28672
50101a26:	d9 ff f0 c4 	lea %a15,[%a15]20272 <70004f30 <Cdisptab+0x688>>
50101a2a:	c4 fe       	ld.a %a14,[%a15+]
50101a2c:	54 f4       	ld.w %d4,[%a15]
50101a2e:	2d 0e 00 00 	calli %a14
50101a32:	0d 00 40 02 	rslcx 
50101a36:	00 80       	rfe 
	...

50101a40 <__interrupt_210>:
50101a40:	e0 d2       	bisr 210
50101a42:	91 00 00 f7 	movh.a %a15,28672
50101a46:	d9 ff f8 c4 	lea %a15,[%a15]20280 <70004f38 <Cdisptab+0x690>>
50101a4a:	c4 fe       	ld.a %a14,[%a15+]
50101a4c:	54 f4       	ld.w %d4,[%a15]
50101a4e:	2d 0e 00 00 	calli %a14
50101a52:	0d 00 40 02 	rslcx 
50101a56:	00 80       	rfe 
	...

50101a60 <__interrupt_211>:
50101a60:	e0 d3       	bisr 211
50101a62:	91 00 00 f7 	movh.a %a15,28672
50101a66:	d9 ff c0 d4 	lea %a15,[%a15]20288 <70004f40 <Cdisptab+0x698>>
50101a6a:	c4 fe       	ld.a %a14,[%a15+]
50101a6c:	54 f4       	ld.w %d4,[%a15]
50101a6e:	2d 0e 00 00 	calli %a14
50101a72:	0d 00 40 02 	rslcx 
50101a76:	00 80       	rfe 
	...

50101a80 <__interrupt_212>:
50101a80:	e0 d4       	bisr 212
50101a82:	91 00 00 f7 	movh.a %a15,28672
50101a86:	d9 ff c8 d4 	lea %a15,[%a15]20296 <70004f48 <Cdisptab+0x6a0>>
50101a8a:	c4 fe       	ld.a %a14,[%a15+]
50101a8c:	54 f4       	ld.w %d4,[%a15]
50101a8e:	2d 0e 00 00 	calli %a14
50101a92:	0d 00 40 02 	rslcx 
50101a96:	00 80       	rfe 
	...

50101aa0 <__interrupt_213>:
50101aa0:	e0 d5       	bisr 213
50101aa2:	91 00 00 f7 	movh.a %a15,28672
50101aa6:	d9 ff d0 d4 	lea %a15,[%a15]20304 <70004f50 <Cdisptab+0x6a8>>
50101aaa:	c4 fe       	ld.a %a14,[%a15+]
50101aac:	54 f4       	ld.w %d4,[%a15]
50101aae:	2d 0e 00 00 	calli %a14
50101ab2:	0d 00 40 02 	rslcx 
50101ab6:	00 80       	rfe 
	...

50101ac0 <__interrupt_214>:
50101ac0:	e0 d6       	bisr 214
50101ac2:	91 00 00 f7 	movh.a %a15,28672
50101ac6:	d9 ff d8 d4 	lea %a15,[%a15]20312 <70004f58 <Cdisptab+0x6b0>>
50101aca:	c4 fe       	ld.a %a14,[%a15+]
50101acc:	54 f4       	ld.w %d4,[%a15]
50101ace:	2d 0e 00 00 	calli %a14
50101ad2:	0d 00 40 02 	rslcx 
50101ad6:	00 80       	rfe 
	...

50101ae0 <__interrupt_215>:
50101ae0:	e0 d7       	bisr 215
50101ae2:	91 00 00 f7 	movh.a %a15,28672
50101ae6:	d9 ff e0 d4 	lea %a15,[%a15]20320 <70004f60 <Cdisptab+0x6b8>>
50101aea:	c4 fe       	ld.a %a14,[%a15+]
50101aec:	54 f4       	ld.w %d4,[%a15]
50101aee:	2d 0e 00 00 	calli %a14
50101af2:	0d 00 40 02 	rslcx 
50101af6:	00 80       	rfe 
	...

50101b00 <__interrupt_216>:
50101b00:	e0 d8       	bisr 216
50101b02:	91 00 00 f7 	movh.a %a15,28672
50101b06:	d9 ff e8 d4 	lea %a15,[%a15]20328 <70004f68 <Cdisptab+0x6c0>>
50101b0a:	c4 fe       	ld.a %a14,[%a15+]
50101b0c:	54 f4       	ld.w %d4,[%a15]
50101b0e:	2d 0e 00 00 	calli %a14
50101b12:	0d 00 40 02 	rslcx 
50101b16:	00 80       	rfe 
	...

50101b20 <__interrupt_217>:
50101b20:	e0 d9       	bisr 217
50101b22:	91 00 00 f7 	movh.a %a15,28672
50101b26:	d9 ff f0 d4 	lea %a15,[%a15]20336 <70004f70 <Cdisptab+0x6c8>>
50101b2a:	c4 fe       	ld.a %a14,[%a15+]
50101b2c:	54 f4       	ld.w %d4,[%a15]
50101b2e:	2d 0e 00 00 	calli %a14
50101b32:	0d 00 40 02 	rslcx 
50101b36:	00 80       	rfe 
	...

50101b40 <__interrupt_218>:
50101b40:	e0 da       	bisr 218
50101b42:	91 00 00 f7 	movh.a %a15,28672
50101b46:	d9 ff f8 d4 	lea %a15,[%a15]20344 <70004f78 <Cdisptab+0x6d0>>
50101b4a:	c4 fe       	ld.a %a14,[%a15+]
50101b4c:	54 f4       	ld.w %d4,[%a15]
50101b4e:	2d 0e 00 00 	calli %a14
50101b52:	0d 00 40 02 	rslcx 
50101b56:	00 80       	rfe 
	...

50101b60 <__interrupt_219>:
50101b60:	e0 db       	bisr 219
50101b62:	91 00 00 f7 	movh.a %a15,28672
50101b66:	d9 ff c0 e4 	lea %a15,[%a15]20352 <70004f80 <Cdisptab+0x6d8>>
50101b6a:	c4 fe       	ld.a %a14,[%a15+]
50101b6c:	54 f4       	ld.w %d4,[%a15]
50101b6e:	2d 0e 00 00 	calli %a14
50101b72:	0d 00 40 02 	rslcx 
50101b76:	00 80       	rfe 
	...

50101b80 <__interrupt_220>:
50101b80:	e0 dc       	bisr 220
50101b82:	91 00 00 f7 	movh.a %a15,28672
50101b86:	d9 ff c8 e4 	lea %a15,[%a15]20360 <70004f88 <Cdisptab+0x6e0>>
50101b8a:	c4 fe       	ld.a %a14,[%a15+]
50101b8c:	54 f4       	ld.w %d4,[%a15]
50101b8e:	2d 0e 00 00 	calli %a14
50101b92:	0d 00 40 02 	rslcx 
50101b96:	00 80       	rfe 
	...

50101ba0 <__interrupt_221>:
50101ba0:	e0 dd       	bisr 221
50101ba2:	91 00 00 f7 	movh.a %a15,28672
50101ba6:	d9 ff d0 e4 	lea %a15,[%a15]20368 <70004f90 <Cdisptab+0x6e8>>
50101baa:	c4 fe       	ld.a %a14,[%a15+]
50101bac:	54 f4       	ld.w %d4,[%a15]
50101bae:	2d 0e 00 00 	calli %a14
50101bb2:	0d 00 40 02 	rslcx 
50101bb6:	00 80       	rfe 
	...

50101bc0 <__interrupt_222>:
50101bc0:	e0 de       	bisr 222
50101bc2:	91 00 00 f7 	movh.a %a15,28672
50101bc6:	d9 ff d8 e4 	lea %a15,[%a15]20376 <70004f98 <Cdisptab+0x6f0>>
50101bca:	c4 fe       	ld.a %a14,[%a15+]
50101bcc:	54 f4       	ld.w %d4,[%a15]
50101bce:	2d 0e 00 00 	calli %a14
50101bd2:	0d 00 40 02 	rslcx 
50101bd6:	00 80       	rfe 
	...

50101be0 <__interrupt_223>:
50101be0:	e0 df       	bisr 223
50101be2:	91 00 00 f7 	movh.a %a15,28672
50101be6:	d9 ff e0 e4 	lea %a15,[%a15]20384 <70004fa0 <Cdisptab+0x6f8>>
50101bea:	c4 fe       	ld.a %a14,[%a15+]
50101bec:	54 f4       	ld.w %d4,[%a15]
50101bee:	2d 0e 00 00 	calli %a14
50101bf2:	0d 00 40 02 	rslcx 
50101bf6:	00 80       	rfe 
	...

50101c00 <__interrupt_224>:
50101c00:	e0 e0       	bisr 224
50101c02:	91 00 00 f7 	movh.a %a15,28672
50101c06:	d9 ff e8 e4 	lea %a15,[%a15]20392 <70004fa8 <Cdisptab+0x700>>
50101c0a:	c4 fe       	ld.a %a14,[%a15+]
50101c0c:	54 f4       	ld.w %d4,[%a15]
50101c0e:	2d 0e 00 00 	calli %a14
50101c12:	0d 00 40 02 	rslcx 
50101c16:	00 80       	rfe 
	...

50101c20 <__interrupt_225>:
50101c20:	e0 e1       	bisr 225
50101c22:	91 00 00 f7 	movh.a %a15,28672
50101c26:	d9 ff f0 e4 	lea %a15,[%a15]20400 <70004fb0 <Cdisptab+0x708>>
50101c2a:	c4 fe       	ld.a %a14,[%a15+]
50101c2c:	54 f4       	ld.w %d4,[%a15]
50101c2e:	2d 0e 00 00 	calli %a14
50101c32:	0d 00 40 02 	rslcx 
50101c36:	00 80       	rfe 
	...

50101c40 <__interrupt_226>:
50101c40:	e0 e2       	bisr 226
50101c42:	91 00 00 f7 	movh.a %a15,28672
50101c46:	d9 ff f8 e4 	lea %a15,[%a15]20408 <70004fb8 <Cdisptab+0x710>>
50101c4a:	c4 fe       	ld.a %a14,[%a15+]
50101c4c:	54 f4       	ld.w %d4,[%a15]
50101c4e:	2d 0e 00 00 	calli %a14
50101c52:	0d 00 40 02 	rslcx 
50101c56:	00 80       	rfe 
	...

50101c60 <__interrupt_227>:
50101c60:	e0 e3       	bisr 227
50101c62:	91 00 00 f7 	movh.a %a15,28672
50101c66:	d9 ff c0 f4 	lea %a15,[%a15]20416 <70004fc0 <Cdisptab+0x718>>
50101c6a:	c4 fe       	ld.a %a14,[%a15+]
50101c6c:	54 f4       	ld.w %d4,[%a15]
50101c6e:	2d 0e 00 00 	calli %a14
50101c72:	0d 00 40 02 	rslcx 
50101c76:	00 80       	rfe 
	...

50101c80 <__interrupt_228>:
50101c80:	e0 e4       	bisr 228
50101c82:	91 00 00 f7 	movh.a %a15,28672
50101c86:	d9 ff c8 f4 	lea %a15,[%a15]20424 <70004fc8 <Cdisptab+0x720>>
50101c8a:	c4 fe       	ld.a %a14,[%a15+]
50101c8c:	54 f4       	ld.w %d4,[%a15]
50101c8e:	2d 0e 00 00 	calli %a14
50101c92:	0d 00 40 02 	rslcx 
50101c96:	00 80       	rfe 
	...

50101ca0 <__interrupt_229>:
50101ca0:	e0 e5       	bisr 229
50101ca2:	91 00 00 f7 	movh.a %a15,28672
50101ca6:	d9 ff d0 f4 	lea %a15,[%a15]20432 <70004fd0 <Cdisptab+0x728>>
50101caa:	c4 fe       	ld.a %a14,[%a15+]
50101cac:	54 f4       	ld.w %d4,[%a15]
50101cae:	2d 0e 00 00 	calli %a14
50101cb2:	0d 00 40 02 	rslcx 
50101cb6:	00 80       	rfe 
	...

50101cc0 <__interrupt_230>:
50101cc0:	e0 e6       	bisr 230
50101cc2:	91 00 00 f7 	movh.a %a15,28672
50101cc6:	d9 ff d8 f4 	lea %a15,[%a15]20440 <70004fd8 <Cdisptab+0x730>>
50101cca:	c4 fe       	ld.a %a14,[%a15+]
50101ccc:	54 f4       	ld.w %d4,[%a15]
50101cce:	2d 0e 00 00 	calli %a14
50101cd2:	0d 00 40 02 	rslcx 
50101cd6:	00 80       	rfe 
	...

50101ce0 <__interrupt_231>:
50101ce0:	e0 e7       	bisr 231
50101ce2:	91 00 00 f7 	movh.a %a15,28672
50101ce6:	d9 ff e0 f4 	lea %a15,[%a15]20448 <70004fe0 <Cdisptab+0x738>>
50101cea:	c4 fe       	ld.a %a14,[%a15+]
50101cec:	54 f4       	ld.w %d4,[%a15]
50101cee:	2d 0e 00 00 	calli %a14
50101cf2:	0d 00 40 02 	rslcx 
50101cf6:	00 80       	rfe 
	...

50101d00 <__interrupt_232>:
50101d00:	e0 e8       	bisr 232
50101d02:	91 00 00 f7 	movh.a %a15,28672
50101d06:	d9 ff e8 f4 	lea %a15,[%a15]20456 <70004fe8 <Cdisptab+0x740>>
50101d0a:	c4 fe       	ld.a %a14,[%a15+]
50101d0c:	54 f4       	ld.w %d4,[%a15]
50101d0e:	2d 0e 00 00 	calli %a14
50101d12:	0d 00 40 02 	rslcx 
50101d16:	00 80       	rfe 
	...

50101d20 <__interrupt_233>:
50101d20:	e0 e9       	bisr 233
50101d22:	91 00 00 f7 	movh.a %a15,28672
50101d26:	d9 ff f0 f4 	lea %a15,[%a15]20464 <70004ff0 <Cdisptab+0x748>>
50101d2a:	c4 fe       	ld.a %a14,[%a15+]
50101d2c:	54 f4       	ld.w %d4,[%a15]
50101d2e:	2d 0e 00 00 	calli %a14
50101d32:	0d 00 40 02 	rslcx 
50101d36:	00 80       	rfe 
	...

50101d40 <__interrupt_234>:
50101d40:	e0 ea       	bisr 234
50101d42:	91 00 00 f7 	movh.a %a15,28672
50101d46:	d9 ff f8 f4 	lea %a15,[%a15]20472 <70004ff8 <Cdisptab+0x750>>
50101d4a:	c4 fe       	ld.a %a14,[%a15+]
50101d4c:	54 f4       	ld.w %d4,[%a15]
50101d4e:	2d 0e 00 00 	calli %a14
50101d52:	0d 00 40 02 	rslcx 
50101d56:	00 80       	rfe 
	...

50101d60 <__interrupt_235>:
50101d60:	e0 eb       	bisr 235
50101d62:	91 00 00 f7 	movh.a %a15,28672
50101d66:	d9 ff 00 05 	lea %a15,[%a15]20480 <70005000 <Cdisptab+0x758>>
50101d6a:	c4 fe       	ld.a %a14,[%a15+]
50101d6c:	54 f4       	ld.w %d4,[%a15]
50101d6e:	2d 0e 00 00 	calli %a14
50101d72:	0d 00 40 02 	rslcx 
50101d76:	00 80       	rfe 
	...

50101d80 <__interrupt_236>:
50101d80:	e0 ec       	bisr 236
50101d82:	91 00 00 f7 	movh.a %a15,28672
50101d86:	d9 ff 08 05 	lea %a15,[%a15]20488 <70005008 <Cdisptab+0x760>>
50101d8a:	c4 fe       	ld.a %a14,[%a15+]
50101d8c:	54 f4       	ld.w %d4,[%a15]
50101d8e:	2d 0e 00 00 	calli %a14
50101d92:	0d 00 40 02 	rslcx 
50101d96:	00 80       	rfe 
	...

50101da0 <__interrupt_237>:
50101da0:	e0 ed       	bisr 237
50101da2:	91 00 00 f7 	movh.a %a15,28672
50101da6:	d9 ff 10 05 	lea %a15,[%a15]20496 <70005010 <Cdisptab+0x768>>
50101daa:	c4 fe       	ld.a %a14,[%a15+]
50101dac:	54 f4       	ld.w %d4,[%a15]
50101dae:	2d 0e 00 00 	calli %a14
50101db2:	0d 00 40 02 	rslcx 
50101db6:	00 80       	rfe 
	...

50101dc0 <__interrupt_238>:
50101dc0:	e0 ee       	bisr 238
50101dc2:	91 00 00 f7 	movh.a %a15,28672
50101dc6:	d9 ff 18 05 	lea %a15,[%a15]20504 <70005018 <Cdisptab+0x770>>
50101dca:	c4 fe       	ld.a %a14,[%a15+]
50101dcc:	54 f4       	ld.w %d4,[%a15]
50101dce:	2d 0e 00 00 	calli %a14
50101dd2:	0d 00 40 02 	rslcx 
50101dd6:	00 80       	rfe 
	...

50101de0 <__interrupt_239>:
50101de0:	e0 ef       	bisr 239
50101de2:	91 00 00 f7 	movh.a %a15,28672
50101de6:	d9 ff 20 05 	lea %a15,[%a15]20512 <70005020 <Cdisptab+0x778>>
50101dea:	c4 fe       	ld.a %a14,[%a15+]
50101dec:	54 f4       	ld.w %d4,[%a15]
50101dee:	2d 0e 00 00 	calli %a14
50101df2:	0d 00 40 02 	rslcx 
50101df6:	00 80       	rfe 
	...

50101e00 <__interrupt_240>:
50101e00:	e0 f0       	bisr 240
50101e02:	91 00 00 f7 	movh.a %a15,28672
50101e06:	d9 ff 28 05 	lea %a15,[%a15]20520 <70005028 <Cdisptab+0x780>>
50101e0a:	c4 fe       	ld.a %a14,[%a15+]
50101e0c:	54 f4       	ld.w %d4,[%a15]
50101e0e:	2d 0e 00 00 	calli %a14
50101e12:	0d 00 40 02 	rslcx 
50101e16:	00 80       	rfe 
	...

50101e20 <__interrupt_241>:
50101e20:	e0 f1       	bisr 241
50101e22:	91 00 00 f7 	movh.a %a15,28672
50101e26:	d9 ff 30 05 	lea %a15,[%a15]20528 <70005030 <Cdisptab+0x788>>
50101e2a:	c4 fe       	ld.a %a14,[%a15+]
50101e2c:	54 f4       	ld.w %d4,[%a15]
50101e2e:	2d 0e 00 00 	calli %a14
50101e32:	0d 00 40 02 	rslcx 
50101e36:	00 80       	rfe 
	...

50101e40 <__interrupt_242>:
50101e40:	e0 f2       	bisr 242
50101e42:	91 00 00 f7 	movh.a %a15,28672
50101e46:	d9 ff 38 05 	lea %a15,[%a15]20536 <70005038 <Cdisptab+0x790>>
50101e4a:	c4 fe       	ld.a %a14,[%a15+]
50101e4c:	54 f4       	ld.w %d4,[%a15]
50101e4e:	2d 0e 00 00 	calli %a14
50101e52:	0d 00 40 02 	rslcx 
50101e56:	00 80       	rfe 
	...

50101e60 <__interrupt_243>:
50101e60:	e0 f3       	bisr 243
50101e62:	91 00 00 f7 	movh.a %a15,28672
50101e66:	d9 ff 00 15 	lea %a15,[%a15]20544 <70005040 <Cdisptab+0x798>>
50101e6a:	c4 fe       	ld.a %a14,[%a15+]
50101e6c:	54 f4       	ld.w %d4,[%a15]
50101e6e:	2d 0e 00 00 	calli %a14
50101e72:	0d 00 40 02 	rslcx 
50101e76:	00 80       	rfe 
	...

50101e80 <__interrupt_244>:
50101e80:	e0 f4       	bisr 244
50101e82:	91 00 00 f7 	movh.a %a15,28672
50101e86:	d9 ff 08 15 	lea %a15,[%a15]20552 <70005048 <Cdisptab+0x7a0>>
50101e8a:	c4 fe       	ld.a %a14,[%a15+]
50101e8c:	54 f4       	ld.w %d4,[%a15]
50101e8e:	2d 0e 00 00 	calli %a14
50101e92:	0d 00 40 02 	rslcx 
50101e96:	00 80       	rfe 
	...

50101ea0 <__interrupt_245>:
50101ea0:	e0 f5       	bisr 245
50101ea2:	91 00 00 f7 	movh.a %a15,28672
50101ea6:	d9 ff 10 15 	lea %a15,[%a15]20560 <70005050 <Cdisptab+0x7a8>>
50101eaa:	c4 fe       	ld.a %a14,[%a15+]
50101eac:	54 f4       	ld.w %d4,[%a15]
50101eae:	2d 0e 00 00 	calli %a14
50101eb2:	0d 00 40 02 	rslcx 
50101eb6:	00 80       	rfe 
	...

50101ec0 <__interrupt_246>:
50101ec0:	e0 f6       	bisr 246
50101ec2:	91 00 00 f7 	movh.a %a15,28672
50101ec6:	d9 ff 18 15 	lea %a15,[%a15]20568 <70005058 <Cdisptab+0x7b0>>
50101eca:	c4 fe       	ld.a %a14,[%a15+]
50101ecc:	54 f4       	ld.w %d4,[%a15]
50101ece:	2d 0e 00 00 	calli %a14
50101ed2:	0d 00 40 02 	rslcx 
50101ed6:	00 80       	rfe 
	...

50101ee0 <__interrupt_247>:
50101ee0:	e0 f7       	bisr 247
50101ee2:	91 00 00 f7 	movh.a %a15,28672
50101ee6:	d9 ff 20 15 	lea %a15,[%a15]20576 <70005060 <Cdisptab+0x7b8>>
50101eea:	c4 fe       	ld.a %a14,[%a15+]
50101eec:	54 f4       	ld.w %d4,[%a15]
50101eee:	2d 0e 00 00 	calli %a14
50101ef2:	0d 00 40 02 	rslcx 
50101ef6:	00 80       	rfe 
	...

50101f00 <__interrupt_248>:
50101f00:	e0 f8       	bisr 248
50101f02:	91 00 00 f7 	movh.a %a15,28672
50101f06:	d9 ff 28 15 	lea %a15,[%a15]20584 <70005068 <Cdisptab+0x7c0>>
50101f0a:	c4 fe       	ld.a %a14,[%a15+]
50101f0c:	54 f4       	ld.w %d4,[%a15]
50101f0e:	2d 0e 00 00 	calli %a14
50101f12:	0d 00 40 02 	rslcx 
50101f16:	00 80       	rfe 
	...

50101f20 <__interrupt_249>:
50101f20:	e0 f9       	bisr 249
50101f22:	91 00 00 f7 	movh.a %a15,28672
50101f26:	d9 ff 30 15 	lea %a15,[%a15]20592 <70005070 <Cdisptab+0x7c8>>
50101f2a:	c4 fe       	ld.a %a14,[%a15+]
50101f2c:	54 f4       	ld.w %d4,[%a15]
50101f2e:	2d 0e 00 00 	calli %a14
50101f32:	0d 00 40 02 	rslcx 
50101f36:	00 80       	rfe 
	...

50101f40 <__interrupt_250>:
50101f40:	e0 fa       	bisr 250
50101f42:	91 00 00 f7 	movh.a %a15,28672
50101f46:	d9 ff 38 15 	lea %a15,[%a15]20600 <70005078 <Cdisptab+0x7d0>>
50101f4a:	c4 fe       	ld.a %a14,[%a15+]
50101f4c:	54 f4       	ld.w %d4,[%a15]
50101f4e:	2d 0e 00 00 	calli %a14
50101f52:	0d 00 40 02 	rslcx 
50101f56:	00 80       	rfe 
	...

50101f60 <__interrupt_251>:
50101f60:	e0 fb       	bisr 251
50101f62:	91 00 00 f7 	movh.a %a15,28672
50101f66:	d9 ff 00 25 	lea %a15,[%a15]20608 <70005080 <Cdisptab+0x7d8>>
50101f6a:	c4 fe       	ld.a %a14,[%a15+]
50101f6c:	54 f4       	ld.w %d4,[%a15]
50101f6e:	2d 0e 00 00 	calli %a14
50101f72:	0d 00 40 02 	rslcx 
50101f76:	00 80       	rfe 
	...

50101f80 <__interrupt_252>:
50101f80:	e0 fc       	bisr 252
50101f82:	91 00 00 f7 	movh.a %a15,28672
50101f86:	d9 ff 08 25 	lea %a15,[%a15]20616 <70005088 <Cdisptab+0x7e0>>
50101f8a:	c4 fe       	ld.a %a14,[%a15+]
50101f8c:	54 f4       	ld.w %d4,[%a15]
50101f8e:	2d 0e 00 00 	calli %a14
50101f92:	0d 00 40 02 	rslcx 
50101f96:	00 80       	rfe 
	...

50101fa0 <__interrupt_253>:
50101fa0:	e0 fd       	bisr 253
50101fa2:	91 00 00 f7 	movh.a %a15,28672
50101fa6:	d9 ff 10 25 	lea %a15,[%a15]20624 <70005090 <Cdisptab+0x7e8>>
50101faa:	c4 fe       	ld.a %a14,[%a15+]
50101fac:	54 f4       	ld.w %d4,[%a15]
50101fae:	2d 0e 00 00 	calli %a14
50101fb2:	0d 00 40 02 	rslcx 
50101fb6:	00 80       	rfe 
	...

50101fc0 <__interrupt_254>:
50101fc0:	e0 fe       	bisr 254
50101fc2:	91 00 00 f7 	movh.a %a15,28672
50101fc6:	d9 ff 18 25 	lea %a15,[%a15]20632 <70005098 <Cdisptab+0x7f0>>
50101fca:	c4 fe       	ld.a %a14,[%a15+]
50101fcc:	54 f4       	ld.w %d4,[%a15]
50101fce:	2d 0e 00 00 	calli %a14
50101fd2:	0d 00 40 02 	rslcx 
50101fd6:	00 80       	rfe 
	...

50101fe0 <__interrupt_255>:
50101fe0:	e0 ff       	bisr 255
50101fe2:	91 00 00 f7 	movh.a %a15,28672
50101fe6:	d9 ff 20 25 	lea %a15,[%a15]20640 <700050a0 <Cdisptab+0x7f8>>
50101fea:	c4 fe       	ld.a %a14,[%a15+]
50101fec:	54 f4       	ld.w %d4,[%a15]
50101fee:	2d 0e 00 00 	calli %a14
50101ff2:	0d 00 40 02 	rslcx 
50101ff6:	00 80       	rfe 
	...
